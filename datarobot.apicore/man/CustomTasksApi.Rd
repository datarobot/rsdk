% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/custom_tasks_api.R
\docType{class}
\name{CustomTasksApi}
\alias{CustomTasksApi}
\title{CustomTasks operations}
\format{
An \code{R6Class} generator object
}
\description{
datarobot.apicore.CustomTasks
}
\examples{

## ------------------------------------------------
## Method `CustomTasksApi$CustomTaskVersionCreateFromLatest`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
filesToDelete <- oneOf<string,array>$new() # OneOfstringarray | The IDs of the files to be deleted.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTaskVersionCreateFromLatest(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksAccessControlList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksAccessControlList(offset, limit, customTaskId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksAccessControlPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksAccessControlPatchMany(customTaskId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskCreate <- CustomTaskCreate$new() # CustomTaskCreate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksCreate(customTaskCreate=customTaskCreate)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksDelete(customTaskId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksDownloadList(customTaskId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksFromCustomTaskCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskCopy <- CustomTaskCopy$new() # CustomTaskCopy |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksFromCustomTaskCreate(customTaskCopy=customTaskCopy)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom task list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom tasks being returned in order of creation time descending.
searchFor <- 'searchFor_example' # character | String to search for occurrence in custom task's description, language and name. Search is case insensitive. If not specified, all custom tasks will be returned.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksList(offset, limit, orderBy=orderBy, searchFor=searchFor)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskUpdate <- CustomTaskUpdate$new() # CustomTaskUpdate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksPatch(customTaskId, customTaskUpdate=customTaskUpdate)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksRetrieve(customTaskId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsCreate(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsDependencyBuildCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildCreate(customTaskId, customTaskVersionId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsDependencyBuildDeleteMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildDeleteMany(customTaskId, customTaskVersionId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsDependencyBuildList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildList(customTaskId, customTaskVersionId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsDependencyBuildLogList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildLogList(customTaskId, customTaskVersionId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDownloadList(customTaskId, customTaskVersionId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsFromRepositoryCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsFromRepositoryCreate(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsFromRepositoryPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsFromRepositoryPatchMany(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsList(offset, limit, customTaskId)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
customTaskVersionMetadataUpdate <- CustomTaskVersionMetadataUpdate$new() # CustomTaskVersionMetadataUpdate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsPatch(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate=customTaskVersionMetadataUpdate)
}

## ------------------------------------------------
## Method `CustomTasksApi$CustomTasksVersionsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsRetrieve(customTaskId, customTaskVersionId)
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{apiClient}}{Handles the client-server communication.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{CustomTasksApi$new()}}
\item \href{#method-CustomTaskVersionCreateFromLatest}{\code{CustomTasksApi$CustomTaskVersionCreateFromLatest()}}
\item \href{#method-CustomTasksAccessControlList}{\code{CustomTasksApi$CustomTasksAccessControlList()}}
\item \href{#method-CustomTasksAccessControlPatchMany}{\code{CustomTasksApi$CustomTasksAccessControlPatchMany()}}
\item \href{#method-CustomTasksCreate}{\code{CustomTasksApi$CustomTasksCreate()}}
\item \href{#method-CustomTasksDelete}{\code{CustomTasksApi$CustomTasksDelete()}}
\item \href{#method-CustomTasksDownloadList}{\code{CustomTasksApi$CustomTasksDownloadList()}}
\item \href{#method-CustomTasksFromCustomTaskCreate}{\code{CustomTasksApi$CustomTasksFromCustomTaskCreate()}}
\item \href{#method-CustomTasksList}{\code{CustomTasksApi$CustomTasksList()}}
\item \href{#method-CustomTasksPatch}{\code{CustomTasksApi$CustomTasksPatch()}}
\item \href{#method-CustomTasksRetrieve}{\code{CustomTasksApi$CustomTasksRetrieve()}}
\item \href{#method-CustomTasksVersionsCreate}{\code{CustomTasksApi$CustomTasksVersionsCreate()}}
\item \href{#method-CustomTasksVersionsDependencyBuildCreate}{\code{CustomTasksApi$CustomTasksVersionsDependencyBuildCreate()}}
\item \href{#method-CustomTasksVersionsDependencyBuildDeleteMany}{\code{CustomTasksApi$CustomTasksVersionsDependencyBuildDeleteMany()}}
\item \href{#method-CustomTasksVersionsDependencyBuildList}{\code{CustomTasksApi$CustomTasksVersionsDependencyBuildList()}}
\item \href{#method-CustomTasksVersionsDependencyBuildLogList}{\code{CustomTasksApi$CustomTasksVersionsDependencyBuildLogList()}}
\item \href{#method-CustomTasksVersionsDownloadList}{\code{CustomTasksApi$CustomTasksVersionsDownloadList()}}
\item \href{#method-CustomTasksVersionsFromRepositoryCreate}{\code{CustomTasksApi$CustomTasksVersionsFromRepositoryCreate()}}
\item \href{#method-CustomTasksVersionsFromRepositoryPatchMany}{\code{CustomTasksApi$CustomTasksVersionsFromRepositoryPatchMany()}}
\item \href{#method-CustomTasksVersionsList}{\code{CustomTasksApi$CustomTasksVersionsList()}}
\item \href{#method-CustomTasksVersionsPatch}{\code{CustomTasksApi$CustomTasksVersionsPatch()}}
\item \href{#method-CustomTasksVersionsRetrieve}{\code{CustomTasksApi$CustomTasksVersionsRetrieve()}}
\item \href{#method-clone}{\code{CustomTasksApi$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$new(apiClient)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{apiClient}}{A configurable \code{ApiClient} instance. If none provided, a new client with default configuration will be created.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTaskVersionCreateFromLatest"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTaskVersionCreateFromLatest}{}}}
\subsection{Method \code{CustomTaskVersionCreateFromLatest()}}{
Update custom task version files.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTaskVersionCreateFromLatest(
  customTaskId,
  baseEnvironmentId,
  isMajorUpdate,
  file = NULL,
  filePath = NULL,
  filesToDelete = NULL,
  maximumMemory = NULL,
  requiredMetadata = NULL,
  requiredMetadataValues = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{baseEnvironmentId}}{character. The base environment to use with this custom task version.}

\item{\code{isMajorUpdate}}{Enum < \link{false, False, true, True} > If set to true, new major version will created, otherwise minor version will be created.}

\item{\code{file}}{data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would \emph{also} need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.}

\item{\code{filePath}}{\link{OneOfstringarray}. The local path of the file being uploaded. See the `file` field explanation for more details.}

\item{\code{filesToDelete}}{\link{OneOfstringarray}. The IDs of the files to be deleted.}

\item{\code{maximumMemory}}{integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed}

\item{\code{requiredMetadata}}{character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.}

\item{\code{requiredMetadataValues}}{character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom task version with files added, replaced or deleted. Files from the previous version of a custom task will be used as a basis.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Item successfully created.
\itemize{
}
\item \strong{\code{413}} Item or collection of items was too large in size (bytes).
\itemize{
}
\item \strong{\code{422}} Cannot create the custom task version due to one or more errors. All error responses will have a \"message\" field and some may have optional fields. The optional fields include: \link[=\\"errors\\", \\"dependencies\\", \\"invalidDependencies\\"]{\"errors\", \"dependencies\", \"invalidDependencies\"}
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
filesToDelete <- oneOf<string,array>$new() # OneOfstringarray | The IDs of the files to be deleted.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTaskVersionCreateFromLatest(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksAccessControlList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksAccessControlList}{}}}
\subsection{Method \code{CustomTasksAccessControlList()}}{
Get a list of users who have access to this custom task and their roles on it.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksAccessControlList(offset, limit, customTaskId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get a list of users who have access to this custom task and their roles on it.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A list of users who have access to this custom task and their roles on it.
\itemize{
}
\item \strong{\code{400}} Both username and userId were specified.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskAccessControlListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksAccessControlList(offset, limit, customTaskId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksAccessControlPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksAccessControlPatchMany}{}}}
\subsection{Method \code{CustomTasksAccessControlPatchMany()}}{
Grant access or update roles for users on this custom task and appropriate learning data.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksAccessControlPatchMany(
  customTaskId,
  sharingUpdateOrRemoveWithGrant = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{sharingUpdateOrRemoveWithGrant}}{\link{SharingUpdateOrRemoveWithGrant}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Grant access or update roles for users on this custom task and appropriate learning data. Up to 100 user roles may be set in a single request.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Roles updated successfully.
\itemize{
}
\item \strong{\code{409}} The request would leave the custom task without an owner.
\itemize{
}
\item \strong{\code{422}} One of the users in the request does not exist, or the request is otherwise invalid.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksAccessControlPatchMany(customTaskId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksCreate}{}}}
\subsection{Method \code{CustomTasksCreate()}}{
Create a custom task
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksCreate(customTaskCreate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskCreate}}{\link{CustomTaskCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates a new custom task and returns the newly created metadata record for it.  A custom task may either be an estimator or a transform. Estimators must support a single target type (e.g. binaryClassification, regression). Regression and anomaly detection models are expected to produce predictions that are arbitrary floating-point or integer numbers. A classification model is expected to return predictions with probability scores for each class.  For example, a binary classification model might return:  .. code:: Python      {         positiveClassLabel: probability,         negativeClassLabel: 1.0 - probability     }  Transforms are expected to return a dataframe or sparse matrix with the same number of rows as the input feature matrix. At this time, only numeric outputs are supported for custom transforms.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Custom task successfully created.
\itemize{
}
\item \strong{\code{403}} Custom task creation is not enabled.
\itemize{
}
\item \strong{\code{422}} Input parameters invalid
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskCreate <- CustomTaskCreate$new() # CustomTaskCreate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksCreate(customTaskCreate=customTaskCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksDelete"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksDelete}{}}}
\subsection{Method \code{CustomTasksDelete()}}{
Delete custom task.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksDelete(customTaskId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Delete a custom task. Only users who have permission to edit custom task can delete it. Only custom tasks which are not currently deployed  can be deleted. Relevant CustomTaskImage will be deleted also.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Record deleted.
\itemize{
}
\item \strong{\code{409}} This custom task is currently deployed, trained, or part of a user blueprint, and cannot be deleted. The response body will contain link where these conflicts can be retrieved.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksDelete(customTaskId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksDownloadList}{}}}
\subsection{Method \code{CustomTasksDownloadList()}}{
Download the latest custom task version content.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksDownloadList(customTaskId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download the latest item bundle from a custom task as a zip compressed archive.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The download succeeded.
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download (\"attachment;filename=model-<model_id>-version-<version_id>.zip\").
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksDownloadList(customTaskId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksFromCustomTaskCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksFromCustomTaskCreate}{}}}
\subsection{Method \code{CustomTasksFromCustomTaskCreate()}}{
Clone custom task.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksFromCustomTaskCreate(customTaskCopy = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskCopy}}{\link{CustomTaskCopy}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates a copy of the provided custom task, including metadata, versions of that task, and uploaded files. Associates the new versions with files owned by the custom task.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Successfully created copy.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskCopy <- CustomTaskCopy$new() # CustomTaskCopy |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksFromCustomTaskCreate(customTaskCopy=customTaskCopy)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksList}{}}}
\subsection{Method \code{CustomTasksList()}}{
List custom tasks.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksList(
  offset,
  limit,
  orderBy = NULL,
  searchFor = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{orderBy}}{Enum < \link{created, -created, updated, -updated} > Sort order which will be applied to custom task list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom tasks being returned in order of creation time descending.}

\item{\code{searchFor}}{character. String to search for occurrence in custom task's description, language and name. Search is case insensitive. If not specified, all custom tasks will be returned.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve metadata for all custom tasks the user has access to.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom task list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom tasks being returned in order of creation time descending.
searchFor <- 'searchFor_example' # character | String to search for occurrence in custom task's description, language and name. Search is case insensitive. If not specified, all custom tasks will be returned.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksList(offset, limit, orderBy=orderBy, searchFor=searchFor)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksPatch"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksPatch}{}}}
\subsection{Method \code{CustomTasksPatch()}}{
Update custom task.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksPatch(customTaskId, customTaskUpdate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskUpdate}}{\link{CustomTaskUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Updates metadata for an existing custom task.  All custom tasks must support one target type (e.g. binaryClassification, regression, transform).  Setting `positiveClassLabel` and `negativeClassLabel` to null will set the labels to their default values (1 and 0 for positiveClassLabel and negativeClassLabel, respectively).  Setting `positiveClassLabel`, `negativeClassLabel`, 'targetName` is disabled if task has active deployments.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Created.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskUpdate <- CustomTaskUpdate$new() # CustomTaskUpdate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksPatch(customTaskId, customTaskUpdate=customTaskUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksRetrieve}{}}}
\subsection{Method \code{CustomTasksRetrieve()}}{
Get custom task.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksRetrieve(customTaskId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve metadata for a custom task


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksRetrieve(customTaskId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsCreate}{}}}
\subsection{Method \code{CustomTasksVersionsCreate()}}{
Create custom task version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsCreate(
  customTaskId,
  baseEnvironmentId,
  isMajorUpdate,
  file = NULL,
  filePath = NULL,
  maximumMemory = NULL,
  requiredMetadata = NULL,
  requiredMetadataValues = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{baseEnvironmentId}}{character. The base environment to use with this custom task version.}

\item{\code{isMajorUpdate}}{Enum < \link{false, False, true, True} > If set to true, new major version will created, otherwise minor version will be created.}

\item{\code{file}}{data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would \emph{also} need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.}

\item{\code{filePath}}{\link{OneOfstringarray}. The local path of the file being uploaded. See the `file` field explanation for more details.}

\item{\code{maximumMemory}}{integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed}

\item{\code{requiredMetadata}}{character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.}

\item{\code{requiredMetadataValues}}{character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom task version with attached files if supplied.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Item successfully created.
\itemize{
}
\item \strong{\code{413}} Item or collection of items was too large in size (bytes).
\itemize{
}
\item \strong{\code{422}} Cannot create the custom task version due to one or more errors. All error responses will have a \"message\" field and some may have optional fields. The optional fields include: \link[=\\"errors\\", \\"dependencies\\", \\"invalidDependencies\\"]{\"errors\", \"dependencies\", \"invalidDependencies\"}
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsCreate(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsDependencyBuildCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsDependencyBuildCreate}{}}}
\subsection{Method \code{CustomTasksVersionsDependencyBuildCreate()}}{
Start a custom task version's dependency build.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsDependencyBuildCreate(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Start a custom task version's dependency build. This is required to test, deploy, or train custom tasks.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Custom task version's dependency build has started.
\itemize{
}
\item \strong{\code{422}} Custom task dependency build has failed.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionDependencyBuildMetadataResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildCreate(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsDependencyBuildDeleteMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsDependencyBuildDeleteMany}{}}}
\subsection{Method \code{CustomTasksVersionsDependencyBuildDeleteMany()}}{
Cancel dependency build.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsDependencyBuildDeleteMany(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Cancel the custom task version's dependency build.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Custom task version's dependency build was cancelled.
\itemize{
}
\item \strong{\code{409}} Custom task dependency build has reached a terminal state and cannot be cancelled.
\itemize{
}
\item \strong{\code{422}} No custom task dependency build started for specified version or dependency image is in use and cannot be deleted
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildDeleteMany(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsDependencyBuildList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsDependencyBuildList}{}}}
\subsection{Method \code{CustomTasksVersionsDependencyBuildList()}}{
Retrieve the custom task version's dependency build status.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsDependencyBuildList(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the custom task version's dependency build status.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The metadata from the custom task version's dependency build.
\itemize{
}
\item \strong{\code{422}} Custom task dependency build has not started.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionDependencyBuildMetadataResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildList(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsDependencyBuildLogList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsDependencyBuildLogList}{}}}
\subsection{Method \code{CustomTasksVersionsDependencyBuildLogList()}}{
Retrieve the custom task version's dependency build log.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsDependencyBuildLogList(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the custom task version's dependency build log.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The log file generated during the custom task version's dependency build.
\itemize{
}
\item \strong{\code{404}} Dependency build is in progress or could not be found.
\itemize{
}
\item \strong{\code{422}} Custom task dependency build has not started.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDependencyBuildLogList(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsDownloadList}{}}}
\subsection{Method \code{CustomTasksVersionsDownloadList()}}{
Download custom task version content.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsDownloadList(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download a specific item bundle from a custom task as a zip compressed archive.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The download succeeded.
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download (\"attachment;filename=model-<model_id>-version-<version_id>.zip\").
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsDownloadList(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsFromRepositoryCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsFromRepositoryCreate}{}}}
\subsection{Method \code{CustomTasksVersionsFromRepositoryCreate()}}{
Create custom task version from remote repository.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsFromRepositoryCreate(
  customTaskId,
  customTaskVersionCreateFromRepository = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionCreateFromRepository}}{\link{CustomTaskVersionCreateFromRepository}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom task version with only files added from the specified remote repository.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Accepted: request placed to a queue for processing.
\itemize{
\item \strong{\code{Location}} URL for tracking async job status.
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsFromRepositoryCreate(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsFromRepositoryPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsFromRepositoryPatchMany}{}}}
\subsection{Method \code{CustomTasksVersionsFromRepositoryPatchMany()}}{
Create custom task version from remote repository with files from previous version.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsFromRepositoryPatchMany(
  customTaskId,
  customTaskVersionCreateFromRepository = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionCreateFromRepository}}{\link{CustomTaskVersionCreateFromRepository}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom task version with files added from a remote repository. Files from the previous version of a custom task will be used as a basis.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Accepted: request placed to a queue for processing.
\itemize{
\item \strong{\code{Location}} URL for tracking async job status.
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsFromRepositoryPatchMany(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsList}{}}}
\subsection{Method \code{CustomTasksVersionsList()}}{
List custom task versions.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsList(offset, limit, customTaskId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List custom task versions.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
\item \strong{\code{400}} Query parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customTaskId <- 'customTaskId_example' # character | ID of the custom task.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsList(offset, limit, customTaskId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsPatch"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsPatch}{}}}
\subsection{Method \code{CustomTasksVersionsPatch()}}{
Update custom task version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsPatch(
  customTaskId,
  customTaskVersionId,
  customTaskVersionMetadataUpdate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{customTaskVersionMetadataUpdate}}{\link{CustomTaskVersionMetadataUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Edit metadata of a specific task version.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The edit was successful.
\itemize{
}
\item \strong{\code{404}} Custom task not found or user does not have edit permissions.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
customTaskVersionMetadataUpdate <- CustomTaskVersionMetadataUpdate$new() # CustomTaskVersionMetadataUpdate |

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsPatch(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate=customTaskVersionMetadataUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTasksVersionsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTasksVersionsRetrieve}{}}}
\subsection{Method \code{CustomTasksVersionsRetrieve()}}{
Get custom task version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$CustomTasksVersionsRetrieve(
  customTaskId,
  customTaskVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTaskId}}{character. ID of the custom task.}

\item{\code{customTaskVersionId}}{character. ID of the custom task version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Display a requested version of a custom task along with the files attached to it.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTaskVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTaskId <- 'customTaskId_example' # character | ID of the custom task.
customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.

api.instance <- CustomTasksApi$new()
result <- api.instance$CustomTasksVersionsRetrieve(customTaskId, customTaskVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{CustomTasksApi$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
