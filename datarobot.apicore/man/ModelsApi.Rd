% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/models_api.R
\docType{class}
\name{ModelsApi}
\alias{ModelsApi}
\title{Models operations}
\format{
An \code{R6Class} generator object
}
\description{
datarobot.apicore.Models
}
\examples{

## ------------------------------------------------
## Method `ModelsApi$CustomInferenceImagesFeatureImpactCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
imageId <- 'imageId_example' # character | ID of the image of the custom inference model to submit feature impact job for.
featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$CustomInferenceImagesFeatureImpactCreate(imageId, featureImpactCreatePayload=featureImpactCreatePayload)
}

## ------------------------------------------------
## Method `ModelsApi$CustomInferenceImagesFeatureImpactList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
imageId <- 'imageId_example' # character | ID of the image of the custom inference model to retrieve feature impact from.

api.instance <- ModelsApi$new()
result <- api.instance$CustomInferenceImagesFeatureImpactList(imageId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelDeploymentsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.
customModelIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the custom model which model deployments will be retrieved.
environmentIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the execution environment which model deployments will be retrieved.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelDeploymentsList(offset, limit, customModelIds=customModelIds, environmentIds=environmentIds)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelLimitsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelLimitsList()
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelTests <- CustomModelTests$new() # CustomModelTests |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsCreate(customModelTests=customModelTests)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsDelete(customModelTestId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the Custom Model to retrieve testing history for.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsList(offset, limit, customModelId, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, desiredMemory=desiredMemory, replicas=replicas, requiresHa=requiresHa)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsLogList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsLogList(customModelTestId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsRetrieve(customModelTestId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelTestsTailList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
lines <- 100 # integer | Number of lines from the log to retrieve (1-1000, default 100).
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsTailList(lines, customModelTestId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsAccessControlList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsAccessControlList(offset, limit, customModelId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsAccessControlPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsAccessControlPatchMany(customModelId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelCreate <- CustomModelCreate$new() # CustomModelCreate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsCreate(customModelCreate=customModelCreate)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsDelete(customModelId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsDownloadList(customModelId, pps=pps)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsFromCustomModelCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelCopy <- CustomModelCopy$new() # CustomModelCopy |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsFromCustomModelCreate(customModelCopy=customModelCopy)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelType <- 'customModelType_example' # character | If \"training\" specified, only Custom Training Tasks will be returned. If \"inference\" specified, only Custom Inference Models will be returned. If not specified, all custom models will be returned. After deprecation, only Custom Inference Models will be returned
isDeployed <- 'isDeployed_example' # character | If \"true\" specified, only deployed custom models will be returned. If \"false\" specified, only not deployed custom models will be returned. If not specified, all custom models will be returned.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom model list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom models being returned in order of creation time descending.
searchFor <- 'searchFor_example' # character | String to search for occurrence in custom model's description, language and name. Search is case insensitive. If not specified, all custom models will be returned.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsList(offset, limit, customModelType=customModelType, isDeployed=isDeployed, orderBy=orderBy, searchFor=searchFor)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelUpdate <- CustomModelUpdate$new() # CustomModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsPatch(customModelId, customModelUpdate=customModelUpdate)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsPredictionExplanationsInitializationCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelPredictionExplanations <- CustomModelPredictionExplanations$new() # CustomModelPredictionExplanations |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsPredictionExplanationsInitializationCreate(customModelPredictionExplanations=customModelPredictionExplanations)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsRetrieve(customModelId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsTrainingDataPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
trainingDataAssignment <- TrainingDataAssignment$new() # TrainingDataAssignment |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsTrainingDataPatchMany(customModelId, trainingDataAssignment=trainingDataAssignment)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionCreateFromLatest`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
filesToDelete <- oneOf<string,array>$new() # OneOfstringarray | The IDs of the files to be deleted.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionCreateFromLatest(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory=desiredMemory, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsConversionsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionCreateQuery <- ConversionCreateQuery$new() # ConversionCreateQuery |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsCreate(customModelId, customModelVersionId, conversionCreateQuery=conversionCreateQuery)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsConversionsDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionId <- 'conversionId_example' # character | ID of the custom model conversion.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsDelete(customModelId, customModelVersionId, conversionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsConversionsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
isLatest <- "false" # character | Whether to return only the latest associated custom model conversion or all of the associated ones.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsList(offset, limit, customModelId, customModelVersionId, isLatest=isLatest)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsConversionsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionId <- 'conversionId_example' # character | ID of the custom model conversion.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsRetrieve(customModelId, customModelVersionId, conversionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsCreate(customModelId, isMajorUpdate, baseEnvironmentId=baseEnvironmentId, desiredMemory=desiredMemory, file=file, filePath=filePath, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsDependencyBuildCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildCreate(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsDependencyBuildDeleteMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildDeleteMany(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsDependencyBuildList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildList(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsDependencyBuildLogList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildLogList(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDownloadList(customModelId, customModelVersionId, pps=pps)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsFeatureImpactCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFeatureImpactCreate(customModelId, customModelVersionId, featureImpactCreatePayload=featureImpactCreatePayload)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsFeatureImpactList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFeatureImpactList(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsFromRepositoryCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFromRepositoryCreate(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsFromRepositoryPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFromRepositoryPatchMany(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsList(offset, limit, customModelId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
customModelVersionMetadataUpdate <- CustomModelVersionMetadataUpdate$new() # CustomModelVersionMetadataUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsPatch(customModelId, customModelVersionId, customModelVersionMetadataUpdate=customModelVersionMetadataUpdate)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsPredictionExplanationsInitializationCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsPredictionExplanationsInitializationCreate(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomModelsVersionsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsRetrieve(customModelId, customModelVersionId)
}

## ------------------------------------------------
## Method `ModelsApi$CustomTrainingBlueprintsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
customTrainingBlueprintCreate <- CustomTrainingBlueprintCreate$new() # CustomTrainingBlueprintCreate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomTrainingBlueprintsCreate(customTrainingBlueprintCreate=customTrainingBlueprintCreate)
}

## ------------------------------------------------
## Method `ModelsApi$CustomTrainingBlueprintsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | List blueprints for a specific model. Default: all.
reverse <- "False" # character | List blueprints in reverse order.
targetTypes <- ['targetTypes_example'] # array[character] | Custom model target types to return.

api.instance <- ModelsApi$new()
result <- api.instance$CustomTrainingBlueprintsList(offset, limit, customModelId=customModelId, reverse=reverse, targetTypes=targetTypes)
}

## ------------------------------------------------
## Method `ModelsApi$ModelExportsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
modelExport <- ModelExport$new() # ModelExport |

api.instance <- ModelsApi$new()
result <- api.instance$ModelExportsCreate(modelExport=modelExport)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesArchiveCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesArchiveCreate(modelPackageId)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesFeaturesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | The number of features to skip, defaults to 0.
limit <- 50 # integer | The number of features to return, defaults to 0.
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
includeNonPredictionFeatures <- "false" # character | When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
forSegmentedAnalysis <- "false" # character | When True, features returned will be filtered to those usable for segmented analysis.
search <- 'search_example' # character | Case insensitive search against names of the deployment's features.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to model package feature list. Prefix the attribute name with a dash to sort in descending order, e.g. \"-name\".

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesFeaturesList(offset, limit, modelPackageId, includeNonPredictionFeatures=includeNonPredictionFeatures, forSegmentedAnalysis=forSegmentedAnalysis, search=search, orderBy=orderBy)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesFromLearningModelCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
modelPackageCreateFromLearningModel <- ModelPackageCreateFromLearningModel$new() # ModelPackageCreateFromLearningModel |

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesFromLearningModelCreate(modelPackageCreateFromLearningModel=modelPackageCreateFromLearningModel)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.
modelId <- 'modelId_example' # character | If specified, limit results to model packages for the model with the specified ID.
similarTo <- 'similarTo_example' # character | Return model packages similar to a given model package ID. If used, will only return model packages that match `target.name`, `target.type`, `target.classNames` (for classification models), `modelKind.isTimeSeries`, and `modelKind.isMultiseries` of the specified model package.
forChallenger <- 'forChallenger_example' # character | Can be used with similarTo to request similar model packages with the intent to use them as challenger models; for external model packages, instead of returning similar external model packages, similar DataRobot and Custom model packages will be retrieved.
search <- 'search_example' # character | Provide a term to search for in package name, model name, or description
predictionThreshold <- 3.4 # numeric | Prediction threshold used for binary classification models
imported <- 'imported_example' # character | If specified, filter for either imported (true) or non-imported (false) model packages
predictionEnvironmentId <- 'predictionEnvironmentId_example' # character | Can be used to filter packages by what is supported by the prediction environment
modelKind <- OneOfstringarray$new() # OneOfstringarray | Return models from the registry that match a specific format.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesList(offset=offset, limit=limit, modelId=modelId, similarTo=similarTo, forChallenger=forChallenger, search=search, predictionThreshold=predictionThreshold, imported=imported, predictionEnvironmentId=predictionEnvironmentId, modelKind=modelKind)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesRetrieve(modelPackageId)
}

## ------------------------------------------------
## Method `ModelsApi$ModelPackagesSharedRolesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped
limit <- 10 # integer | At most this many results are returned
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesSharedRolesList(offset, limit, modelPackageId, id=id, name=name, shareRecipientType=shareRecipientType)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderBuildersCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
baseBlenderBuilderCreate <- BaseBlenderBuilderCreate$new() # BaseBlenderBuilderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersCreate(projectId, baseBlenderBuilderCreate=baseBlenderBuilderCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderBuildersList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
offset <- 0 # integer | The maximum number of blender builder job records to return
limit <- 100 # integer | pagination offset

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersList(projectId, offset, limit)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderBuildersRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
buildId <- 'buildId_example' # character | The ID of the blender builder job to get data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersRetrieve(projectId, buildId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderModelsBlendCheckCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
blenderCreate <- BlenderCreate$new() # BlenderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsBlendCheckCreate(projectId, blenderCreate=blenderCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
blenderCreate <- BlenderCreate$new() # BlenderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsCreate(projectId, blenderCreate=blenderCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 0 # integer | At most this many results are returned. If 0, all results.
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsList(offset, limit, projectId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsBlenderModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsCombinedModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsList(projectId, offset=offset, limit=limit)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsCombinedModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsRetrieve(projectId, combinedModelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsCombinedModelsSegmentsDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsSegmentsDownloadList(projectId, combinedModelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsCombinedModelsSegmentsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.
searchSegmentName <- 'searchSegmentName_example' # character | Case insensitive search against segment name.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsSegmentsList(projectId, combinedModelId, offset=offset, limit=limit, searchSegmentName=searchSegmentName)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDatetimeModelsBacktestsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsBacktestsCreate(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDatetimeModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
trainDatetimeModel <- TrainDatetimeModel$new() # TrainDatetimeModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsCreate(projectId, trainDatetimeModel=trainDatetimeModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDatetimeModelsFromModelCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
retrainDatetimeModel <- RetrainDatetimeModel$new() # RetrainDatetimeModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsFromModelCreate(projectId, retrainDatetimeModel=retrainDatetimeModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDatetimeModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.
bulkOperationId <- 'bulkOperationId_example' # character | the ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsList(projectId, offset=offset, limit=limit, bulkOperationId=bulkOperationId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDatetimeModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsDeploymentReadyModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
prepareForDeployment <- PrepareForDeployment$new() # PrepareForDeployment |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDeploymentReadyModelsCreate(projectId, prepareForDeployment=prepareForDeployment)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsEureqaDistributionPlotRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaDistributionPlotRetrieve(projectId, solutionId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsEureqaModelDetailRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelDetailRetrieve(projectId, solutionId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsEureqaModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
eureqaLeaderboardEntryPayload <- EureqaLeaderboardEntryPayload$new() # EureqaLeaderboardEntryPayload |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelsCreate(projectId, eureqaLeaderboardEntryPayload=eureqaLeaderboardEntryPayload)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsEureqaModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsFrozenDatetimeModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
trainDatetimeFrozenModel <- TrainDatetimeFrozenModel$new() # TrainDatetimeFrozenModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenDatetimeModelsCreate(projectId, trainDatetimeFrozenModel=trainDatetimeFrozenModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsFrozenModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
frozenModelCreate <- FrozenModelCreate$new() # FrozenModelCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsCreate(projectId, frozenModelCreate=frozenModelCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsFrozenModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 0 # integer | At most this many results are returned. If 0, all results.
projectId <- 'projectId_example' # character | The project ID
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric.  If not, all metrics will be included.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsList(offset, limit, projectId, withMetric=withMetric)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsFrozenModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelJobsDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
jobId <- 'jobId_example' # character | The job ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsDelete(projectId, jobId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelJobsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
status <- 'status_example' # character | If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsList(projectId, status=status)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelJobsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
jobId <- 'jobId_example' # character | The job ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsRetrieve(projectId, jobId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsAdvancedTuningCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
modelAdvancedTuning <- ModelAdvancedTuning$new() # ModelAdvancedTuning |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsAdvancedTuningCreate(projectId, modelId, modelAdvancedTuning=modelAdvancedTuning)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsAdvancedTuningParametersList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsAdvancedTuningParametersList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsClusterNamesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsClusterNamesList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsClusterNamesPatchMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
clusterNamesUpdateParam <- ClusterNamesUpdateParam$new() # ClusterNamesUpdateParam |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsClusterNamesPatchMany(projectId, modelId, clusterNamesUpdateParam=clusterNamesUpdateParam)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
trainModel <- TrainModel$new() # TrainModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCreate(projectId, trainModel=trainModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsCrossValidationCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
body <- NULL # object |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCrossValidationCreate(projectId, modelId, body=body)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsCrossValidationScoresList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
metric <- 'metric_example' # character | Set to the name of a metric to only return results for that metric.
partition <- 3.4 # numeric | Set to a value such as 1.0, 2.0 to only return results for the specified partition.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCrossValidationScoresList(projectId, modelId, metric=metric, partition=partition)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsDelete`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsDelete(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsExportList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsExportList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsFeaturesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsFeaturesList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsFromModelCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
retrainModel <- RetrainModel$new() # RetrainModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsFromModelCreate(projectId, retrainModel=retrainModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsMissingReportList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsMissingReportList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsNumIterationsTrainedList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsNumIterationsTrainedList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsParametersList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsParametersList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
modelUpdate <- ModelUpdate$new() # ModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPatch(projectId, modelId, modelUpdate=modelUpdate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPredictionIntervalsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project to calculate prediction intervals for. Must be a time series project.
modelId <- 'modelId_example' # character | The model to calculate prediction intervals for.
predictionIntervalsCreate <- PredictionIntervalsCreate$new() # PredictionIntervalsCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPredictionIntervalsCreate(projectId, modelId, predictionIntervalsCreate=predictionIntervalsCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPredictionIntervalsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project to retrieve prediction intervals for. Must be a time series project.
modelId <- 'modelId_example' # character | The model to retrieve prediction intervals for.
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPredictionIntervalsList(projectId, modelId, offset=offset, limit=limit)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPrimeInfoList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model belongs to
modelId <- 'modelId_example' # character | the model to check

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeInfoList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPrimeRulesetsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model to approximate belongs to
modelId <- 'modelId_example' # character | the model to approximate
body <- NULL # object |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeRulesetsCreate(projectId, modelId, body=body)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsPrimeRulesetsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model belongs to
modelId <- 'modelId_example' # character | the model to find approximating rulesets for

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeRulesetsList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsScoringCodeList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that created the model
modelId <- 'modelId_example' # character | the model to use
sourceCode <- "false" # character | If set to \"true\", the downloaded JAR file will contain only the source code and will not be executable.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsScoringCodeList(projectId, modelId, sourceCode=sourceCode)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsModelsSupportedCapabilitiesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsSupportedCapabilitiesList(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeFilesCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the Prime model belongs to
primeFileCreate <- PrimeFileCreate$new() # PrimeFileCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesCreate(projectId, primeFileCreate=primeFileCreate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeFilesDownloadList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the file belongs to
primeFileId <- 'primeFileId_example' # character | the Prime file to download code from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesDownloadList(projectId, primeFileId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeFilesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list available files for
offset <- 0 # integer | this many results will be skipped
limit <- 0 # integer | at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
parentModelId <- 'parentModelId_example' # character | if specified only Prime files approximating the specified parent model will be returned; otherwise all applicable Prime files will be returned.
modelId <- 'modelId_example' # character | if specified only Prime files with code used in the specified prime model will be returned; otherwise all applicable Prime files will be returned

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesList(projectId, offset=offset, limit=limit, parentModelId=parentModelId, modelId=modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeFilesRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the file belongs to
primeFileId <- 'primeFileId_example' # character | the file to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesRetrieve(projectId, primeFileId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project in which to create the model
primeModelCreatePayload <- PrimeModelCreatePayload$new() # PrimeModelCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsCreate(projectId, primeModelCreatePayload=primeModelCreatePayload)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list models from
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsList(projectId, offset=offset, limit=limit)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsPrimeModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to retrieve the model from
modelId <- 'modelId_example' # character | the model to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTableModelsCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
createRatingTableModel <- CreateRatingTableModel$new() # CreateRatingTableModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsCreate(projectId, createRatingTableModel=createRatingTableModel)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTableModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list models from
bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTableModelsRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to retrieve the model from
modelId <- 'modelId_example' # character | the model to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsRetrieve(projectId, modelId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTablesCreate`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
parentModelId <- 'parentModelId_example' # character | the parent model this rating table file was derived from
ratingTableFile <- File.new('/path/to/file') # data.frame | rating table file to use for the new rating table. Accepts `Content-Type:multipart/form-data`
ratingTableName <- 'ratingTableName_example' # character | the name of the new rating table to create

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesCreate(projectId, parentModelId, ratingTableFile, ratingTableName)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTablesFileList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesFileList(projectId, ratingTableId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTablesList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
parentModelId <- 'parentModelId_example' # character | optional. If specified, only rating tables with this parentModelId will be returned
modelId <- 'modelId_example' # character | optional. If specified, only rating tables with this modelId will be returned
offset <- 0 # integer | optional (default: 0), this many results will be skipped
limit <- 0 # integer | optional (default: no limit), at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesList(projectId, parentModelId=parentModelId, modelId=modelId, offset=offset, limit=limit)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTablesPatch`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from
ratingTableUpdate <- RatingTableUpdate$new() # RatingTableUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesPatch(projectId, ratingTableId, ratingTableUpdate=ratingTableUpdate)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRatingTablesRetrieve`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesRetrieve(projectId, ratingTableId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRecommendedModelsList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRecommendedModelsList(projectId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsRecommendedModelsRecommendedModelList`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRecommendedModelsRecommendedModelList(projectId)
}

## ------------------------------------------------
## Method `ModelsApi$ProjectsSegmentChampionPutMany`
## ------------------------------------------------

\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
segmentChampionModelUpdate <- SegmentChampionModelUpdate$new() # SegmentChampionModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsSegmentChampionPutMany(projectId, segmentChampionModelUpdate=segmentChampionModelUpdate)
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{apiClient}}{Handles the client-server communication.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{ModelsApi$new()}}
\item \href{#method-CustomInferenceImagesFeatureImpactCreate}{\code{ModelsApi$CustomInferenceImagesFeatureImpactCreate()}}
\item \href{#method-CustomInferenceImagesFeatureImpactList}{\code{ModelsApi$CustomInferenceImagesFeatureImpactList()}}
\item \href{#method-CustomModelDeploymentsList}{\code{ModelsApi$CustomModelDeploymentsList()}}
\item \href{#method-CustomModelLimitsList}{\code{ModelsApi$CustomModelLimitsList()}}
\item \href{#method-CustomModelTestsCreate}{\code{ModelsApi$CustomModelTestsCreate()}}
\item \href{#method-CustomModelTestsDelete}{\code{ModelsApi$CustomModelTestsDelete()}}
\item \href{#method-CustomModelTestsList}{\code{ModelsApi$CustomModelTestsList()}}
\item \href{#method-CustomModelTestsLogList}{\code{ModelsApi$CustomModelTestsLogList()}}
\item \href{#method-CustomModelTestsRetrieve}{\code{ModelsApi$CustomModelTestsRetrieve()}}
\item \href{#method-CustomModelTestsTailList}{\code{ModelsApi$CustomModelTestsTailList()}}
\item \href{#method-CustomModelsAccessControlList}{\code{ModelsApi$CustomModelsAccessControlList()}}
\item \href{#method-CustomModelsAccessControlPatchMany}{\code{ModelsApi$CustomModelsAccessControlPatchMany()}}
\item \href{#method-CustomModelsCreate}{\code{ModelsApi$CustomModelsCreate()}}
\item \href{#method-CustomModelsDelete}{\code{ModelsApi$CustomModelsDelete()}}
\item \href{#method-CustomModelsDownloadList}{\code{ModelsApi$CustomModelsDownloadList()}}
\item \href{#method-CustomModelsFromCustomModelCreate}{\code{ModelsApi$CustomModelsFromCustomModelCreate()}}
\item \href{#method-CustomModelsList}{\code{ModelsApi$CustomModelsList()}}
\item \href{#method-CustomModelsPatch}{\code{ModelsApi$CustomModelsPatch()}}
\item \href{#method-CustomModelsPredictionExplanationsInitializationCreate}{\code{ModelsApi$CustomModelsPredictionExplanationsInitializationCreate()}}
\item \href{#method-CustomModelsRetrieve}{\code{ModelsApi$CustomModelsRetrieve()}}
\item \href{#method-CustomModelsTrainingDataPatchMany}{\code{ModelsApi$CustomModelsTrainingDataPatchMany()}}
\item \href{#method-CustomModelsVersionCreateFromLatest}{\code{ModelsApi$CustomModelsVersionCreateFromLatest()}}
\item \href{#method-CustomModelsVersionsConversionsCreate}{\code{ModelsApi$CustomModelsVersionsConversionsCreate()}}
\item \href{#method-CustomModelsVersionsConversionsDelete}{\code{ModelsApi$CustomModelsVersionsConversionsDelete()}}
\item \href{#method-CustomModelsVersionsConversionsList}{\code{ModelsApi$CustomModelsVersionsConversionsList()}}
\item \href{#method-CustomModelsVersionsConversionsRetrieve}{\code{ModelsApi$CustomModelsVersionsConversionsRetrieve()}}
\item \href{#method-CustomModelsVersionsCreate}{\code{ModelsApi$CustomModelsVersionsCreate()}}
\item \href{#method-CustomModelsVersionsDependencyBuildCreate}{\code{ModelsApi$CustomModelsVersionsDependencyBuildCreate()}}
\item \href{#method-CustomModelsVersionsDependencyBuildDeleteMany}{\code{ModelsApi$CustomModelsVersionsDependencyBuildDeleteMany()}}
\item \href{#method-CustomModelsVersionsDependencyBuildList}{\code{ModelsApi$CustomModelsVersionsDependencyBuildList()}}
\item \href{#method-CustomModelsVersionsDependencyBuildLogList}{\code{ModelsApi$CustomModelsVersionsDependencyBuildLogList()}}
\item \href{#method-CustomModelsVersionsDownloadList}{\code{ModelsApi$CustomModelsVersionsDownloadList()}}
\item \href{#method-CustomModelsVersionsFeatureImpactCreate}{\code{ModelsApi$CustomModelsVersionsFeatureImpactCreate()}}
\item \href{#method-CustomModelsVersionsFeatureImpactList}{\code{ModelsApi$CustomModelsVersionsFeatureImpactList()}}
\item \href{#method-CustomModelsVersionsFromRepositoryCreate}{\code{ModelsApi$CustomModelsVersionsFromRepositoryCreate()}}
\item \href{#method-CustomModelsVersionsFromRepositoryPatchMany}{\code{ModelsApi$CustomModelsVersionsFromRepositoryPatchMany()}}
\item \href{#method-CustomModelsVersionsList}{\code{ModelsApi$CustomModelsVersionsList()}}
\item \href{#method-CustomModelsVersionsPatch}{\code{ModelsApi$CustomModelsVersionsPatch()}}
\item \href{#method-CustomModelsVersionsPredictionExplanationsInitializationCreate}{\code{ModelsApi$CustomModelsVersionsPredictionExplanationsInitializationCreate()}}
\item \href{#method-CustomModelsVersionsRetrieve}{\code{ModelsApi$CustomModelsVersionsRetrieve()}}
\item \href{#method-CustomTrainingBlueprintsCreate}{\code{ModelsApi$CustomTrainingBlueprintsCreate()}}
\item \href{#method-CustomTrainingBlueprintsList}{\code{ModelsApi$CustomTrainingBlueprintsList()}}
\item \href{#method-ModelExportsCreate}{\code{ModelsApi$ModelExportsCreate()}}
\item \href{#method-ModelPackagesArchiveCreate}{\code{ModelsApi$ModelPackagesArchiveCreate()}}
\item \href{#method-ModelPackagesFeaturesList}{\code{ModelsApi$ModelPackagesFeaturesList()}}
\item \href{#method-ModelPackagesFromLearningModelCreate}{\code{ModelsApi$ModelPackagesFromLearningModelCreate()}}
\item \href{#method-ModelPackagesList}{\code{ModelsApi$ModelPackagesList()}}
\item \href{#method-ModelPackagesRetrieve}{\code{ModelsApi$ModelPackagesRetrieve()}}
\item \href{#method-ModelPackagesSharedRolesList}{\code{ModelsApi$ModelPackagesSharedRolesList()}}
\item \href{#method-ProjectsBlenderBuildersCreate}{\code{ModelsApi$ProjectsBlenderBuildersCreate()}}
\item \href{#method-ProjectsBlenderBuildersList}{\code{ModelsApi$ProjectsBlenderBuildersList()}}
\item \href{#method-ProjectsBlenderBuildersRetrieve}{\code{ModelsApi$ProjectsBlenderBuildersRetrieve()}}
\item \href{#method-ProjectsBlenderModelsBlendCheckCreate}{\code{ModelsApi$ProjectsBlenderModelsBlendCheckCreate()}}
\item \href{#method-ProjectsBlenderModelsCreate}{\code{ModelsApi$ProjectsBlenderModelsCreate()}}
\item \href{#method-ProjectsBlenderModelsList}{\code{ModelsApi$ProjectsBlenderModelsList()}}
\item \href{#method-ProjectsBlenderModelsRetrieve}{\code{ModelsApi$ProjectsBlenderModelsRetrieve()}}
\item \href{#method-ProjectsCombinedModelsList}{\code{ModelsApi$ProjectsCombinedModelsList()}}
\item \href{#method-ProjectsCombinedModelsRetrieve}{\code{ModelsApi$ProjectsCombinedModelsRetrieve()}}
\item \href{#method-ProjectsCombinedModelsSegmentsDownloadList}{\code{ModelsApi$ProjectsCombinedModelsSegmentsDownloadList()}}
\item \href{#method-ProjectsCombinedModelsSegmentsList}{\code{ModelsApi$ProjectsCombinedModelsSegmentsList()}}
\item \href{#method-ProjectsDatetimeModelsBacktestsCreate}{\code{ModelsApi$ProjectsDatetimeModelsBacktestsCreate()}}
\item \href{#method-ProjectsDatetimeModelsCreate}{\code{ModelsApi$ProjectsDatetimeModelsCreate()}}
\item \href{#method-ProjectsDatetimeModelsFromModelCreate}{\code{ModelsApi$ProjectsDatetimeModelsFromModelCreate()}}
\item \href{#method-ProjectsDatetimeModelsList}{\code{ModelsApi$ProjectsDatetimeModelsList()}}
\item \href{#method-ProjectsDatetimeModelsRetrieve}{\code{ModelsApi$ProjectsDatetimeModelsRetrieve()}}
\item \href{#method-ProjectsDeploymentReadyModelsCreate}{\code{ModelsApi$ProjectsDeploymentReadyModelsCreate()}}
\item \href{#method-ProjectsEureqaDistributionPlotRetrieve}{\code{ModelsApi$ProjectsEureqaDistributionPlotRetrieve()}}
\item \href{#method-ProjectsEureqaModelDetailRetrieve}{\code{ModelsApi$ProjectsEureqaModelDetailRetrieve()}}
\item \href{#method-ProjectsEureqaModelsCreate}{\code{ModelsApi$ProjectsEureqaModelsCreate()}}
\item \href{#method-ProjectsEureqaModelsRetrieve}{\code{ModelsApi$ProjectsEureqaModelsRetrieve()}}
\item \href{#method-ProjectsFrozenDatetimeModelsCreate}{\code{ModelsApi$ProjectsFrozenDatetimeModelsCreate()}}
\item \href{#method-ProjectsFrozenModelsCreate}{\code{ModelsApi$ProjectsFrozenModelsCreate()}}
\item \href{#method-ProjectsFrozenModelsList}{\code{ModelsApi$ProjectsFrozenModelsList()}}
\item \href{#method-ProjectsFrozenModelsRetrieve}{\code{ModelsApi$ProjectsFrozenModelsRetrieve()}}
\item \href{#method-ProjectsModelJobsDelete}{\code{ModelsApi$ProjectsModelJobsDelete()}}
\item \href{#method-ProjectsModelJobsList}{\code{ModelsApi$ProjectsModelJobsList()}}
\item \href{#method-ProjectsModelJobsRetrieve}{\code{ModelsApi$ProjectsModelJobsRetrieve()}}
\item \href{#method-ProjectsModelsAdvancedTuningCreate}{\code{ModelsApi$ProjectsModelsAdvancedTuningCreate()}}
\item \href{#method-ProjectsModelsAdvancedTuningParametersList}{\code{ModelsApi$ProjectsModelsAdvancedTuningParametersList()}}
\item \href{#method-ProjectsModelsClusterNamesList}{\code{ModelsApi$ProjectsModelsClusterNamesList()}}
\item \href{#method-ProjectsModelsClusterNamesPatchMany}{\code{ModelsApi$ProjectsModelsClusterNamesPatchMany()}}
\item \href{#method-ProjectsModelsCreate}{\code{ModelsApi$ProjectsModelsCreate()}}
\item \href{#method-ProjectsModelsCrossValidationCreate}{\code{ModelsApi$ProjectsModelsCrossValidationCreate()}}
\item \href{#method-ProjectsModelsCrossValidationScoresList}{\code{ModelsApi$ProjectsModelsCrossValidationScoresList()}}
\item \href{#method-ProjectsModelsDelete}{\code{ModelsApi$ProjectsModelsDelete()}}
\item \href{#method-ProjectsModelsExportList}{\code{ModelsApi$ProjectsModelsExportList()}}
\item \href{#method-ProjectsModelsFeaturesList}{\code{ModelsApi$ProjectsModelsFeaturesList()}}
\item \href{#method-ProjectsModelsFromModelCreate}{\code{ModelsApi$ProjectsModelsFromModelCreate()}}
\item \href{#method-ProjectsModelsList}{\code{ModelsApi$ProjectsModelsList()}}
\item \href{#method-ProjectsModelsMissingReportList}{\code{ModelsApi$ProjectsModelsMissingReportList()}}
\item \href{#method-ProjectsModelsNumIterationsTrainedList}{\code{ModelsApi$ProjectsModelsNumIterationsTrainedList()}}
\item \href{#method-ProjectsModelsParametersList}{\code{ModelsApi$ProjectsModelsParametersList()}}
\item \href{#method-ProjectsModelsPatch}{\code{ModelsApi$ProjectsModelsPatch()}}
\item \href{#method-ProjectsModelsPredictionIntervalsCreate}{\code{ModelsApi$ProjectsModelsPredictionIntervalsCreate()}}
\item \href{#method-ProjectsModelsPredictionIntervalsList}{\code{ModelsApi$ProjectsModelsPredictionIntervalsList()}}
\item \href{#method-ProjectsModelsPrimeInfoList}{\code{ModelsApi$ProjectsModelsPrimeInfoList()}}
\item \href{#method-ProjectsModelsPrimeRulesetsCreate}{\code{ModelsApi$ProjectsModelsPrimeRulesetsCreate()}}
\item \href{#method-ProjectsModelsPrimeRulesetsList}{\code{ModelsApi$ProjectsModelsPrimeRulesetsList()}}
\item \href{#method-ProjectsModelsRetrieve}{\code{ModelsApi$ProjectsModelsRetrieve()}}
\item \href{#method-ProjectsModelsScoringCodeList}{\code{ModelsApi$ProjectsModelsScoringCodeList()}}
\item \href{#method-ProjectsModelsSupportedCapabilitiesList}{\code{ModelsApi$ProjectsModelsSupportedCapabilitiesList()}}
\item \href{#method-ProjectsPrimeFilesCreate}{\code{ModelsApi$ProjectsPrimeFilesCreate()}}
\item \href{#method-ProjectsPrimeFilesDownloadList}{\code{ModelsApi$ProjectsPrimeFilesDownloadList()}}
\item \href{#method-ProjectsPrimeFilesList}{\code{ModelsApi$ProjectsPrimeFilesList()}}
\item \href{#method-ProjectsPrimeFilesRetrieve}{\code{ModelsApi$ProjectsPrimeFilesRetrieve()}}
\item \href{#method-ProjectsPrimeModelsCreate}{\code{ModelsApi$ProjectsPrimeModelsCreate()}}
\item \href{#method-ProjectsPrimeModelsList}{\code{ModelsApi$ProjectsPrimeModelsList()}}
\item \href{#method-ProjectsPrimeModelsRetrieve}{\code{ModelsApi$ProjectsPrimeModelsRetrieve()}}
\item \href{#method-ProjectsRatingTableModelsCreate}{\code{ModelsApi$ProjectsRatingTableModelsCreate()}}
\item \href{#method-ProjectsRatingTableModelsList}{\code{ModelsApi$ProjectsRatingTableModelsList()}}
\item \href{#method-ProjectsRatingTableModelsRetrieve}{\code{ModelsApi$ProjectsRatingTableModelsRetrieve()}}
\item \href{#method-ProjectsRatingTablesCreate}{\code{ModelsApi$ProjectsRatingTablesCreate()}}
\item \href{#method-ProjectsRatingTablesFileList}{\code{ModelsApi$ProjectsRatingTablesFileList()}}
\item \href{#method-ProjectsRatingTablesList}{\code{ModelsApi$ProjectsRatingTablesList()}}
\item \href{#method-ProjectsRatingTablesPatch}{\code{ModelsApi$ProjectsRatingTablesPatch()}}
\item \href{#method-ProjectsRatingTablesRetrieve}{\code{ModelsApi$ProjectsRatingTablesRetrieve()}}
\item \href{#method-ProjectsRecommendedModelsList}{\code{ModelsApi$ProjectsRecommendedModelsList()}}
\item \href{#method-ProjectsRecommendedModelsRecommendedModelList}{\code{ModelsApi$ProjectsRecommendedModelsRecommendedModelList()}}
\item \href{#method-ProjectsSegmentChampionPutMany}{\code{ModelsApi$ProjectsSegmentChampionPutMany()}}
\item \href{#method-clone}{\code{ModelsApi$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$new(apiClient)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{apiClient}}{A configurable \code{ApiClient} instance. If none provided, a new client with default configuration will be created.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomInferenceImagesFeatureImpactCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomInferenceImagesFeatureImpactCreate}{}}}
\subsection{Method \code{CustomInferenceImagesFeatureImpactCreate()}}{
Create custom model feature impact.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomInferenceImagesFeatureImpactCreate(
  imageId,
  featureImpactCreatePayload = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{imageId}}{character. ID of the image of the custom inference model to submit feature impact job for.}

\item{\code{featureImpactCreatePayload}}{\link{FeatureImpactCreatePayload}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Add a request to calculate feature impact for a custom inference model image to             the queue.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:post:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/`  This route is a counterpart of a corresponding endpoint for native models: :http:post:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Feature impact request has been successfully submitted.
\itemize{
\item \strong{\code{Location}} Contains a url for tracking job status: :http:get:`/api/v2/status/(statusId)/`.
}
\item \strong{\code{404}} If feature impact has already been submitted. The response will include `jobId` property which can be used for tracking its progress.
\itemize{
}
\item \strong{\code{422}} If job cannot be submitted because of invalid input or model state: (1) if image id does not correspond to a custom inference model, (2) if training data is not yet assigned or assignment is in progress, (3) if the `rowCount` exceeds the minimum or maximum value for this model's training data.
\itemize{
}
}
}

\subsection{Returns}{
\link{FeatureImpactCreateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
imageId <- 'imageId_example' # character | ID of the image of the custom inference model to submit feature impact job for.
featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$CustomInferenceImagesFeatureImpactCreate(imageId, featureImpactCreatePayload=featureImpactCreatePayload)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomInferenceImagesFeatureImpactList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomInferenceImagesFeatureImpactList}{}}}
\subsection{Method \code{CustomInferenceImagesFeatureImpactList()}}{
Get custom model feature impact.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomInferenceImagesFeatureImpactList(imageId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{imageId}}{character. ID of the image of the custom inference model to retrieve feature impact from.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve feature impact scores for features in a custom inference model image.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:get:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/`  This route is a counterpart of a corresponding endpoint for native models: :http:get:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Custom model feature impact returned.
\itemize{
}
\item \strong{\code{404}} No feature impact data found for custom model.
\itemize{
}
\item \strong{\code{422}} Cannot retrieve feature impact scores: (1) if custom model is not an inference model, (2) if training data is not assigned, (3) if feature impact job is in progress for custom model.
\itemize{
}
}
}

\subsection{Returns}{
\link{FeatureImpactResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
imageId <- 'imageId_example' # character | ID of the image of the custom inference model to retrieve feature impact from.

api.instance <- ModelsApi$new()
result <- api.instance$CustomInferenceImagesFeatureImpactList(imageId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelDeploymentsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelDeploymentsList}{}}}
\subsection{Method \code{CustomModelDeploymentsList()}}{
List custom model deployments.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelDeploymentsList(
  offset,
  limit,
  customModelIds = NULL,
  environmentIds = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelIds}}{\link{OneOfstringarray}. List of ID's of the custom model which model deployments will be retrieved.}

\item{\code{environmentIds}}{\link{OneOfstringarray}. List of ID's of the execution environment which model deployments will be retrieved.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List of model deployments for user sorted by creation time descending.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
\item \strong{\code{400}} Query parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelDeploymentListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.
customModelIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the custom model which model deployments will be retrieved.
environmentIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the execution environment which model deployments will be retrieved.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelDeploymentsList(offset, limit, customModelIds=customModelIds, environmentIds=environmentIds)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelLimitsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelLimitsList}{}}}
\subsection{Method \code{CustomModelLimitsList()}}{
Get custom model resource limits.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelLimitsList(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve custom model resource limits the user has access to.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelResourceLimits}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelLimitsList()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsCreate}{}}}
\subsection{Method \code{CustomModelTestsCreate()}}{
Create custom model test.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsCreate(customModelTests = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelTests}}{\link{CustomModelTests}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Test a custom inference model. This will start a job to check that the custom model can make predictions against the supplied dataset without breaking.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Model testing job successfully started.
\itemize{
\item \strong{\code{Location}} URL that can be polled to check the status.
}
\item \strong{\code{403}} No access to use data for testing custom model.
\itemize{
}
\item \strong{\code{404}} Custom model or dataset not found.
\itemize{
}
\item \strong{\code{422}} Custom Model Testing cannot be submitted because of invalid input or model state: (1) if user does not have permission to create legacy conversion environment, (2) testing is already in progress for the custom model, (3) dataset used for testing is not snapshotted,(4) other cases.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelAsyncOperationResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelTests <- CustomModelTests$new() # CustomModelTests |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsCreate(customModelTests=customModelTests)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsDelete"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsDelete}{}}}
\subsection{Method \code{CustomModelTestsDelete()}}{
Cancel custom model test.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsDelete(customModelTestId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelTestId}}{character. ID of the testing history attempt.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Cancel custom inference model testing.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Testing canceled.
\itemize{
}
\item \strong{\code{404}} Testing attempt not found.
\itemize{
}
\item \strong{\code{409}} Testing attempt has already reached a terminal state.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsDelete(customModelTestId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsList}{}}}
\subsection{Method \code{CustomModelTestsList()}}{
List custom model tests.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsList(
  offset,
  limit,
  customModelId,
  maximumMemory = NULL,
  networkEgressPolicy = NULL,
  desiredMemory = NULL,
  replicas = NULL,
  requiresHa = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelId}}{character. ID of the Custom Model to retrieve testing history for.}

\item{\code{maximumMemory}}{integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed}

\item{\code{networkEgressPolicy}}{Enum < \link{NONE, PUBLIC} > Network egress policy.}

\item{\code{desiredMemory}}{integer. The amount of memory that is expected to be allocated by the custom model.}

\item{\code{replicas}}{integer. A fixed number of replicas that will be set for the given custom-model.}

\item{\code{requiresHa}}{character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the testing history for a model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelTestsListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the Custom Model to retrieve testing history for.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsList(offset, limit, customModelId, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, desiredMemory=desiredMemory, replicas=replicas, requiresHa=requiresHa)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsLogList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsLogList}{}}}
\subsection{Method \code{CustomModelTestsLogList()}}{
Get custom model test log.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsLogList(customModelTestId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelTestId}}{character. ID of the testing history attempt.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the logs from a model testing attempt.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The log file will be downloaded.
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download (\"attachment;filename=testing-<custom_model_id>.log\").
}
\item \strong{\code{404}} No testing log found.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsLogList(customModelTestId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsRetrieve}{}}}
\subsection{Method \code{CustomModelTestsRetrieve()}}{
Get custom model test.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsRetrieve(customModelTestId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelTestId}}{character. ID of the testing history attempt.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve a specific testing history entry for a custom model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelTestsResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsRetrieve(customModelTestId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelTestsTailList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelTestsTailList}{}}}
\subsection{Method \code{CustomModelTestsTailList()}}{
Get custom model test log tail.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelTestsTailList(lines, customModelTestId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lines}}{integer. Number of lines from the log to retrieve (1-1000, default 100).}

\item{\code{customModelTestId}}{character. ID of the testing history attempt.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the last N lines of logs from a model testing attempt.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The log tail was retrieved.
\itemize{
}
\item \strong{\code{400}} Requested number of lines is invalid.
\itemize{
}
\item \strong{\code{404}} The testing history entry cannot be found.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelTestsLogTailResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
lines <- 100 # integer | Number of lines from the log to retrieve (1-1000, default 100).
customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelTestsTailList(lines, customModelTestId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsAccessControlList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsAccessControlList}{}}}
\subsection{Method \code{CustomModelsAccessControlList()}}{
Get a list of users who have access to this custom model and their roles on it.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsAccessControlList(offset, limit, customModelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get a list of users who have access to this custom model and their roles on it.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A list of users who have access to this custom model and their roles on it.
\itemize{
}
\item \strong{\code{400}} Both username and userId were specified.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelAccessControlListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsAccessControlList(offset, limit, customModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsAccessControlPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsAccessControlPatchMany}{}}}
\subsection{Method \code{CustomModelsAccessControlPatchMany()}}{
Grant access or update roles for users on this custom model and appropriate learning data.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsAccessControlPatchMany(
  customModelId,
  sharingUpdateOrRemoveWithGrant = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{sharingUpdateOrRemoveWithGrant}}{\link{SharingUpdateOrRemoveWithGrant}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Grant access or update roles for users on this custom model and appropriate learning data. Up to 100 user roles may be set in a single request.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Roles updated successfully.
\itemize{
}
\item \strong{\code{409}} The request would leave the custom model without an owner.
\itemize{
}
\item \strong{\code{422}} One of the users in the request does not exist, or the request is otherwise invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelAccessControlUpdateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsAccessControlPatchMany(customModelId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsCreate}{}}}
\subsection{Method \code{CustomModelsCreate()}}{
Create custom model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsCreate(customModelCreate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelCreate}}{\link{CustomModelCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates a new custom model and returns the newly created metadata record for it.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  A regression model is expected to produce predictions that are arbitrary floating-point or integer numbers. A classification model is expected to return predictions with probability scores for each class.  For example, a binary classification model might return:  .. code:: Python      {         positiveClassLabel: probability,         negativeClassLabel: 1.0 - probability     }  For Custom Inference Models, the ``file`` parameter must be either a tarball or zip archive containing, at minimum, a script named ``start_server.sh``.  It may contain additional files, including scripts and precompiled binaries as well as data files.  ``start_server.sh`` may execute these scripts and/or binaries.  When this script is executed, it is run as part of an Environment (specified via subsequent API calls), and all included scripts and binaries can take advantage of any programming language interpreters, compilers, libraries, or other tools included in the Environment. ``start_server.sh`` must be marked as executable (``chmod +x``).  When ``start_server.sh`` is launched, it must launch and maintain (in the foreground) a Web server that listens on two URLs:  * ``GET $URL_PREFIX/``     This route must return a 200 response code with an empty body immediately     if the server is ready to respond to prediction requests.  Otherwise it should     either not accept the request, not respond to the request, or return a     503 response code. * ``POST $URL_PREFIX/predict_no_state/``     This route must accept as input a JSON object of the form:      .. code-block:: Python          {             'X': {                 'col1': \link{...col1_data...},                 'col2': \link{...col2_data...},                 'col3': \link{...col3_data...},                 ...             }         }      The data lists will all be the same length.      It must return a JSON object of the form:      .. code-block:: Python          {             'predictions': \link{...predictions data...}         }      The predictions data must correspond 1:1 to the rows in the input data lists.      ``$URL_PREFIX`` is provided as an environment variable.  The Web server process must     re-read its value every time the process starts, as it may change.     It is an opaque string that is guaranteed to be a valid URL component,     but may contain path separators (``/``).


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Created.
\itemize{
}
\item \strong{\code{403}} Custom model creation is not enabled.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelCreate <- CustomModelCreate$new() # CustomModelCreate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsCreate(customModelCreate=customModelCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsDelete"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsDelete}{}}}
\subsection{Method \code{CustomModelsDelete()}}{
Delete custom model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsDelete(customModelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Delete a custom model. Only users who have permission to edit custom model can delete it. Only custom models which are not currently deployed or undergoing custom model testing can be deleted. Relevant CustomModelImage will be deleted also.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Record deleted.
\itemize{
}
\item \strong{\code{409}} This custom model is currently deployed and cannot be deleted. The response body will contain link where those deployments can be retrieved.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsDelete(customModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsDownloadList}{}}}
\subsection{Method \code{CustomModelsDownloadList()}}{
Download the latest custom model version content.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsDownloadList(customModelId, pps = "False", ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{pps}}{Enum < \link{false, False, true, True} > Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download the latest item bundle from a custom model as a zip compressed archive.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The download succeeded.
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download (\"attachment;filename=model-<model_id>-version-<version_id>.zip\").
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsDownloadList(customModelId, pps=pps)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsFromCustomModelCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsFromCustomModelCreate}{}}}
\subsection{Method \code{CustomModelsFromCustomModelCreate()}}{
Clone custom model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsFromCustomModelCreate(customModelCopy = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelCopy}}{\link{CustomModelCopy}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Creates a copy of the provided custom model, including metadata, versions of that model, and uploaded files. Associates the new versions with files owned by the custom model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Successfully created copy.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelCopy <- CustomModelCopy$new() # CustomModelCopy |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsFromCustomModelCreate(customModelCopy=customModelCopy)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsList}{}}}
\subsection{Method \code{CustomModelsList()}}{
List custom models.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsList(
  offset,
  limit,
  customModelType = NULL,
  isDeployed = NULL,
  orderBy = NULL,
  searchFor = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelType}}{Enum < \link{training, inference} > If \"training\" specified, only Custom Training Tasks will be returned. If \"inference\" specified, only Custom Inference Models will be returned. If not specified, all custom models will be returned. After deprecation, only Custom Inference Models will be returned}

\item{\code{isDeployed}}{Enum < \link{false, False, true, True} > If \"true\" specified, only deployed custom models will be returned. If \"false\" specified, only not deployed custom models will be returned. If not specified, all custom models will be returned.}

\item{\code{orderBy}}{Enum < \link{created, -created, updated, -updated} > Sort order which will be applied to custom model list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom models being returned in order of creation time descending.}

\item{\code{searchFor}}{character. String to search for occurrence in custom model's description, language and name. Search is case insensitive. If not specified, all custom models will be returned.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve metadata for all custom models the user has access to.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelType <- 'customModelType_example' # character | If \"training\" specified, only Custom Training Tasks will be returned. If \"inference\" specified, only Custom Inference Models will be returned. If not specified, all custom models will be returned. After deprecation, only Custom Inference Models will be returned
isDeployed <- 'isDeployed_example' # character | If \"true\" specified, only deployed custom models will be returned. If \"false\" specified, only not deployed custom models will be returned. If not specified, all custom models will be returned.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom model list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom models being returned in order of creation time descending.
searchFor <- 'searchFor_example' # character | String to search for occurrence in custom model's description, language and name. Search is case insensitive. If not specified, all custom models will be returned.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsList(offset, limit, customModelType=customModelType, isDeployed=isDeployed, orderBy=orderBy, searchFor=searchFor)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsPatch"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsPatch}{}}}
\subsection{Method \code{CustomModelsPatch()}}{
Update custom model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsPatch(customModelId, customModelUpdate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelUpdate}}{\link{CustomModelUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Updates metadata for an existing custom model.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  Setting `positiveClassLabel` and `negativeClassLabel` to null will set the labels to their default values (1 and 0 for positiveClassLabel and negativeClassLabel, respectively).  Setting `positiveClassLabel`, `negativeClassLabel`, 'targetName` is disabled if model has active deployments or assigned training data.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Created.
\itemize{
}
\item \strong{\code{403}} Custom inference model modification is not enabled for the user.
\itemize{
}
\item \strong{\code{409}} Custom model cannot be updated while it is being validated or some fields cannot be updated after deployment or assigning training data.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelUpdate <- CustomModelUpdate$new() # CustomModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsPatch(customModelId, customModelUpdate=customModelUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsPredictionExplanationsInitializationCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsPredictionExplanationsInitializationCreate}{}}}
\subsection{Method \code{CustomModelsPredictionExplanationsInitializationCreate()}}{
Create a new prediction explanations initialization for custom model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsPredictionExplanationsInitializationCreate(
  customModelPredictionExplanations = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelPredictionExplanations}}{\link{CustomModelPredictionExplanations}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new prediction explanations initialization for custom model. This is a necessary prerequisite for generating prediction explanations.  .. minversion:: v2.23     DEPRECATED please use custom model version route instead:     :http:post:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/predictionExplanationsInitialization/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The request was accepted and will be worked on.
\itemize{
\item \strong{\code{Location}} URL to poll to track the prediction explanation initialization has finished.
}
\item \strong{\code{422}} Specified custom model is not valid for prediction explanations.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelPredictionExplanations <- CustomModelPredictionExplanations$new() # CustomModelPredictionExplanations |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsPredictionExplanationsInitializationCreate(customModelPredictionExplanations=customModelPredictionExplanations)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsRetrieve}{}}}
\subsection{Method \code{CustomModelsRetrieve()}}{
Get custom model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsRetrieve(customModelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve metadata for a custom model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsRetrieve(customModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsTrainingDataPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsTrainingDataPatchMany}{}}}
\subsection{Method \code{CustomModelsTrainingDataPatchMany()}}{
Assign training data to custom model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsTrainingDataPatchMany(
  customModelId,
  trainingDataAssignment = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{trainingDataAssignment}}{\link{TrainingDataAssignment}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Assigns training data from provided dataset to provided Custom Inference Model. For each of custom model's deployments the training data from the specified project is used as baseline, this will enable turning drift tracking on for those deployments.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The request was accepted and will be worked on.
\itemize{
\item \strong{\code{Location}} URL to poll to track the training data assignment has finished.
}
\item \strong{\code{409}} Custom model has assigned training data already and is deployed.
\itemize{
}
\item \strong{\code{410}} The requested Dataset has been deleted.
\itemize{
}
\item \strong{\code{422}} Dataset ingest must finish before assigning training data or provided dataset is incompatible with the custom model.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
trainingDataAssignment <- TrainingDataAssignment$new() # TrainingDataAssignment |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsTrainingDataPatchMany(customModelId, trainingDataAssignment=trainingDataAssignment)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionCreateFromLatest"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionCreateFromLatest}{}}}
\subsection{Method \code{CustomModelsVersionCreateFromLatest()}}{
Update custom model version files.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionCreateFromLatest(
  customModelId,
  baseEnvironmentId,
  isMajorUpdate,
  desiredMemory = NULL,
  file = NULL,
  filePath = NULL,
  filesToDelete = NULL,
  maximumMemory = NULL,
  networkEgressPolicy = NULL,
  replicas = NULL,
  requiredMetadata = NULL,
  requiredMetadataValues = NULL,
  requiresHa = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{baseEnvironmentId}}{character. The base environment to use with this model version.}

\item{\code{isMajorUpdate}}{Enum < \link{false, False, true, True} > If set to true, new major version will created, otherwise minor version will be created.}

\item{\code{desiredMemory}}{integer. The amount of memory that is expected to be allocated by the custom model.}

\item{\code{file}}{data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would \emph{also} need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.}

\item{\code{filePath}}{\link{OneOfstringarray}. The local path of the file being uploaded. See the `file` field explanation for more details.}

\item{\code{filesToDelete}}{\link{OneOfstringarray}. The IDs of the files to be deleted.}

\item{\code{maximumMemory}}{integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed}

\item{\code{networkEgressPolicy}}{Enum < \link{NONE, PUBLIC} > Network egress policy.}

\item{\code{replicas}}{integer. A fixed number of replicas that will be set for the given custom-model.}

\item{\code{requiredMetadata}}{character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.}

\item{\code{requiredMetadataValues}}{character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.}

\item{\code{requiresHa}}{character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom model version with files added, replaced or deleted. Files from the previous version of a custom models will be used as a basis.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Item successfully created.
\itemize{
}
\item \strong{\code{413}} Item or collection of items was too large in size (bytes).
\itemize{
}
\item \strong{\code{422}} Cannot create the custom task version due to one or more errors. All error responses will have a \"message\" field and some may have optional fields. The optional fields include: \link[=\\"errors\\", \\"dependencies\\", \\"invalidDependencies\\"]{\"errors\", \"dependencies\", \"invalidDependencies\"}
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
filesToDelete <- oneOf<string,array>$new() # OneOfstringarray | The IDs of the files to be deleted.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionCreateFromLatest(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory=desiredMemory, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsConversionsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsConversionsCreate}{}}}
\subsection{Method \code{CustomModelsVersionsConversionsCreate()}}{
Generates JAR file from particular files.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsConversionsCreate(
  customModelId,
  customModelVersionId,
  conversionCreateQuery = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{conversionCreateQuery}}{\link{ConversionCreateQuery}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Converts files in the given custom model version to a JAR file.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The request was accepted and will be worked on.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelConversionAsyncOperationResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionCreateQuery <- ConversionCreateQuery$new() # ConversionCreateQuery |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsCreate(customModelId, customModelVersionId, conversionCreateQuery=conversionCreateQuery)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsConversionsDelete"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsConversionsDelete}{}}}
\subsection{Method \code{CustomModelsVersionsConversionsDelete()}}{
Stop a given custom model conversion.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsConversionsDelete(
  customModelId,
  customModelVersionId,
  conversionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{conversionId}}{character. ID of the custom model conversion.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Stop a running conversion for given model and model version.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}}
\itemize{
}
\item \strong{\code{422}} The given conversion is not active.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionId <- 'conversionId_example' # character | ID of the custom model conversion.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsDelete(customModelId, customModelVersionId, conversionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsConversionsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsConversionsList}{}}}
\subsection{Method \code{CustomModelsVersionsConversionsList()}}{
Get a list or latest custom model conversion(s).
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsConversionsList(
  offset,
  limit,
  customModelId,
  customModelVersionId,
  isLatest = "false",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{isLatest}}{Enum < \link{false, False, true, True} > Whether to return only the latest associated custom model conversion or all of the associated ones.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get the list of custom model conversions that are associated with the given custom model. Alternatively, it can return a single item list of the latest custom model conversion that is associated with the given custom model version.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{ConversionListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
isLatest <- "false" # character | Whether to return only the latest associated custom model conversion or all of the associated ones.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsList(offset, limit, customModelId, customModelVersionId, isLatest=isLatest)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsConversionsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsConversionsRetrieve}{}}}
\subsection{Method \code{CustomModelsVersionsConversionsRetrieve()}}{
Get a given custom model conversion.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsConversionsRetrieve(
  customModelId,
  customModelVersionId,
  conversionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{conversionId}}{character. ID of the custom model conversion.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get a given custom model conversion.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{ConversionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
conversionId <- 'conversionId_example' # character | ID of the custom model conversion.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsConversionsRetrieve(customModelId, customModelVersionId, conversionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsCreate}{}}}
\subsection{Method \code{CustomModelsVersionsCreate()}}{
Create custom model version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsCreate(
  customModelId,
  isMajorUpdate,
  baseEnvironmentId = NULL,
  desiredMemory = NULL,
  file = NULL,
  filePath = NULL,
  maximumMemory = NULL,
  networkEgressPolicy = NULL,
  replicas = NULL,
  requiredMetadata = NULL,
  requiredMetadataValues = NULL,
  requiresHa = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{isMajorUpdate}}{Enum < \link{false, False, true, True} > If set to true, new major version will created, otherwise minor version will be created.}

\item{\code{baseEnvironmentId}}{character. The base environment to use with this model version.}

\item{\code{desiredMemory}}{integer. The amount of memory that is expected to be allocated by the custom model.}

\item{\code{file}}{data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would \emph{also} need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.}

\item{\code{filePath}}{\link{OneOfstringarray}. The local path of the file being uploaded. See the `file` field explanation for more details.}

\item{\code{maximumMemory}}{integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed}

\item{\code{networkEgressPolicy}}{Enum < \link{NONE, PUBLIC} > Network egress policy.}

\item{\code{replicas}}{integer. A fixed number of replicas that will be set for the given custom-model.}

\item{\code{requiredMetadata}}{character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.}

\item{\code{requiredMetadataValues}}{character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.}

\item{\code{requiresHa}}{character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom model version with attached files if supplied.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Item successfully created.
\itemize{
}
\item \strong{\code{413}} Item or collection of items was too large in size (bytes).
\itemize{
}
\item \strong{\code{422}} Cannot create the custom task version due to one or more errors. All error responses will have a \"message\" field and some may have optional fields. The optional fields include: \link[=\\"errors\\", \\"dependencies\\", \\"invalidDependencies\\"]{\"errors\", \"dependencies\", \"invalidDependencies\"}
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsCreate(customModelId, isMajorUpdate, baseEnvironmentId=baseEnvironmentId, desiredMemory=desiredMemory, file=file, filePath=filePath, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsDependencyBuildCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsDependencyBuildCreate}{}}}
\subsection{Method \code{CustomModelsVersionsDependencyBuildCreate()}}{
Start a custom model version's dependency build.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsDependencyBuildCreate(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Start a custom model version's dependency build. This is required to test, deploy, or train custom models.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Custom model version's dependency build has started.
\itemize{
}
\item \strong{\code{422}} Custom model dependency build has failed.
\itemize{
}
}
}

\subsection{Returns}{
\link{BaseDependencyBuildMetadataResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildCreate(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsDependencyBuildDeleteMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsDependencyBuildDeleteMany}{}}}
\subsection{Method \code{CustomModelsVersionsDependencyBuildDeleteMany()}}{
Cancel dependency build.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsDependencyBuildDeleteMany(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Cancel the custom model version's dependency build.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} Custom model version's dependency build was cancelled.
\itemize{
}
\item \strong{\code{409}} Custom model dependency build has reached a terminal state and cannot be cancelled.
\itemize{
}
\item \strong{\code{422}} No custom model dependency build started for specified version or dependency image is in use and cannot be deleted
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildDeleteMany(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsDependencyBuildList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsDependencyBuildList}{}}}
\subsection{Method \code{CustomModelsVersionsDependencyBuildList()}}{
Retrieve the custom model version's dependency build status.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsDependencyBuildList(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the custom model version's dependency build status.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The metadata from the custom model version's dependency build.
\itemize{
}
\item \strong{\code{422}} Custom model dependency build has not started.
\itemize{
}
}
}

\subsection{Returns}{
\link{BaseDependencyBuildMetadataResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildList(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsDependencyBuildLogList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsDependencyBuildLogList}{}}}
\subsection{Method \code{CustomModelsVersionsDependencyBuildLogList()}}{
Retrieve the custom model version's dependency build log.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsDependencyBuildLogList(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the custom model version's dependency build log.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The log file generated during the custom model version's dependency build.
\itemize{
}
\item \strong{\code{404}} Dependency build is in progress or could not be found.
\itemize{
}
\item \strong{\code{422}} Custom model dependency build has not started.
\itemize{
}
}
}

\subsection{Returns}{
\link{DependencyBuildLogResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDependencyBuildLogList(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsDownloadList}{}}}
\subsection{Method \code{CustomModelsVersionsDownloadList()}}{
Download custom model version content.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsDownloadList(
  customModelId,
  customModelVersionId,
  pps = "False",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{pps}}{Enum < \link{false, False, true, True} > Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download a specific item bundle from a custom model as a zip compressed archive.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The download succeeded.
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download (\"attachment;filename=model-<model_id>-version-<version_id>.zip\").
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsDownloadList(customModelId, customModelVersionId, pps=pps)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsFeatureImpactCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsFeatureImpactCreate}{}}}
\subsection{Method \code{CustomModelsVersionsFeatureImpactCreate()}}{
Create custom model feature impact.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsFeatureImpactCreate(
  customModelId,
  customModelVersionId,
  featureImpactCreatePayload = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{featureImpactCreatePayload}}{\link{FeatureImpactCreatePayload}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Add a request to calculate feature impact for a custom inference model image to             the queue.  This route is a counterpart of a corresponding endpoint for native models: :http:post:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Feature impact request has been successfully submitted.
\itemize{
\item \strong{\code{Location}} Contains a url for tracking job status: :http:get:`/api/v2/status/(statusId)/`.
}
\item \strong{\code{404}} If feature impact has already been submitted. The response will include `jobId` property which can be used for tracking its progress.
\itemize{
}
\item \strong{\code{422}} If job cannot be submitted because of invalid input or model state: (1) if image id does not correspond to a custom inference model, (2) if training data is not yet assigned or assignment is in progress, (3) if the `rowCount` exceeds the minimum or maximum value for this model's training data.
\itemize{
}
}
}

\subsection{Returns}{
\link{FeatureImpactCreateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFeatureImpactCreate(customModelId, customModelVersionId, featureImpactCreatePayload=featureImpactCreatePayload)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsFeatureImpactList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsFeatureImpactList}{}}}
\subsection{Method \code{CustomModelsVersionsFeatureImpactList()}}{
Get custom model feature impact.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsFeatureImpactList(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve feature impact scores for features in a custom inference model image.   This route is a counterpart of a corresponding endpoint for native models: :http:get:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Custom model feature impact returned.
\itemize{
}
\item \strong{\code{404}} No feature impact data found for custom model.
\itemize{
}
\item \strong{\code{422}} Cannot retrieve feature impact scores: (1) if custom model is not an inference model, (2) if training data is not assigned, (3) if feature impact job is in progress for custom model.
\itemize{
}
}
}

\subsection{Returns}{
\link{FeatureImpactResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFeatureImpactList(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsFromRepositoryCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsFromRepositoryCreate}{}}}
\subsection{Method \code{CustomModelsVersionsFromRepositoryCreate()}}{
Create custom model version from remote repository.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsFromRepositoryCreate(
  customModelId,
  customModelVersionCreateFromRepository = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionCreateFromRepository}}{\link{CustomModelVersionCreateFromRepository}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom model version with only files added from the specified remote repository.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Accepted: request placed to a queue for processing.
\itemize{
\item \strong{\code{Location}} URL for tracking async job status.
}
\item \strong{\code{422}} Custom Model version cannot be created: (1) input parameters are invalid, (2) if user does not have permission to create legacy conversion environment.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFromRepositoryCreate(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsFromRepositoryPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsFromRepositoryPatchMany}{}}}
\subsection{Method \code{CustomModelsVersionsFromRepositoryPatchMany()}}{
Create custom model version from remote repository with files from previous version.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsFromRepositoryPatchMany(
  customModelId,
  customModelVersionCreateFromRepository = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionCreateFromRepository}}{\link{CustomModelVersionCreateFromRepository}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new custom model version with files added from a remote repository. Files from the previous version of a custom models will be used as a basis.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Accepted: request placed to a queue for processing.
\itemize{
\item \strong{\code{Location}} URL for tracking async job status.
}
\item \strong{\code{422}} Custom Model version cannot be created: (1) input parameters are invalid, (2) if user does not have permission to create legacy conversion environment.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsFromRepositoryPatchMany(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsList}{}}}
\subsection{Method \code{CustomModelsVersionsList()}}{
List custom model versions.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsList(offset, limit, customModelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List custom model versions.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
\item \strong{\code{400}} Query parameters are invalid.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelVersionListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | ID of the custom model.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsList(offset, limit, customModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsPatch"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsPatch}{}}}
\subsection{Method \code{CustomModelsVersionsPatch()}}{
Update custom model version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsPatch(
  customModelId,
  customModelVersionId,
  customModelVersionMetadataUpdate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{customModelVersionMetadataUpdate}}{\link{CustomModelVersionMetadataUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Edit metadata of a specific model version.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The edit was successful.
\itemize{
}
\item \strong{\code{404}} Custom model not found or user does not have edit permissions.
\itemize{
}
\item \strong{\code{422}} Cannot update custom model metadata.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
customModelVersionMetadataUpdate <- CustomModelVersionMetadataUpdate$new() # CustomModelVersionMetadataUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsPatch(customModelId, customModelVersionId, customModelVersionMetadataUpdate=customModelVersionMetadataUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsPredictionExplanationsInitializationCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsPredictionExplanationsInitializationCreate}{}}}
\subsection{Method \code{CustomModelsVersionsPredictionExplanationsInitializationCreate()}}{
Create a new prediction explanations initialization for custom model version.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsPredictionExplanationsInitializationCreate(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new prediction explanations initialization for custom model version. This is a necessary prerequisite for generating prediction explanations.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The request was accepted and will be worked on.
\itemize{
\item \strong{\code{Location}} URL to poll to track the prediction explanation initialization has finished.
}
\item \strong{\code{422}} Specified custom model is not valid for prediction explanations.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsPredictionExplanationsInitializationCreate(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomModelsVersionsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-CustomModelsVersionsRetrieve}{}}}
\subsection{Method \code{CustomModelsVersionsRetrieve()}}{
Get custom model version.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomModelsVersionsRetrieve(
  customModelId,
  customModelVersionId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customModelId}}{character. ID of the custom model.}

\item{\code{customModelVersionId}}{character. ID of the custom model version.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Display a requested version of a custom model along with the files attached to it.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomModelVersionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customModelId <- 'customModelId_example' # character | ID of the custom model.
customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.

api.instance <- ModelsApi$new()
result <- api.instance$CustomModelsVersionsRetrieve(customModelId, customModelVersionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTrainingBlueprintsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTrainingBlueprintsCreate}{}}}
\subsection{Method \code{CustomTrainingBlueprintsCreate()}}{
Create a blueprint from a single custom training estimator.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomTrainingBlueprintsCreate(
  customTrainingBlueprintCreate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{customTrainingBlueprintCreate}}{\link{CustomTrainingBlueprintCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This route creates a blueprint from a custom training estimator with an environment so that it can be trained via blueprint ID.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Blueprint successfully created.
\itemize{
}
\item \strong{\code{404}} Any of the entities in the request cannot be retrieved.
\itemize{
}
\item \strong{\code{422}} Input parameters are invalid: either the custom model is for inference or no environment version ID was specified and the given environment has no versions.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTrainingBlueprintResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
customTrainingBlueprintCreate <- CustomTrainingBlueprintCreate$new() # CustomTrainingBlueprintCreate |

api.instance <- ModelsApi$new()
result <- api.instance$CustomTrainingBlueprintsCreate(customTrainingBlueprintCreate=customTrainingBlueprintCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-CustomTrainingBlueprintsList"></a>}}
\if{latex}{\out{\hypertarget{method-CustomTrainingBlueprintsList}{}}}
\subsection{Method \code{CustomTrainingBlueprintsList()}}{
List training blueprints.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$CustomTrainingBlueprintsList(
  offset,
  limit,
  customModelId = NULL,
  reverse = "False",
  targetTypes = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{customModelId}}{character. List blueprints for a specific model. Default: all.}

\item{\code{reverse}}{Enum < \link{false, False, true, True} > List blueprints in reverse order.}

\item{\code{targetTypes}}{Enum < \link{Binary, Regression, Multiclass, Anomaly, Transform, Unstructured} > Custom model target types to return.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List custom training blueprints.  This route retrieves the metadata for all custom training blueprints             a user has access to.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Custom training blueprint list returned.
\itemize{
}
}
}

\subsection{Returns}{
\link{CustomTrainingBlueprintListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 1000 # integer | At most this many results are returned.
customModelId <- 'customModelId_example' # character | List blueprints for a specific model. Default: all.
reverse <- "False" # character | List blueprints in reverse order.
targetTypes <- ['targetTypes_example'] # array[character] | Custom model target types to return.

api.instance <- ModelsApi$new()
result <- api.instance$CustomTrainingBlueprintsList(offset, limit, customModelId=customModelId, reverse=reverse, targetTypes=targetTypes)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelExportsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ModelExportsCreate}{}}}
\subsection{Method \code{ModelExportsCreate()}}{
Create model export job
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelExportsCreate(modelExport = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{modelExport}}{\link{ModelExport}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create model export job. Note: Export of User and Open-Source models (and blenders including these models) is not supported at the moment.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}}
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{403}} You do not have permissions on this project to manage models
\itemize{
}
\item \strong{\code{422}} Model export is not supported in selected models.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
modelExport <- ModelExport$new() # ModelExport |

api.instance <- ModelsApi$new()
result <- api.instance$ModelExportsCreate(modelExport=modelExport)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesArchiveCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesArchiveCreate}{}}}
\subsection{Method \code{ModelPackagesArchiveCreate()}}{
Archive a model package.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesArchiveCreate(modelPackageId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{modelPackageId}}{character. ID of the model package.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Permanently archive a model package. It will no longer be able to be used in new deployments or replacement. It will not be accessible in the model package list api. It will only be accessible at the model package retrieve route for this model package.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}}
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesArchiveCreate(modelPackageId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesFeaturesList"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesFeaturesList}{}}}
\subsection{Method \code{ModelPackagesFeaturesList()}}{
Retrieve feature list.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesFeaturesList(
  offset,
  limit,
  modelPackageId,
  includeNonPredictionFeatures = "false",
  forSegmentedAnalysis = "false",
  search = NULL,
  orderBy = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. The number of features to skip, defaults to 0.}

\item{\code{limit}}{integer. The number of features to return, defaults to 0.}

\item{\code{modelPackageId}}{character. ID of the model package.}

\item{\code{includeNonPredictionFeatures}}{Enum < \link{false, False, true, True} > When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.}

\item{\code{forSegmentedAnalysis}}{Enum < \link{false, False, true, True} > When True, features returned will be filtered to those usable for segmented analysis.}

\item{\code{search}}{character. Case insensitive search against names of the deployment's features.}

\item{\code{orderBy}}{Enum < \link{name, -name, importance, -importance, featureType, -featureType, dateFormat, -dateFormat, knownInAdvance, -knownInAdvance} > Sort order which will be applied to model package feature list. Prefix the attribute name with a dash to sort in descending order, e.g. \"-name\".}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the feature list for given model package.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} OK.
\itemize{
}
}
}

\subsection{Returns}{
\link{FeatureListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | The number of features to skip, defaults to 0.
limit <- 50 # integer | The number of features to return, defaults to 0.
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
includeNonPredictionFeatures <- "false" # character | When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
forSegmentedAnalysis <- "false" # character | When True, features returned will be filtered to those usable for segmented analysis.
search <- 'search_example' # character | Case insensitive search against names of the deployment's features.
orderBy <- 'orderBy_example' # character | Sort order which will be applied to model package feature list. Prefix the attribute name with a dash to sort in descending order, e.g. \"-name\".

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesFeaturesList(offset, limit, modelPackageId, includeNonPredictionFeatures=includeNonPredictionFeatures, forSegmentedAnalysis=forSegmentedAnalysis, search=search, orderBy=orderBy)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesFromLearningModelCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesFromLearningModelCreate}{}}}
\subsection{Method \code{ModelPackagesFromLearningModelCreate()}}{
Create model package from DataRobot model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesFromLearningModelCreate(
  modelPackageCreateFromLearningModel = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{modelPackageCreateFromLearningModel}}{\link{ModelPackageCreateFromLearningModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create model package from DataRobot model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}}
\itemize{
}
\item \strong{\code{403}} The user does not have permission to create a Model Package.
\itemize{
}
\item \strong{\code{404}} Either the model_id not exist or the user does not have permission to view the model and project.
\itemize{
}
\item \strong{\code{422}} Unable to process the Model Package creation request.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
modelPackageCreateFromLearningModel <- ModelPackageCreateFromLearningModel$new() # ModelPackageCreateFromLearningModel |

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesFromLearningModelCreate(modelPackageCreateFromLearningModel=modelPackageCreateFromLearningModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesList"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesList}{}}}
\subsection{Method \code{ModelPackagesList()}}{
List model packages
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesList(
  offset = 0,
  limit = 100,
  modelId = NULL,
  similarTo = NULL,
  forChallenger = NULL,
  search = NULL,
  predictionThreshold = NULL,
  imported = NULL,
  predictionEnvironmentId = NULL,
  modelKind = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{modelId}}{character. If specified, limit results to model packages for the model with the specified ID.}

\item{\code{similarTo}}{character. Return model packages similar to a given model package ID. If used, will only return model packages that match `target.name`, `target.type`, `target.classNames` (for classification models), `modelKind.isTimeSeries`, and `modelKind.isMultiseries` of the specified model package.}

\item{\code{forChallenger}}{character. Can be used with similarTo to request similar model packages with the intent to use them as challenger models; for external model packages, instead of returning similar external model packages, similar DataRobot and Custom model packages will be retrieved.}

\item{\code{search}}{character. Provide a term to search for in package name, model name, or description}

\item{\code{predictionThreshold}}{numeric. Prediction threshold used for binary classification models}

\item{\code{imported}}{character. If specified, filter for either imported (true) or non-imported (false) model packages}

\item{\code{predictionEnvironmentId}}{character. Can be used to filter packages by what is supported by the prediction environment}

\item{\code{modelKind}}{\link{OneOfstringarray}. Return models from the registry that match a specific format.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the list of model packages a user has access to.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
\item \strong{\code{400}} Request invalid, refer to messages for detail.
\itemize{
}
\item \strong{\code{403}} Either MMM Model Packages or New Model Registry are not enabled.
\itemize{
}
\item \strong{\code{404}} User permissions problem.
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelPackageListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.
modelId <- 'modelId_example' # character | If specified, limit results to model packages for the model with the specified ID.
similarTo <- 'similarTo_example' # character | Return model packages similar to a given model package ID. If used, will only return model packages that match `target.name`, `target.type`, `target.classNames` (for classification models), `modelKind.isTimeSeries`, and `modelKind.isMultiseries` of the specified model package.
forChallenger <- 'forChallenger_example' # character | Can be used with similarTo to request similar model packages with the intent to use them as challenger models; for external model packages, instead of returning similar external model packages, similar DataRobot and Custom model packages will be retrieved.
search <- 'search_example' # character | Provide a term to search for in package name, model name, or description
predictionThreshold <- 3.4 # numeric | Prediction threshold used for binary classification models
imported <- 'imported_example' # character | If specified, filter for either imported (true) or non-imported (false) model packages
predictionEnvironmentId <- 'predictionEnvironmentId_example' # character | Can be used to filter packages by what is supported by the prediction environment
modelKind <- OneOfstringarray$new() # OneOfstringarray | Return models from the registry that match a specific format.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesList(offset=offset, limit=limit, modelId=modelId, similarTo=similarTo, forChallenger=forChallenger, search=search, predictionThreshold=predictionThreshold, imported=imported, predictionEnvironmentId=predictionEnvironmentId, modelKind=modelKind)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesRetrieve}{}}}
\subsection{Method \code{ModelPackagesRetrieve()}}{
Retrieve info about a model package.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesRetrieve(modelPackageId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{modelPackageId}}{character. ID of the model package.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve info about a model package.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
\item \strong{\code{404}} Either the model package does not exist or the user does not have permission to view the model package.
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelPackageRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesRetrieve(modelPackageId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ModelPackagesSharedRolesList"></a>}}
\if{latex}{\out{\hypertarget{method-ModelPackagesSharedRolesList}{}}}
\subsection{Method \code{ModelPackagesSharedRolesList()}}{
Get model package's access control list
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ModelPackagesSharedRolesList(
  offset,
  limit,
  modelPackageId,
  id = NULL,
  name = NULL,
  shareRecipientType = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped}

\item{\code{limit}}{integer. At most this many results are returned}

\item{\code{modelPackageId}}{character. ID of the model package.}

\item{\code{id}}{character. Only return roles for a user, group or organization with this identifier.}

\item{\code{name}}{character. Only return roles for a user, group or organization with this name.}

\item{\code{shareRecipientType}}{Enum < \link{user, group, organization} > List access controls for recipients with this type.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get a list of users, groups and organizations who have access to this template and their roles on the template.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The model package's access control list.
\itemize{
}
\item \strong{\code{400}} Both username and userId were specified
\itemize{
}
\item \strong{\code{404}} Either the Model Package does not exist or the user does not have permissions to view the Model Package.
\itemize{
}
}
}

\subsection{Returns}{
\link{SharingListV2Response}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped
limit <- 10 # integer | At most this many results are returned
modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.

api.instance <- ModelsApi$new()
result <- api.instance$ModelPackagesSharedRolesList(offset, limit, modelPackageId, id=id, name=name, shareRecipientType=shareRecipientType)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderBuildersCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderBuildersCreate}{}}}
\subsection{Method \code{ProjectsBlenderBuildersCreate()}}{
Create blenders using the blender builder system.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderBuildersCreate(
  projectId,
  baseBlenderBuilderCreate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{baseBlenderBuilderCreate}}{\link{BaseBlenderBuilderCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a blender builder job, which will create one or more blenders.  The CORRELATION     method uses a combination of model accuracy score along with correlation between models to     select models for blending.  The VALIDATION method uses the raw model accuracy scores, but     can be useful for creating different types of blenders with those models.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A list of blenderbuilder IDs
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
baseBlenderBuilderCreate <- BaseBlenderBuilderCreate$new() # BaseBlenderBuilderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersCreate(projectId, baseBlenderBuilderCreate=baseBlenderBuilderCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderBuildersList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderBuildersList}{}}}
\subsection{Method \code{ProjectsBlenderBuildersList()}}{
Get information about all blender builder jobs associated with the project.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderBuildersList(projectId, offset, limit, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID that the blender builder is associated with.}

\item{\code{offset}}{integer. The maximum number of blender builder job records to return}

\item{\code{limit}}{integer. pagination offset}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get information about all blender builder jobs associated with the project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} List of blender builder job IDs in the project
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
offset <- 0 # integer | The maximum number of blender builder job records to return
limit <- 100 # integer | pagination offset

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersList(projectId, offset, limit)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderBuildersRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderBuildersRetrieve}{}}}
\subsection{Method \code{ProjectsBlenderBuildersRetrieve()}}{
Get information about a completed blender builder job.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderBuildersRetrieve(projectId, buildId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID that the blender builder is associated with.}

\item{\code{buildId}}{character. The ID of the blender builder job to get data for.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get information about a completed blender builder job.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Blender builder job result
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
buildId <- 'buildId_example' # character | The ID of the blender builder job to get data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderBuildersRetrieve(projectId, buildId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderModelsBlendCheckCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderModelsBlendCheckCreate}{}}}
\subsection{Method \code{ProjectsBlenderModelsBlendCheckCreate()}}{
Check if models can be blended.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderModelsBlendCheckCreate(
  projectId,
  blenderCreate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{blenderCreate}}{\link{BlenderCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Check if models can be blended.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Information on whether models can be blended and why.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} Unable to process request.
\itemize{
}
}
}

\subsection{Returns}{
\link{BlenderInfoRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
blenderCreate <- BlenderCreate$new() # BlenderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsBlendCheckCreate(projectId, blenderCreate=blenderCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderModelsCreate}{}}}
\subsection{Method \code{ProjectsBlenderModelsCreate()}}{
Create a blender from other models using a specified blender method.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderModelsCreate(projectId, blenderCreate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{blenderCreate}}{\link{BlenderCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a blender from other models using a specified blender method. Note: Time Series projects only allow the following blender methods: \"AVG\", \"MED\", \"FORECAST_DISTANCE_ENET\", and \"FORECAST_DISTANCE_AVG\".


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Model job successfully added to queue. See the Location header.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status of the job.
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} Unable to create a blender or request is not supported in this context.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
blenderCreate <- BlenderCreate$new() # BlenderCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsCreate(projectId, blenderCreate=blenderCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderModelsList}{}}}
\subsection{Method \code{ProjectsBlenderModelsList()}}{
List all blenders in a project.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderModelsList(offset, limit, projectId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned. If 0, all results.}

\item{\code{projectId}}{character. The project ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all blenders in a project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A list of all of the blenders in a project.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
}
}

\subsection{Returns}{
\link{BlenderListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 0 # integer | At most this many results are returned. If 0, all results.
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsList(offset, limit, projectId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsBlenderModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsBlenderModelsRetrieve}{}}}
\subsection{Method \code{ProjectsBlenderModelsRetrieve()}}{
Retrieve a blender.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsBlenderModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve a blender. Blenders are a special type of models, so the response includes all attributes that would be in a response to :http:get:`/api/v2/projects/(projectId)/models/(modelId)/` as well as some additional ones.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The blender model.
\itemize{
}
\item \strong{\code{404}} Specified blender not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{BlenderRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsBlenderModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsCombinedModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsCombinedModelsList}{}}}
\subsection{Method \code{ProjectsCombinedModelsList()}}{
Retrieve all existing combined models for this project.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsCombinedModelsList(projectId, offset = 0, limit = 100, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{offset}}{integer. Number of results to skip.}

\item{\code{limit}}{integer. At most this many results are returned. The default may change without notice.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve all existing combined models for this project. .. note::      To retrieve information on the segments for a combined model, retrieve the combined model using :http:get:`/api/v2/projects/(projectId)/combinedModels/(combinedModelId)/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{CombinedModelListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsList(projectId, offset=offset, limit=limit)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsCombinedModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsCombinedModelsRetrieve}{}}}
\subsection{Method \code{ProjectsCombinedModelsRetrieve()}}{
Retrieve an existing combined model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsCombinedModelsRetrieve(projectId, combinedModelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The ID of the project.}

\item{\code{combinedModelId}}{character. The ID of combined model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve an existing combined model. If available, contains information on which champion model is used for each segment.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{CombinedModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsRetrieve(projectId, combinedModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsCombinedModelsSegmentsDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsCombinedModelsSegmentsDownloadList}{}}}
\subsection{Method \code{ProjectsCombinedModelsSegmentsDownloadList()}}{
Download Combined Model segments info.
Produces: "text/csv"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsCombinedModelsSegmentsDownloadList(
  projectId,
  combinedModelId,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The ID of the project.}

\item{\code{combinedModelId}}{character. The ID of combined model.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download Combined Model segments info (name, related project & model details) as a CSV.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
\item \strong{\code{ContentMinusDisposition}} Contains an auto generated filename for this download.
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsSegmentsDownloadList(projectId, combinedModelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsCombinedModelsSegmentsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsCombinedModelsSegmentsList}{}}}
\subsection{Method \code{ProjectsCombinedModelsSegmentsList()}}{
Retrieve Combined Model segments info.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsCombinedModelsSegmentsList(
  projectId,
  combinedModelId,
  offset = 0,
  limit = 100,
  searchSegmentName = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The ID of the project.}

\item{\code{combinedModelId}}{character. The ID of combined model.}

\item{\code{offset}}{integer. Number of results to skip.}

\item{\code{limit}}{integer. At most this many results are returned. The default may change without notice.}

\item{\code{searchSegmentName}}{character. Case insensitive search against segment name.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve Combined Model segments info (name, related project & model details).


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{CombinedModelSegmentsPaginatedResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The ID of the project.
combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.
searchSegmentName <- 'searchSegmentName_example' # character | Case insensitive search against segment name.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsCombinedModelsSegmentsList(projectId, combinedModelId, offset=offset, limit=limit, searchSegmentName=searchSegmentName)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDatetimeModelsBacktestsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDatetimeModelsBacktestsCreate}{}}}
\subsection{Method \code{ProjectsDatetimeModelsBacktestsCreate()}}{
Score all the available backtests of a datetime model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDatetimeModelsBacktestsCreate(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Score all the available backtests of a datetime model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Scoring of all the available backtests of a datetime model has been successfully requested.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsBacktestsCreate(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDatetimeModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDatetimeModelsCreate}{}}}
\subsection{Method \code{ProjectsDatetimeModelsCreate()}}{
Train a new datetime model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDatetimeModelsCreate(
  projectId,
  trainDatetimeModel = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{trainDatetimeModel}}{\link{TrainDatetimeModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Train a new datetime model.  All durations and datetimes should be specified in accordance with the :ref:`timestamp and duration formatting rules<time_format>`.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The model has been successfully submitted.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{422}} There was an error submitting the specified job. See the `message` field for more details.
\itemize{
}
}
}

\subsection{Returns}{
\link{DatetimeModelSubmissionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
trainDatetimeModel <- TrainDatetimeModel$new() # TrainDatetimeModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsCreate(projectId, trainDatetimeModel=trainDatetimeModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDatetimeModelsFromModelCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDatetimeModelsFromModelCreate}{}}}
\subsection{Method \code{ProjectsDatetimeModelsFromModelCreate()}}{
Retrain an existing datetime model with specified parameters.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDatetimeModelsFromModelCreate(
  projectId,
  retrainDatetimeModel = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{retrainDatetimeModel}}{\link{RetrainDatetimeModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrain an existing datetime model using a new training period for the model training set (with optional time window sampling) or different feature list.  All durations and datetimes should be specified in accordance with the :ref:`timestamp and duration formatting rules<time_format>`.  Note that only one of `trainingDuration` or `trainingRowCount` or `trainingStartDate` and `trainingEndDate` should be specified. If `trainingStartDate` and `trainingEndDate` are specified, the source model must be frozen.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Retrain an existing datetime model using a new sample size and/or feature list.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{403}} User does not have permissions to manage models.
\itemize{
}
\item \strong{\code{404}} Model with specified `modelId` doesn't exist, or user does not have access to the project.
\itemize{
}
\item \strong{\code{422}} Model with specified `modelId` is deprecated, or it doesn't support retraining with specified parameters.
\itemize{
}
}
}

\subsection{Returns}{
\link{DatetimeModelSubmissionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
retrainDatetimeModel <- RetrainDatetimeModel$new() # RetrainDatetimeModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsFromModelCreate(projectId, retrainDatetimeModel=retrainDatetimeModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDatetimeModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDatetimeModelsList}{}}}
\subsection{Method \code{ProjectsDatetimeModelsList()}}{
List datetime partitioned project models
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDatetimeModelsList(
  projectId,
  offset = 0,
  limit = 100,
  bulkOperationId = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{offset}}{integer. Number of results to skip.}

\item{\code{limit}}{integer. At most this many results are returned. The default may change without notice.}

\item{\code{bulkOperationId}}{character. the ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all the models from a datetime partitioned project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The datetime partitioned project's models
\itemize{
}
}
}

\subsection{Returns}{
\link{DatetimeModelsResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.
bulkOperationId <- 'bulkOperationId_example' # character | the ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsList(projectId, offset=offset, limit=limit, bulkOperationId=bulkOperationId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDatetimeModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDatetimeModelsRetrieve}{}}}
\subsection{Method \code{ProjectsDatetimeModelsRetrieve()}}{
Get datetime model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDatetimeModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Look up a particular datetime model All durations and datetimes are specified in accordance with :ref:`timestamp and duration formatting rules <time_format>`.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Datetime model
\itemize{
}
}
}

\subsection{Returns}{
\link{DatetimeModelDetailsResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDatetimeModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsDeploymentReadyModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsDeploymentReadyModelsCreate}{}}}
\subsection{Method \code{ProjectsDeploymentReadyModelsCreate()}}{
Prepare a model for deployment
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsDeploymentReadyModelsCreate(
  projectId,
  prepareForDeployment = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{prepareForDeployment}}{\link{PrepareForDeployment}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Prepare a specific model for deployment. This model will go through the recommendation stages.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{201}} Start preparing the model for deployment.
\itemize{
}
\item \strong{\code{422}} An error occurred when submitting the model job
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
prepareForDeployment <- PrepareForDeployment$new() # PrepareForDeployment |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsDeploymentReadyModelsCreate(projectId, prepareForDeployment=prepareForDeployment)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsEureqaDistributionPlotRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsEureqaDistributionPlotRetrieve}{}}}
\subsection{Method \code{ProjectsEureqaDistributionPlotRetrieve()}}{
Retrieve Eureqa model details plot.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsEureqaDistributionPlotRetrieve(projectId, solutionId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{solutionId}}{character. The ID of the solution to return data for.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve Eureqa model details plot.  Available for classification projects only


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Eureqa model details plot.
\itemize{
}
\item \strong{\code{404}} Data was not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{EureqaDistributionDetailResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaDistributionPlotRetrieve(projectId, solutionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsEureqaModelDetailRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsEureqaModelDetailRetrieve}{}}}
\subsection{Method \code{ProjectsEureqaModelDetailRetrieve()}}{
Retrieve Eureqa model details plot.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsEureqaModelDetailRetrieve(projectId, solutionId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{solutionId}}{character. The ID of the solution to return data for.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve Eureqa model details plot.  Available for regression projects only


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Eureqa model details plot.
\itemize{
}
\item \strong{\code{404}} Data was not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{EureqaModelDetailResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelDetailRetrieve(projectId, solutionId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsEureqaModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsEureqaModelsCreate}{}}}
\subsection{Method \code{ProjectsEureqaModelsCreate()}}{
Create a new model from an existing eureqa solution.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsEureqaModelsCreate(
  projectId,
  eureqaLeaderboardEntryPayload = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{eureqaLeaderboardEntryPayload}}{\link{EureqaLeaderboardEntryPayload}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new model from an existing eureqa solution.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Request accepted, creation is underway.
\itemize{
\item \strong{\code{Location}} The location at which the new model can be retrieved.
}
\item \strong{\code{404}} Data not found.
\itemize{
}
\item \strong{\code{422}} Model for this solution already exists.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
eureqaLeaderboardEntryPayload <- EureqaLeaderboardEntryPayload$new() # EureqaLeaderboardEntryPayload |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelsCreate(projectId, eureqaLeaderboardEntryPayload=eureqaLeaderboardEntryPayload)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsEureqaModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsEureqaModelsRetrieve}{}}}
\subsection{Method \code{ProjectsEureqaModelsRetrieve()}}{
Retrieve the pareto front for the specified Eureqa model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsEureqaModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the pareto front for the specified Eureqa model.  Only the best solution in the pareto front will have a corresponding model initially. Models can be created for other solutions using :http:post:`/api/v2/projects/(projectId)/eureqaModels/`.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Pareto front for the Eureqa model.
\itemize{
}
\item \strong{\code{404}} Data was not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{ParetoFrontResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsEureqaModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsFrozenDatetimeModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsFrozenDatetimeModelsCreate}{}}}
\subsection{Method \code{ProjectsFrozenDatetimeModelsCreate()}}{
Train a frozen datetime model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsFrozenDatetimeModelsCreate(
  projectId,
  trainDatetimeFrozenModel = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{trainDatetimeFrozenModel}}{\link{TrainDatetimeFrozenModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Train a frozen datetime model. If no training data is specified, the frozen datetime model will be trained on the most recent data using an amount of data that is equivalent to the original model. However, if the equivalent duration does not provide enough rows for training, then the duration will be extended until the minimum is met. Note that this will require the holdout of the project to be unlocked.  All durations and datetimes should be specified in accordance with the :ref:`timestamp and duration formatting rules<time_format>`.  Note that only one of `trainingDuration`, `trainingRowCount`, `trainingStartDate` and `trainingEndDate`, or `useProjectSettings` may be specified.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The model has been successfully submitted.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{403}} User does not have permissions to manage models.
\itemize{
}
\item \strong{\code{404}} Model with specified `modelId` does not exist, or user does not have access to the project.
\itemize{
}
\item \strong{\code{422}} Model with specified `modelId` is deprecated, or it does not support retraining with specified parameters.
\itemize{
}
}
}

\subsection{Returns}{
\link{DatetimeModelSubmissionResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
trainDatetimeFrozenModel <- TrainDatetimeFrozenModel$new() # TrainDatetimeFrozenModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenDatetimeModelsCreate(projectId, trainDatetimeFrozenModel=trainDatetimeFrozenModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsFrozenModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsFrozenModelsCreate}{}}}
\subsection{Method \code{ProjectsFrozenModelsCreate()}}{
Train a new frozen model with parameters from an existing model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsFrozenModelsCreate(projectId, frozenModelCreate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{frozenModelCreate}}{\link{FrozenModelCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Train a new frozen model with parameters from an existing model. Frozen models use tuning parameters from another model on the leaderboard, allowing them to be retrained on a larger amount of the training data more efficiently.   To specify the amount of data to use to train the model, use either `samplePct` to express a percentage of the rows of the dataset to use or `trainingRowCount` to express the number of rows to use.   If neither `samplePct` or `trainingRowCount` is specified, the model will be trained on the maximum available training data that can be used to train an in-memory model.   For projects using smart sampling, `samplePct` and `trainingRowCount` will be interpreted as a percent or number of rows of the minority class.   When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64\% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64\% of the data. Using actual integer row counts (or `project.max_training_rows`) avoids ambiguity around how many rows of data you want the model to use.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} The frozen model has been successfully submitted.
\itemize{
\item \strong{\code{Location}} Contains a url at which the job processing the model can be retrieved as with :http:get:`/api/v2/projects/(projectId)/modelJobs/(jobId)/`..
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} Unable to process request.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
frozenModelCreate <- FrozenModelCreate$new() # FrozenModelCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsCreate(projectId, frozenModelCreate=frozenModelCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsFrozenModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsFrozenModelsList}{}}}
\subsection{Method \code{ProjectsFrozenModelsList()}}{
List all frozen models from a project.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsFrozenModelsList(
  offset,
  limit,
  projectId,
  withMetric = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned. If 0, all results.}

\item{\code{projectId}}{character. The project ID}

\item{\code{withMetric}}{character. If specified, the returned models will only have scores for this metric.  If not, all metrics will be included.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all frozen models from a project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A list of frozen models in the project.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
}
}

\subsection{Returns}{
\link{FrozenModelListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
offset <- 0 # integer | This many results will be skipped.
limit <- 0 # integer | At most this many results are returned. If 0, all results.
projectId <- 'projectId_example' # character | The project ID
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric.  If not, all metrics will be included.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsList(offset, limit, projectId, withMetric=withMetric)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsFrozenModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsFrozenModelsRetrieve}{}}}
\subsection{Method \code{ProjectsFrozenModelsRetrieve()}}{
Look up a particular frozen model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsFrozenModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Look up a particular frozen model. If model with given ID exists but it's not frozen, returns 404 Not Found.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The frozen model.
\itemize{
}
\item \strong{\code{404}} No such frozen model found.
\itemize{
}
}
}

\subsection{Returns}{
\link{FrozenModelRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsFrozenModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelJobsDelete"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelJobsDelete}{}}}
\subsection{Method \code{ProjectsModelJobsDelete()}}{
Cancel a modeling job.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelJobsDelete(projectId, jobId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID.}

\item{\code{jobId}}{character. The job ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Cancel a modeling job


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} The job has been successfully cancelled.
\itemize{
}
\item \strong{\code{404}} no job with jobId found, or the job has already completed
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
jobId <- 'jobId_example' # character | The job ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsDelete(projectId, jobId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelJobsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelJobsList}{}}}
\subsection{Method \code{ProjectsModelJobsList()}}{
List modeling jobs
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelJobsList(projectId, status = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID.}

\item{\code{status}}{Enum < \link{queue, inprogress, error} > If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List modeling jobs.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} List of modeling jobs.
\itemize{
}
}
}

\subsection{Returns}{
list( \link{ModelingJobListResponse} )
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
status <- 'status_example' # character | If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsList(projectId, status=status)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelJobsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelJobsRetrieve}{}}}
\subsection{Method \code{ProjectsModelJobsRetrieve()}}{
Look up a specific modeling job
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelJobsRetrieve(projectId, jobId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID.}

\item{\code{jobId}}{character. The job ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Look up a particular modeling job


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} A modeling job
\itemize{
\item \strong{\code{Location}} if a status code 303 was returned, will contain a url at which the completed model can be retrieved`
}
\item \strong{\code{303}} Task is completed, see Location header for the location of a new resource
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelJobResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
jobId <- 'jobId_example' # character | The job ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelJobsRetrieve(projectId, jobId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsAdvancedTuningCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsAdvancedTuningCreate}{}}}
\subsection{Method \code{ProjectsModelsAdvancedTuningCreate()}}{
Submit a job to make a new version of the model with different advanced tuning parameters.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsAdvancedTuningCreate(
  projectId,
  modelId,
  modelAdvancedTuning = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{modelAdvancedTuning}}{\link{ModelAdvancedTuning}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Submit a job to make a new version of the model with different advanced tuning parameters. Note: This route currently supports all models other than: OSS, blenders, prime, scaleout, baseline and user-created. Currently, only single-stage models (most simple models) are supported. Blueprints that run multiple steps, for example one step to predict zero vs nonzero and a second step to determine the value of nonzero predictions, are not supported. (:ref:`Advanced Tuning documentation <grid_search>`). Parameters may be omitted from this endpoint. If a parameter is omitted, its `currentValue` will be used. To see the possible parameter IDs and constraints on possible values, see :http:get:`/api/v2/projects/(projectId)/models/(modelId)/advancedTuning/parameters/`.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The job has been successfully submitted. See the Location header.
\itemize{
\item \strong{\code{Location}} A url at which the job processing the model can be retrieved.
}
\item \strong{\code{403}} Permission denied creating advanced tuned model
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{413}} Tuning request is too large
\itemize{
}
\item \strong{\code{422}} Could not create new job.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
modelAdvancedTuning <- ModelAdvancedTuning$new() # ModelAdvancedTuning |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsAdvancedTuningCreate(projectId, modelId, modelAdvancedTuning=modelAdvancedTuning)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsAdvancedTuningParametersList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsAdvancedTuningParametersList}{}}}
\subsection{Method \code{ProjectsModelsAdvancedTuningParametersList()}}{
Retrieve information about all advanced tuning parameters available for the specified model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsAdvancedTuningParametersList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve information about all advanced tuning parameters available for the specified model. Note: This route currently supports all models other than: OSS, blenders, prime, scaleout, baseline and user-created


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The information about all advanced tuning parameters available for the specified model.
\itemize{
}
\item \strong{\code{403}} Permission denied creating advanced tuned model.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} This model does not support advanced tuning.
\itemize{
}
}
}

\subsection{Returns}{
\link{AdvancedTuningArgumentsRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsAdvancedTuningParametersList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsClusterNamesList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsClusterNamesList}{}}}
\subsection{Method \code{ProjectsModelsClusterNamesList()}}{
Retrieve cluster names assigned to an unsupervised cluster model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsClusterNamesList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve all cluster names assigned to an unsupervised cluster model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Retrieve all cluster names for the model
\itemize{
}
\item \strong{\code{404}} Could not find unsupervised clustering model. Possible reasons include: 1. Provided model id points to a model that does not exist in specified project. 2. Provided model has incompatible type. Method requires model to be unsupervised clustering model.
\itemize{
}
}
}

\subsection{Returns}{
\link{ClusterNamesResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsClusterNamesList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsClusterNamesPatchMany"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsClusterNamesPatchMany}{}}}
\subsection{Method \code{ProjectsModelsClusterNamesPatchMany()}}{
Update cluster names assigned to an unsupervised cluster model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsClusterNamesPatchMany(
  projectId,
  modelId,
  clusterNamesUpdateParam = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{clusterNamesUpdateParam}}{\link{ClusterNamesUpdateParam}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Update and then retrieve all cluster names assigned to an unsupervised cluster model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Update cluster names and then retrieve all cluster names for the model
\itemize{
}
\item \strong{\code{404}} Could not find unsupervised clustering model. Possible reasons include: 1. Provided model id points to a model which does not exists in specified project. 2. Provided model has incompatible type. Method requires model to be unsupervised clustering model.
\itemize{
}
\item \strong{\code{422}} The request cannot be processed. Possible reasons include: 1. Mapping contains invalid current cluster name and referenced cluster was not found. 2. Mapping is invalid as after update, clusters will not be uniquely identifiable by name.
\itemize{
}
}
}

\subsection{Returns}{
\link{ClusterNamesResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
clusterNamesUpdateParam <- ClusterNamesUpdateParam$new() # ClusterNamesUpdateParam |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsClusterNamesPatchMany(projectId, modelId, clusterNamesUpdateParam=clusterNamesUpdateParam)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsCreate}{}}}
\subsection{Method \code{ProjectsModelsCreate()}}{
Train a new model
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsCreate(projectId, trainModel = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID.}

\item{\code{trainModel}}{\link{TrainModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Train a new model. To specify the amount of data to use to train the model, use either `samplePct` to express a percentage of the rows of the dataset to use or `trainingRowCount` to express the number of rows to use. If neither `samplePct` or `trainingRowCount` is specified, the model will be trained on the maximum available training data that can be used to train an in-memory model. For projects using smart sampling, samplePct and trainingRowCount will be interpreted as a percent or number of rows of the minority class.   When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64\% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64\% of the data. Using actual integer row counts (or `project.max_training_rows`) avoids ambiguity around how many rows of data you want the model to use.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Creation has successfully started. See the Location header.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{422}} Could not create new job
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
trainModel <- TrainModel$new() # TrainModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCreate(projectId, trainModel=trainModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsCrossValidationCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsCrossValidationCreate}{}}}
\subsection{Method \code{ProjectsModelsCrossValidationCreate()}}{
Run Cross Validation on a model.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsCrossValidationCreate(
  projectId,
  modelId,
  body = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{body}}{object.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Run Cross Validation on a model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The model has been successfully submitted.
\itemize{
\item \strong{\code{Location}} Contains a url at which the job processing the model can be retrieved
}
\item \strong{\code{422}} Unable to process the request.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
body <- NULL # object |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCrossValidationCreate(projectId, modelId, body=body)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsCrossValidationScoresList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsCrossValidationScoresList}{}}}
\subsection{Method \code{ProjectsModelsCrossValidationScoresList()}}{
Get Cross Validation scores for each partition in a model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsCrossValidationScoresList(
  projectId,
  modelId,
  metric = NULL,
  partition = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{metric}}{character. Set to the name of a metric to only return results for that metric.}

\item{\code{partition}}{numeric. Set to a value such as 1.0, 2.0 to only return results for the specified partition.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\preformatted{     Get Cross Validation scores for each partition in a model.         .. note:: Individual partition scores are only available for newer models; older models that                   have cross validation score calculated will need to be retrained.
}


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The Cross Validation scores for each partition in a model.
\itemize{
}
\item \strong{\code{404}} Not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{CrossValidationRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
metric <- 'metric_example' # character | Set to the name of a metric to only return results for that metric.
partition <- 3.4 # numeric | Set to a value such as 1.0, 2.0 to only return results for the specified partition.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsCrossValidationScoresList(projectId, modelId, metric=metric, partition=partition)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsDelete"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsDelete}{}}}
\subsection{Method \code{ProjectsModelsDelete()}}{
Delete a model from the leaderboard.
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsDelete(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Delete a model from the leaderboard


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} The model has been successfully deleted.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} Unable to process the request.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsDelete(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsExportList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsExportList}{}}}
\subsection{Method \code{ProjectsModelsExportList()}}{
Download exported model
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsExportList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download exported model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
\item \strong{\code{ContentMinusDisposition}} `attachment;filename=<filename>.drx`. The filename is dynamically generated.
\item \strong{\code{ContentMinusType}} `application/octet-stream`
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsExportList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsFeaturesList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsFeaturesList}{}}}
\subsection{Method \code{ProjectsModelsFeaturesList()}}{
List the features used in a model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsFeaturesList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List the features used in a model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The features used in a model.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelFeatureListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsFeaturesList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsFromModelCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsFromModelCreate}{}}}
\subsection{Method \code{ProjectsModelsFromModelCreate()}}{
Retrain a model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsFromModelCreate(projectId, retrainModel = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{retrainModel}}{\link{RetrainModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrain an existing model using a new sample size and/or feature list.When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64\% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64\% of the data. Using actual integer row counts (or `project.max_training_rows`) avoids ambiguity around how many rows of data you want the model to use. Note that only one of `samplePct` or `trainingRowCount` should be specified.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Retrain an existing model using a new sample size and/or feature list.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
\item \strong{\code{422}} model with specified `modelId` is deprecated, or it doesn't support retraining using a new sample size and/or feature list
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelRetrainResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
retrainModel <- RetrainModel$new() # RetrainModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsFromModelCreate(projectId, retrainModel=retrainModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsList}{}}}
\subsection{Method \code{ProjectsModelsList()}}{
List project models
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsList(
  projectId,
  bulkOperationId = NULL,
  orderBy = NULL,
  name = NULL,
  samplePct = NULL,
  withMetric = NULL,
  isStarred = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID.}

\item{\code{bulkOperationId}}{character. The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.}

\item{\code{orderBy}}{Enum < \link{metric, -metric, samplePct, -samplePct} > A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.}

\item{\code{name}}{character. If specified, will filter for models with model type matching `name`}

\item{\code{samplePct}}{numeric. If specified, will filter for models with matching sample percentage}

\item{\code{withMetric}}{character. If specified, the returned models will only have scores for this metric. If not, all metrics will be included.}

\item{\code{isStarred}}{Enum < \link{false, False, true, True} > If specified, will filter for models marked as starred.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Lists all the models from a project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The project's models
\itemize{
}
}
}

\subsection{Returns}{
list( \link{ModelDetailsResponse} )
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID.
bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsMissingReportList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsMissingReportList}{}}}
\subsection{Method \code{ProjectsModelsMissingReportList()}}{
Retrieve a summary of how the model's subtasks handle missing values.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsMissingReportList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve a summary of how the model's subtasks handle missing values         Only models built after the missing value report feature was added will have reports,         and only models with at least one imputation or encoding task, e.g. ordinal encoding,         missing value imputation. Blenders and scaleout models do not support Missing Value reports.          The report will describe how each feature's missing values were treated, and report how many         missing values were present in the training data. Features which were not processed by a         given blueprint task will not mention it: for instance, a categorical feature with many         unique values may not be considered eligible for processing by a One-Hot Encoding          Report is collected for those features which are considered eligible by given         blueprint task. For instance, categorical feature with a lot of unique values may not be         considered as eligible in One-Hot Encoding task.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Retrieve a summary of how the model's subtasks handle missing values.
\itemize{
}
\item \strong{\code{404}} Could not found missing value report for provided project & model id.
\itemize{
}
}
}

\subsection{Returns}{
\link{MissingReportRetrieve}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsMissingReportList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsNumIterationsTrainedList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsNumIterationsTrainedList}{}}}
\subsection{Method \code{ProjectsModelsNumIterationsTrainedList()}}{
Get number of iterations trained
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsNumIterationsTrainedList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the actual number of iterations or estimators trained by a tree-based early stopping model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The number of estimators/iterations trained
\itemize{
}
\item \strong{\code{404}} Cannot retrieve early stopping information for this model.
\itemize{
}
}
}

\subsection{Returns}{
\link{NumIterationsTrainedResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsNumIterationsTrainedList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsParametersList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsParametersList}{}}}
\subsection{Method \code{ProjectsModelsParametersList()}}{
Retrieve model parameters.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsParametersList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve model parameters. These are the parameters that appear in the webapp on the `Coefficients` tab. Note that they are only available for some models.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The parameters of the model.
\itemize{
}
\item \strong{\code{422}} Unable to process the request.
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelParametersRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsParametersList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPatch"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPatch}{}}}
\subsection{Method \code{ProjectsModelsPatch()}}{
Updates a model's attribute(s).
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPatch(projectId, modelId, modelUpdate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{modelUpdate}}{\link{ModelUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Updates a model's attribute(s)


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{204}} The model has been successfully updated with new attributes.
\itemize{
}
\item \strong{\code{404}} This resource does not exist.
\itemize{
}
\item \strong{\code{422}} Unable to process the request.
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID
modelUpdate <- ModelUpdate$new() # ModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPatch(projectId, modelId, modelUpdate=modelUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPredictionIntervalsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPredictionIntervalsCreate}{}}}
\subsection{Method \code{ProjectsModelsPredictionIntervalsCreate()}}{
Calculate prediction intervals for the specified percentiles for this model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPredictionIntervalsCreate(
  projectId,
  modelId,
  predictionIntervalsCreate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project to calculate prediction intervals for. Must be a time series project.}

\item{\code{modelId}}{character. The model to calculate prediction intervals for.}

\item{\code{predictionIntervalsCreate}}{\link{PredictionIntervalsCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Submit a job to calculate prediction intervals for the specified percentiles for this model.  Note that the project this model belongs to must be a time series project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Job was successfully submitted. See Location header.
\itemize{
\item \strong{\code{Location}} A url that can be polled to check the status.
}
}
}

\subsection{Returns}{
\link{PredictionIntervalsCreateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project to calculate prediction intervals for. Must be a time series project.
modelId <- 'modelId_example' # character | The model to calculate prediction intervals for.
predictionIntervalsCreate <- PredictionIntervalsCreate$new() # PredictionIntervalsCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPredictionIntervalsCreate(projectId, modelId, predictionIntervalsCreate=predictionIntervalsCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPredictionIntervalsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPredictionIntervalsList}{}}}
\subsection{Method \code{ProjectsModelsPredictionIntervalsList()}}{
Retrieve prediction intervals that are already calculated for this model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPredictionIntervalsList(
  projectId,
  modelId,
  offset = 0,
  limit = 100,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project to retrieve prediction intervals for. Must be a time series project.}

\item{\code{modelId}}{character. The model to retrieve prediction intervals for.}

\item{\code{offset}}{integer. This many results will be skipped.}

\item{\code{limit}}{integer. At most this many results are returned.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve prediction intervals (in descending order) that are already calculated for this model. Note that the project this model belongs to must be a time series project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Request was successful.
\itemize{
}
}
}

\subsection{Returns}{
\link{PredictionIntervalsListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project to retrieve prediction intervals for. Must be a time series project.
modelId <- 'modelId_example' # character | The model to retrieve prediction intervals for.
offset <- 0 # integer | This many results will be skipped.
limit <- 100 # integer | At most this many results are returned.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPredictionIntervalsList(projectId, modelId, offset=offset, limit=limit)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPrimeInfoList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPrimeInfoList}{}}}
\subsection{Method \code{ProjectsModelsPrimeInfoList()}}{
Check a Model for Prime Eligibility
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPrimeInfoList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the model belongs to}

\item{\code{modelId}}{character. the model to check}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Check if a model can be approximated by DataRobot Prime


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{PrimeInfoRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model belongs to
modelId <- 'modelId_example' # character | the model to check

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeInfoList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPrimeRulesetsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPrimeRulesetsCreate}{}}}
\subsection{Method \code{ProjectsModelsPrimeRulesetsCreate()}}{
Create Rulesets
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPrimeRulesetsCreate(
  projectId,
  modelId,
  body = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the model to approximate belongs to}

\item{\code{modelId}}{character. the model to approximate}

\item{\code{body}}{object.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Approximate an existing model on the leaderboard with DataRobot Prime. A request body should be an empty JSON {}


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} The request was understood and accepted, and is now being worked on. See the Location header
\itemize{
\item \strong{\code{Location}} a url that can be polled to check the status of the job
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model to approximate belongs to
modelId <- 'modelId_example' # character | the model to approximate
body <- NULL # object |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeRulesetsCreate(projectId, modelId, body=body)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsPrimeRulesetsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsPrimeRulesetsList}{}}}
\subsection{Method \code{ProjectsModelsPrimeRulesetsList()}}{
List Rulesets
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsPrimeRulesetsList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the model belongs to}

\item{\code{modelId}}{character. the model to find approximating rulesets for}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all the rulesets approximating a model  When rulesets are created for the parent model, all of the rulesets are created at once, but not all rulesets have corresponding Prime models (until they are directly requested).


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
list( \link{PrimeRulesetsListResponse} )
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the model belongs to
modelId <- 'modelId_example' # character | the model to find approximating rulesets for

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsPrimeRulesetsList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsRetrieve}{}}}
\subsection{Method \code{ProjectsModelsRetrieve()}}{
Get model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Look up a particular model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The model
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelDetailsResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsScoringCodeList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsScoringCodeList}{}}}
\subsection{Method \code{ProjectsModelsScoringCodeList()}}{
Retrieve Scoring Code
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsScoringCodeList(
  projectId,
  modelId,
  sourceCode = "false",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that created the model}

\item{\code{modelId}}{character. the model to use}

\item{\code{sourceCode}}{Enum < \link{false, False, true, True} > If set to \"true\", the downloaded JAR file will contain only the source code and will not be executable.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve Scoring Code for making new predictions from an existing model offline. You need the \"Scoring Code\" feature enabled to use this route.  By default, returns a compiled executable JAR that can be executed locally to calculate model predictions, or it can be used as a library for a Java application. Execute it with the '--help` parameters to learn how to use it as a command-line utility. See model API documentation (https://javadoc.io/doc/com.datarobot/datarobot-prediction/latest/index.html) to be able to use it inside an existing Java application.  With the sourceCode query parameter set to 'true', returns a source code archive that can be used to review internal calculations of the model. This JAR is NOT executable.  See \"https://app.datarobot.com/docs/predictions/scoring-code/scorecode.html\" in DataRobot application for more information.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} JAR file
\itemize{
\item \strong{\code{ContentMinusDisposition}} attachment; filename=\"<\"filename\">\".jar The suggested filename for the scoring code is dynamically generated
\item \strong{\code{ContentMinusType}} application/java-archive
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that created the model
modelId <- 'modelId_example' # character | the model to use
sourceCode <- "false" # character | If set to \"true\", the downloaded JAR file will contain only the source code and will not be executable.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsScoringCodeList(projectId, modelId, sourceCode=sourceCode)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsModelsSupportedCapabilitiesList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsModelsSupportedCapabilitiesList}{}}}
\subsection{Method \code{ProjectsModelsSupportedCapabilitiesList()}}{
Get supported capabilities for a model.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsModelsSupportedCapabilitiesList(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{modelId}}{character. The model ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get supported capabilities for a model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Successfully returned model capability information.
\itemize{
}
\item \strong{\code{404}} Resource not found.
\itemize{
}
}
}

\subsection{Returns}{
\link{ModelCapabilitiesRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
modelId <- 'modelId_example' # character | The model ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsModelsSupportedCapabilitiesList(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeFilesCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeFilesCreate}{}}}
\subsection{Method \code{ProjectsPrimeFilesCreate()}}{
Create a Prime File
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeFilesCreate(projectId, primeFileCreate = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the Prime model belongs to}

\item{\code{primeFileCreate}}{\link{PrimeFileCreate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Request creation and validation of source code from a Prime model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} prime validation job added to queue. See the Location header.
\itemize{
\item \strong{\code{Location}} a url that can be polled to check the status of prime validation job
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the Prime model belongs to
primeFileCreate <- PrimeFileCreate$new() # PrimeFileCreate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesCreate(projectId, primeFileCreate=primeFileCreate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeFilesDownloadList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeFilesDownloadList}{}}}
\subsection{Method \code{ProjectsPrimeFilesDownloadList()}}{
Download Code
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeFilesDownloadList(projectId, primeFileId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the file belongs to}

\item{\code{primeFileId}}{character. the Prime file to download code from}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Download code from an existing Prime file


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The response will contain a file with the executable code from the Prime file
\itemize{
\item \strong{\code{ContentMinusDisposition}} Will be attachment;filename=\"<\"filename\">\". The suggested filename will depend on the language Prime file was generated for.
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the file belongs to
primeFileId <- 'primeFileId_example' # character | the Prime file to download code from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesDownloadList(projectId, primeFileId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeFilesList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeFilesList}{}}}
\subsection{Method \code{ProjectsPrimeFilesList()}}{
Get Prime Files
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeFilesList(
  projectId,
  offset = 0,
  limit = 0,
  parentModelId = NULL,
  modelId = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project to list available files for}

\item{\code{offset}}{integer. this many results will be skipped}

\item{\code{limit}}{integer. at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.}

\item{\code{parentModelId}}{character. if specified only Prime files approximating the specified parent model will be returned; otherwise all applicable Prime files will be returned.}

\item{\code{modelId}}{character. if specified only Prime files with code used in the specified prime model will be returned; otherwise all applicable Prime files will be returned}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all DataRobot Prime files available for download


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{PrimeFileListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list available files for
offset <- 0 # integer | this many results will be skipped
limit <- 0 # integer | at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
parentModelId <- 'parentModelId_example' # character | if specified only Prime files approximating the specified parent model will be returned; otherwise all applicable Prime files will be returned.
modelId <- 'modelId_example' # character | if specified only Prime files with code used in the specified prime model will be returned; otherwise all applicable Prime files will be returned

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesList(projectId, offset=offset, limit=limit, parentModelId=parentModelId, modelId=modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeFilesRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeFilesRetrieve}{}}}
\subsection{Method \code{ProjectsPrimeFilesRetrieve()}}{
Retrieve metadata about a DataRobot Prime file
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeFilesRetrieve(projectId, primeFileId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project the file belongs to}

\item{\code{primeFileId}}{character. the file to retrieve}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve metadata about a DataRobot Prime file available for download


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{PrimeFileResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project the file belongs to
primeFileId <- 'primeFileId_example' # character | the file to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeFilesRetrieve(projectId, primeFileId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeModelsCreate}{}}}
\subsection{Method \code{ProjectsPrimeModelsCreate()}}{
Create a Prime Model from a Ruleset
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeModelsCreate(
  projectId,
  primeModelCreatePayload = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project in which to create the model}

\item{\code{primeModelCreatePayload}}{\link{PrimeModelCreatePayload}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a Prime model using a particular ruleset.  DataRobot Prime is not available for multiclass projects.  Once rulesets approximating a parent model have been created, using POST /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/, this route will allow creation of a Prime model using one of those rulesets.  Available rulesets can be retrieved via GET /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} Prime model creation job successfully added to queue. See the Location header.
\itemize{
\item \strong{\code{Location}} a url that can be polled to check the status of the job
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project in which to create the model
primeModelCreatePayload <- PrimeModelCreatePayload$new() # PrimeModelCreatePayload |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsCreate(projectId, primeModelCreatePayload=primeModelCreatePayload)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeModelsList}{}}}
\subsection{Method \code{ProjectsPrimeModelsList()}}{
List all Prime models in a project
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeModelsList(projectId, offset = 0, limit = 100, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project to list models from}

\item{\code{offset}}{integer. Number of results to skip.}

\item{\code{limit}}{integer. At most this many results are returned. The default may change without notice.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List all Prime models in a project


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{PrimeModelListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list models from
offset <- 0 # integer | Number of results to skip.
limit <- 100 # integer | At most this many results are returned. The default may change without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsList(projectId, offset=offset, limit=limit)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsPrimeModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsPrimeModelsRetrieve}{}}}
\subsection{Method \code{ProjectsPrimeModelsRetrieve()}}{
Retrieve a Prime model details
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsPrimeModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project to retrieve the model from}

\item{\code{modelId}}{character. the model to retrieve}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve a Prime model details


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} Prime models are an extension of models, so the response includes all attributes that would be in a response to GET /api/v2/projects/(projectId)/models/(modelId)/ as well as some additional ones.
\itemize{
}
}
}

\subsection{Returns}{
\link{PrimeModelDetailsRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to retrieve the model from
modelId <- 'modelId_example' # character | the model to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsPrimeModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTableModelsCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTableModelsCreate}{}}}
\subsection{Method \code{ProjectsRatingTableModelsCreate()}}{
Create New Models From A Rating Table
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTableModelsCreate(
  projectId,
  createRatingTableModel = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that owns this data}

\item{\code{createRatingTableModel}}{\link{CreateRatingTableModel}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new rating table model from a validated rating table record


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} the request was understood and accepted, and is now being worked on
\itemize{
\item \strong{\code{Location}} a url of an asynchronous operation status object that can be polled to check the status of the job validating the new rating table
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
createRatingTableModel <- CreateRatingTableModel$new() # CreateRatingTableModel |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsCreate(projectId, createRatingTableModel=createRatingTableModel)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTableModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTableModelsList}{}}}
\subsection{Method \code{ProjectsRatingTableModelsList()}}{
List Rating Table Models
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTableModelsList(
  projectId,
  bulkOperationId = NULL,
  orderBy = NULL,
  name = NULL,
  samplePct = NULL,
  withMetric = NULL,
  isStarred = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project to list models from}

\item{\code{bulkOperationId}}{character. The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.}

\item{\code{orderBy}}{Enum < \link{metric, -metric, samplePct, -samplePct} > A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.}

\item{\code{name}}{character. If specified, will filter for models with model type matching `name`}

\item{\code{samplePct}}{numeric. If specified, will filter for models with matching sample percentage}

\item{\code{withMetric}}{character. If specified, the returned models will only have scores for this metric. If not, all metrics will be included.}

\item{\code{isStarred}}{Enum < \link{false, False, true, True} > If specified, will filter for models marked as starred.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Lists all the models from a project that have rating tables


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The response will include a json list of models in the same format as      those from GET /api/v2/projects/(projectId)/ratingTableModels/(modelId)/.
\itemize{
}
}
}

\subsection{Returns}{
list( \link{RatingTableModelDetailsResponse} )
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to list models from
bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTableModelsRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTableModelsRetrieve}{}}}
\subsection{Method \code{ProjectsRatingTableModelsRetrieve()}}{
Retrieve Rating Table Model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTableModelsRetrieve(projectId, modelId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project to retrieve the model from}

\item{\code{modelId}}{character. the model to retrieve}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Look up a particular rating table model


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{RatingTableModelDetailsResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project to retrieve the model from
modelId <- 'modelId_example' # character | the model to retrieve

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTableModelsRetrieve(projectId, modelId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTablesCreate"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTablesCreate}{}}}
\subsection{Method \code{ProjectsRatingTablesCreate()}}{
Upload Modified Rating Table File
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTablesCreate(
  projectId,
  parentModelId,
  ratingTableFile,
  ratingTableName,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that owns this data}

\item{\code{parentModelId}}{character. the parent model this rating table file was derived from}

\item{\code{ratingTableFile}}{data.frame. rating table file to use for the new rating table. Accepts `Content-Type:multipart/form-data`}

\item{\code{ratingTableName}}{character. the name of the new rating table to create}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create a new rating table from a rating table file This will create a new rating table, regardless of whether the validation succeeds. The rating table object will have a validationError which will be left blank in the case of successful validation.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{202}} the request was understood and accepted, and is now being worked on
\itemize{
\item \strong{\code{Location}} a url of an asynchronous operation status object that can be polled to check the status of the job validating the new rating table
}
}
}

\subsection{Returns}{
\link{RatingTableCreateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
parentModelId <- 'parentModelId_example' # character | the parent model this rating table file was derived from
ratingTableFile <- File.new('/path/to/file') # data.frame | rating table file to use for the new rating table. Accepts `Content-Type:multipart/form-data`
ratingTableName <- 'ratingTableName_example' # character | the name of the new rating table to create

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesCreate(projectId, parentModelId, ratingTableFile, ratingTableName)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTablesFileList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTablesFileList}{}}}
\subsection{Method \code{ProjectsRatingTablesFileList()}}{
Retrieve Rating Table File
Produces: NA
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTablesFileList(projectId, ratingTableId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that owns this data}

\item{\code{ratingTableId}}{character. the rating table ID to retrieve the source file from}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieve the CSV file for the rating table


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The response will contain a file containing the rating table in csv format
\itemize{
}
}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesFileList(projectId, ratingTableId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTablesList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTablesList}{}}}
\subsection{Method \code{ProjectsRatingTablesList()}}{
List Rating Tables For The Project
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTablesList(
  projectId,
  parentModelId = NULL,
  modelId = NULL,
  offset = 0,
  limit = 0,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{parentModelId}}{character. optional. If specified, only rating tables with this parentModelId will be returned}

\item{\code{modelId}}{character. optional. If specified, only rating tables with this modelId will be returned}

\item{\code{offset}}{integer. optional (default: 0), this many results will be skipped}

\item{\code{limit}}{integer. optional (default: no limit), at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
List RatingTable objects for a project.     These contain metadata about the rating table and the location at which the corresponding rating      table file can be retrieved.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{RatingTableListResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
parentModelId <- 'parentModelId_example' # character | optional. If specified, only rating tables with this parentModelId will be returned
modelId <- 'modelId_example' # character | optional. If specified, only rating tables with this modelId will be returned
offset <- 0 # integer | optional (default: 0), this many results will be skipped
limit <- 0 # integer | optional (default: no limit), at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesList(projectId, parentModelId=parentModelId, modelId=modelId, offset=offset, limit=limit)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTablesPatch"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTablesPatch}{}}}
\subsection{Method \code{ProjectsRatingTablesPatch()}}{
Update an uploaded rating table
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTablesPatch(
  projectId,
  ratingTableId,
  ratingTableUpdate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that owns this data}

\item{\code{ratingTableId}}{character. the rating table ID to retrieve the source file from}

\item{\code{ratingTableUpdate}}{\link{RatingTableUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Rating tables may only be updated if they have not yet been used to create a model.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} On success, will return the modified rating table record in the same      format as GET /api/v2/projects/(projectId)/ratingTables/(ratingTableId)/
\itemize{
}
}
}

\subsection{Returns}{
\link{RatingTableRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from
ratingTableUpdate <- RatingTableUpdate$new() # RatingTableUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesPatch(projectId, ratingTableId, ratingTableUpdate=ratingTableUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRatingTablesRetrieve"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRatingTablesRetrieve}{}}}
\subsection{Method \code{ProjectsRatingTablesRetrieve()}}{
Retrieve Rating Table Information
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRatingTablesRetrieve(projectId, ratingTableId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. the project that owns this data}

\item{\code{ratingTableId}}{character. the rating table ID to retrieve the source file from}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieves a rating table


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}}
\itemize{
}
}
}

\subsection{Returns}{
\link{RatingTableRetrieveResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | the project that owns this data
ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRatingTablesRetrieve(projectId, ratingTableId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRecommendedModelsList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRecommendedModelsList}{}}}
\subsection{Method \code{ProjectsRecommendedModelsList()}}{
List recommended models for the project
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRecommendedModelsList(projectId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Retrieves all of the current recommended models for the project


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The list of recommended models
\itemize{
}
}
}

\subsection{Returns}{
list( \link{RecommendedModelResponse} )
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRecommendedModelsList(projectId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsRecommendedModelsRecommendedModelList"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsRecommendedModelsRecommendedModelList}{}}}
\subsection{Method \code{ProjectsRecommendedModelsRecommendedModelList()}}{
Get recommended model
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsRecommendedModelsRecommendedModelList(projectId, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This route returns the simplest recommended model available. To see all the available recommended models, use :http:get:`/api/v2/projects/(projectId)/recommendedModels/`


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The recommended model
\itemize{
}
}
}

\subsection{Returns}{
\link{RecommendedModelResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsRecommendedModelsRecommendedModelList(projectId)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ProjectsSegmentChampionPutMany"></a>}}
\if{latex}{\out{\hypertarget{method-ProjectsSegmentChampionPutMany}{}}}
\subsection{Method \code{ProjectsSegmentChampionPutMany()}}{
Update champion model for a segment project.
Produces: "application/json"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$ProjectsSegmentChampionPutMany(
  projectId,
  segmentChampionModelUpdate = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectId}}{character. The project ID}

\item{\code{segmentChampionModelUpdate}}{\link{SegmentChampionModelUpdate}.}

\item{\code{...}}{Optional. Additional named parameters to be passed downward.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Update champion model for a segment project.


Response status codes, messages, and headers:
\itemize{
\item \strong{\code{200}} The ID of Combined model that has been updated with new segment champion model.
\itemize{
}
}
}

\subsection{Returns}{
\link{SegmentChampionModelUpdateResponse}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
library(datarobot.apicore)
projectId <- 'projectId_example' # character | The project ID
segmentChampionModelUpdate <- SegmentChampionModelUpdate$new() # SegmentChampionModelUpdate |

api.instance <- ModelsApi$new()
result <- api.instance$ProjectsSegmentChampionPutMany(projectId, segmentChampionModelUpdate=segmentChampionModelUpdate)
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ModelsApi$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
