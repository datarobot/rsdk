# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Predictions operations
#' @description datarobot.apicore.Predictions
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
PredictionsApi <- R6::R6Class(
  "PredictionsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Creates a new Batch Prediction job definition
    #' Produces: "application/json"
    #'
    #' @details Create a Batch Prediction Job definition. A configuration for a Batch Prediction job which can either be executed manually upon request or on scheduled intervals, if enabled. The API payload is the same as for /batchPredictions along with optional &#x60;enabled&#x60; and &#x60;schedule&#x60; items.
    #' @details This method invokes `POST /batchPredictionJobDefinitions/` in the DataRobot Public API.
    #' @param batchPredictionJobDefinitionsCreate \link{BatchPredictionJobDefinitionsCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobDefinitionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job details for the created Batch Prediction job definition
    #' \itemize{
    #' }
    #' \item **`403`** You are not authorized to create a job definition on this deployment due to your permissions role
    #' \itemize{
    #' }
    #' \item **`422`** You tried to create a job definition with uncompatible or missing parameters to create a fully functioning job definition
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' batchPredictionJobDefinitionsCreate <- BatchPredictionJobDefinitionsCreate$new() # BatchPredictionJobDefinitionsCreate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsCreate(batchPredictionJobDefinitionsCreate=batchPredictionJobDefinitionsCreate)
    #' }
    BatchPredictionJobDefinitionsCreate = function(batchPredictionJobDefinitionsCreate = NULL, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsCreateWithHttpInfo(batchPredictionJobDefinitionsCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete Batch Prediction job definition
    #' Produces: NA
    #'
    #' @details Delete a Batch Prediction job definition
    #' @details This method invokes `DELETE /batchPredictionJobDefinitions/{jobDefinitionId}/` in the DataRobot Public API.
    #' @param jobDefinitionId character. ID of the Batch Prediction job definition
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`403`** You are not authorized to delete this job definition due to your permissions role
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' \item **`409`** Job could not be deleted, as there are currently running jobs in the queue.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobDefinitionId <- 'jobDefinitionId_example' # character | ID of the Batch Prediction job definition
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsDelete(jobDefinitionId)
    #' }
    BatchPredictionJobDefinitionsDelete = function(jobDefinitionId, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsDeleteWithHttpInfo(jobDefinitionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Batch Prediction job definitions
    #' Produces: "application/json"
    #'
    #' @details List all Batch Prediction jobs definitions available
    #' @details This method invokes `GET /batchPredictionJobDefinitions/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param deploymentId character. Includes only definitions for this particular deployment
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobDefinitionsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of all available jobs
    #' \itemize{
    #' }
    #' \item **`422`** Your input data or query arguments did not work together
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 100 # integer | At most this many results are returned
    #' deploymentId <- 'deploymentId_example' # character | Includes only definitions for this particular deployment
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsList(offset, limit, deploymentId=deploymentId)
    #' }
    BatchPredictionJobDefinitionsList = function(offset, limit, deploymentId = NULL, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsListWithHttpInfo(offset, limit, deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update Batch Prediction job definition
    #' Produces: "application/json"
    #'
    #' @details Update a Batch Prediction job definition
    #' @details This method invokes `PATCH /batchPredictionJobDefinitions/{jobDefinitionId}/` in the DataRobot Public API.
    #' @param jobDefinitionId character. ID of the Batch Prediction job definition
    #' @param batchPredictionJobDefinitionsUpdate \link{BatchPredictionJobDefinitionsUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobDefinitionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job details for the updated Batch Prediction job definition
    #' \itemize{
    #' }
    #' \item **`403`** You are not authorized to alter the contents of this job definition due to your permissions role
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' \item **`409`** You chose a name of your job definition that was already existing within your organization
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobDefinitionId <- 'jobDefinitionId_example' # character | ID of the Batch Prediction job definition
    #' batchPredictionJobDefinitionsUpdate <- BatchPredictionJobDefinitionsUpdate$new() # BatchPredictionJobDefinitionsUpdate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsPatch(jobDefinitionId, batchPredictionJobDefinitionsUpdate=batchPredictionJobDefinitionsUpdate)
    #' }
    BatchPredictionJobDefinitionsPatch = function(jobDefinitionId, batchPredictionJobDefinitionsUpdate = NULL, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsPatchWithHttpInfo(jobDefinitionId, batchPredictionJobDefinitionsUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve job definition snippet for PBP
    #' Produces: NA
    #'
    #' @details Retrieve a Batch Prediction job definition for Portable Batch Predictions
    #' @details This method invokes `GET /batchPredictionJobDefinitions/{jobDefinitionId}/portable/` in the DataRobot Public API.
    #' @param jobDefinitionId character. ID of the Batch Prediction job definition
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Snippet for Portable Batch Predictions
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobDefinitionId <- 'jobDefinitionId_example' # character | ID of the Batch Prediction job definition
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsPortableList(jobDefinitionId)
    #' }
    BatchPredictionJobDefinitionsPortableList = function(jobDefinitionId, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsPortableListWithHttpInfo(jobDefinitionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Batch Prediction job definition
    #' Produces: "application/json"
    #'
    #' @details Retrieve a Batch Prediction job definition
    #' @details This method invokes `GET /batchPredictionJobDefinitions/{jobDefinitionId}/` in the DataRobot Public API.
    #' @param jobDefinitionId character. ID of the Batch Prediction job definition
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobDefinitionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job details for the requested Batch Prediction job definition
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobDefinitionId <- 'jobDefinitionId_example' # character | ID of the Batch Prediction job definition
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionJobDefinitionsRetrieve(jobDefinitionId)
    #' }
    BatchPredictionJobDefinitionsRetrieve = function(jobDefinitionId, ...) {
      apiResponse <- private$BatchPredictionJobDefinitionsRetrieveWithHttpInfo(jobDefinitionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Creates a new Batch Prediction job
    #' Produces: "application/json"
    #'
    #' @details Submit the configuration for the job and it will be submitted to the queue
    #' @details This method invokes `POST /batchPredictions/` in the DataRobot Public API.
    #' @param batchPredictionJobCreate \link{BatchPredictionJobCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job details for the created Batch Prediction job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' batchPredictionJobCreate <- BatchPredictionJobCreate$new() # BatchPredictionJobCreate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsCreate(batchPredictionJobCreate=batchPredictionJobCreate)
    #' }
    BatchPredictionsCreate = function(batchPredictionJobCreate = NULL, ...) {
      apiResponse <- private$BatchPredictionsCreateWithHttpInfo(batchPredictionJobCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Finalize a multipart upload
    #' Produces: NA
    #'
    #' @details Finalize a multipart upload, indicating that no further chunks will be sent
    #' @details This method invokes `POST /batchPredictions/{predictionJobId}/csvUpload/finalizeMultipart/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Acknowledgement that the request was accepted or an error message
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' \item **`409`** Only multipart jobs can be finalized.
    #' \itemize{
    #' }
    #' \item **`422`** No data was uploaded
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsCsvUploadFinalizeMultipartCreate(predictionJobId, partNumber)
    #' }
    BatchPredictionsCsvUploadFinalizeMultipartCreate = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsCsvUploadFinalizeMultipartCreateWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Upload CSV data in multiple parts
    #' Produces: NA
    #'
    #' @details Stream CSV data to the prediction job in many parts.Only available for jobs that uses the localFile intake option.
    #' @details This method invokes `PUT /batchPredictions/{predictionJobId}/csvUpload/part/{partNumber}/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job data was successfully submitted
    #' \itemize{
    #' }
    #' \item **`404`** Job does not exist or does not require data
    #' \itemize{
    #' }
    #' \item **`406`** Not acceptable MIME type
    #' \itemize{
    #' }
    #' \item **`409`** Dataset upload has already begun
    #' \itemize{
    #' }
    #' \item **`422`** Job was \&quot;ABORTED\&quot; due to too many errors in the data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsCsvUploadPartPut(predictionJobId, partNumber)
    #' }
    BatchPredictionsCsvUploadPartPut = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsCsvUploadPartPutWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Creates a new_model_id Batch Prediction job
    #' Produces: NA
    #'
    #' @details Stream CSV data to the prediction job. Only available for jobs thatuses the localFile intake option.
    #' @details This method invokes `PUT /batchPredictions/{predictionJobId}/csvUpload/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job data was successfully submitted
    #' \itemize{
    #' }
    #' \item **`404`** Job does not exist or does not require data
    #' \itemize{
    #' }
    #' \item **`406`** Not acceptable MIME type
    #' \itemize{
    #' }
    #' \item **`409`** Dataset upload has already begun
    #' \itemize{
    #' }
    #' \item **`422`** Job was \&quot;ABORTED\&quot; due to too many errors in the data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsCsvUploadPutMany(predictionJobId, partNumber)
    #' }
    BatchPredictionsCsvUploadPutMany = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsCsvUploadPutManyWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel a Batch Prediction job
    #' Produces: NA
    #'
    #' @details If the job is running, it will be aborted. Then it will be removed, meaning all underlying data will be deleted and the job is removed from the list of jobs.
    #' @details This method invokes `DELETE /batchPredictions/{predictionJobId}/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job cancelled
    #' \itemize{
    #' }
    #' \item **`404`** Job does not exist or was not submitted to the queue.
    #' \itemize{
    #' }
    #' \item **`409`** Job cannot be aborted for some reason. Possible reasons: job is already aborted or completed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsDelete(predictionJobId, partNumber)
    #' }
    BatchPredictionsDelete = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsDeleteWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download the scored data set of a batch prediction job
    #' Produces: NA
    #'
    #' @details This is only valid for jobs scored using the \&quot;localFile\&quot; output option
    #' @details This method invokes `GET /batchPredictions/{predictionJobId}/download/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job was downloaded correctly
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;result-&lt;id&gt;.csv\&quot;).
    #' \item **`ContentMinusType`** MIME type of the returned data
    #' }
    #' \item **`404`** Job does not exist or is not completed
    #' \itemize{
    #' }
    #' \item **`406`** Not acceptable MIME type
    #' \itemize{
    #' }
    #' \item **`422`** Job was \&quot;ABORTED\&quot; due to too many errors in the data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsDownloadList(predictionJobId, partNumber)
    #' }
    BatchPredictionsDownloadList = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsDownloadListWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new a Batch Prediction job based on an existing Batch Prediction job.
    #' Produces: "application/json"
    #'
    #' @details Copies an existing job and submits it to the queue.
    #' @details This method invokes `POST /batchPredictions/fromExisting/` in the DataRobot Public API.
    #' @param batchPredictionJobId \link{BatchPredictionJobId}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job details for the created Batch Prediction job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' batchPredictionJobId <- BatchPredictionJobId$new() # BatchPredictionJobId |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsFromExistingCreate(batchPredictionJobId=batchPredictionJobId)
    #' }
    BatchPredictionsFromExistingCreate = function(batchPredictionJobId = NULL, ...) {
      apiResponse <- private$BatchPredictionsFromExistingCreateWithHttpInfo(batchPredictionJobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Launch a Batch Prediction job for scoring
    #' Produces: "application/json"
    #'
    #' @details Launches a one-time batch prediction job based off of the previously supplied definition referring to the job definition ID and puts it on the queue.
    #' @details This method invokes `POST /batchPredictions/fromJobDefinition/` in the DataRobot Public API.
    #' @param batchPredictionJobDefinitionId \link{BatchPredictionJobDefinitionId}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job details for the created Batch Prediction job
    #' \itemize{
    #' }
    #' \item **`404`** Job was deleted, never existed or you do not have access to it
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' batchPredictionJobDefinitionId <- BatchPredictionJobDefinitionId$new() # BatchPredictionJobDefinitionId |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsFromJobDefinitionCreate(batchPredictionJobDefinitionId=batchPredictionJobDefinitionId)
    #' }
    BatchPredictionsFromJobDefinitionCreate = function(batchPredictionJobDefinitionId = NULL, ...) {
      apiResponse <- private$BatchPredictionsFromJobDefinitionCreateWithHttpInfo(batchPredictionJobDefinitionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List batch prediction jobs
    #' Produces: "application/json"
    #'
    #' @details Get a collection of batch prediction jobs by statuses
    #' @details This method invokes `GET /batchPredictions/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param allJobs character. (For organization admins) Include jobs for all users in the organization.
    #' @param status \link{OneOfstringarray}. Includes only jobs that have the status value that matches this flag. Repeat the parameter for filtering on multiple statuses.
    #' @param source \link{OneOfstringarray}. Includes only jobs that have the source value that matches this flag. Repeat the parameter for filtering on multiple statuses.
    #' @param deploymentId character. Includes only jobs for this particular deployment
    #' @param modelId character. ID of leaderboard model which is used in job for processing predictions dataset
    #' @param jobId character. Includes only job by specific id
    #' @param orderBy Enum < [created, -created, status, -status] > Sort order which will be applied to batch prediction list. Prefix the attribute name with a dash to sort in descending order, e.g. \&quot;-created\&quot;.
    #' @param cutoffHours integer. Only list jobs created at most this amount of hours ago.
    #' @param startDateTime character. ISO-formatted datetime of the earliest time the job was added (inclusive). For example \&quot;2008-08-24T12:00:00Z\&quot;. Will ignore cutoffHours if set.
    #' @param endDateTime character. ISO-formatted datetime of the latest time the job was added (inclusive). For example \&quot;2008-08-24T12:00:00Z\&quot;.
    #' @param batchPredictionJobDefinitionId character. Includes only jobs for this particular definition
    #' @param hostname \link{OneOfstringarray}. Includes only jobs for this particular prediction instance hostname
    #' @param intakeType Enum < [local_file, azure, bigquery, dataStage, dataset, dss, gcp, http, jdbc, localFile, s3, snowflake, synapse] > Includes only jobs for this particular intake type
    #' @param outputType Enum < [local_file, azure, bigquery, gcp, http, jdbc, localFile, s3, snowflake, synapse, tableau] > Includes only jobs for this particular output type
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of Batch Prediction job objects
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 100 # integer | At most this many results are returned
    #' allJobs <- FALSE # character | (For organization admins) Include jobs for all users in the organization.
    #' status <- list(c('status_example')) # OneOfstringarray | Includes only jobs that have the status value that matches this flag. Repeat the parameter for filtering on multiple statuses.
    #' source <- list(c('source_example')) # OneOfstringarray | Includes only jobs that have the source value that matches this flag. Repeat the parameter for filtering on multiple statuses.
    #' deploymentId <- 'deploymentId_example' # character | Includes only jobs for this particular deployment
    #' modelId <- 'modelId_example' # character | ID of leaderboard model which is used in job for processing predictions dataset
    #' jobId <- 'jobId_example' # character | Includes only job by specific id
    #' orderBy <- 'orderBy_example' # character | Sort order which will be applied to batch prediction list. Prefix the attribute name with a dash to sort in descending order, e.g. \"-created\".
    #' cutoffHours <- 56 # integer | Only list jobs created at most this amount of hours ago.
    #' startDateTime <- 'startDateTime_example' # character | ISO-formatted datetime of the earliest time the job was added (inclusive). For example \"2008-08-24T12:00:00Z\". Will ignore cutoffHours if set.
    #' endDateTime <- 'endDateTime_example' # character | ISO-formatted datetime of the latest time the job was added (inclusive). For example \"2008-08-24T12:00:00Z\".
    #' batchPredictionJobDefinitionId <- 'batchPredictionJobDefinitionId_example' # character | Includes only jobs for this particular definition
    #' hostname <- list(c('hostname_example')) # OneOfstringarray | Includes only jobs for this particular prediction instance hostname
    #' intakeType <- 'intakeType_example' # character | Includes only jobs for this particular intake type
    #' outputType <- 'outputType_example' # character | Includes only jobs for this particular output type
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsList(offset, limit, allJobs, status=status, source=source, deploymentId=deploymentId, modelId=modelId, jobId=jobId, orderBy=orderBy, cutoffHours=cutoffHours, startDateTime=startDateTime, endDateTime=endDateTime, batchPredictionJobDefinitionId=batchPredictionJobDefinitionId, hostname=hostname, intakeType=intakeType, outputType=outputType)
    #' }
    BatchPredictionsList = function(offset, limit, allJobs, status = NULL, source = NULL, deploymentId = NULL, modelId = NULL, jobId = NULL, orderBy = NULL, cutoffHours = NULL, startDateTime = NULL, endDateTime = NULL, batchPredictionJobDefinitionId = NULL, hostname = NULL, intakeType = NULL, outputType = NULL, ...) {
      apiResponse <- private$BatchPredictionsListWithHttpInfo(offset, limit, allJobs, status, source, deploymentId, modelId, jobId, orderBy, cutoffHours, startDateTime, endDateTime, batchPredictionJobDefinitionId, hostname, intakeType, outputType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a Batch Prediction job
    #' Produces: "application/json"
    #'
    #' @details If a job has finished execution regardless of the result, it can have parameters changed to ensure better filtering in the job list upon retrieval. Another case: updating job scoring status externally.
    #' @details This method invokes `PATCH /batchPredictions/{predictionJobId}/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param batchPredictionJobUpdate \link{BatchPredictionJobUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job updated
    #' \itemize{
    #' }
    #' \item **`404`** Job does not exist or was not submitted to the queue.
    #' \itemize{
    #' }
    #' \item **`409`** Job cannot be hidden for some reason. Possible reasons: job is not in a deletable state.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #' batchPredictionJobUpdate <- BatchPredictionJobUpdate$new() # BatchPredictionJobUpdate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsPatch(predictionJobId, partNumber, batchPredictionJobUpdate=batchPredictionJobUpdate)
    #' }
    BatchPredictionsPatch = function(predictionJobId, partNumber, batchPredictionJobUpdate = NULL, ...) {
      apiResponse <- private$BatchPredictionsPatchWithHttpInfo(predictionJobId, partNumber, batchPredictionJobUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Batch Prediction job
    #' Produces: "application/json"
    #'
    #' @details Retrieve a Batch Prediction job.
    #' @details This method invokes `GET /batchPredictions/{predictionJobId}/` in the DataRobot Public API.
    #' @param predictionJobId character. ID of the Batch Prediction job
    #' @param partNumber integer. The number of which csv part is being uploaded when using multipart upload
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchPredictionJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job details for the requested Batch Prediction job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionJobId <- 'predictionJobId_example' # character | ID of the Batch Prediction job
    #' partNumber <- 0 # integer | The number of which csv part is being uploaded when using multipart upload
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$BatchPredictionsRetrieve(predictionJobId, partNumber)
    #' }
    BatchPredictionsRetrieve = function(predictionJobId, partNumber, ...) {
      apiResponse <- private$BatchPredictionsRetrieveWithHttpInfo(predictionJobId, partNumber, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve training predictions
    #' Produces: "application/json", "text/csv"
    #'
    #' @details Retrieve training predictions that have previously been computed
    #' @details This method invokes `GET /projects/{projectId}/trainingPredictions/{predictionId}/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param projectId character. Project ID to retrieve training predictions for
    #' @param predictionId character. Prediction ID to retrieve training predictions for
    #' @param accept Enum < [application/json, text/csv] > Requested MIME type for the returned data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{TrainingPredictionsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Training predictions encoded either as JSON or CSV
    #' \itemize{
    #' \item **`ContentMinusType`** MIME type of the returned data
    #' }
    #' \item **`404`** Job does not exist or is not completed
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' projectId <- 'projectId_example' # character | Project ID to retrieve training predictions for
    #' predictionId <- 'predictionId_example' # character | Prediction ID to retrieve training predictions for
    #' accept <- 'accept_example' # character | Requested MIME type for the returned data
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ComputedTrainingPredictionsList(offset, limit, projectId, predictionId, accept=accept)
    #' }
    ComputedTrainingPredictionsList = function(offset, limit, projectId, predictionId, accept = NULL, ...) {
      apiResponse <- private$ComputedTrainingPredictionsListWithHttpInfo(offset, limit, projectId, predictionId, accept, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new prediction explanations initialization.
    #' Produces: NA
    #'
    #' @details Create a new prediction explanations initialization. This is a necessary prerequisite for generating prediction explanations.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param predictionExplanationsInitializationCreate \link{PredictionExplanationsInitializationCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' predictionExplanationsInitializationCreate <- PredictionExplanationsInitializationCreate$new() # PredictionExplanationsInitializationCreate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationCreate(projectId, modelId, predictionExplanationsInitializationCreate=predictionExplanationsInitializationCreate)
    #' }
    ProjectsModelsPredictionExplanationsInitializationCreate = function(projectId, modelId, predictionExplanationsInitializationCreate = NULL, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo(projectId, modelId, predictionExplanationsInitializationCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete an existing PredictionExplanationsInitialization.
    #' Produces: NA
    #'
    #' @details Delete an existing PredictionExplanationsInitialization.
    #' @details This method invokes `DELETE /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The deletion was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationDeleteMany(projectId, modelId)
    #' }
    ProjectsModelsPredictionExplanationsInitializationDeleteMany = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationDeleteManyWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the current PredictionExplanationsInitialization.
    #' Produces: NA
    #'
    #' @details Retrieve the current PredictionExplanationsInitialization. A PredictionExplanationsInitialization is a pre-requisite for successfully computing prediction explanations using a particular model, and can be used to preview the prediction explanations that would be generated for a complete dataset.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param excludeAdjustedPredictions Enum < [false, False, true, True] > Whether to include adjusted prediction in the PredictionExplanationsSample response.
    #' @param predictionExplanationsInitializationRetrieve \link{PredictionExplanationsInitializationRetrieve}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' excludeAdjustedPredictions <- "true" # character | Whether to include adjusted prediction in the PredictionExplanationsSample response.
    #' predictionExplanationsInitializationRetrieve <- PredictionExplanationsInitializationRetrieve$new() # PredictionExplanationsInitializationRetrieve |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationList(projectId, modelId, excludeAdjustedPredictions=excludeAdjustedPredictions, predictionExplanationsInitializationRetrieve=predictionExplanationsInitializationRetrieve)
    #' }
    ProjectsModelsPredictionExplanationsInitializationList = function(projectId, modelId, excludeAdjustedPredictions = "true", predictionExplanationsInitializationRetrieve = NULL, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo(projectId, modelId, excludeAdjustedPredictions, predictionExplanationsInitializationRetrieve, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel a queued prediction job
    #' Produces: NA
    #'
    #' @details Cancel a queued prediction job
    #' @details This method invokes `DELETE /projects/{projectId}/predictJobs/{jobId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The job has been successfully cancelled
    #' \itemize{
    #' }
    #' \item **`404`** Job was not found or the job has already completed
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictJobsDelete(projectId, jobId)
    #' }
    ProjectsPredictJobsDelete = function(projectId, jobId, ...) {
      apiResponse <- private$ProjectsPredictJobsDeleteWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all prediction jobs for a project
    #' Produces: "application/json"
    #'
    #' @details List all prediction jobs for a project
    #' @details This method invokes `GET /projects/{projectId}/predictJobs/` in the DataRobot Public API.
    #' @param projectId character. The project ID.
    #' @param status Enum < [queue, inprogress, error] > If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{PredictJobDetailsResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of prediction jobs for a project
    #' \itemize{
    #' }
    #' \item **`404`** Job was not found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' status <- 'status_example' # character | If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictJobsList(projectId, status=status)
    #' }
    ProjectsPredictJobsList = function(projectId, status = NULL, ...) {
      apiResponse <- private$ProjectsPredictJobsListWithHttpInfo(projectId, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Look up a particular prediction job
    #' Produces: "application/json"
    #'
    #' @details Look up a particular prediction job
    #' @details This method invokes `GET /projects/{projectId}/predictJobs/{jobId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictJobDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The job has been successfully retrieved and has not yet finished.
    #' \itemize{
    #' \item **`Location`** present only when the requested job has finished - contains a url from which the completed predictions may be retrieved as with :http:get:&#x60;/api/v2/projects/(projectId)/predictions/(predictionId)/&#x60;
    #' }
    #' \item **`303`** The job has been successfully retrieved and has been completed. See Location header. The response json is also included.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictJobsRetrieve(projectId, jobId)
    #' }
    ProjectsPredictJobsRetrieve = function(projectId, jobId, ...) {
      apiResponse <- private$ProjectsPredictJobsRetrieveWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Upload a dataset for predictions from a &#x60;&#x60;DataSource&#x60;&#x60;.
    #' Produces: NA
    #'
    #' @details Upload a dataset for predictions from a &#x60;DataSource&#x60;.
    #' @details This method invokes `POST /projects/{projectId}/predictionDatasets/dataSourceUploads/` in the DataRobot Public API.
    #' @param projectId character. The project ID to which the data source will be uploaded to.
    #' @param predictionDataSource \link{PredictionDataSource}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Upload successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID to which the data source will be uploaded to.
    #' predictionDataSource <- PredictionDataSource$new() # PredictionDataSource |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsDataSourceUploadsCreate(projectId, predictionDataSource=predictionDataSource)
    #' }
    ProjectsPredictionDatasetsDataSourceUploadsCreate = function(projectId, predictionDataSource = NULL, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsDataSourceUploadsCreateWithHttpInfo(projectId, predictionDataSource, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create prediction dataset
    #' Produces: "application/json"
    #'
    #' @details Create a prediction dataset from a Dataset Asset referenced by AI Catalog item/version ID.
    #' @details This method invokes `POST /projects/{projectId}/predictionDatasets/datasetUploads/` in the DataRobot Public API.
    #' @param projectId character. The project ID.
    #' @param predictionFromCatalogDataset \link{PredictionFromCatalogDataset}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatePredictionDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** Target not set yet or cannot specify time series options with a non time series project.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' predictionFromCatalogDataset <- PredictionFromCatalogDataset$new() # PredictionFromCatalogDataset |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsDatasetUploadsCreate(projectId, predictionFromCatalogDataset=predictionFromCatalogDataset)
    #' }
    ProjectsPredictionDatasetsDatasetUploadsCreate = function(projectId, predictionFromCatalogDataset = NULL, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsDatasetUploadsCreateWithHttpInfo(projectId, predictionFromCatalogDataset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a dataset that was uploaded for prediction.
    #' Produces: NA
    #'
    #' @details Delete a dataset that was uploaded for prediction.
    #' @details This method invokes `DELETE /projects/{projectId}/predictionDatasets/{datasetId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID that owns the data.
    #' @param datasetId character. The dataset ID to delete.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The dataset has been successfully deleted.
    #' \itemize{
    #' }
    #' \item **`404`** No dataset with the specified &#x60;datasetId&#x60; found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID that owns the data.
    #' datasetId <- 'datasetId_example' # character | The dataset ID to delete.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsDelete(projectId, datasetId)
    #' }
    ProjectsPredictionDatasetsDelete = function(projectId, datasetId, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsDeleteWithHttpInfo(projectId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Upload a file for predictions from an attached file.
    #' Produces: NA
    #'
    #' @details Upload a file for predictions from an attached file.
    #' @details This method invokes `POST /projects/{projectId}/predictionDatasets/fileUploads/` in the DataRobot Public API.
    #' @param projectId character. The project ID to which the data will be uploaded for prediction.
    #' @param predictionFileUpload \link{PredictionFileUpload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Upload successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID to which the data will be uploaded for prediction.
    #' predictionFileUpload <- PredictionFileUpload$new() # PredictionFileUpload |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsFileUploadsCreate(projectId, predictionFileUpload=predictionFileUpload)
    #' }
    ProjectsPredictionDatasetsFileUploadsCreate = function(projectId, predictionFileUpload = NULL, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsFileUploadsCreateWithHttpInfo(projectId, predictionFileUpload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List predictions datasets uploaded to a project.
    #' Produces: "application/json"
    #'
    #' @details List predictions datasets uploaded to a project.
    #' @details This method invokes `GET /projects/{projectId}/predictionDatasets/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param projectId character. The project ID to query.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionDatasetListControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request to list the uploaded predictions datasets was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' projectId <- 'projectId_example' # character | The project ID to query.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsList(offset, limit, projectId)
    #' }
    ProjectsPredictionDatasetsList = function(offset, limit, projectId, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get the metadata of a specific dataset. This only works for datasets uploaded to an existing project for prediction.
    #' Produces: "application/json"
    #'
    #' @details Get the metadata of a specific dataset. This only works for datasets uploaded to an existing project for prediction.
    #' @details This method invokes `GET /projects/{projectId}/predictionDatasets/{datasetId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID that owns the data.
    #' @param datasetId character. The dataset ID to query for.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionDatasetRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request to retrieve the metadata of a specified dataset was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID that owns the data.
    #' datasetId <- 'datasetId_example' # character | The dataset ID to query for.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsRetrieve(projectId, datasetId)
    #' }
    ProjectsPredictionDatasetsRetrieve = function(projectId, datasetId, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsRetrieveWithHttpInfo(projectId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Upload a file for predictions from a URL.
    #' Produces: NA
    #'
    #' @details Upload a file for predictions from a URL.
    #' @details This method invokes `POST /projects/{projectId}/predictionDatasets/urlUploads/` in the DataRobot Public API.
    #' @param projectId character. The project ID to which the data will be uploaded for prediction.
    #' @param predictionUrlUpload \link{PredictionURLUpload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Upload successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID to which the data will be uploaded for prediction.
    #' predictionUrlUpload <- PredictionURLUpload$new() # PredictionURLUpload |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionDatasetsUrlUploadsCreate(projectId, predictionUrlUpload=predictionUrlUpload)
    #' }
    ProjectsPredictionDatasetsUrlUploadsCreate = function(projectId, predictionUrlUpload = NULL, ...) {
      apiResponse <- private$ProjectsPredictionDatasetsUrlUploadsCreateWithHttpInfo(projectId, predictionUrlUpload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new PredictionExplanations object (and its accompanying PredictionExplanationsRecord).
    #' Produces: NA
    #'
    #' @details Create a new PredictionExplanations object (and its accompanying PredictionExplanationsRecord). In order to successfully create PredictionExplanations for a particular model and dataset, you must first - Compute feature impact for the model via :&lt;http:post&gt;:/api/v2/projects/(projectId)/models/(modelId)/featureImpact/ - Compute a PredictionExplanationsInitialization for the model via :&lt;http:post&gt;:/api/v2/projects/(projectId)/models/(modelId)/predictionExplanationsInitialization/ - Compute predictions for the model and dataset via :&lt;http:post&gt;:/api/v2/projects/(projectId)/predictions/ thresholdHigh and thresholdLow are optional filters applied to speed up computation. When at least one is specified, only the selected outlier rows will have prediction explanations computed. Rows are considered to be outliers if their predicted value (in case of regression projects) or probability of being the positive class (in case of classification projects) isless than thresholdLow or greater than thresholdHigh. If neither is specified, prediction explanations will be computed for all rows.
    #' @details This method invokes `POST /projects/{projectId}/predictionExplanations/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsCreate \link{PredictionExplanationsCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsCreate <- PredictionExplanationsCreate$new() # PredictionExplanationsCreate |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsCreate(projectId, predictionExplanationsCreate=predictionExplanationsCreate)
    #' }
    ProjectsPredictionExplanationsCreate = function(projectId, predictionExplanationsCreate = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsCreateWithHttpInfo(projectId, predictionExplanationsCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve stored Prediction Explanations.
    #' Produces: NA
    #'
    #' @details Retrieve stored Prediction Explanations. Each PredictionExplanationsRow retrieved corresponds to a row of the prediction dataset, although some rows may not have had prediction explanations computed depending on the thresholds selected.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanations/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a new maximum limit may be imposed without notice.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param offset integer. This many results will be skipped.
    #' @param excludeAdjustedPredictions Enum < [false, False, true, True] > Whether to include adjusted prediction in PredictionExplanationsRow response.
    #' @param predictionExplanationsRetrieve \link{PredictionExplanationsRetrieve}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 3000 # integer | At most this many results are returned. The default may change and a new maximum limit may be imposed without notice.
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #' offset <- 0 # integer | This many results will be skipped.
    #' excludeAdjustedPredictions <- "true" # character | Whether to include adjusted prediction in PredictionExplanationsRow response.
    #' predictionExplanationsRetrieve <- PredictionExplanationsRetrieve$new() # PredictionExplanationsRetrieve |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsList(limit, projectId, predictionExplanationsId, offset=offset, excludeAdjustedPredictions=excludeAdjustedPredictions, predictionExplanationsRetrieve=predictionExplanationsRetrieve)
    #' }
    ProjectsPredictionExplanationsList = function(limit, projectId, predictionExplanationsId, offset = 0, excludeAdjustedPredictions = "true", predictionExplanationsRetrieve = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsListWithHttpInfo(limit, projectId, predictionExplanationsId, offset, excludeAdjustedPredictions, predictionExplanationsRetrieve, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete saved Prediction Explanations.
    #' Produces: NA
    #'
    #' @details Delete saved Prediction Explanations. Deletes both the actual prediction explanations and the corresponding PredictionExplanationsRecord.
    #' @details This method invokes `DELETE /projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The object was deleted successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsDelete(projectId, predictionExplanationsId)
    #' }
    ProjectsPredictionExplanationsRecordsDelete = function(projectId, predictionExplanationsId, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsDeleteWithHttpInfo(projectId, predictionExplanationsId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List PredictionExplanationsRecord objects for a project.
    #' Produces: "application/json"
    #'
    #' @details List PredictionExplanationsRecord objects for a project. These contain metadata about the computed prediction explanations and the location at which the PredictionExplanations can be retrieved.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanationsRecords/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param modelId character. If specified, only prediction explanations records computed for this model will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionExplanationsRecordList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The object was found and returned successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' modelId <- 'modelId_example' # character | If specified, only prediction explanations records computed for this model will be returned.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsList(projectId, offset=offset, limit=limit, modelId=modelId)
    #' }
    ProjectsPredictionExplanationsRecordsList = function(projectId, offset = 0, limit = 100, modelId = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsListWithHttpInfo(projectId, offset, limit, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a PredictionExplanationsRecord object.
    #' Produces: NA
    #'
    #' @details Retrieve a PredictionExplanationsRecord object. A PredictionExplanationsRecord contains metadata about the computed prediction explanations and the location at which the PredictionExplanations can be retrieved.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param predictionExplanationsRecord \link{PredictionExplanationsRecord}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The object was found and returned successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #' predictionExplanationsRecord <- PredictionExplanationsRecord$new() # PredictionExplanationsRecord |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsRetrieve(projectId, predictionExplanationsId, predictionExplanationsRecord=predictionExplanationsRecord)
    #' }
    ProjectsPredictionExplanationsRecordsRetrieve = function(projectId, predictionExplanationsId, predictionExplanationsRecord = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo(projectId, predictionExplanationsId, predictionExplanationsRecord, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Make new predictions.
    #' Produces: NA
    #'
    #' @details There are two ways of making predictions. The recommended way is to first upload your dataset to the project, and then using the corresponding datasetId, predict against that dataset. To follow that pattern, send the json request body.  Note that requesting prediction intervals will automatically trigger backtesting if backtests were not already completed for this model.  The legacy method which is deprecated is to send the file directly with the predictions request. If you need to predict against a file 10MB in size or larger, you will be required to use the above workflow for uploaded datasets. However, the following multipart/form-data can be used with small files:  form file   a dataset to make predictions on  form modelId   the model to use to make predictions  Note  If using the legacy method of uploading data to this endpoint, a new dataset will be created behind the scenes. For performance reasons, it would be much better to utilize the workflow of creating the dataset first and using the supported method of making predictions of this endpoint. However, to preserve the functionality of existing workflows, the legacy method still exists.
    #' @details This method invokes `POST /projects/{projectId}/predictions/` in the DataRobot Public API.
    #' @param projectId character. The project to make predictions within.
    #' @param contentType Enum < [application/json, multipart/form-data] > Content types available for making request. &#x60;multipart/form-data&#x60; is the legacy deprecated method to send the small file with the prediction request.
    #' @param createPredictionFromDataset \link{CreatePredictionFromDataset}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Prediction has successfully been requested. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status of the predictions as with :http:get:&#x60;/api/v2/projects/(projectId)/predictJobs/(jobId)/&#x60;
    #' }
    #' \item **`422`** The request cannot be processed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to make predictions within.
    #' contentType <- 'contentType_example' # character | Content types available for making request. `multipart/form-data` is the legacy deprecated method to send the small file with the prediction request.
    #' createPredictionFromDataset <- CreatePredictionFromDataset$new() # CreatePredictionFromDataset |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionsCreate(projectId, contentType, createPredictionFromDataset=createPredictionFromDataset)
    #' }
    ProjectsPredictionsCreate = function(projectId, contentType, createPredictionFromDataset = NULL, ...) {
      apiResponse <- private$ProjectsPredictionsCreateWithHttpInfo(projectId, contentType, createPredictionFromDataset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of prediction records.
    #' Produces: "application/json"
    #'
    #' @details Get a list of prediction records.  v2.21 Use :&lt;http:get&gt;:/api/v2/projects/(projectId)/predictionsMetadata/ instead. The only difference is that parameter datasetId is renamed to predictionDatasetId both in request and response.
    #' @details This method invokes `GET /projects/{projectId}/predictions/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' @param projectId character. The project of the predictions.
    #' @param datasetId character. Dataset id used to create the predictions
    #' @param modelId character. Model id
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrieveListPredictionMetadataObjectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The json array of prediction metadata objects.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 1000 # integer | At most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' projectId <- 'projectId_example' # character | The project of the predictions.
    #' datasetId <- 'datasetId_example' # character | Dataset id used to create the predictions
    #' modelId <- 'modelId_example' # character | Model id
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionsList(offset, limit, projectId, datasetId=datasetId, modelId=modelId)
    #' }
    ProjectsPredictionsList = function(offset, limit, projectId, datasetId = NULL, modelId = NULL, ...) {
      apiResponse <- private$ProjectsPredictionsListWithHttpInfo(offset, limit, projectId, datasetId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of prediction metadata records.
    #' Produces: "application/json"
    #'
    #' @details Use the ID of a metadata object to get the complete set of predictions.
    #' @details This method invokes `GET /projects/{projectId}/predictionsMetadata/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' @param projectId character. The project of the predictions.
    #' @param predictionDatasetId character. Dataset id used to create the predictions
    #' @param modelId character. Model id
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrieveListPredictionMetadataObjectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The json array of prediction metadata objects.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 1000 # integer | At most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' projectId <- 'projectId_example' # character | The project of the predictions.
    #' predictionDatasetId <- 'predictionDatasetId_example' # character | Dataset id used to create the predictions
    #' modelId <- 'modelId_example' # character | Model id
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionsMetadataList(offset, limit, projectId, predictionDatasetId=predictionDatasetId, modelId=modelId)
    #' }
    ProjectsPredictionsMetadataList = function(offset, limit, projectId, predictionDatasetId = NULL, modelId = NULL, ...) {
      apiResponse <- private$ProjectsPredictionsMetadataListWithHttpInfo(offset, limit, projectId, predictionDatasetId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve metadata for a set of predictions.
    #' Produces: "application/json"
    #'
    #' @details Use the ID of a metadata object to get the complete set of predictions.
    #' @details This method invokes `GET /projects/{projectId}/predictionsMetadata/{predictionId}/` in the DataRobot Public API.
    #' @param predictionId character. The id of the prediction record to retrieve. If you have the jobId, you can retrieve the predictionId using :http:get:&#x60;/api/v2/projects/(projectId)/predictJobs/(jobId)/&#x60;.
    #' @param projectId character. The id of the project the prediction belongs to.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrievePredictionMetadataObject}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Prediction metadata object.
    #' \itemize{
    #' }
    #' \item **`404`** Training predictions not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionId <- 'predictionId_example' # character | The id of the prediction record to retrieve. If you have the jobId, you can retrieve the predictionId using :http:get:`/api/v2/projects/(projectId)/predictJobs/(jobId)/`.
    #' projectId <- 'projectId_example' # character | The id of the project the prediction belongs to.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionsMetadataRetrieve(predictionId, projectId)
    #' }
    ProjectsPredictionsMetadataRetrieve = function(predictionId, projectId, ...) {
      apiResponse <- private$ProjectsPredictionsMetadataRetrieveWithHttpInfo(predictionId, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a completed set of predictions.
    #' Produces: "application/json"
    #'
    #' @details Retrieve predictions that have previously been computed. Training predictions encoded either as JSON or CSV. If CSV output was requested, the returned CSV data will contain the following columns:  - For regression projects: row_id and prediction. - For binary classification projects: row_id, prediction,   class\\_\\&lt;positive_class_label\\&gt; and class\\_\\&lt;negative_class_label\\&gt;. - For multiclass projects: row_id, prediction and a   class\\_\\&lt;class_label\\&gt; for each class. - For multilabel projects: row_id and for each class   prediction\\_\\&lt;class_label\\&gt; and class\\_\\&lt;class_label\\&gt;. - For time-series, these additional columns will be added:   forecast_point, forecast_distance, timestamp, and series_id.  v2.21  - If explanationAlgorithm &#x3D; &#39;shap&#39;, these additional columns will be   added: triplets of (Explanation\\_\\&lt;i\\&gt;\\_feature_name,   Explanation\\_\\&lt;i\\&gt;\\_feature_value, and Explanation\\_\\&lt;i\\&gt;\\_strength)   for i ranging from 1 to maxExplanations, shap_remaining_total and   shap_base_value. Binary classification projects will also have   explained_class, the class for which positive SHAP values imply an   increased probability.
    #' @details This method invokes `GET /projects/{projectId}/predictions/{predictionId}/` in the DataRobot Public API.
    #' @param predictionId character. The id of the prediction record to retrieve. If you have the jobId, you can retrieve the predictionId using :http:get:&#x60;/api/v2/projects/(projectId)/predictJobs/(jobId)/&#x60;.
    #' @param projectId character. The id of the project the prediction belongs to.
    #' @param shapMulticlassLevel character. Required in multiclass projects with SHAP prediction explanations. This parameter specifies which of the target classes (levels) you would like to retrieve explanations for. This will NOT affect a non-multiclass project.
    #' @param accept Enum < [application/json, text/csv] > Requested MIME type for the returned data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Predictions that have previously been computed.
    #' \itemize{
    #' \item **`ContentMinusType`** MIME type of the returned data
    #' }
    #' \item **`404`** No prediction data found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' predictionId <- 'predictionId_example' # character | The id of the prediction record to retrieve. If you have the jobId, you can retrieve the predictionId using :http:get:`/api/v2/projects/(projectId)/predictJobs/(jobId)/`.
    #' projectId <- 'projectId_example' # character | The id of the project the prediction belongs to.
    #' shapMulticlassLevel <- 'shapMulticlassLevel_example' # character | Required in multiclass projects with SHAP prediction explanations. This parameter specifies which of the target classes (levels) you would like to retrieve explanations for. This will NOT affect a non-multiclass project.
    #' accept <- 'accept_example' # character | Requested MIME type for the returned data
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsPredictionsRetrieve(predictionId, projectId, shapMulticlassLevel=shapMulticlassLevel, accept=accept)
    #' }
    ProjectsPredictionsRetrieve = function(predictionId, projectId, shapMulticlassLevel = NULL, accept = NULL, ...) {
      apiResponse <- private$ProjectsPredictionsRetrieveWithHttpInfo(predictionId, projectId, shapMulticlassLevel, accept, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Submits a job to compute predictions for training data
    #' Produces: NA
    #'
    #' @details Create training data predictions
    #' @details This method invokes `POST /projects/{projectId}/trainingPredictions/` in the DataRobot Public API.
    #' @param projectId character. Project ID to compute training predictions for
    #' @param createTrainingPrediction \link{CreateTrainingPrediction}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Submitted successfully. See Location header.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | Project ID to compute training predictions for
    #' createTrainingPrediction <- CreateTrainingPrediction$new() # CreateTrainingPrediction |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ProjectsTrainingPredictionsCreate(projectId, createTrainingPrediction=createTrainingPrediction)
    #' }
    ProjectsTrainingPredictionsCreate = function(projectId, createTrainingPrediction = NULL, ...) {
      apiResponse <- private$ProjectsTrainingPredictionsCreateWithHttpInfo(projectId, createTrainingPrediction, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete scheduled job
    #' Produces: NA
    #'
    #' @details Delete scheduled job
    #' @details This method invokes `DELETE /scheduledJobs/{jobId}/` in the DataRobot Public API.
    #' @param jobId character. The ID of the job being requested.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Job deleted
    #' \itemize{
    #' }
    #' \item **`404`** Job was not found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobId <- 'jobId_example' # character | The ID of the job being requested.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ScheduledJobsDelete(jobId)
    #' }
    ScheduledJobsDelete = function(jobId, ...) {
      apiResponse <- private$ScheduledJobsDeleteWithHttpInfo(jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List scheduled deployment batch prediction jobs a user can view
    #' Produces: "application/json"
    #'
    #' @details Get a list of scheduled batch prediction jobs a user can view
    #' @details This method invokes `GET /scheduledJobs/` in the DataRobot Public API.
    #' @param offset integer. The number of scheduled jobs to skip. Defaults to 0.
    #' @param limit integer. The number of scheduled jobs (max 100) to return. Defaults to 20
    #' @param orderBy character. The order to sort the scheduled jobs. Defaults to order by last successful run timestamp in descending order.
    #' @param search character. Case insensitive search against scheduled jobs name or type name.
    #' @param deploymentId character. Filter by the prediction integration deployment ID. Ignored for non prediction integration type ID.
    #' @param typeId Enum < [predictionIntegration, datasetRefresh] > filter by scheduled job type ID.
    #' @param integrationTypeName Enum < [sql, tableau, snowflake, kdb] > filter by integration type name.
    #' @param queryByUser Enum < [createdBy, updatedBy] > Which user field to filter with.
    #' @param filterEnabled Enum < [false, False, true, True] > Filter jobs using the enabled field. If &#x60;true&#x60;, only enabled jobs are returned, otherwise if &#x60;false&#x60;, only disabled jobs are returned. The default returns both enabled and disabled jobs.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ScheduledJobsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of scheduled batch prediction jobs
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of scheduled jobs to skip. Defaults to 0.
    #' limit <- 20 # integer | The number of scheduled jobs (max 100) to return. Defaults to 20
    #' orderBy <- "name" # character | The order to sort the scheduled jobs. Defaults to order by last successful run timestamp in descending order.
    #' search <- "" # character | Case insensitive search against scheduled jobs name or type name.
    #' deploymentId <- 'deploymentId_example' # character | Filter by the prediction integration deployment ID. Ignored for non prediction integration type ID.
    #' typeId <- "predictionIntegration" # character | filter by scheduled job type ID.
    #' integrationTypeName <- 'integrationTypeName_example' # character | filter by integration type name.
    #' queryByUser <- "createdBy" # character | Which user field to filter with.
    #' filterEnabled <- 'filterEnabled_example' # character | Filter jobs using the enabled field. If `true`, only enabled jobs are returned, otherwise if `false`, only disabled jobs are returned. The default returns both enabled and disabled jobs.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ScheduledJobsList(offset, limit, orderBy=orderBy, search=search, deploymentId=deploymentId, typeId=typeId, integrationTypeName=integrationTypeName, queryByUser=queryByUser, filterEnabled=filterEnabled)
    #' }
    ScheduledJobsList = function(offset, limit, orderBy = "name", search = "", deploymentId = NULL, typeId = "predictionIntegration", integrationTypeName = NULL, queryByUser = "createdBy", filterEnabled = NULL, ...) {
      apiResponse <- private$ScheduledJobsListWithHttpInfo(offset, limit, orderBy, search, deploymentId, typeId, integrationTypeName, queryByUser, filterEnabled, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Run or stop a previously created scheduled integration job
    #' Produces: NA
    #'
    #' @details Run or stop a previously created scheduled integration job
    #' @details This method invokes `PATCH /scheduledJobs/{jobId}/` in the DataRobot Public API.
    #' @param jobId character. The ID of the job being requested.
    #' @param scheduledJobRunStop \link{ScheduledJobRunStop}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Job was either started or stopped
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to run the job
    #' \itemize{
    #' }
    #' \item **`404`** Scheduled job does not exist
    #' \itemize{
    #' }
    #' \item **`422`** Scheduled job is already stopped or is already running
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobId <- 'jobId_example' # character | The ID of the job being requested.
    #' scheduledJobRunStop <- ScheduledJobRunStop$new() # ScheduledJobRunStop |
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ScheduledJobsPatch(jobId, scheduledJobRunStop=scheduledJobRunStop)
    #' }
    ScheduledJobsPatch = function(jobId, scheduledJobRunStop = NULL, ...) {
      apiResponse <- private$ScheduledJobsPatchWithHttpInfo(jobId, scheduledJobRunStop, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List a single deployment batch prediction job
    #' Produces: "application/json"
    #'
    #' @details Get a scheduled batch prediction job
    #' @details This method invokes `GET /scheduledJobs/{jobId}/` in the DataRobot Public API.
    #' @param jobId character. The ID of the job being requested.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ScheduledJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A scheduled batch prediction job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' jobId <- 'jobId_example' # character | The ID of the job being requested.
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$ScheduledJobsRetrieve(jobId)
    #' }
    ScheduledJobsRetrieve = function(jobId, ...) {
      apiResponse <- private$ScheduledJobsRetrieveWithHttpInfo(jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List training prediction jobs
    #' Produces: "application/json"
    #'
    #' @details Get a list of training prediction records
    #' @details This method invokes `GET /projects/{projectId}/trainingPredictions/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param projectId character. Project ID to retrieve training predictions for
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{TrainingPredictionsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of training prediction jobs
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' projectId <- 'projectId_example' # character | Project ID to retrieve training predictions for
    #'
    #' api.instance <- PredictionsApi$new()
    #' result <- api.instance$TrainingPredictionsList(offset, limit, projectId)
    #' }
    TrainingPredictionsList = function(offset, limit, projectId, ...) {
      apiResponse <- private$TrainingPredictionsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsCreateWithHttpInfo = function(batchPredictionJobDefinitionsCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batchPredictionJobDefinitionsCreate`) && isa(batchPredictionJobDefinitionsCreate, c("BatchPredictionJobDefinitionsCreate", "R6"))) {
        body <- `batchPredictionJobDefinitionsCreate`$toJSON()
      } else {
        stop("BatchPredictionJobDefinitionsCreateWithHttpInfo requires parameter batchPredictionJobDefinitionsCreate to be of type BatchPredictionJobDefinitionsCreate.")
      }

      urlPath <- "/batchPredictionJobDefinitions/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobDefinitionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsDeleteWithHttpInfo = function(jobDefinitionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobDefinitionId`)) {
        stop("Missing required parameter `jobDefinitionId`.")
      }

      body <- NULL
      urlPath <- "/batchPredictionJobDefinitions/{jobDefinitionId}/"
      if (!missing(`jobDefinitionId`)) {
        urlPath <- gsub(paste0("\\{", "jobDefinitionId", "\\}"), URLencode(as.character(`jobDefinitionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsListWithHttpInfo = function(offset, limit, deploymentId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["deploymentId"] <- deploymentId

      body <- NULL
      urlPath <- "/batchPredictionJobDefinitions/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobDefinitionsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsPatchWithHttpInfo = function(jobDefinitionId, batchPredictionJobDefinitionsUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobDefinitionId`)) {
        stop("Missing required parameter `jobDefinitionId`.")
      }

      if (!missing(`batchPredictionJobDefinitionsUpdate`) && isa(batchPredictionJobDefinitionsUpdate, c("BatchPredictionJobDefinitionsUpdate", "R6"))) {
        body <- `batchPredictionJobDefinitionsUpdate`$toJSON()
      } else {
        stop("BatchPredictionJobDefinitionsPatchWithHttpInfo requires parameter batchPredictionJobDefinitionsUpdate to be of type BatchPredictionJobDefinitionsUpdate.")
      }

      urlPath <- "/batchPredictionJobDefinitions/{jobDefinitionId}/"
      if (!missing(`jobDefinitionId`)) {
        urlPath <- gsub(paste0("\\{", "jobDefinitionId", "\\}"), URLencode(as.character(`jobDefinitionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobDefinitionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsPortableList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsPortableListWithHttpInfo = function(jobDefinitionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobDefinitionId`)) {
        stop("Missing required parameter `jobDefinitionId`.")
      }

      body <- NULL
      urlPath <- "/batchPredictionJobDefinitions/{jobDefinitionId}/portable/"
      if (!missing(`jobDefinitionId`)) {
        urlPath <- gsub(paste0("\\{", "jobDefinitionId", "\\}"), URLencode(as.character(`jobDefinitionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionJobDefinitionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionJobDefinitionsRetrieveWithHttpInfo = function(jobDefinitionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobDefinitionId`)) {
        stop("Missing required parameter `jobDefinitionId`.")
      }

      body <- NULL
      urlPath <- "/batchPredictionJobDefinitions/{jobDefinitionId}/"
      if (!missing(`jobDefinitionId`)) {
        urlPath <- gsub(paste0("\\{", "jobDefinitionId", "\\}"), URLencode(as.character(`jobDefinitionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobDefinitionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsCreateWithHttpInfo = function(batchPredictionJobCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batchPredictionJobCreate`) && isa(batchPredictionJobCreate, c("BatchPredictionJobCreate", "R6"))) {
        body <- `batchPredictionJobCreate`$toJSON()
      } else {
        stop("BatchPredictionsCreateWithHttpInfo requires parameter batchPredictionJobCreate to be of type BatchPredictionJobCreate.")
      }

      urlPath <- "/batchPredictions/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsCsvUploadFinalizeMultipartCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsCsvUploadFinalizeMultipartCreateWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/csvUpload/finalizeMultipart/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsCsvUploadPartPut`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsCsvUploadPartPutWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/csvUpload/part/{partNumber}/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsCsvUploadPutMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsCsvUploadPutManyWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/csvUpload/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsDeleteWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsDownloadListWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/download/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsFromExistingCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsFromExistingCreateWithHttpInfo = function(batchPredictionJobId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batchPredictionJobId`) && isa(batchPredictionJobId, c("BatchPredictionJobId", "R6"))) {
        body <- `batchPredictionJobId`$toJSON()
      } else {
        stop("BatchPredictionsFromExistingCreateWithHttpInfo requires parameter batchPredictionJobId to be of type BatchPredictionJobId.")
      }

      urlPath <- "/batchPredictions/fromExisting/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsFromJobDefinitionCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsFromJobDefinitionCreateWithHttpInfo = function(batchPredictionJobDefinitionId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batchPredictionJobDefinitionId`) && isa(batchPredictionJobDefinitionId, c("BatchPredictionJobDefinitionId", "R6"))) {
        body <- `batchPredictionJobDefinitionId`$toJSON()
      } else {
        stop("BatchPredictionsFromJobDefinitionCreateWithHttpInfo requires parameter batchPredictionJobDefinitionId to be of type BatchPredictionJobDefinitionId.")
      }

      urlPath <- "/batchPredictions/fromJobDefinition/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsListWithHttpInfo = function(offset, limit, allJobs, status = NULL, source = NULL, deploymentId = NULL, modelId = NULL, jobId = NULL, orderBy = NULL, cutoffHours = NULL, startDateTime = NULL, endDateTime = NULL, batchPredictionJobDefinitionId = NULL, hostname = NULL, intakeType = NULL, outputType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`allJobs`)) {
        stop("Missing required parameter `allJobs`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["status"] <- status

      queryParams["source"] <- source

      queryParams["deploymentId"] <- deploymentId

      queryParams["modelId"] <- modelId

      queryParams["jobId"] <- jobId

      queryParams["orderBy"] <- orderBy

      queryParams["allJobs"] <- allJobs

      queryParams["cutoffHours"] <- cutoffHours

      queryParams["startDateTime"] <- startDateTime

      queryParams["endDateTime"] <- endDateTime

      queryParams["batchPredictionJobDefinitionId"] <- batchPredictionJobDefinitionId

      queryParams["hostname"] <- hostname

      queryParams["intakeType"] <- intakeType

      queryParams["outputType"] <- outputType

      body <- NULL
      urlPath <- "/batchPredictions/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsPatchWithHttpInfo = function(predictionJobId, partNumber, batchPredictionJobUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      if (!missing(`batchPredictionJobUpdate`) && isa(batchPredictionJobUpdate, c("BatchPredictionJobUpdate", "R6"))) {
        body <- `batchPredictionJobUpdate`$toJSON()
      } else {
        stop("BatchPredictionsPatchWithHttpInfo requires parameter batchPredictionJobUpdate to be of type BatchPredictionJobUpdate.")
      }

      urlPath <- "/batchPredictions/{predictionJobId}/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchPredictionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchPredictionsRetrieveWithHttpInfo = function(predictionJobId, partNumber, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionJobId`)) {
        stop("Missing required parameter `predictionJobId`.")
      }

      if (missing(`partNumber`)) {
        stop("Missing required parameter `partNumber`.")
      }

      body <- NULL
      urlPath <- "/batchPredictions/{predictionJobId}/"
      if (!missing(`predictionJobId`)) {
        urlPath <- gsub(paste0("\\{", "predictionJobId", "\\}"), URLencode(as.character(`predictionJobId`), reserved = TRUE), urlPath)
      }

      if (!missing(`partNumber`)) {
        urlPath <- gsub(paste0("\\{", "partNumber", "\\}"), URLencode(as.character(`partNumber`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchPredictionJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ComputedTrainingPredictionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ComputedTrainingPredictionsListWithHttpInfo = function(offset, limit, projectId, predictionId, accept = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionId`)) {
        stop("Missing required parameter `predictionId`.")
      }

      headerParams["Accept"] <- `accept`

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/trainingPredictions/{predictionId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionId`)) {
        urlPath <- gsub(paste0("\\{", "predictionId", "\\}"), URLencode(as.character(`predictionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "TrainingPredictionsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo = function(projectId, modelId, predictionExplanationsInitializationCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`predictionExplanationsInitializationCreate`) && isa(predictionExplanationsInitializationCreate, c("PredictionExplanationsInitializationCreate", "R6"))) {
        body <- `predictionExplanationsInitializationCreate`$toJSON()
      } else {
        stop("ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo requires parameter predictionExplanationsInitializationCreate to be of type PredictionExplanationsInitializationCreate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationDeleteManyWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo = function(projectId, modelId, excludeAdjustedPredictions = "true", predictionExplanationsInitializationRetrieve = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["excludeAdjustedPredictions"] <- excludeAdjustedPredictions

      if (!missing(`predictionExplanationsInitializationRetrieve`) && isa(predictionExplanationsInitializationRetrieve, c("PredictionExplanationsInitializationRetrieve", "R6"))) {
        body <- `predictionExplanationsInitializationRetrieve`$toJSON()
      } else {
        stop("ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo requires parameter predictionExplanationsInitializationRetrieve to be of type PredictionExplanationsInitializationRetrieve.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictJobsDeleteWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictJobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictJobsListWithHttpInfo = function(projectId, status = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["status"] <- status

      body <- NULL
      urlPath <- "/projects/{projectId}/predictJobs/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[PredictJobDetailsResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictJobsRetrieveWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictJobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictJobDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsDataSourceUploadsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsDataSourceUploadsCreateWithHttpInfo = function(projectId, predictionDataSource = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionDataSource`) && isa(predictionDataSource, c("PredictionDataSource", "R6"))) {
        body <- `predictionDataSource`$toJSON()
      } else {
        stop("ProjectsPredictionDatasetsDataSourceUploadsCreateWithHttpInfo requires parameter predictionDataSource to be of type PredictionDataSource.")
      }

      urlPath <- "/projects/{projectId}/predictionDatasets/dataSourceUploads/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsDatasetUploadsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsDatasetUploadsCreateWithHttpInfo = function(projectId, predictionFromCatalogDataset = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionFromCatalogDataset`) && isa(predictionFromCatalogDataset, c("PredictionFromCatalogDataset", "R6"))) {
        body <- `predictionFromCatalogDataset`$toJSON()
      } else {
        stop("ProjectsPredictionDatasetsDatasetUploadsCreateWithHttpInfo requires parameter predictionFromCatalogDataset to be of type PredictionFromCatalogDataset.")
      }

      urlPath <- "/projects/{projectId}/predictionDatasets/datasetUploads/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatePredictionDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsDeleteWithHttpInfo = function(projectId, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionDatasets/{datasetId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsFileUploadsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsFileUploadsCreateWithHttpInfo = function(projectId, predictionFileUpload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionFileUpload`) && isa(predictionFileUpload, c("PredictionFileUpload", "R6"))) {
        body <- `predictionFileUpload`$toJSON()
      } else {
        stop("ProjectsPredictionDatasetsFileUploadsCreateWithHttpInfo requires parameter predictionFileUpload to be of type PredictionFileUpload.")
      }

      urlPath <- "/projects/{projectId}/predictionDatasets/fileUploads/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionDatasets/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionDatasetListControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsRetrieveWithHttpInfo = function(projectId, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionDatasets/{datasetId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionDatasetRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionDatasetsUrlUploadsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionDatasetsUrlUploadsCreateWithHttpInfo = function(projectId, predictionUrlUpload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionUrlUpload`) && isa(predictionUrlUpload, c("PredictionURLUpload", "R6"))) {
        body <- `predictionUrlUpload`$toJSON()
      } else {
        stop("ProjectsPredictionDatasetsUrlUploadsCreateWithHttpInfo requires parameter predictionUrlUpload to be of type PredictionURLUpload.")
      }

      urlPath <- "/projects/{projectId}/predictionDatasets/urlUploads/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsCreateWithHttpInfo = function(projectId, predictionExplanationsCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionExplanationsCreate`) && isa(predictionExplanationsCreate, c("PredictionExplanationsCreate", "R6"))) {
        body <- `predictionExplanationsCreate`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsCreateWithHttpInfo requires parameter predictionExplanationsCreate to be of type PredictionExplanationsCreate.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanations/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsListWithHttpInfo = function(limit, projectId, predictionExplanationsId, offset = 0, excludeAdjustedPredictions = "true", predictionExplanationsRetrieve = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["excludeAdjustedPredictions"] <- excludeAdjustedPredictions

      if (!missing(`predictionExplanationsRetrieve`) && isa(predictionExplanationsRetrieve, c("PredictionExplanationsRetrieve", "R6"))) {
        body <- `predictionExplanationsRetrieve`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsListWithHttpInfo requires parameter predictionExplanationsRetrieve to be of type PredictionExplanationsRetrieve.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanations/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsDeleteWithHttpInfo = function(projectId, predictionExplanationsId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsListWithHttpInfo = function(projectId, offset = 0, limit = 100, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionExplanationsRecordList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo = function(projectId, predictionExplanationsId, predictionExplanationsRecord = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      if (!missing(`predictionExplanationsRecord`) && isa(predictionExplanationsRecord, c("PredictionExplanationsRecord", "R6"))) {
        body <- `predictionExplanationsRecord`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo requires parameter predictionExplanationsRecord to be of type PredictionExplanationsRecord.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionsCreateWithHttpInfo = function(projectId, contentType, createPredictionFromDataset = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`contentType`)) {
        stop("Missing required parameter `contentType`.")
      }

      headerParams["Content-Type"] <- `contentType`

      if (!missing(`createPredictionFromDataset`) && isa(createPredictionFromDataset, c("CreatePredictionFromDataset", "R6"))) {
        body <- `createPredictionFromDataset`$toJSON()
      } else {
        stop("ProjectsPredictionsCreateWithHttpInfo requires parameter createPredictionFromDataset to be of type CreatePredictionFromDataset.")
      }

      urlPath <- "/projects/{projectId}/predictions/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionsListWithHttpInfo = function(offset, limit, projectId, datasetId = NULL, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/predictions/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrieveListPredictionMetadataObjectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionsMetadataListWithHttpInfo = function(offset, limit, projectId, predictionDatasetId = NULL, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["predictionDatasetId"] <- predictionDatasetId

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionsMetadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrieveListPredictionMetadataObjectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionsMetadataRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionsMetadataRetrieveWithHttpInfo = function(predictionId, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionId`)) {
        stop("Missing required parameter `predictionId`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionsMetadata/{predictionId}/"
      if (!missing(`predictionId`)) {
        urlPath <- gsub(paste0("\\{", "predictionId", "\\}"), URLencode(as.character(`predictionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrievePredictionMetadataObject", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionsRetrieveWithHttpInfo = function(predictionId, projectId, shapMulticlassLevel = NULL, accept = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`predictionId`)) {
        stop("Missing required parameter `predictionId`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      headerParams["Accept"] <- `accept`

      queryParams["shapMulticlassLevel"] <- shapMulticlassLevel

      body <- NULL
      urlPath <- "/projects/{projectId}/predictions/{predictionId}/"
      if (!missing(`predictionId`)) {
        urlPath <- gsub(paste0("\\{", "predictionId", "\\}"), URLencode(as.character(`predictionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsTrainingPredictionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsTrainingPredictionsCreateWithHttpInfo = function(projectId, createTrainingPrediction = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`createTrainingPrediction`) && isa(createTrainingPrediction, c("CreateTrainingPrediction", "R6"))) {
        body <- `createTrainingPrediction`$toJSON()
      } else {
        stop("ProjectsTrainingPredictionsCreateWithHttpInfo requires parameter createTrainingPrediction to be of type CreateTrainingPrediction.")
      }

      urlPath <- "/projects/{projectId}/trainingPredictions/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ScheduledJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ScheduledJobsDeleteWithHttpInfo = function(jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/scheduledJobs/{jobId}/"
      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ScheduledJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ScheduledJobsListWithHttpInfo = function(offset, limit, orderBy = "name", search = "", deploymentId = NULL, typeId = "predictionIntegration", integrationTypeName = NULL, queryByUser = "createdBy", filterEnabled = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["search"] <- search

      queryParams["deploymentId"] <- deploymentId

      queryParams["typeId"] <- typeId

      queryParams["integrationTypeName"] <- integrationTypeName

      queryParams["queryByUser"] <- queryByUser

      queryParams["filterEnabled"] <- filterEnabled

      body <- NULL
      urlPath <- "/scheduledJobs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ScheduledJobsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ScheduledJobsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ScheduledJobsPatchWithHttpInfo = function(jobId, scheduledJobRunStop = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      if (!missing(`scheduledJobRunStop`) && isa(scheduledJobRunStop, c("ScheduledJobRunStop", "R6"))) {
        body <- `scheduledJobRunStop`$toJSON()
      } else {
        stop("ScheduledJobsPatchWithHttpInfo requires parameter scheduledJobRunStop to be of type ScheduledJobRunStop.")
      }

      urlPath <- "/scheduledJobs/{jobId}/"
      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ScheduledJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ScheduledJobsRetrieveWithHttpInfo = function(jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/scheduledJobs/{jobId}/"
      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ScheduledJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `TrainingPredictionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    TrainingPredictionsListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/trainingPredictions/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "TrainingPredictionsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
