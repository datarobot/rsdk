# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Notifications operations
#' @description datarobot.apicore.Notifications
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
NotificationsApi <- R6::R6Class(
  "NotificationsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Create notification channel
    #' Produces: "application/json"
    #'
    #' @details Create a new notification channel.
    #' @param notificationChannelCreate \link{NotificationChannelCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationChannelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Notification channel created successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationChannelCreate <- NotificationChannelCreate$new() # NotificationChannelCreate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationChannelsCreate(notificationChannelCreate=notificationChannelCreate)
    #' }
    NotificationChannelsCreate = function(notificationChannelCreate = NULL, ...) {
      apiResponse <- private$NotificationChannelsCreateWithHttpInfo(notificationChannelCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete notification channel
    #' Produces: NA
    #'
    #' @details Delete the notification channel.
    #' @param channelId character. The id of the notification channel.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification channel deleted successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' channelId <- 'channelId_example' # character | The id of the notification channel.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationChannelsDelete(channelId)
    #' }
    NotificationChannelsDelete = function(channelId, ...) {
      apiResponse <- private$NotificationChannelsDeleteWithHttpInfo(channelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List notification channels
    #' Produces: "application/json"
    #'
    #' @details List the notification channels according to the query.
    #' @param offset integer. How many notification channels to skip.
    #' @param limit integer. At most this many notification channels to return.
    #' @param namePart character. Only return the notification channels whose names contain the given substring.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationChannelsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Notification channels listed successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | How many notification channels to skip.
    #' limit <- 100 # integer | At most this many notification channels to return.
    #' namePart <- 'namePart_example' # character | Only return the notification channels whose names contain the given substring.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationChannelsList(offset, limit, namePart=namePart)
    #' }
    NotificationChannelsList = function(offset, limit, namePart = NULL, ...) {
      apiResponse <- private$NotificationChannelsListWithHttpInfo(offset, limit, namePart, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update notification channel
    #' Produces: NA
    #'
    #' @details Update the notification channel.
    #' @param channelId character. The id of the notification channel.
    #' @param notificationChannelUpdate \link{NotificationChannelUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification channel updated successfully.
    #' \itemize{
    #' }
    #' \item **`400`** Email verification code is invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' channelId <- 'channelId_example' # character | The id of the notification channel.
    #' notificationChannelUpdate <- NotificationChannelUpdate$new() # NotificationChannelUpdate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationChannelsPut(channelId, notificationChannelUpdate=notificationChannelUpdate)
    #' }
    NotificationChannelsPut = function(channelId, notificationChannelUpdate = NULL, ...) {
      apiResponse <- private$NotificationChannelsPutWithHttpInfo(channelId, notificationChannelUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve notification channel
    #' Produces: "application/json"
    #'
    #' @details Retrieve the notification channel.
    #' @param channelId character. The id of the notification channel.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationChannelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Notification channel retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' channelId <- 'channelId_example' # character | The id of the notification channel.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationChannelsRetrieve(channelId)
    #' }
    NotificationChannelsRetrieve = function(channelId, ...) {
      apiResponse <- private$NotificationChannelsRetrieveWithHttpInfo(channelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Sending a 6 digit verification code to user&#39;s email
    #' Produces: "application/json"
    #'
    #' @details Sending a 6 digit verification code to user&#39;s email
    #' @param notificationEmailChannelVerification \link{NotificationEmailChannelVerification}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationEmailChannelVerificationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationEmailChannelVerification <- NotificationEmailChannelVerification$new() # NotificationEmailChannelVerification |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationEmailChannelVerificationCreate(notificationEmailChannelVerification=notificationEmailChannelVerification)
    #' }
    NotificationEmailChannelVerificationCreate = function(notificationEmailChannelVerification = NULL, ...) {
      apiResponse <- private$NotificationEmailChannelVerificationCreateWithHttpInfo(notificationEmailChannelVerification, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the status of whether admin enter code correctly
    #' Produces: "application/json"
    #'
    #' @details Retrieve the status of whether admin enter code correctly
    #' @param notificationEmailChannelVerificationStatus \link{NotificationEmailChannelVerificationStatus}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationEmailChannelVerificationStatusResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationEmailChannelVerificationStatus <- NotificationEmailChannelVerificationStatus$new() # NotificationEmailChannelVerificationStatus |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationEmailChannelVerificationStatusCreate(notificationEmailChannelVerificationStatus=notificationEmailChannelVerificationStatus)
    #' }
    NotificationEmailChannelVerificationStatusCreate = function(notificationEmailChannelVerificationStatus = NULL, ...) {
      apiResponse <- private$NotificationEmailChannelVerificationStatusCreateWithHttpInfo(notificationEmailChannelVerificationStatus, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List event types and groups the user can include in notification policies.
    #' Produces: "application/json"
    #'
    #' @details List event types and groups the user can include in notification policies. Events and groups are filtered by user permissions and event properties. It is not a complete list of all defined events; instead, it is a list of the events available to the user.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationEventListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Event types and groups selectable for notification policies
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationEventsList()
    #' }
    NotificationEventsList = function(...) {
      apiResponse <- private$NotificationEventsListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the notification logs
    #' Produces: "application/json"
    #'
    #' @details List the notification logs that correspond to provided conditions. Default ordering is desc by notification log timestamp
    #' @param offset integer. The number of records to skip over. Default 0
    #' @param limit integer. The number of records to return. Default to 100, minimum to 1, maximum to 1000
    #' @param policyId character. The id of the policy to filter notification logs
    #' @param channelId character. The id of the channel to filter notification logs
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationLogListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of records to skip over. Default 0
    #' limit <- 100 # integer | The number of records to return. Default to 100, minimum to 1, maximum to 1000
    #' policyId <- 'policyId_example' # character | The id of the policy to filter notification logs
    #' channelId <- 'channelId_example' # character | The id of the channel to filter notification logs
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationLogsList(offset, limit, policyId=policyId, channelId=channelId)
    #' }
    NotificationLogsList = function(offset, limit, policyId = NULL, channelId = NULL, ...) {
      apiResponse <- private$NotificationLogsListWithHttpInfo(offset, limit, policyId, channelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create notification policy
    #' Produces: "application/json"
    #'
    #' @details Create a new notification policy.
    #' @param notificationPolicyCreate \link{NotificationPolicyCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationPolicyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Notification policy created successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationPolicyCreate <- NotificationPolicyCreate$new() # NotificationPolicyCreate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPoliciesCreate(notificationPolicyCreate=notificationPolicyCreate)
    #' }
    NotificationPoliciesCreate = function(notificationPolicyCreate = NULL, ...) {
      apiResponse <- private$NotificationPoliciesCreateWithHttpInfo(notificationPolicyCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete notification policy
    #' Produces: NA
    #'
    #' @details Delete the notification policy.
    #' @param policyId character. The id of the notification policy
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification policy deleted successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' policyId <- 'policyId_example' # character | The id of the notification policy
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPoliciesDelete(policyId)
    #' }
    NotificationPoliciesDelete = function(policyId, ...) {
      apiResponse <- private$NotificationPoliciesDeleteWithHttpInfo(policyId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List notification policies
    #' Produces: "application/json"
    #'
    #' @details List the notification policies that satisfy the query condition.
    #' @param offset integer. How many notification channels to skip.
    #' @param limit integer. At most this many notification channels to return.
    #' @param channelId character. Return policies with this channel.
    #' @param namePart character. Only return the notification channels whose names contain the given substring.
    #' @param eventGroup Enum < [base, applications.all, batch_predictions.all, change_requests.all, comment.all, dataset.all, model_deployments.critical_health, model_deployments.health, model_deployments.management_agent, model_deployments.management_agent_health, prediction_request.all, model_deployments.all, project.all, monitoring.all, perma_delete_project.all, remote.all, users_delete.all] > Return policies with this event group.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationPoliciesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Notification policies listed successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | How many notification channels to skip.
    #' limit <- 100 # integer | At most this many notification channels to return.
    #' channelId <- 'channelId_example' # character | Return policies with this channel.
    #' namePart <- 'namePart_example' # character | Only return the notification channels whose names contain the given substring.
    #' eventGroup <- 'eventGroup_example' # character | Return policies with this event group.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPoliciesList(offset, limit, channelId=channelId, namePart=namePart, eventGroup=eventGroup)
    #' }
    NotificationPoliciesList = function(offset, limit, channelId = NULL, namePart = NULL, eventGroup = NULL, ...) {
      apiResponse <- private$NotificationPoliciesListWithHttpInfo(offset, limit, channelId, namePart, eventGroup, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update notification policy
    #' Produces: NA
    #'
    #' @details Update the notification policy.
    #' @param policyId character. The id of the notification policy
    #' @param notificationPolicyUpdate \link{NotificationPolicyUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification policy updated successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' policyId <- 'policyId_example' # character | The id of the notification policy
    #' notificationPolicyUpdate <- NotificationPolicyUpdate$new() # NotificationPolicyUpdate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPoliciesPut(policyId, notificationPolicyUpdate=notificationPolicyUpdate)
    #' }
    NotificationPoliciesPut = function(policyId, notificationPolicyUpdate = NULL, ...) {
      apiResponse <- private$NotificationPoliciesPutWithHttpInfo(policyId, notificationPolicyUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve notification policy
    #' Produces: "application/json"
    #'
    #' @details Retrieve the notification policy.
    #' @param policyId character. The id of the notification policy
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationPolicyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Notification policy retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' policyId <- 'policyId_example' # character | The id of the notification policy
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPoliciesRetrieve(policyId)
    #' }
    NotificationPoliciesRetrieve = function(policyId, ...) {
      apiResponse <- private$NotificationPoliciesRetrieveWithHttpInfo(policyId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new ignored notification
    #' Produces: "application/json"
    #'
    #' @details Create a new ignored notification
    #' @param notificationPolicyMuteCreate \link{NotificationPolicyMuteCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationPolicyMuteResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationPolicyMuteCreate <- NotificationPolicyMuteCreate$new() # NotificationPolicyMuteCreate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPolicyMutesCreate(notificationPolicyMuteCreate=notificationPolicyMuteCreate)
    #' }
    NotificationPolicyMutesCreate = function(notificationPolicyMuteCreate = NULL, ...) {
      apiResponse <- private$NotificationPolicyMutesCreateWithHttpInfo(notificationPolicyMuteCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete the existing notification policy mute
    #' Produces: NA
    #'
    #' @details Delete the existing notification policy mute
    #' @param muteId character. The id of the notification policy mute to delete
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' muteId <- 'muteId_example' # character | The id of the notification policy mute to delete
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPolicyMutesDelete(muteId)
    #' }
    NotificationPolicyMutesDelete = function(muteId, ...) {
      apiResponse <- private$NotificationPolicyMutesDeleteWithHttpInfo(muteId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the ignored notifications filtered by orgId if provided
    #' Produces: "application/json"
    #'
    #' @details List the ignored notifications filtered by orgId if provided
    #' @param offset integer. The number of records to skip over. Default 0
    #' @param limit integer. The number of records to return. Default to 100, minimum to 1, maximum to 1000
    #' @param entityId character. The id of the entity to filter
    #' @param orgId character. The id of the organization that ignored notifications relate to
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationPolicyMuteListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of records to skip over. Default 0
    #' limit <- 100 # integer | The number of records to return. Default to 100, minimum to 1, maximum to 1000
    #' entityId <- 'entityId_example' # character | The id of the entity to filter
    #' orgId <- 'orgId_example' # character | The id of the organization that ignored notifications relate to
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationPolicyMutesList(offset, limit, entityId=entityId, orgId=orgId)
    #' }
    NotificationPolicyMutesList = function(offset, limit, entityId = NULL, orgId = NULL, ...) {
      apiResponse <- private$NotificationPolicyMutesListWithHttpInfo(offset, limit, entityId, orgId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Test webhook notification channel
    #' Produces: "application/json"
    #'
    #' @details Test the webhook notification channel.
    #' @param notificationWebhookChannelTestCreate \link{NotificationWebhookChannelTestCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationWebhookChannelTestId}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** The test for the webhook notification channel was created.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationWebhookChannelTestCreate <- NotificationWebhookChannelTestCreate$new() # NotificationWebhookChannelTestCreate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationWebhookChannelTestsCreate(notificationWebhookChannelTestCreate=notificationWebhookChannelTestCreate)
    #' }
    NotificationWebhookChannelTestsCreate = function(notificationWebhookChannelTestCreate = NULL, ...) {
      apiResponse <- private$NotificationWebhookChannelTestsCreateWithHttpInfo(notificationWebhookChannelTestCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve status of notification channel test
    #' Produces: "application/json"
    #'
    #' @details Retrieve the status of the notification channel test.
    #' @param notificationId character. The identifier of the notification.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NotificationWebhookChannelStatusResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The notification status was retrieved.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationId <- 'notificationId_example' # character | The identifier of the notification.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationWebhookChannelTestsRetrieve(notificationId)
    #' }
    NotificationWebhookChannelTestsRetrieve = function(notificationId, ...) {
      apiResponse <- private$NotificationWebhookChannelTestsRetrieveWithHttpInfo(notificationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Resends the notification
    #' Produces: NA
    #'
    #' @details Resends the notification
    #' @param notificationResend \link{NotificationResend}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' notificationResend <- NotificationResend$new() # NotificationResend |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$NotificationsCreate(notificationResend=notificationResend)
    #' }
    NotificationsCreate = function(notificationResend = NULL, ...) {
      apiResponse <- private$NotificationsCreateWithHttpInfo(notificationResend, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Post a remote deployment event
    #' Produces: "application/json"
    #'
    #' @details Post an event from a remote deployment.
    #' @param remoteEventCreate \link{RemoteEventCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreateRemoteEventResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** The event was created.
    #' \itemize{
    #' }
    #' \item **`404`** The deployment was not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request instructions or failed to post the event.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' remoteEventCreate <- RemoteEventCreate$new() # RemoteEventCreate |
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$RemoteEventsCreate(remoteEventCreate=remoteEventCreate)
    #' }
    RemoteEventsCreate = function(remoteEventCreate = NULL, ...) {
      apiResponse <- private$RemoteEventsCreateWithHttpInfo(remoteEventCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete user notification
    #' Produces: NA
    #'
    #' @details Delete one notification associated with the user.
    #' @param userNotificationId character. Unique identifier of the notification.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification was deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userNotificationId <- 'userNotificationId_example' # character | Unique identifier of the notification.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$UserNotificationsDelete(userNotificationId)
    #' }
    UserNotificationsDelete = function(userNotificationId, ...) {
      apiResponse <- private$UserNotificationsDeleteWithHttpInfo(userNotificationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete all user notifications
    #' Produces: NA
    #'
    #' @details Delete all notifications associated with the user.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notifications were deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$UserNotificationsDeleteMany()
    #' }
    UserNotificationsDeleteMany = function(...) {
      apiResponse <- private$UserNotificationsDeleteManyWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List user notifications
    #' Produces: "application/json"
    #'
    #' @details Returns list of user&#39;s notifications from latest to oldest.
    #' @param offset integer. The number of records to skip over
    #' @param limit integer. The number of records to return
    #' @param isRead character. When provided, returns only read or unread notifications
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserNotificationListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of notifications.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of records to skip over
    #' limit <- 100 # integer | The number of records to return
    #' isRead <- 'isRead_example' # character | When provided, returns only read or unread notifications
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$UserNotificationsList(offset=offset, limit=limit, isRead=isRead)
    #' }
    UserNotificationsList = function(offset = 0, limit = 100, isRead = NULL, ...) {
      apiResponse <- private$UserNotificationsListWithHttpInfo(offset, limit, isRead, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Mark as read
    #' Produces: NA
    #'
    #' @details Mark one associated notification with the user as read.
    #' @param userNotificationId character. Unique identifier of the notification.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Notification was marked as read.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userNotificationId <- 'userNotificationId_example' # character | Unique identifier of the notification.
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$UserNotificationsPatch(userNotificationId)
    #' }
    UserNotificationsPatch = function(userNotificationId, ...) {
      apiResponse <- private$UserNotificationsPatchWithHttpInfo(userNotificationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Mark all as read
    #' Produces: NA
    #'
    #' @details Mark all associated notifications with the user as read.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** All notification were marked as read.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- NotificationsApi$new()
    #' result <- api.instance$UserNotificationsPatchMany()
    #' }
    UserNotificationsPatchMany = function(...) {
      apiResponse <- private$UserNotificationsPatchManyWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `NotificationChannelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationChannelsCreateWithHttpInfo = function(notificationChannelCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationChannelCreate`) && isa(notificationChannelCreate, c("NotificationChannelCreate", "R6"))) {
        body <- `notificationChannelCreate`$toJSON()
      } else {
        stop("NotificationChannelsCreateWithHttpInfo requires parameter notificationChannelCreate to be of type NotificationChannelCreate.")
      }

      urlPath <- "/notificationChannels/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationChannelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationChannelsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationChannelsDeleteWithHttpInfo = function(channelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`channelId`)) {
        stop("Missing required parameter `channelId`.")
      }

      body <- NULL
      urlPath <- "/notificationChannels/{channelId}/"
      if (!missing(`channelId`)) {
        urlPath <- gsub(paste0("\\{", "channelId", "\\}"), URLencode(as.character(`channelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationChannelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationChannelsListWithHttpInfo = function(offset, limit, namePart = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["namePart"] <- namePart

      body <- NULL
      urlPath <- "/notificationChannels/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationChannelsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationChannelsPut`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationChannelsPutWithHttpInfo = function(channelId, notificationChannelUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`channelId`)) {
        stop("Missing required parameter `channelId`.")
      }

      if (!missing(`notificationChannelUpdate`) && isa(notificationChannelUpdate, c("NotificationChannelUpdate", "R6"))) {
        body <- `notificationChannelUpdate`$toJSON()
      } else {
        stop("NotificationChannelsPutWithHttpInfo requires parameter notificationChannelUpdate to be of type NotificationChannelUpdate.")
      }

      urlPath <- "/notificationChannels/{channelId}/"
      if (!missing(`channelId`)) {
        urlPath <- gsub(paste0("\\{", "channelId", "\\}"), URLencode(as.character(`channelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationChannelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationChannelsRetrieveWithHttpInfo = function(channelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`channelId`)) {
        stop("Missing required parameter `channelId`.")
      }

      body <- NULL
      urlPath <- "/notificationChannels/{channelId}/"
      if (!missing(`channelId`)) {
        urlPath <- gsub(paste0("\\{", "channelId", "\\}"), URLencode(as.character(`channelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationChannelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationEmailChannelVerificationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationEmailChannelVerificationCreateWithHttpInfo = function(notificationEmailChannelVerification = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationEmailChannelVerification`) && isa(notificationEmailChannelVerification, c("NotificationEmailChannelVerification", "R6"))) {
        body <- `notificationEmailChannelVerification`$toJSON()
      } else {
        stop("NotificationEmailChannelVerificationCreateWithHttpInfo requires parameter notificationEmailChannelVerification to be of type NotificationEmailChannelVerification.")
      }

      urlPath <- "/notificationEmailChannelVerification/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationEmailChannelVerificationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationEmailChannelVerificationStatusCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationEmailChannelVerificationStatusCreateWithHttpInfo = function(notificationEmailChannelVerificationStatus = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationEmailChannelVerificationStatus`) && isa(notificationEmailChannelVerificationStatus, c("NotificationEmailChannelVerificationStatus", "R6"))) {
        body <- `notificationEmailChannelVerificationStatus`$toJSON()
      } else {
        stop("NotificationEmailChannelVerificationStatusCreateWithHttpInfo requires parameter notificationEmailChannelVerificationStatus to be of type NotificationEmailChannelVerificationStatus.")
      }

      urlPath <- "/notificationEmailChannelVerificationStatus/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationEmailChannelVerificationStatusResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationEventsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationEventsListWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/notificationEvents/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationEventListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationLogsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationLogsListWithHttpInfo = function(offset, limit, policyId = NULL, channelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["policyId"] <- policyId

      queryParams["channelId"] <- channelId

      body <- NULL
      urlPath <- "/notificationLogs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationLogListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPoliciesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPoliciesCreateWithHttpInfo = function(notificationPolicyCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationPolicyCreate`) && isa(notificationPolicyCreate, c("NotificationPolicyCreate", "R6"))) {
        body <- `notificationPolicyCreate`$toJSON()
      } else {
        stop("NotificationPoliciesCreateWithHttpInfo requires parameter notificationPolicyCreate to be of type NotificationPolicyCreate.")
      }

      urlPath <- "/notificationPolicies/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationPolicyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPoliciesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPoliciesDeleteWithHttpInfo = function(policyId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`policyId`)) {
        stop("Missing required parameter `policyId`.")
      }

      body <- NULL
      urlPath <- "/notificationPolicies/{policyId}/"
      if (!missing(`policyId`)) {
        urlPath <- gsub(paste0("\\{", "policyId", "\\}"), URLencode(as.character(`policyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPoliciesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPoliciesListWithHttpInfo = function(offset, limit, channelId = NULL, namePart = NULL, eventGroup = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["channelId"] <- channelId

      queryParams["namePart"] <- namePart

      queryParams["eventGroup"] <- eventGroup

      body <- NULL
      urlPath <- "/notificationPolicies/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationPoliciesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPoliciesPut`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPoliciesPutWithHttpInfo = function(policyId, notificationPolicyUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`policyId`)) {
        stop("Missing required parameter `policyId`.")
      }

      if (!missing(`notificationPolicyUpdate`) && isa(notificationPolicyUpdate, c("NotificationPolicyUpdate", "R6"))) {
        body <- `notificationPolicyUpdate`$toJSON()
      } else {
        stop("NotificationPoliciesPutWithHttpInfo requires parameter notificationPolicyUpdate to be of type NotificationPolicyUpdate.")
      }

      urlPath <- "/notificationPolicies/{policyId}/"
      if (!missing(`policyId`)) {
        urlPath <- gsub(paste0("\\{", "policyId", "\\}"), URLencode(as.character(`policyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPoliciesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPoliciesRetrieveWithHttpInfo = function(policyId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`policyId`)) {
        stop("Missing required parameter `policyId`.")
      }

      body <- NULL
      urlPath <- "/notificationPolicies/{policyId}/"
      if (!missing(`policyId`)) {
        urlPath <- gsub(paste0("\\{", "policyId", "\\}"), URLencode(as.character(`policyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationPolicyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPolicyMutesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPolicyMutesCreateWithHttpInfo = function(notificationPolicyMuteCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationPolicyMuteCreate`) && isa(notificationPolicyMuteCreate, c("NotificationPolicyMuteCreate", "R6"))) {
        body <- `notificationPolicyMuteCreate`$toJSON()
      } else {
        stop("NotificationPolicyMutesCreateWithHttpInfo requires parameter notificationPolicyMuteCreate to be of type NotificationPolicyMuteCreate.")
      }

      urlPath <- "/notificationPolicyMutes/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationPolicyMuteResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPolicyMutesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPolicyMutesDeleteWithHttpInfo = function(muteId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`muteId`)) {
        stop("Missing required parameter `muteId`.")
      }

      body <- NULL
      urlPath <- "/notificationPolicyMutes/{muteId}/"
      if (!missing(`muteId`)) {
        urlPath <- gsub(paste0("\\{", "muteId", "\\}"), URLencode(as.character(`muteId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationPolicyMutesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationPolicyMutesListWithHttpInfo = function(offset, limit, entityId = NULL, orgId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["entityId"] <- entityId

      queryParams["orgId"] <- orgId

      body <- NULL
      urlPath <- "/notificationPolicyMutes/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationPolicyMuteListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationWebhookChannelTestsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationWebhookChannelTestsCreateWithHttpInfo = function(notificationWebhookChannelTestCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationWebhookChannelTestCreate`) && isa(notificationWebhookChannelTestCreate, c("NotificationWebhookChannelTestCreate", "R6"))) {
        body <- `notificationWebhookChannelTestCreate`$toJSON()
      } else {
        stop("NotificationWebhookChannelTestsCreateWithHttpInfo requires parameter notificationWebhookChannelTestCreate to be of type NotificationWebhookChannelTestCreate.")
      }

      urlPath <- "/notificationWebhookChannelTests/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationWebhookChannelTestId", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationWebhookChannelTestsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationWebhookChannelTestsRetrieveWithHttpInfo = function(notificationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`notificationId`)) {
        stop("Missing required parameter `notificationId`.")
      }

      body <- NULL
      urlPath <- "/notificationWebhookChannelTests/{notificationId}/"
      if (!missing(`notificationId`)) {
        urlPath <- gsub(paste0("\\{", "notificationId", "\\}"), URLencode(as.character(`notificationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NotificationWebhookChannelStatusResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `NotificationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    NotificationsCreateWithHttpInfo = function(notificationResend = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`notificationResend`) && isa(notificationResend, c("NotificationResend", "R6"))) {
        body <- `notificationResend`$toJSON()
      } else {
        stop("NotificationsCreateWithHttpInfo requires parameter notificationResend to be of type NotificationResend.")
      }

      urlPath <- "/notifications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RemoteEventsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RemoteEventsCreateWithHttpInfo = function(remoteEventCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`remoteEventCreate`) && isa(remoteEventCreate, c("RemoteEventCreate", "R6"))) {
        body <- `remoteEventCreate`$toJSON()
      } else {
        stop("RemoteEventsCreateWithHttpInfo requires parameter remoteEventCreate to be of type RemoteEventCreate.")
      }

      urlPath <- "/remoteEvents/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreateRemoteEventResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserNotificationsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserNotificationsDeleteWithHttpInfo = function(userNotificationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userNotificationId`)) {
        stop("Missing required parameter `userNotificationId`.")
      }

      body <- NULL
      urlPath <- "/userNotifications/{userNotificationId}/"
      if (!missing(`userNotificationId`)) {
        urlPath <- gsub(paste0("\\{", "userNotificationId", "\\}"), URLencode(as.character(`userNotificationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserNotificationsDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserNotificationsDeleteManyWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/userNotifications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserNotificationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserNotificationsListWithHttpInfo = function(offset = 0, limit = 100, isRead = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["isRead"] <- isRead

      body <- NULL
      urlPath <- "/userNotifications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserNotificationListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserNotificationsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserNotificationsPatchWithHttpInfo = function(userNotificationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userNotificationId`)) {
        stop("Missing required parameter `userNotificationId`.")
      }

      body <- NULL
      urlPath <- "/userNotifications/{userNotificationId}/"
      if (!missing(`userNotificationId`)) {
        urlPath <- gsub(paste0("\\{", "userNotificationId", "\\}"), URLencode(as.character(`userNotificationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserNotificationsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserNotificationsPatchManyWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/userNotifications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
