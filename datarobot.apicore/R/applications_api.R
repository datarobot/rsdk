# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Applications operations
#' @description datarobot.apicore.Applications
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
ApplicationsApi <- R6::R6Class(
  "ApplicationsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description List of available application types to deploy.
    #' Produces: "application/json"
    #'
    #' @details List of available application types to deploy.
    #' @param offset integer. The number of records to skip over. Defaults to 0.
    #' @param limit integer. The number of records to return. Defaults to 0, meaning all records.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationTypeListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of records to skip over. Defaults to 0.
    #' limit <- 0 # integer | The number of records to return. Defaults to 0, meaning all records.
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationTypesList(offset, limit)
    #' }
    ApplicationTypesList = function(offset, limit, ...) {
      apiResponse <- private$ApplicationTypesListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve one application type
    #' Produces: "application/json"
    #'
    #' @details Retrieve one application type
    #' @param applicationTypeId character. The application type to retrieve
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationTypeRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** No app type matching the specified identifier found or user does not have permissions to access to this app type
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationTypeId <- 'applicationTypeId_example' # character | The application type to retrieve
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationTypesRetrieve(applicationTypeId)
    #' }
    ApplicationTypesRetrieve = function(applicationTypeId, ...) {
      apiResponse <- private$ApplicationTypesRetrieveWithHttpInfo(applicationTypeId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List application type usecases
    #' Produces: "application/json"
    #'
    #' @details List of available usecases for application type.
    #' @param offset integer. The number of records to skip over. Defaults to 0.
    #' @param limit integer. The number of records to return. Defaults to 100.
    #' @param applicationTypeId character. The application type to retrieve
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationTypeUsecasesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of records to skip over. Defaults to 0.
    #' limit <- 100 # integer | The number of records to return. Defaults to 100.
    #' applicationTypeId <- 'applicationTypeId_example' # character | The application type to retrieve
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationTypesUsecasesList(offset, limit, applicationTypeId)
    #' }
    ApplicationTypesUsecasesList = function(offset, limit, applicationTypeId, ...) {
      apiResponse <- private$ApplicationTypesUsecasesListWithHttpInfo(offset, limit, applicationTypeId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get application user role
    #' Produces: "application/json"
    #'
    #' @details Get application user role
    #' @param applicationId character. The ID of the application
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationUserRoleResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** user&#39;s role on application entity, taking into account RBAC, groups and organization.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationUserRoleRetrieve(applicationId)
    #' }
    ApplicationUserRoleRetrieve = function(applicationId, ...) {
      apiResponse <- private$ApplicationUserRoleRetrieveWithHttpInfo(applicationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description A list of users with access to this application
    #' Produces: "application/json"
    #'
    #' @details A list of users who have access to this application and their roles
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param applicationId character. The ID of the application
    #' @param username character. Optional, only return the access control information for a user with this username.
    #' @param userId character. Optional, only return the access control information for a user with this user ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationAccessControlList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`400`** Bad Request, both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Entity not found. Either the application does not exist or the user does not have permissions to view the application.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' username <- 'username_example' # character | Optional, only return the access control information for a user with this username.
    #' userId <- 'userId_example' # character | Optional, only return the access control information for a user with this user ID.
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsAccessControlList(offset, limit, applicationId, username=username, userId=userId)
    #' }
    ApplicationsAccessControlList = function(offset, limit, applicationId, username = NULL, userId = NULL, ...) {
      apiResponse <- private$ApplicationsAccessControlListWithHttpInfo(offset, limit, applicationId, username, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update access control for this application.
    #' Produces: NA
    #'
    #' @details Update access control for this application. Request is processed only if updates can be performed on all entries.
    #' @param applicationId character. The ID of the application
    #' @param applicationAccessControlUpdateRequest \link{ApplicationAccessControlUpdateRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have appropriate privileges
    #' \itemize{
    #' }
    #' \item **`404`** Invalid applicationId provided or invalid username provided to modify access for
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationAccessControlUpdateRequest <- ApplicationAccessControlUpdateRequest$new() # ApplicationAccessControlUpdateRequest |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsAccessControlPatchMany(applicationId, applicationAccessControlUpdateRequest=applicationAccessControlUpdateRequest)
    #' }
    ApplicationsAccessControlPatchMany = function(applicationId, applicationAccessControlUpdateRequest = NULL, ...) {
      apiResponse <- private$ApplicationsAccessControlPatchManyWithHttpInfo(applicationId, applicationAccessControlUpdateRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Redeploys application with refreshed auth token.
    #' Produces: NA
    #'
    #' @details Redeploys application with refreshed auth token.
    #' @param applicationId character. The ID of the application
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** App is not deployed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsAuthTokenPatchMany(applicationId)
    #' }
    ApplicationsAuthTokenPatchMany = function(applicationId, ...) {
      apiResponse <- private$ApplicationsAuthTokenPatchManyWithHttpInfo(applicationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Schedules a build job
    #' Produces: NA
    #'
    #' @details Schedules a build job, which is normally automatically scheduled at the end of DataRobot autopilot. This is currently used in tests only, so this route is for internal use only.
    #' @param applicationId character. The ID of the application
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** The job has been added to the queue. See the Location header.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' body <- NULL # object |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsBuildJobsCreate(applicationId, body=body)
    #' }
    ApplicationsBuildJobsCreate = function(applicationId, body = NULL, ...) {
      apiResponse <- private$ApplicationsBuildJobsCreateWithHttpInfo(applicationId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create an application
    #' Produces: "application/json"
    #'
    #' @details Create an application. Note that the number of active applications users can have at the same time is limited.
    #' @param applicationCreate \link{ApplicationCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to launch application of provided type.
    #' \itemize{
    #' }
    #' \item **`404`** No app type matching the specified identifier found or user does not have permissions to access to this app type.
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationCreate <- ApplicationCreate$new() # ApplicationCreate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsCreate(applicationCreate=applicationCreate)
    #' }
    ApplicationsCreate = function(applicationCreate = NULL, ...) {
      apiResponse <- private$ApplicationsCreateWithHttpInfo(applicationCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete an application
    #' Produces: NA
    #'
    #' @details Delete an application
    #' @param applicationId character. The ID of the application
    #' @param applicationParam \link{ApplicationParam}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The application has been deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationParam <- ApplicationParam$new() # ApplicationParam |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDelete(applicationId, applicationParam=applicationParam)
    #' }
    ApplicationsDelete = function(applicationId, applicationParam = NULL, ...) {
      apiResponse <- private$ApplicationsDeleteWithHttpInfo(applicationId, applicationParam, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the application&#39;s deployment state.
    #' Produces: NA
    #'
    #' @details Update the application&#39;s deployment state. Transitioning the app to &#x60;deactivated&#x60; state will keep the app record in the database, but the app will not be accessible at its URL until changed back to &#x60;deployed&#x60; state again. When the limit of active apps has been reached, this API can be used to deactivate some applications to make space for new ones.
    #' @param applicationId character. The ID of the application
    #' @param applicationDeploymentStateUpdate \link{ApplicationDeploymentStateUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationDeploymentStateUpdate <- ApplicationDeploymentStateUpdate$new() # ApplicationDeploymentStateUpdate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDeploymentStatePatchMany(applicationId, applicationDeploymentStateUpdate=applicationDeploymentStateUpdate)
    #' }
    ApplicationsDeploymentStatePatchMany = function(applicationId, applicationDeploymentStateUpdate = NULL, ...) {
      apiResponse <- private$ApplicationsDeploymentStatePatchManyWithHttpInfo(applicationId, applicationDeploymentStateUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Links a deployment to an application
    #' Produces: NA
    #'
    #' @details If application creates deployment during its lifetime, we want to have an API to link deployment with application.
    #' @param applicationId character. The ID of the application
    #' @param addDeploymentToApplication \link{AddDeploymentToApplication}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' addDeploymentToApplication <- AddDeploymentToApplication$new() # AddDeploymentToApplication |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDeploymentsCreate(applicationId, addDeploymentToApplication=addDeploymentToApplication)
    #' }
    ApplicationsDeploymentsCreate = function(applicationId, addDeploymentToApplication = NULL, ...) {
      apiResponse <- private$ApplicationsDeploymentsCreateWithHttpInfo(applicationId, addDeploymentToApplication, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete link between application and deployment.
    #' Produces: NA
    #'
    #' @details Delete link between application and deployment.
    #' @param applicationId character. The ID of the application
    #' @param modelDeploymentId character. The ID of the model deployment
    #' @param applicationModelDeploymentParam \link{ApplicationModelDeploymentParam}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The link has been deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' modelDeploymentId <- 'modelDeploymentId_example' # character | The ID of the model deployment
    #' applicationModelDeploymentParam <- ApplicationModelDeploymentParam$new() # ApplicationModelDeploymentParam |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDeploymentsDelete(applicationId, modelDeploymentId, applicationModelDeploymentParam=applicationModelDeploymentParam)
    #' }
    ApplicationsDeploymentsDelete = function(applicationId, modelDeploymentId, applicationModelDeploymentParam = NULL, ...) {
      apiResponse <- private$ApplicationsDeploymentsDeleteWithHttpInfo(applicationId, modelDeploymentId, applicationModelDeploymentParam, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a duplicate of the application
    #' Produces: "application/json"
    #'
    #' @details Create a copy of App Builder application. Note that the number of active applications users can have at the same time is limited.
    #' @param applicationId character. The ID of the application
    #' @param applicationDuplicate \link{ApplicationDuplicate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** Dulication has successfully started. See the Location header.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to launch application of provided type.
    #' \itemize{
    #' }
    #' \item **`404`** App for duplication was not found
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationDuplicate <- ApplicationDuplicate$new() # ApplicationDuplicate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDuplicateCreate(applicationId, applicationDuplicate=applicationDuplicate)
    #' }
    ApplicationsDuplicateCreate = function(applicationId, applicationDuplicate = NULL, ...) {
      apiResponse <- private$ApplicationsDuplicateCreateWithHttpInfo(applicationId, applicationDuplicate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Paginated list of applications created by the currently authenticated user.
    #' Produces: "application/json"
    #'
    #' @details Paginated list of applications created by the currently authenticated user.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsList(offset, limit)
    #' }
    ApplicationsList = function(offset, limit, ...) {
      apiResponse <- private$ApplicationsListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update an application&#39;s name and/or domain prefix
    #' Produces: NA
    #'
    #' @details Update an application&#39;s name and/or domain prefix
    #' @param applicationId character. The ID of the application
    #' @param applicationDeploymentUpdate \link{ApplicationDeploymentUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The application has been updated.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationDeploymentUpdate <- ApplicationDeploymentUpdate$new() # ApplicationDeploymentUpdate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsPatch(applicationId, applicationDeploymentUpdate=applicationDeploymentUpdate)
    #' }
    ApplicationsPatch = function(applicationId, applicationDeploymentUpdate = NULL, ...) {
      apiResponse <- private$ApplicationsPatchWithHttpInfo(applicationId, applicationDeploymentUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve an application
    #' Produces: "application/json"
    #'
    #' @details Retrieve an application
    #' @param applicationId character. The ID of the application
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsRetrieve(applicationId)
    #' }
    ApplicationsRetrieve = function(applicationId, ...) {
      apiResponse <- private$ApplicationsRetrieveWithHttpInfo(applicationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users, groups and organizations that have an access to this application
    #' Produces: NA
    #'
    #' @details Get a list of users, groups and organizations that have an access to this application
    #' @param applicationId character. The ID of the application
    #' @param limit integer. The number of records to return in the range of 1 to 100
    #' @param offset integer. The number of records to skip over. Default 0.
    #' @param name character. Only return roles for a user, group or organization with this name
    #' @param id character. Only return roles for a user, group or organization with this id
    #' @param shareRecipientType Enum < [user, group, organization] > Specify the recipient type, one of &#39;user&#39;, &#39;group&#39;, &#39;organization&#39;
    #' @param applicationSharedRolesList \link{ApplicationSharedRolesList}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' limit <- 56 # integer | The number of records to return in the range of 1 to 100
    #' offset <- 0 # integer | The number of records to skip over. Default 0.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this id
    #' shareRecipientType <- 'shareRecipientType_example' # character | Specify the recipient type, one of 'user', 'group', 'organization'
    #' applicationSharedRolesList <- ApplicationSharedRolesList$new() # ApplicationSharedRolesList |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsSharedRolesList(applicationId, limit=limit, offset=offset, name=name, id=id, shareRecipientType=shareRecipientType, applicationSharedRolesList=applicationSharedRolesList)
    #' }
    ApplicationsSharedRolesList = function(applicationId, limit = NULL, offset = 0, name = NULL, id = NULL, shareRecipientType = NULL, applicationSharedRolesList = NULL, ...) {
      apiResponse <- private$ApplicationsSharedRolesListWithHttpInfo(applicationId, limit, offset, name, id, shareRecipientType, applicationSharedRolesList, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Share an application with a user, group, or organization
    #' Produces: NA
    #'
    #' @details Share an application with a user, group, or organization
    #' @param sendNotification character. Send a notification
    #' @param note character. A note to go with the project share
    #' @param operation character. Name of the action being taken, only &#39;updateRoles&#39; is supported
    #' @param roles list( \link{ApplicationSharedRolesEntryUpdate} )
    #' @param applicationId character. The ID of the application
    #' @param applicationSharingUpdateOrRemove \link{ApplicationSharingUpdateOrRemove}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The roles updated successfully
    #' \itemize{
    #' }
    #' \item **`422`** The request was formatted improperly.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' sendNotification <- FALSE # character | Send a notification
    #' note <- 'note_example' # character | A note to go with the project share
    #' operation <- 'operation_example' # character | Name of the action being taken, only 'updateRoles' is supported
    #' roles <- [ApplicationSharedRolesEntryUpdate$new()] # array[ApplicationSharedRolesEntryUpdate] | Role objects, may contain up to 100 per request
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationSharingUpdateOrRemove <- ApplicationSharingUpdateOrRemove$new() # ApplicationSharingUpdateOrRemove |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsSharedRolesPatchMany(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove=applicationSharingUpdateOrRemove)
    #' }
    ApplicationsSharedRolesPatchMany = function(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove = NULL, ...) {
      apiResponse <- private$ApplicationsSharedRolesPatchManyWithHttpInfo(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Redeploys application with specified version.
    #' Produces: NA
    #'
    #' @details Redeploys application with specified version. If version is omitted latest available version is used.
    #' @param applicationId character. The ID of the application
    #' @param applicationUpgradeDeploymentVersion \link{ApplicationUpgradeDeploymentVersion}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationUpgradeDeploymentVersion <- ApplicationUpgradeDeploymentVersion$new() # ApplicationUpgradeDeploymentVersion |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsVersionPatchMany(applicationId, applicationUpgradeDeploymentVersion=applicationUpgradeDeploymentVersion)
    #' }
    ApplicationsVersionPatchMany = function(applicationId, applicationUpgradeDeploymentVersion = NULL, ...) {
      apiResponse <- private$ApplicationsVersionPatchManyWithHttpInfo(applicationId, applicationUpgradeDeploymentVersion, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a demo application
    #' Produces: NA
    #'
    #' @details Create a demo application. The number of active applications users can have at the same time is limited.
    #' @param demoApplication \link{DemoApplication}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' }
    #' \item **`404`** No app type matching the specified identifier found or user does not have permissions to access to this app type.
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' demoApplication <- DemoApplication$new() # DemoApplication |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$DemoApplicationsCreate(demoApplication=demoApplication)
    #' }
    DemoApplicationsCreate = function(demoApplication = NULL, ...) {
      apiResponse <- private$DemoApplicationsCreateWithHttpInfo(demoApplication, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `ApplicationTypesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationTypesListWithHttpInfo = function(offset, limit, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/applicationTypes/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationTypeListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationTypesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationTypesRetrieveWithHttpInfo = function(applicationTypeId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationTypeId`)) {
        stop("Missing required parameter `applicationTypeId`.")
      }

      body <- NULL
      urlPath <- "/applicationTypes/{applicationTypeId}/"
      if (!missing(`applicationTypeId`)) {
        urlPath <- gsub(paste0("\\{", "applicationTypeId", "\\}"), URLencode(as.character(`applicationTypeId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationTypeRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationTypesUsecasesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationTypesUsecasesListWithHttpInfo = function(offset, limit, applicationTypeId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`applicationTypeId`)) {
        stop("Missing required parameter `applicationTypeId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/applicationTypes/{applicationTypeId}/usecases/"
      if (!missing(`applicationTypeId`)) {
        urlPath <- gsub(paste0("\\{", "applicationTypeId", "\\}"), URLencode(as.character(`applicationTypeId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationTypeUsecasesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationUserRoleRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationUserRoleRetrieveWithHttpInfo = function(applicationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      body <- NULL
      urlPath <- "/applications/{applicationId}/userRole/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationUserRoleResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsAccessControlListWithHttpInfo = function(offset, limit, applicationId, username = NULL, userId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["username"] <- username

      queryParams["userId"] <- userId

      body <- NULL
      urlPath <- "/applications/{applicationId}/accessControl/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationAccessControlList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsAccessControlPatchManyWithHttpInfo = function(applicationId, applicationAccessControlUpdateRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationAccessControlUpdateRequest`) && isa(applicationAccessControlUpdateRequest, c("ApplicationAccessControlUpdateRequest", "R6"))) {
        body <- `applicationAccessControlUpdateRequest`$toJSON()
      } else {
        stop("ApplicationsAccessControlPatchManyWithHttpInfo requires parameter applicationAccessControlUpdateRequest to be of type ApplicationAccessControlUpdateRequest.")
      }

      urlPath <- "/applications/{applicationId}/accessControl/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsAuthTokenPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsAuthTokenPatchManyWithHttpInfo = function(applicationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      body <- NULL
      urlPath <- "/applications/{applicationId}/authToken/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsBuildJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsBuildJobsCreateWithHttpInfo = function(applicationId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("ApplicationsBuildJobsCreateWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/applications/{applicationId}/buildJobs/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsCreateWithHttpInfo = function(applicationCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`applicationCreate`) && isa(applicationCreate, c("ApplicationCreate", "R6"))) {
        body <- `applicationCreate`$toJSON()
      } else {
        stop("ApplicationsCreateWithHttpInfo requires parameter applicationCreate to be of type ApplicationCreate.")
      }

      urlPath <- "/applications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeleteWithHttpInfo = function(applicationId, applicationParam = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationParam`) && isa(applicationParam, c("ApplicationParam", "R6"))) {
        body <- `applicationParam`$toJSON()
      } else {
        stop("ApplicationsDeleteWithHttpInfo requires parameter applicationParam to be of type ApplicationParam.")
      }

      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDeploymentStatePatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeploymentStatePatchManyWithHttpInfo = function(applicationId, applicationDeploymentStateUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationDeploymentStateUpdate`) && isa(applicationDeploymentStateUpdate, c("ApplicationDeploymentStateUpdate", "R6"))) {
        body <- `applicationDeploymentStateUpdate`$toJSON()
      } else {
        stop("ApplicationsDeploymentStatePatchManyWithHttpInfo requires parameter applicationDeploymentStateUpdate to be of type ApplicationDeploymentStateUpdate.")
      }

      urlPath <- "/applications/{applicationId}/deploymentState/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDeploymentsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeploymentsCreateWithHttpInfo = function(applicationId, addDeploymentToApplication = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`addDeploymentToApplication`) && isa(addDeploymentToApplication, c("AddDeploymentToApplication", "R6"))) {
        body <- `addDeploymentToApplication`$toJSON()
      } else {
        stop("ApplicationsDeploymentsCreateWithHttpInfo requires parameter addDeploymentToApplication to be of type AddDeploymentToApplication.")
      }

      urlPath <- "/applications/{applicationId}/deployments/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDeploymentsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeploymentsDeleteWithHttpInfo = function(applicationId, modelDeploymentId, applicationModelDeploymentParam = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (missing(`modelDeploymentId`)) {
        stop("Missing required parameter `modelDeploymentId`.")
      }

      if (!missing(`applicationModelDeploymentParam`) && isa(applicationModelDeploymentParam, c("ApplicationModelDeploymentParam", "R6"))) {
        body <- `applicationModelDeploymentParam`$toJSON()
      } else {
        stop("ApplicationsDeploymentsDeleteWithHttpInfo requires parameter applicationModelDeploymentParam to be of type ApplicationModelDeploymentParam.")
      }

      urlPath <- "/applications/{applicationId}/deployments/{modelDeploymentId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelDeploymentId`)) {
        urlPath <- gsub(paste0("\\{", "modelDeploymentId", "\\}"), URLencode(as.character(`modelDeploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDuplicateCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDuplicateCreateWithHttpInfo = function(applicationId, applicationDuplicate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationDuplicate`) && isa(applicationDuplicate, c("ApplicationDuplicate", "R6"))) {
        body <- `applicationDuplicate`$toJSON()
      } else {
        stop("ApplicationsDuplicateCreateWithHttpInfo requires parameter applicationDuplicate to be of type ApplicationDuplicate.")
      }

      urlPath <- "/applications/{applicationId}/duplicate/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsListWithHttpInfo = function(offset, limit, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/applications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsPatchWithHttpInfo = function(applicationId, applicationDeploymentUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationDeploymentUpdate`) && isa(applicationDeploymentUpdate, c("ApplicationDeploymentUpdate", "R6"))) {
        body <- `applicationDeploymentUpdate`$toJSON()
      } else {
        stop("ApplicationsPatchWithHttpInfo requires parameter applicationDeploymentUpdate to be of type ApplicationDeploymentUpdate.")
      }

      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsRetrieveWithHttpInfo = function(applicationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      body <- NULL
      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsSharedRolesListWithHttpInfo = function(applicationId, limit = NULL, offset = 0, name = NULL, id = NULL, shareRecipientType = NULL, applicationSharedRolesList = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["name"] <- name

      queryParams["id"] <- id

      queryParams["shareRecipientType"] <- shareRecipientType

      if (!missing(`applicationSharedRolesList`) && isa(applicationSharedRolesList, c("ApplicationSharedRolesList", "R6"))) {
        body <- `applicationSharedRolesList`$toJSON()
      } else {
        stop("ApplicationsSharedRolesListWithHttpInfo requires parameter applicationSharedRolesList to be of type ApplicationSharedRolesList.")
      }

      urlPath <- "/applications/{applicationId}/sharedRoles/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsSharedRolesPatchManyWithHttpInfo = function(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sendNotification`)) {
        stop("Missing required parameter `sendNotification`.")
      }

      if (missing(`note`)) {
        stop("Missing required parameter `note`.")
      }

      if (missing(`operation`)) {
        stop("Missing required parameter `operation`.")
      }

      if (missing(`roles`)) {
        stop("Missing required parameter `roles`.")
      }

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["sendNotification"] <- sendNotification

      queryParams["note"] <- note

      queryParams["operation"] <- operation

      queryParams["roles"] <- roles

      if (!missing(`applicationSharingUpdateOrRemove`) && isa(applicationSharingUpdateOrRemove, c("ApplicationSharingUpdateOrRemove", "R6"))) {
        body <- `applicationSharingUpdateOrRemove`$toJSON()
      } else {
        stop("ApplicationsSharedRolesPatchManyWithHttpInfo requires parameter applicationSharingUpdateOrRemove to be of type ApplicationSharingUpdateOrRemove.")
      }

      urlPath <- "/applications/{applicationId}/sharedRoles/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsVersionPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsVersionPatchManyWithHttpInfo = function(applicationId, applicationUpgradeDeploymentVersion = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationUpgradeDeploymentVersion`) && isa(applicationUpgradeDeploymentVersion, c("ApplicationUpgradeDeploymentVersion", "R6"))) {
        body <- `applicationUpgradeDeploymentVersion`$toJSON()
      } else {
        stop("ApplicationsVersionPatchManyWithHttpInfo requires parameter applicationUpgradeDeploymentVersion to be of type ApplicationUpgradeDeploymentVersion.")
      }

      urlPath <- "/applications/{applicationId}/version/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DemoApplicationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DemoApplicationsCreateWithHttpInfo = function(demoApplication = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`demoApplication`) && isa(demoApplication, c("DemoApplication", "R6"))) {
        body <- `demoApplication`$toJSON()
      } else {
        stop("DemoApplicationsCreateWithHttpInfo requires parameter demoApplication to be of type DemoApplication.")
      }

      urlPath <- "/demoApplications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
