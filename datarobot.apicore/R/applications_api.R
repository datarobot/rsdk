# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Applications operations
#' @description datarobot.apicore.Applications
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
ApplicationsApi <- R6::R6Class(
  "ApplicationsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Get application user role
    #' Produces: "application/json"
    #'
    #' @details Get application user role
    #' @details This method invokes `GET /applications/{applicationId}/userRole/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationUserRoleResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** user&#39;s role on application entity, taking into account RBAC, groups and organization.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationUserRoleRetrieve(applicationId)
    #' }
    ApplicationUserRoleRetrieve = function(applicationId, ...) {
      apiResponse <- private$ApplicationUserRoleRetrieveWithHttpInfo(applicationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description A list of users with access to this application
    #' Produces: "application/json"
    #'
    #' @details A list of users who have access to this application and their roles
    #' @details This method invokes `GET /applications/{applicationId}/accessControl/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param applicationId character. The ID of the application
    #' @param username character. Optional, only return the access control information for a user with this username.
    #' @param userId character. Optional, only return the access control information for a user with this user ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationAccessControlList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`400`** Bad Request, both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Entity not found. Either the application does not exist or the user does not have permissions to view the application.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' username <- 'username_example' # character | Optional, only return the access control information for a user with this username.
    #' userId <- 'userId_example' # character | Optional, only return the access control information for a user with this user ID.
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsAccessControlList(offset, limit, applicationId, username=username, userId=userId)
    #' }
    ApplicationsAccessControlList = function(offset, limit, applicationId, username = NULL, userId = NULL, ...) {
      apiResponse <- private$ApplicationsAccessControlListWithHttpInfo(offset, limit, applicationId, username, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update access control for this application.
    #' Produces: NA
    #'
    #' @details Update access control for this application. Request is processed only if updates can be performed on all entries.
    #' @details This method invokes `PATCH /applications/{applicationId}/accessControl/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param applicationAccessControlUpdateRequest \link{ApplicationAccessControlUpdateRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have appropriate privileges
    #' \itemize{
    #' }
    #' \item **`404`** Invalid applicationId provided or invalid username provided to modify access for
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationAccessControlUpdateRequest <- ApplicationAccessControlUpdateRequest$new() # ApplicationAccessControlUpdateRequest |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsAccessControlPatchMany(applicationId, applicationAccessControlUpdateRequest=applicationAccessControlUpdateRequest)
    #' }
    ApplicationsAccessControlPatchMany = function(applicationId, applicationAccessControlUpdateRequest = NULL, ...) {
      apiResponse <- private$ApplicationsAccessControlPatchManyWithHttpInfo(applicationId, applicationAccessControlUpdateRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create an application
    #' Produces: "application/json"
    #'
    #' @details Create an application. Note that the number of active applications users can have at the same time is limited.
    #' @details This method invokes `POST /applications/` in the DataRobot Public API.
    #' @param applicationCreate \link{ApplicationCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to launch application of provided type.
    #' \itemize{
    #' }
    #' \item **`404`** No app type matching the specified identifier found or user does not have permissions to access to this app type.
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationCreate <- ApplicationCreate$new() # ApplicationCreate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsCreate(applicationCreate=applicationCreate)
    #' }
    ApplicationsCreate = function(applicationCreate = NULL, ...) {
      apiResponse <- private$ApplicationsCreateWithHttpInfo(applicationCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete an application
    #' Produces: NA
    #'
    #' @details Delete an application
    #' @details This method invokes `DELETE /applications/{applicationId}/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param applicationParam \link{ApplicationParam}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The application has been deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationParam <- ApplicationParam$new() # ApplicationParam |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDelete(applicationId, applicationParam=applicationParam)
    #' }
    ApplicationsDelete = function(applicationId, applicationParam = NULL, ...) {
      apiResponse <- private$ApplicationsDeleteWithHttpInfo(applicationId, applicationParam, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Links a deployment to an application
    #' Produces: NA
    #'
    #' @details If application creates deployment during its lifetime, we want to have an API to link deployment with application.
    #' @details This method invokes `POST /applications/{applicationId}/deployments/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param addDeploymentToApplication \link{AddDeploymentToApplication}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' addDeploymentToApplication <- AddDeploymentToApplication$new() # AddDeploymentToApplication |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDeploymentsCreate(applicationId, addDeploymentToApplication=addDeploymentToApplication)
    #' }
    ApplicationsDeploymentsCreate = function(applicationId, addDeploymentToApplication = NULL, ...) {
      apiResponse <- private$ApplicationsDeploymentsCreateWithHttpInfo(applicationId, addDeploymentToApplication, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete link between application and deployment.
    #' Produces: NA
    #'
    #' @details Delete link between application and deployment.
    #' @details This method invokes `DELETE /applications/{applicationId}/deployments/{modelDeploymentId}/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param modelDeploymentId character. The ID of the model deployment
    #' @param applicationModelDeploymentParam \link{ApplicationModelDeploymentParam}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The link has been deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' modelDeploymentId <- 'modelDeploymentId_example' # character | The ID of the model deployment
    #' applicationModelDeploymentParam <- ApplicationModelDeploymentParam$new() # ApplicationModelDeploymentParam |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDeploymentsDelete(applicationId, modelDeploymentId, applicationModelDeploymentParam=applicationModelDeploymentParam)
    #' }
    ApplicationsDeploymentsDelete = function(applicationId, modelDeploymentId, applicationModelDeploymentParam = NULL, ...) {
      apiResponse <- private$ApplicationsDeploymentsDeleteWithHttpInfo(applicationId, modelDeploymentId, applicationModelDeploymentParam, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a duplicate of the application
    #' Produces: "application/json"
    #'
    #' @details Create a copy of App Builder application. Note that the number of active applications users can have at the same time is limited.
    #' @details This method invokes `POST /applications/{applicationId}/duplicate/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param applicationDuplicate \link{ApplicationDuplicate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`202`** Dulication has successfully started. See the Location header.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to launch application of provided type.
    #' \itemize{
    #' }
    #' \item **`404`** App for duplication was not found
    #' \itemize{
    #' }
    #' \item **`422`** Application could not be created with the given input.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationDuplicate <- ApplicationDuplicate$new() # ApplicationDuplicate |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsDuplicateCreate(applicationId, applicationDuplicate=applicationDuplicate)
    #' }
    ApplicationsDuplicateCreate = function(applicationId, applicationDuplicate = NULL, ...) {
      apiResponse <- private$ApplicationsDuplicateCreateWithHttpInfo(applicationId, applicationDuplicate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Paginated list of applications created by the currently authenticated user.
    #' Produces: "application/json"
    #'
    #' @details Paginated list of applications created by the currently authenticated user.
    #' @details This method invokes `GET /applications/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsList(offset, limit)
    #' }
    ApplicationsList = function(offset, limit, ...) {
      apiResponse <- private$ApplicationsListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update an application&#39;s name and/or description
    #' Produces: NA
    #'
    #' @details Update an application&#39;s name and/or description
    #' @details This method invokes `PATCH /applications/{applicationId}/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param applicationNameAndDescription \link{ApplicationNameAndDescription}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The application has been updated.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationNameAndDescription <- ApplicationNameAndDescription$new() # ApplicationNameAndDescription |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsPatch(applicationId, applicationNameAndDescription=applicationNameAndDescription)
    #' }
    ApplicationsPatch = function(applicationId, applicationNameAndDescription = NULL, ...) {
      apiResponse <- private$ApplicationsPatchWithHttpInfo(applicationId, applicationNameAndDescription, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve an application
    #' Produces: "application/json"
    #'
    #' @details Retrieve an application
    #' @details This method invokes `GET /applications/{applicationId}/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ApplicationRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsRetrieve(applicationId)
    #' }
    ApplicationsRetrieve = function(applicationId, ...) {
      apiResponse <- private$ApplicationsRetrieveWithHttpInfo(applicationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users, groups and organizations that have an access to this application
    #' Produces: NA
    #'
    #' @details Get a list of users, groups and organizations that have an access to this application
    #' @details This method invokes `GET /applications/{applicationId}/sharedRoles/` in the DataRobot Public API.
    #' @param applicationId character. The ID of the application
    #' @param limit integer. The number of records to return in the range of 1 to 100
    #' @param offset integer. The number of records to skip over. Default 0.
    #' @param name character. Only return roles for a user, group or organization with this name
    #' @param id character. Only return roles for a user, group or organization with this id
    #' @param shareRecipientType Enum < [user, group, organization] > Specify the recipient type, one of &#39;user&#39;, &#39;group&#39;, &#39;organization&#39;
    #' @param applicationSharedRolesList \link{ApplicationSharedRolesList}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' limit <- 56 # integer | The number of records to return in the range of 1 to 100
    #' offset <- 0 # integer | The number of records to skip over. Default 0.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this id
    #' shareRecipientType <- 'shareRecipientType_example' # character | Specify the recipient type, one of 'user', 'group', 'organization'
    #' applicationSharedRolesList <- ApplicationSharedRolesList$new() # ApplicationSharedRolesList |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsSharedRolesList(applicationId, limit=limit, offset=offset, name=name, id=id, shareRecipientType=shareRecipientType, applicationSharedRolesList=applicationSharedRolesList)
    #' }
    ApplicationsSharedRolesList = function(applicationId, limit = NULL, offset = 0, name = NULL, id = NULL, shareRecipientType = NULL, applicationSharedRolesList = NULL, ...) {
      apiResponse <- private$ApplicationsSharedRolesListWithHttpInfo(applicationId, limit, offset, name, id, shareRecipientType, applicationSharedRolesList, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Share an application with a user, group, or organization
    #' Produces: NA
    #'
    #' @details Share an application with a user, group, or organization
    #' @details This method invokes `PATCH /applications/{applicationId}/sharedRoles/` in the DataRobot Public API.
    #' @param sendNotification character. Send a notification
    #' @param note character. A note to go with the project share
    #' @param operation character. Name of the action being taken, only &#39;updateRoles&#39; is supported
    #' @param roles list( \link{ApplicationSharedRolesEntryUpdate} )
    #' @param applicationId character. The ID of the application
    #' @param applicationSharingUpdateOrRemove \link{ApplicationSharingUpdateOrRemove}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The roles updated successfully
    #' \itemize{
    #' }
    #' \item **`422`** The request was formatted improperly.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' sendNotification <- FALSE # character | Send a notification
    #' note <- 'note_example' # character | A note to go with the project share
    #' operation <- 'operation_example' # character | Name of the action being taken, only 'updateRoles' is supported
    #' roles <- [ApplicationSharedRolesEntryUpdate$new()] # array[ApplicationSharedRolesEntryUpdate] | Role objects, may contain up to 100 per request
    #' applicationId <- 'applicationId_example' # character | The ID of the application
    #' applicationSharingUpdateOrRemove <- ApplicationSharingUpdateOrRemove$new() # ApplicationSharingUpdateOrRemove |
    #'
    #' api.instance <- ApplicationsApi$new()
    #' result <- api.instance$ApplicationsSharedRolesPatchMany(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove=applicationSharingUpdateOrRemove)
    #' }
    ApplicationsSharedRolesPatchMany = function(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove = NULL, ...) {
      apiResponse <- private$ApplicationsSharedRolesPatchManyWithHttpInfo(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `ApplicationUserRoleRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationUserRoleRetrieveWithHttpInfo = function(applicationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      body <- NULL
      urlPath <- "/applications/{applicationId}/userRole/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationUserRoleResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsAccessControlListWithHttpInfo = function(offset, limit, applicationId, username = NULL, userId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["username"] <- username

      queryParams["userId"] <- userId

      body <- NULL
      urlPath <- "/applications/{applicationId}/accessControl/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationAccessControlList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsAccessControlPatchManyWithHttpInfo = function(applicationId, applicationAccessControlUpdateRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationAccessControlUpdateRequest`) && isa(applicationAccessControlUpdateRequest, c("ApplicationAccessControlUpdateRequest", "R6"))) {
        body <- `applicationAccessControlUpdateRequest`$toJSON()
      } else {
        stop("ApplicationsAccessControlPatchManyWithHttpInfo requires parameter applicationAccessControlUpdateRequest to be of type ApplicationAccessControlUpdateRequest.")
      }

      urlPath <- "/applications/{applicationId}/accessControl/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsCreateWithHttpInfo = function(applicationCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`applicationCreate`) && isa(applicationCreate, c("ApplicationCreate", "R6"))) {
        body <- `applicationCreate`$toJSON()
      } else {
        stop("ApplicationsCreateWithHttpInfo requires parameter applicationCreate to be of type ApplicationCreate.")
      }

      urlPath <- "/applications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeleteWithHttpInfo = function(applicationId, applicationParam = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationParam`) && isa(applicationParam, c("ApplicationParam", "R6"))) {
        body <- `applicationParam`$toJSON()
      } else {
        stop("ApplicationsDeleteWithHttpInfo requires parameter applicationParam to be of type ApplicationParam.")
      }

      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDeploymentsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeploymentsCreateWithHttpInfo = function(applicationId, addDeploymentToApplication = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`addDeploymentToApplication`) && isa(addDeploymentToApplication, c("AddDeploymentToApplication", "R6"))) {
        body <- `addDeploymentToApplication`$toJSON()
      } else {
        stop("ApplicationsDeploymentsCreateWithHttpInfo requires parameter addDeploymentToApplication to be of type AddDeploymentToApplication.")
      }

      urlPath <- "/applications/{applicationId}/deployments/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDeploymentsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDeploymentsDeleteWithHttpInfo = function(applicationId, modelDeploymentId, applicationModelDeploymentParam = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (missing(`modelDeploymentId`)) {
        stop("Missing required parameter `modelDeploymentId`.")
      }

      if (!missing(`applicationModelDeploymentParam`) && isa(applicationModelDeploymentParam, c("ApplicationModelDeploymentParam", "R6"))) {
        body <- `applicationModelDeploymentParam`$toJSON()
      } else {
        stop("ApplicationsDeploymentsDeleteWithHttpInfo requires parameter applicationModelDeploymentParam to be of type ApplicationModelDeploymentParam.")
      }

      urlPath <- "/applications/{applicationId}/deployments/{modelDeploymentId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelDeploymentId`)) {
        urlPath <- gsub(paste0("\\{", "modelDeploymentId", "\\}"), URLencode(as.character(`modelDeploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsDuplicateCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsDuplicateCreateWithHttpInfo = function(applicationId, applicationDuplicate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationDuplicate`) && isa(applicationDuplicate, c("ApplicationDuplicate", "R6"))) {
        body <- `applicationDuplicate`$toJSON()
      } else {
        stop("ApplicationsDuplicateCreateWithHttpInfo requires parameter applicationDuplicate to be of type ApplicationDuplicate.")
      }

      urlPath <- "/applications/{applicationId}/duplicate/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsListWithHttpInfo = function(offset, limit, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/applications/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsPatchWithHttpInfo = function(applicationId, applicationNameAndDescription = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      if (!missing(`applicationNameAndDescription`) && isa(applicationNameAndDescription, c("ApplicationNameAndDescription", "R6"))) {
        body <- `applicationNameAndDescription`$toJSON()
      } else {
        stop("ApplicationsPatchWithHttpInfo requires parameter applicationNameAndDescription to be of type ApplicationNameAndDescription.")
      }

      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsRetrieveWithHttpInfo = function(applicationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      body <- NULL
      urlPath <- "/applications/{applicationId}/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ApplicationRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsSharedRolesListWithHttpInfo = function(applicationId, limit = NULL, offset = 0, name = NULL, id = NULL, shareRecipientType = NULL, applicationSharedRolesList = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["name"] <- name

      queryParams["id"] <- id

      queryParams["shareRecipientType"] <- shareRecipientType

      if (!missing(`applicationSharedRolesList`) && isa(applicationSharedRolesList, c("ApplicationSharedRolesList", "R6"))) {
        body <- `applicationSharedRolesList`$toJSON()
      } else {
        stop("ApplicationsSharedRolesListWithHttpInfo requires parameter applicationSharedRolesList to be of type ApplicationSharedRolesList.")
      }

      urlPath <- "/applications/{applicationId}/sharedRoles/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ApplicationsSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ApplicationsSharedRolesPatchManyWithHttpInfo = function(sendNotification, note, operation, roles, applicationId, applicationSharingUpdateOrRemove = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`sendNotification`)) {
        stop("Missing required parameter `sendNotification`.")
      }

      if (missing(`note`)) {
        stop("Missing required parameter `note`.")
      }

      if (missing(`operation`)) {
        stop("Missing required parameter `operation`.")
      }

      if (missing(`roles`)) {
        stop("Missing required parameter `roles`.")
      }

      if (missing(`applicationId`)) {
        stop("Missing required parameter `applicationId`.")
      }

      queryParams["sendNotification"] <- sendNotification

      queryParams["note"] <- note

      queryParams["operation"] <- operation

      queryParams["roles"] <- roles

      if (!missing(`applicationSharingUpdateOrRemove`) && isa(applicationSharingUpdateOrRemove, c("ApplicationSharingUpdateOrRemove", "R6"))) {
        body <- `applicationSharingUpdateOrRemove`$toJSON()
      } else {
        stop("ApplicationsSharedRolesPatchManyWithHttpInfo requires parameter applicationSharingUpdateOrRemove to be of type ApplicationSharingUpdateOrRemove.")
      }

      urlPath <- "/applications/{applicationId}/sharedRoles/"
      if (!missing(`applicationId`)) {
        urlPath <- gsub(paste0("\\{", "applicationId", "\\}"), URLencode(as.character(`applicationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
