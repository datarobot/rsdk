# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Models operations
#' @description datarobot.apicore.Models
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
ModelsApi <- R6::R6Class(
  "ModelsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Create custom model feature impact.
    #' Produces: "application/json"
    #'
    #' @details Add a request to calculate feature impact for a custom inference model image to             the queue.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:post:&#x60;/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/&#x60;  This route is a counterpart of a corresponding endpoint for native models: :http:post:&#x60;/api/v2/projects/(projectId)/models/(modelId)/featureImpact/&#x60;
    #' @param imageId character. ID of the image of the custom inference model to submit feature impact job for.
    #' @param featureImpactCreatePayload \link{FeatureImpactCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureImpactCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Feature impact request has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** Contains a url for tracking job status: :http:get:&#x60;/api/v2/status/(statusId)/&#x60;.
    #' }
    #' \item **`404`** If feature impact has already been submitted. The response will include &#x60;jobId&#x60; property which can be used for tracking its progress.
    #' \itemize{
    #' }
    #' \item **`422`** If job cannot be submitted because of invalid input or model state: (1) if image id does not correspond to a custom inference model, (2) if training data is not yet assigned or assignment is in progress, (3) if the &#x60;rowCount&#x60; exceeds the minimum or maximum value for this model&#39;s training data.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' imageId <- 'imageId_example' # character | ID of the image of the custom inference model to submit feature impact job for.
    #' featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomInferenceImagesFeatureImpactCreate(imageId, featureImpactCreatePayload=featureImpactCreatePayload)
    #' }
    CustomInferenceImagesFeatureImpactCreate = function(imageId, featureImpactCreatePayload = NULL, ...) {
      apiResponse <- private$CustomInferenceImagesFeatureImpactCreateWithHttpInfo(imageId, featureImpactCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model feature impact.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature impact scores for features in a custom inference model image.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:get:&#x60;/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/&#x60;  This route is a counterpart of a corresponding endpoint for native models: :http:get:&#x60;/api/v2/projects/(projectId)/models/(modelId)/featureImpact/&#x60;
    #' @param imageId character. ID of the image of the custom inference model to retrieve feature impact from.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureImpactResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Custom model feature impact returned.
    #' \itemize{
    #' }
    #' \item **`404`** No feature impact data found for custom model.
    #' \itemize{
    #' }
    #' \item **`422`** Cannot retrieve feature impact scores: (1) if custom model is not an inference model, (2) if training data is not assigned, (3) if feature impact job is in progress for custom model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' imageId <- 'imageId_example' # character | ID of the image of the custom inference model to retrieve feature impact from.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomInferenceImagesFeatureImpactList(imageId)
    #' }
    CustomInferenceImagesFeatureImpactList = function(imageId, ...) {
      apiResponse <- private$CustomInferenceImagesFeatureImpactListWithHttpInfo(imageId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom model deployments.
    #' Produces: "application/json"
    #'
    #' @details List of model deployments for user sorted by creation time descending.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelIds \link{OneOfstringarray}. List of ID&#39;s of the custom model which model deployments will be retrieved.
    #' @param environmentIds \link{OneOfstringarray}. List of ID&#39;s of the execution environment which model deployments will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelDeploymentListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' \item **`400`** Query parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' customModelIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the custom model which model deployments will be retrieved.
    #' environmentIds <- OneOfstringarray$new() # OneOfstringarray | List of ID's of the execution environment which model deployments will be retrieved.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelDeploymentsList(offset, limit, customModelIds=customModelIds, environmentIds=environmentIds)
    #' }
    CustomModelDeploymentsList = function(offset, limit, customModelIds = NULL, environmentIds = NULL, ...) {
      apiResponse <- private$CustomModelDeploymentsListWithHttpInfo(offset, limit, customModelIds, environmentIds, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model resource limits.
    #' Produces: "application/json"
    #'
    #' @details Retrieve custom model resource limits the user has access to.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelResourceLimits}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelLimitsList()
    #' }
    CustomModelLimitsList = function(...) {
      apiResponse <- private$CustomModelLimitsListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model test.
    #' Produces: "application/json"
    #'
    #' @details Test a custom inference model. This will start a job to check that the custom model can make predictions against the supplied dataset without breaking.
    #' @param customModelTests \link{CustomModelTests}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelAsyncOperationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Model testing job successfully started.
    #' \itemize{
    #' \item **`Location`** URL that can be polled to check the status.
    #' }
    #' \item **`403`** No access to use data for testing custom model.
    #' \itemize{
    #' }
    #' \item **`404`** Custom model or dataset not found.
    #' \itemize{
    #' }
    #' \item **`422`** Custom Model Testing cannot be submitted because of invalid input or model state: (1) if user does not have permission to create legacy conversion environment, (2) testing is already in progress for the custom model, (3) dataset used for testing is not snapshotted,(4) other cases.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelTests <- CustomModelTests$new() # CustomModelTests |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsCreate(customModelTests=customModelTests)
    #' }
    CustomModelTestsCreate = function(customModelTests = NULL, ...) {
      apiResponse <- private$CustomModelTestsCreateWithHttpInfo(customModelTests, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel custom model test.
    #' Produces: NA
    #'
    #' @details Cancel custom inference model testing.
    #' @param customModelTestId character. ID of the testing history attempt.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Testing canceled.
    #' \itemize{
    #' }
    #' \item **`404`** Testing attempt not found.
    #' \itemize{
    #' }
    #' \item **`409`** Testing attempt has already reached a terminal state.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsDelete(customModelTestId)
    #' }
    CustomModelTestsDelete = function(customModelTestId, ...) {
      apiResponse <- private$CustomModelTestsDeleteWithHttpInfo(customModelTestId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom model tests.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the testing history for a model.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelId character. ID of the Custom Model to retrieve testing history for.
    #' @param maximumMemory integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' @param networkEgressPolicy Enum < [NONE, PUBLIC] > Network egress policy.
    #' @param desiredMemory integer. The amount of memory that is expected to be allocated by the custom model.
    #' @param replicas integer. A fixed number of replicas that will be set for the given custom-model.
    #' @param requiresHa character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelTestsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelId <- 'customModelId_example' # character | ID of the Custom Model to retrieve testing history for.
    #' maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
    #' desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
    #' replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
    #' requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsList(offset, limit, customModelId, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, desiredMemory=desiredMemory, replicas=replicas, requiresHa=requiresHa)
    #' }
    CustomModelTestsList = function(offset, limit, customModelId, maximumMemory = NULL, networkEgressPolicy = NULL, desiredMemory = NULL, replicas = NULL, requiresHa = NULL, ...) {
      apiResponse <- private$CustomModelTestsListWithHttpInfo(offset, limit, customModelId, maximumMemory, networkEgressPolicy, desiredMemory, replicas, requiresHa, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model test log.
    #' Produces: NA
    #'
    #' @details Retrieve the logs from a model testing attempt.
    #' @param customModelTestId character. ID of the testing history attempt.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The log file will be downloaded.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;testing-&lt;custom_model_id&gt;.log\&quot;).
    #' }
    #' \item **`404`** No testing log found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsLogList(customModelTestId)
    #' }
    CustomModelTestsLogList = function(customModelTestId, ...) {
      apiResponse <- private$CustomModelTestsLogListWithHttpInfo(customModelTestId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model test.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a specific testing history entry for a custom model.
    #' @param customModelTestId character. ID of the testing history attempt.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelTestsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsRetrieve(customModelTestId)
    #' }
    CustomModelTestsRetrieve = function(customModelTestId, ...) {
      apiResponse <- private$CustomModelTestsRetrieveWithHttpInfo(customModelTestId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model test log tail.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the last N lines of logs from a model testing attempt.
    #' @param lines integer. Number of lines from the log to retrieve (1-1000, default 100).
    #' @param customModelTestId character. ID of the testing history attempt.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelTestsLogTailResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The log tail was retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Requested number of lines is invalid.
    #' \itemize{
    #' }
    #' \item **`404`** The testing history entry cannot be found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' lines <- 100 # integer | Number of lines from the log to retrieve (1-1000, default 100).
    #' customModelTestId <- 'customModelTestId_example' # character | ID of the testing history attempt.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelTestsTailList(lines, customModelTestId)
    #' }
    CustomModelTestsTailList = function(lines, customModelTestId, ...) {
      apiResponse <- private$CustomModelTestsTailListWithHttpInfo(lines, customModelTestId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users who have access to this custom model and their roles on it.
    #' Produces: "application/json"
    #'
    #' @details Get a list of users who have access to this custom model and their roles on it.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelId character. ID of the custom model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelAccessControlListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of users who have access to this custom model and their roles on it.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsAccessControlList(offset, limit, customModelId)
    #' }
    CustomModelsAccessControlList = function(offset, limit, customModelId, ...) {
      apiResponse <- private$CustomModelsAccessControlListWithHttpInfo(offset, limit, customModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Grant access or update roles for users on this custom model and appropriate learning data.
    #' Produces: "application/json"
    #'
    #' @details Grant access or update roles for users on this custom model and appropriate learning data. Up to 100 user roles may be set in a single request.
    #' @param customModelId character. ID of the custom model.
    #' @param sharingUpdateOrRemoveWithGrant \link{SharingUpdateOrRemoveWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelAccessControlUpdateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the custom model without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsAccessControlPatchMany(customModelId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
    #' }
    CustomModelsAccessControlPatchMany = function(customModelId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      apiResponse <- private$CustomModelsAccessControlPatchManyWithHttpInfo(customModelId, sharingUpdateOrRemoveWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model.
    #' Produces: "application/json"
    #'
    #' @details  Creates a new custom model and returns the newly created metadata record for it.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  A regression model is expected to produce predictions that are arbitrary floating-point or integer numbers. A classification model is expected to return predictions with probability scores for each class.  For example, a binary classification model might return:  .. code:: Python      {         positiveClassLabel: probability,         negativeClassLabel: 1.0 - probability     }  For Custom Inference Models, the &#x60;&#x60;file&#x60;&#x60; parameter must be either a tarball or zip archive containing, at minimum, a script named &#x60;&#x60;start_server.sh&#x60;&#x60;.  It may contain additional files, including scripts and precompiled binaries as well as data files.  &#x60;&#x60;start_server.sh&#x60;&#x60; may execute these scripts and/or binaries.  When this script is executed, it is run as part of an Environment (specified via subsequent API calls), and all included scripts and binaries can take advantage of any programming language interpreters, compilers, libraries, or other tools included in the Environment. &#x60;&#x60;start_server.sh&#x60;&#x60; must be marked as executable (&#x60;&#x60;chmod +x&#x60;&#x60;).  When &#x60;&#x60;start_server.sh&#x60;&#x60; is launched, it must launch and maintain (in the foreground) a Web server that listens on two URLs:  * &#x60;&#x60;GET $URL_PREFIX/&#x60;&#x60;     This route must return a 200 response code with an empty body immediately     if the server is ready to respond to prediction requests.  Otherwise it should     either not accept the request, not respond to the request, or return a     503 response code. * &#x60;&#x60;POST $URL_PREFIX/predict_no_state/&#x60;&#x60;     This route must accept as input a JSON object of the form:      .. code-block:: Python          {             &#39;X&#39;: {                 &#39;col1&#39;: [...col1_data...],                 &#39;col2&#39;: [...col2_data...],                 &#39;col3&#39;: [...col3_data...],                 ...             }         }      The data lists will all be the same length.      It must return a JSON object of the form:      .. code-block:: Python          {             &#39;predictions&#39;: [...predictions data...]         }      The predictions data must correspond 1:1 to the rows in the input data lists.      &#x60;&#x60;$URL_PREFIX&#x60;&#x60; is provided as an environment variable.  The Web server process must     re-read its value every time the process starts, as it may change.     It is an opaque string that is guaranteed to be a valid URL component,     but may contain path separators (&#x60;&#x60;/&#x60;&#x60;).
    #' @param customModelCreate \link{CustomModelCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Created.
    #' \itemize{
    #' }
    #' \item **`403`** Custom model creation is not enabled.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelCreate <- CustomModelCreate$new() # CustomModelCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsCreate(customModelCreate=customModelCreate)
    #' }
    CustomModelsCreate = function(customModelCreate = NULL, ...) {
      apiResponse <- private$CustomModelsCreateWithHttpInfo(customModelCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete custom model.
    #' Produces: NA
    #'
    #' @details Delete a custom model. Only users who have permission to edit custom model can delete it. Only custom models which are not currently deployed or undergoing custom model testing can be deleted. Relevant CustomModelImage will be deleted also.
    #' @param customModelId character. ID of the custom model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Record deleted.
    #' \itemize{
    #' }
    #' \item **`409`** This custom model is currently deployed and cannot be deleted. The response body will contain link where those deployments can be retrieved.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsDelete(customModelId)
    #' }
    CustomModelsDelete = function(customModelId, ...) {
      apiResponse <- private$CustomModelsDeleteWithHttpInfo(customModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download the latest custom model version content.
    #' Produces: NA
    #'
    #' @details Download the latest item bundle from a custom model as a zip compressed archive.
    #' @param customModelId character. ID of the custom model.
    #' @param pps Enum < [false, False, true, True] > Download model version from PPS tab.If \&quot;true\&quot; specified, model archive includes dependencies install script. If \&quot;false\&quot; specified, dependencies script is not included. If not specified -&gt; \&quot;false\&quot; behavior.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The download succeeded.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;model-&lt;model_id&gt;-version-&lt;version_id&gt;.zip\&quot;).
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsDownloadList(customModelId, pps=pps)
    #' }
    CustomModelsDownloadList = function(customModelId, pps = "False", ...) {
      apiResponse <- private$CustomModelsDownloadListWithHttpInfo(customModelId, pps, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Clone custom model.
    #' Produces: "application/json"
    #'
    #' @details Creates a copy of the provided custom model, including metadata, versions of that model, and uploaded files. Associates the new versions with files owned by the custom model.
    #' @param customModelCopy \link{CustomModelCopy}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Successfully created copy.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelCopy <- CustomModelCopy$new() # CustomModelCopy |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsFromCustomModelCreate(customModelCopy=customModelCopy)
    #' }
    CustomModelsFromCustomModelCreate = function(customModelCopy = NULL, ...) {
      apiResponse <- private$CustomModelsFromCustomModelCreateWithHttpInfo(customModelCopy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom models.
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata for all custom models the user has access to.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelType Enum < [training, inference] > If \&quot;training\&quot; specified, only Custom Training Tasks will be returned. If \&quot;inference\&quot; specified, only Custom Inference Models will be returned. If not specified, all custom models will be returned. After deprecation, only Custom Inference Models will be returned
    #' @param isDeployed Enum < [false, False, true, True] > If \&quot;true\&quot; specified, only deployed custom models will be returned. If \&quot;false\&quot; specified, only not deployed custom models will be returned. If not specified, all custom models will be returned.
    #' @param orderBy Enum < [created, -created, updated, -updated] > Sort order which will be applied to custom model list, valid options are \&quot;created\&quot;, \&quot;updated\&quot;. Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;\&quot;-created\&quot;. By default, the orderBy parameter is None which will result in custom models being returned in order of creation time descending.
    #' @param searchFor character. String to search for occurrence in custom model&#39;s description, language and name. Search is case insensitive. If not specified, all custom models will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelType <- 'customModelType_example' # character | If \"training\" specified, only Custom Training Tasks will be returned. If \"inference\" specified, only Custom Inference Models will be returned. If not specified, all custom models will be returned. After deprecation, only Custom Inference Models will be returned
    #' isDeployed <- 'isDeployed_example' # character | If \"true\" specified, only deployed custom models will be returned. If \"false\" specified, only not deployed custom models will be returned. If not specified, all custom models will be returned.
    #' orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom model list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom models being returned in order of creation time descending.
    #' searchFor <- 'searchFor_example' # character | String to search for occurrence in custom model's description, language and name. Search is case insensitive. If not specified, all custom models will be returned.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsList(offset, limit, customModelType=customModelType, isDeployed=isDeployed, orderBy=orderBy, searchFor=searchFor)
    #' }
    CustomModelsList = function(offset, limit, customModelType = NULL, isDeployed = NULL, orderBy = NULL, searchFor = NULL, ...) {
      apiResponse <- private$CustomModelsListWithHttpInfo(offset, limit, customModelType, isDeployed, orderBy, searchFor, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update custom model.
    #' Produces: "application/json"
    #'
    #' @details  Updates metadata for an existing custom model.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  Setting &#x60;positiveClassLabel&#x60; and &#x60;negativeClassLabel&#x60; to null will set the labels to their default values (1 and 0 for positiveClassLabel and negativeClassLabel, respectively).  Setting &#x60;positiveClassLabel&#x60;, &#x60;negativeClassLabel&#x60;, &#39;targetName&#x60; is disabled if model has active deployments or assigned training data.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelUpdate \link{CustomModelUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Created.
    #' \itemize{
    #' }
    #' \item **`403`** Custom inference model modification is not enabled for the user.
    #' \itemize{
    #' }
    #' \item **`409`** Custom model cannot be updated while it is being validated or some fields cannot be updated after deployment or assigning training data.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelUpdate <- CustomModelUpdate$new() # CustomModelUpdate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsPatch(customModelId, customModelUpdate=customModelUpdate)
    #' }
    CustomModelsPatch = function(customModelId, customModelUpdate = NULL, ...) {
      apiResponse <- private$CustomModelsPatchWithHttpInfo(customModelId, customModelUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new prediction explanations initialization for custom model.
    #' Produces: NA
    #'
    #' @details Create a new prediction explanations initialization for custom model. This is a necessary prerequisite for generating prediction explanations.  .. minversion:: v2.23     DEPRECATED please use custom model version route instead:     :http:post:&#x60;/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/predictionExplanationsInitialization/&#x60;
    #' @param customModelPredictionExplanations \link{CustomModelPredictionExplanations}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** URL to poll to track the prediction explanation initialization has finished.
    #' }
    #' \item **`422`** Specified custom model is not valid for prediction explanations.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelPredictionExplanations <- CustomModelPredictionExplanations$new() # CustomModelPredictionExplanations |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsPredictionExplanationsInitializationCreate(customModelPredictionExplanations=customModelPredictionExplanations)
    #' }
    CustomModelsPredictionExplanationsInitializationCreate = function(customModelPredictionExplanations = NULL, ...) {
      apiResponse <- private$CustomModelsPredictionExplanationsInitializationCreateWithHttpInfo(customModelPredictionExplanations, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata for a custom model.
    #' @param customModelId character. ID of the custom model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsRetrieve(customModelId)
    #' }
    CustomModelsRetrieve = function(customModelId, ...) {
      apiResponse <- private$CustomModelsRetrieveWithHttpInfo(customModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Assign training data to custom model.
    #' Produces: NA
    #'
    #' @details Assigns training data from provided dataset to provided Custom Inference Model. For each of custom model&#39;s deployments the training data from the specified project is used as baseline, this will enable turning drift tracking on for those deployments.
    #' @param customModelId character. ID of the custom model.
    #' @param trainingDataAssignment \link{TrainingDataAssignment}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** URL to poll to track the training data assignment has finished.
    #' }
    #' \item **`409`** Custom model has assigned training data already and is deployed.
    #' \itemize{
    #' }
    #' \item **`410`** The requested Dataset has been deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Dataset ingest must finish before assigning training data or provided dataset is incompatible with the custom model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' trainingDataAssignment <- TrainingDataAssignment$new() # TrainingDataAssignment |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsTrainingDataPatchMany(customModelId, trainingDataAssignment=trainingDataAssignment)
    #' }
    CustomModelsTrainingDataPatchMany = function(customModelId, trainingDataAssignment = NULL, ...) {
      apiResponse <- private$CustomModelsTrainingDataPatchManyWithHttpInfo(customModelId, trainingDataAssignment, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update custom model version files.
    #' Produces: "application/json"
    #'
    #' @details Create a new custom model version with files added, replaced or deleted. Files from the previous version of a custom models will be used as a basis.
    #' @param customModelId character. ID of the custom model.
    #' @param baseEnvironmentId character. The base environment to use with this model version.
    #' @param isMajorUpdate Enum < [false, False, true, True] > If set to true, new major version will created, otherwise minor version will be created.
    #' @param desiredMemory integer. The amount of memory that is expected to be allocated by the custom model.
    #' @param file data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding &#x60;filePath&#x60; supplied that shows the relative location of the file. For example, you have two files: &#x60;/home/username/custom-task/main.py&#x60; and &#x60;/home/username/custom-task/helpers/helper.py&#x60;. When uploading these files, you would _also_ need to include two &#x60;filePath&#x60; fields of, &#x60;\\\&quot;main.py\\\&quot;&#x60; and &#x60;\\\&quot;helpers/helper.py\\\&quot;&#x60;. If the supplied &#x60;file&#x60; already exists at the supplied &#x60;filePath&#x60;, the old file is replaced by the new file.
    #' @param filePath \link{OneOfstringarray}. The local path of the file being uploaded. See the &#x60;file&#x60; field explanation for more details.
    #' @param filesToDelete \link{OneOfstringarray}. The IDs of the files to be deleted.
    #' @param maximumMemory integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' @param networkEgressPolicy Enum < [NONE, PUBLIC] > Network egress policy.
    #' @param replicas integer. A fixed number of replicas that will be set for the given custom-model.
    #' @param requiredMetadata character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' @param requiredMetadataValues character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys.
    #' @param requiresHa character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Item successfully created.
    #' \itemize{
    #' }
    #' \item **`413`** Item or collection of items was too large in size (bytes).
    #' \itemize{
    #' }
    #' \item **`422`** Cannot create the custom task version due to one or more errors. All error responses will have a \&quot;message\&quot; field and some may have optional fields. The optional fields include: [\&quot;errors\&quot;, \&quot;dependencies\&quot;, \&quot;invalidDependencies\&quot;]
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
    #' isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
    #' desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
    #' file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
    #' filesToDelete <- oneOf<string,array>$new() # OneOfstringarray | The IDs of the files to be deleted.
    #' maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
    #' replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
    #' requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
    #' requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionCreateFromLatest(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory=desiredMemory, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
    #' }
    CustomModelsVersionCreateFromLatest = function(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory = NULL, file = NULL, filePath = NULL, filesToDelete = NULL, maximumMemory = NULL, networkEgressPolicy = NULL, replicas = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, requiresHa = NULL, ...) {
      apiResponse <- private$CustomModelsVersionCreateFromLatestWithHttpInfo(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory, file, filePath, filesToDelete, maximumMemory, networkEgressPolicy, replicas, requiredMetadata, requiredMetadataValues, requiresHa, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Generates JAR file from particular files.
    #' Produces: "application/json"
    #'
    #' @details Converts files in the given custom model version to a JAR file.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param conversionCreateQuery \link{ConversionCreateQuery}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelConversionAsyncOperationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' conversionCreateQuery <- ConversionCreateQuery$new() # ConversionCreateQuery |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsConversionsCreate(customModelId, customModelVersionId, conversionCreateQuery=conversionCreateQuery)
    #' }
    CustomModelsVersionsConversionsCreate = function(customModelId, customModelVersionId, conversionCreateQuery = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsConversionsCreateWithHttpInfo(customModelId, customModelVersionId, conversionCreateQuery, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Stop a given custom model conversion.
    #' Produces: NA
    #'
    #' @details Stop a running conversion for given model and model version.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param conversionId character. ID of the custom model conversion.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** The given conversion is not active.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' conversionId <- 'conversionId_example' # character | ID of the custom model conversion.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsConversionsDelete(customModelId, customModelVersionId, conversionId)
    #' }
    CustomModelsVersionsConversionsDelete = function(customModelId, customModelVersionId, conversionId, ...) {
      apiResponse <- private$CustomModelsVersionsConversionsDeleteWithHttpInfo(customModelId, customModelVersionId, conversionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list or latest custom model conversion(s).
    #' Produces: "application/json"
    #'
    #' @details Get the list of custom model conversions that are associated with the given custom model. Alternatively, it can return a single item list of the latest custom model conversion that is associated with the given custom model version.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param isLatest Enum < [false, False, true, True] > Whether to return only the latest associated custom model conversion or all of the associated ones.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ConversionListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' isLatest <- "false" # character | Whether to return only the latest associated custom model conversion or all of the associated ones.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsConversionsList(offset, limit, customModelId, customModelVersionId, isLatest=isLatest)
    #' }
    CustomModelsVersionsConversionsList = function(offset, limit, customModelId, customModelVersionId, isLatest = "false", ...) {
      apiResponse <- private$CustomModelsVersionsConversionsListWithHttpInfo(offset, limit, customModelId, customModelVersionId, isLatest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a given custom model conversion.
    #' Produces: "application/json"
    #'
    #' @details Get a given custom model conversion.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param conversionId character. ID of the custom model conversion.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ConversionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' conversionId <- 'conversionId_example' # character | ID of the custom model conversion.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsConversionsRetrieve(customModelId, customModelVersionId, conversionId)
    #' }
    CustomModelsVersionsConversionsRetrieve = function(customModelId, customModelVersionId, conversionId, ...) {
      apiResponse <- private$CustomModelsVersionsConversionsRetrieveWithHttpInfo(customModelId, customModelVersionId, conversionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model version.
    #' Produces: "application/json"
    #'
    #' @details Create a new custom model version with attached files if supplied.
    #' @param customModelId character. ID of the custom model.
    #' @param isMajorUpdate Enum < [false, False, true, True] > If set to true, new major version will created, otherwise minor version will be created.
    #' @param baseEnvironmentId character. The base environment to use with this model version.
    #' @param desiredMemory integer. The amount of memory that is expected to be allocated by the custom model.
    #' @param file data.frame. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding &#x60;filePath&#x60; supplied that shows the relative location of the file. For example, you have two files: &#x60;/home/username/custom-task/main.py&#x60; and &#x60;/home/username/custom-task/helpers/helper.py&#x60;. When uploading these files, you would _also_ need to include two &#x60;filePath&#x60; fields of, &#x60;\\\&quot;main.py\\\&quot;&#x60; and &#x60;\\\&quot;helpers/helper.py\\\&quot;&#x60;. If the supplied &#x60;file&#x60; already exists at the supplied &#x60;filePath&#x60;, the old file is replaced by the new file.
    #' @param filePath \link{OneOfstringarray}. The local path of the file being uploaded. See the &#x60;file&#x60; field explanation for more details.
    #' @param maximumMemory integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' @param networkEgressPolicy Enum < [NONE, PUBLIC] > Network egress policy.
    #' @param replicas integer. A fixed number of replicas that will be set for the given custom-model.
    #' @param requiredMetadata character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' @param requiredMetadataValues character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys.
    #' @param requiresHa character. Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Item successfully created.
    #' \itemize{
    #' }
    #' \item **`413`** Item or collection of items was too large in size (bytes).
    #' \itemize{
    #' }
    #' \item **`422`** Cannot create the custom task version due to one or more errors. All error responses will have a \&quot;message\&quot; field and some may have optional fields. The optional fields include: [\&quot;errors\&quot;, \&quot;dependencies\&quot;, \&quot;invalidDependencies\&quot;]
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
    #' baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this model version.
    #' desiredMemory <- 56 # integer | The amount of memory that is expected to be allocated by the custom model.
    #' file <- File.new('/path/to/file') # data.frame | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' filePath <- oneOf<string,array>$new() # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
    #' maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' networkEgressPolicy <- 'networkEgressPolicy_example' # character | Network egress policy.
    #' replicas <- 56 # integer | A fixed number of replicas that will be set for the given custom-model.
    #' requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
    #' requiresHa <- 'requiresHa_example' # character | Require all custom model replicas to be deployed on different Kubernetes nodes for predictions fault tolerance.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsCreate(customModelId, isMajorUpdate, baseEnvironmentId=baseEnvironmentId, desiredMemory=desiredMemory, file=file, filePath=filePath, maximumMemory=maximumMemory, networkEgressPolicy=networkEgressPolicy, replicas=replicas, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues, requiresHa=requiresHa)
    #' }
    CustomModelsVersionsCreate = function(customModelId, isMajorUpdate, baseEnvironmentId = NULL, desiredMemory = NULL, file = NULL, filePath = NULL, maximumMemory = NULL, networkEgressPolicy = NULL, replicas = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, requiresHa = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsCreateWithHttpInfo(customModelId, isMajorUpdate, baseEnvironmentId, desiredMemory, file, filePath, maximumMemory, networkEgressPolicy, replicas, requiredMetadata, requiredMetadataValues, requiresHa, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start a custom model version&#39;s dependency build.
    #' Produces: "application/json"
    #'
    #' @details Start a custom model version&#39;s dependency build. This is required to test, deploy, or train custom models.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BaseDependencyBuildMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Custom model version&#39;s dependency build has started.
    #' \itemize{
    #' }
    #' \item **`422`** Custom model dependency build has failed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsDependencyBuildCreate(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsDependencyBuildCreate = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsDependencyBuildCreateWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel dependency build.
    #' Produces: NA
    #'
    #' @details Cancel the custom model version&#39;s dependency build.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Custom model version&#39;s dependency build was cancelled.
    #' \itemize{
    #' }
    #' \item **`409`** Custom model dependency build has reached a terminal state and cannot be cancelled.
    #' \itemize{
    #' }
    #' \item **`422`** No custom model dependency build started for specified version or dependency image is in use and cannot be deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsDependencyBuildDeleteMany(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsDependencyBuildDeleteMany = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsDependencyBuildDeleteManyWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the custom model version&#39;s dependency build status.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the custom model version&#39;s dependency build status.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BaseDependencyBuildMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The metadata from the custom model version&#39;s dependency build.
    #' \itemize{
    #' }
    #' \item **`422`** Custom model dependency build has not started.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsDependencyBuildList(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsDependencyBuildList = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsDependencyBuildListWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the custom model version&#39;s dependency build log.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the custom model version&#39;s dependency build log.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DependencyBuildLogResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The log file generated during the custom model version&#39;s dependency build.
    #' \itemize{
    #' }
    #' \item **`404`** Dependency build is in progress or could not be found.
    #' \itemize{
    #' }
    #' \item **`422`** Custom model dependency build has not started.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsDependencyBuildLogList(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsDependencyBuildLogList = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsDependencyBuildLogListWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download custom model version content.
    #' Produces: NA
    #'
    #' @details Download a specific item bundle from a custom model as a zip compressed archive.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param pps Enum < [false, False, true, True] > Download model version from PPS tab.If \&quot;true\&quot; specified, model archive includes dependencies install script. If \&quot;false\&quot; specified, dependencies script is not included. If not specified -&gt; \&quot;false\&quot; behavior.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The download succeeded.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;model-&lt;model_id&gt;-version-&lt;version_id&gt;.zip\&quot;).
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' pps <- "False" # character | Download model version from PPS tab.If \"true\" specified, model archive includes dependencies install script. If \"false\" specified, dependencies script is not included. If not specified -> \"false\" behavior.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsDownloadList(customModelId, customModelVersionId, pps=pps)
    #' }
    CustomModelsVersionsDownloadList = function(customModelId, customModelVersionId, pps = "False", ...) {
      apiResponse <- private$CustomModelsVersionsDownloadListWithHttpInfo(customModelId, customModelVersionId, pps, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model feature impact.
    #' Produces: "application/json"
    #'
    #' @details Add a request to calculate feature impact for a custom inference model image to             the queue.  This route is a counterpart of a corresponding endpoint for native models: :http:post:&#x60;/api/v2/projects/(projectId)/models/(modelId)/featureImpact/&#x60;
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param featureImpactCreatePayload \link{FeatureImpactCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureImpactCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Feature impact request has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** Contains a url for tracking job status: :http:get:&#x60;/api/v2/status/(statusId)/&#x60;.
    #' }
    #' \item **`404`** If feature impact has already been submitted. The response will include &#x60;jobId&#x60; property which can be used for tracking its progress.
    #' \itemize{
    #' }
    #' \item **`422`** If job cannot be submitted because of invalid input or model state: (1) if image id does not correspond to a custom inference model, (2) if training data is not yet assigned or assignment is in progress, (3) if the &#x60;rowCount&#x60; exceeds the minimum or maximum value for this model&#39;s training data.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsFeatureImpactCreate(customModelId, customModelVersionId, featureImpactCreatePayload=featureImpactCreatePayload)
    #' }
    CustomModelsVersionsFeatureImpactCreate = function(customModelId, customModelVersionId, featureImpactCreatePayload = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsFeatureImpactCreateWithHttpInfo(customModelId, customModelVersionId, featureImpactCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model feature impact.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature impact scores for features in a custom inference model image.   This route is a counterpart of a corresponding endpoint for native models: :http:get:&#x60;/api/v2/projects/(projectId)/models/(modelId)/featureImpact/&#x60;
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureImpactResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Custom model feature impact returned.
    #' \itemize{
    #' }
    #' \item **`404`** No feature impact data found for custom model.
    #' \itemize{
    #' }
    #' \item **`422`** Cannot retrieve feature impact scores: (1) if custom model is not an inference model, (2) if training data is not assigned, (3) if feature impact job is in progress for custom model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsFeatureImpactList(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsFeatureImpactList = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsFeatureImpactListWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model version from remote repository.
    #' Produces: NA
    #'
    #' @details Create a new custom model version with only files added from the specified remote repository.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionCreateFromRepository \link{CustomModelVersionCreateFromRepository}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Accepted: request placed to a queue for processing.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Custom Model version cannot be created: (1) input parameters are invalid, (2) if user does not have permission to create legacy conversion environment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsFromRepositoryCreate(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
    #' }
    CustomModelsVersionsFromRepositoryCreate = function(customModelId, customModelVersionCreateFromRepository = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsFromRepositoryCreateWithHttpInfo(customModelId, customModelVersionCreateFromRepository, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom model version from remote repository with files from previous version.
    #' Produces: NA
    #'
    #' @details Create a new custom model version with files added from a remote repository. Files from the previous version of a custom models will be used as a basis.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionCreateFromRepository \link{CustomModelVersionCreateFromRepository}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Accepted: request placed to a queue for processing.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Custom Model version cannot be created: (1) input parameters are invalid, (2) if user does not have permission to create legacy conversion environment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionCreateFromRepository <- CustomModelVersionCreateFromRepository$new() # CustomModelVersionCreateFromRepository |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsFromRepositoryPatchMany(customModelId, customModelVersionCreateFromRepository=customModelVersionCreateFromRepository)
    #' }
    CustomModelsVersionsFromRepositoryPatchMany = function(customModelId, customModelVersionCreateFromRepository = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsFromRepositoryPatchManyWithHttpInfo(customModelId, customModelVersionCreateFromRepository, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom model versions.
    #' Produces: "application/json"
    #'
    #' @details List custom model versions.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelId character. ID of the custom model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelVersionListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' \item **`400`** Query parameters are invalid.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsList(offset, limit, customModelId)
    #' }
    CustomModelsVersionsList = function(offset, limit, customModelId, ...) {
      apiResponse <- private$CustomModelsVersionsListWithHttpInfo(offset, limit, customModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update custom model version.
    #' Produces: "application/json"
    #'
    #' @details Edit metadata of a specific model version.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param customModelVersionMetadataUpdate \link{CustomModelVersionMetadataUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The edit was successful.
    #' \itemize{
    #' }
    #' \item **`404`** Custom model not found or user does not have edit permissions.
    #' \itemize{
    #' }
    #' \item **`422`** Cannot update custom model metadata.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #' customModelVersionMetadataUpdate <- CustomModelVersionMetadataUpdate$new() # CustomModelVersionMetadataUpdate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsPatch(customModelId, customModelVersionId, customModelVersionMetadataUpdate=customModelVersionMetadataUpdate)
    #' }
    CustomModelsVersionsPatch = function(customModelId, customModelVersionId, customModelVersionMetadataUpdate = NULL, ...) {
      apiResponse <- private$CustomModelsVersionsPatchWithHttpInfo(customModelId, customModelVersionId, customModelVersionMetadataUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new prediction explanations initialization for custom model version.
    #' Produces: NA
    #'
    #' @details Create a new prediction explanations initialization for custom model version. This is a necessary prerequisite for generating prediction explanations.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** URL to poll to track the prediction explanation initialization has finished.
    #' }
    #' \item **`422`** Specified custom model is not valid for prediction explanations.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsPredictionExplanationsInitializationCreate(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsPredictionExplanationsInitializationCreate = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsPredictionExplanationsInitializationCreateWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom model version.
    #' Produces: "application/json"
    #'
    #' @details Display a requested version of a custom model along with the files attached to it.
    #' @param customModelId character. ID of the custom model.
    #' @param customModelVersionId character. ID of the custom model version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomModelVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customModelId <- 'customModelId_example' # character | ID of the custom model.
    #' customModelVersionId <- 'customModelVersionId_example' # character | ID of the custom model version.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomModelsVersionsRetrieve(customModelId, customModelVersionId)
    #' }
    CustomModelsVersionsRetrieve = function(customModelId, customModelVersionId, ...) {
      apiResponse <- private$CustomModelsVersionsRetrieveWithHttpInfo(customModelId, customModelVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a blueprint from a single custom training estimator.
    #' Produces: "application/json"
    #'
    #' @details This route creates a blueprint from a custom training estimator with an environment so that it can be trained via blueprint ID.
    #' @param customTrainingBlueprintCreate \link{CustomTrainingBlueprintCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTrainingBlueprintResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Blueprint successfully created.
    #' \itemize{
    #' }
    #' \item **`404`** Any of the entities in the request cannot be retrieved.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid: either the custom model is for inference or no environment version ID was specified and the given environment has no versions.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTrainingBlueprintCreate <- CustomTrainingBlueprintCreate$new() # CustomTrainingBlueprintCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomTrainingBlueprintsCreate(customTrainingBlueprintCreate=customTrainingBlueprintCreate)
    #' }
    CustomTrainingBlueprintsCreate = function(customTrainingBlueprintCreate = NULL, ...) {
      apiResponse <- private$CustomTrainingBlueprintsCreateWithHttpInfo(customTrainingBlueprintCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List training blueprints.
    #' Produces: "application/json"
    #'
    #' @details List custom training blueprints.  This route retrieves the metadata for all custom training blueprints             a user has access to.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customModelId character. List blueprints for a specific model. Default: all.
    #' @param reverse Enum < [false, False, true, True] > List blueprints in reverse order.
    #' @param targetTypes Enum < [Binary, Regression, Multiclass, Anomaly, Transform, Unstructured] > Custom model target types to return.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTrainingBlueprintListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Custom training blueprint list returned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customModelId <- 'customModelId_example' # character | List blueprints for a specific model. Default: all.
    #' reverse <- "False" # character | List blueprints in reverse order.
    #' targetTypes <- ['targetTypes_example'] # array[character] | Custom model target types to return.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$CustomTrainingBlueprintsList(offset, limit, customModelId=customModelId, reverse=reverse, targetTypes=targetTypes)
    #' }
    CustomTrainingBlueprintsList = function(offset, limit, customModelId = NULL, reverse = "False", targetTypes = NULL, ...) {
      apiResponse <- private$CustomTrainingBlueprintsListWithHttpInfo(offset, limit, customModelId, reverse, targetTypes, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create model export job
    #' Produces: NA
    #'
    #' @details Create model export job. Note: Export of User and Open-Source models (and blenders including these models) is not supported at the moment.
    #' @param modelExport \link{ModelExport}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`**
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** You do not have permissions on this project to manage models
    #' \itemize{
    #' }
    #' \item **`422`** Model export is not supported in selected models.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' modelExport <- ModelExport$new() # ModelExport |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelExportsCreate(modelExport=modelExport)
    #' }
    ModelExportsCreate = function(modelExport = NULL, ...) {
      apiResponse <- private$ModelExportsCreateWithHttpInfo(modelExport, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Archive a model package.
    #' Produces: NA
    #'
    #' @details Permanently archive a model package. It will no longer be able to be used in new deployments or replacement. It will not be accessible in the model package list api. It will only be accessible at the model package retrieve route for this model package.
    #' @param modelPackageId character. ID of the model package.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesArchiveCreate(modelPackageId)
    #' }
    ModelPackagesArchiveCreate = function(modelPackageId, ...) {
      apiResponse <- private$ModelPackagesArchiveCreateWithHttpInfo(modelPackageId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature list.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the feature list for given model package.
    #' @param offset integer. The number of features to skip, defaults to 0.
    #' @param limit integer. The number of features to return, defaults to 0.
    #' @param modelPackageId character. ID of the model package.
    #' @param includeNonPredictionFeatures Enum < [false, False, true, True] > When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
    #' @param forSegmentedAnalysis Enum < [false, False, true, True] > When True, features returned will be filtered to those usable for segmented analysis.
    #' @param search character. Case insensitive search against names of the deployment&#39;s features.
    #' @param orderBy Enum < [name, -name, importance, -importance, featureType, -featureType, dateFormat, -dateFormat, knownInAdvance, -knownInAdvance] > Sort order which will be applied to model package feature list. Prefix the attribute name with a dash to sort in descending order, e.g. \&quot;-name\&quot;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of features to skip, defaults to 0.
    #' limit <- 50 # integer | The number of features to return, defaults to 0.
    #' modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
    #' includeNonPredictionFeatures <- "false" # character | When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
    #' forSegmentedAnalysis <- "false" # character | When True, features returned will be filtered to those usable for segmented analysis.
    #' search <- 'search_example' # character | Case insensitive search against names of the deployment's features.
    #' orderBy <- 'orderBy_example' # character | Sort order which will be applied to model package feature list. Prefix the attribute name with a dash to sort in descending order, e.g. \"-name\".
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesFeaturesList(offset, limit, modelPackageId, includeNonPredictionFeatures=includeNonPredictionFeatures, forSegmentedAnalysis=forSegmentedAnalysis, search=search, orderBy=orderBy)
    #' }
    ModelPackagesFeaturesList = function(offset, limit, modelPackageId, includeNonPredictionFeatures = "false", forSegmentedAnalysis = "false", search = NULL, orderBy = NULL, ...) {
      apiResponse <- private$ModelPackagesFeaturesListWithHttpInfo(offset, limit, modelPackageId, includeNonPredictionFeatures, forSegmentedAnalysis, search, orderBy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create model package from DataRobot model.
    #' Produces: NA
    #'
    #' @details Create model package from DataRobot model.
    #' @param modelPackageCreateFromLearningModel \link{ModelPackageCreateFromLearningModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`**
    #' \itemize{
    #' }
    #' \item **`403`** The user does not have permission to create a Model Package.
    #' \itemize{
    #' }
    #' \item **`404`** Either the model_id not exist or the user does not have permission to view the model and project.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the Model Package creation request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' modelPackageCreateFromLearningModel <- ModelPackageCreateFromLearningModel$new() # ModelPackageCreateFromLearningModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesFromLearningModelCreate(modelPackageCreateFromLearningModel=modelPackageCreateFromLearningModel)
    #' }
    ModelPackagesFromLearningModelCreate = function(modelPackageCreateFromLearningModel = NULL, ...) {
      apiResponse <- private$ModelPackagesFromLearningModelCreateWithHttpInfo(modelPackageCreateFromLearningModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List model packages
    #' Produces: "application/json"
    #'
    #' @details Retrieve the list of model packages a user has access to.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param modelId character. If specified, limit results to model packages for the model with the specified ID.
    #' @param similarTo character. Return model packages similar to a given model package ID. If used, will only return model packages that match &#x60;target.name&#x60;, &#x60;target.type&#x60;, &#x60;target.classNames&#x60; (for classification models), &#x60;modelKind.isTimeSeries&#x60;, and &#x60;modelKind.isMultiseries&#x60; of the specified model package.
    #' @param forChallenger character. Can be used with similarTo to request similar model packages with the intent to use them as challenger models; for external model packages, instead of returning similar external model packages, similar DataRobot and Custom model packages will be retrieved.
    #' @param search character. Provide a term to search for in package name, model name, or description
    #' @param predictionThreshold numeric. Prediction threshold used for binary classification models
    #' @param imported character. If specified, filter for either imported (true) or non-imported (false) model packages
    #' @param predictionEnvironmentId character. Can be used to filter packages by what is supported by the prediction environment
    #' @param modelKind \link{OneOfstringarray}. Return models from the registry that match a specific format.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelPackageListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Either MMM Model Packages or New Model Registry are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** User permissions problem.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' modelId <- 'modelId_example' # character | If specified, limit results to model packages for the model with the specified ID.
    #' similarTo <- 'similarTo_example' # character | Return model packages similar to a given model package ID. If used, will only return model packages that match `target.name`, `target.type`, `target.classNames` (for classification models), `modelKind.isTimeSeries`, and `modelKind.isMultiseries` of the specified model package.
    #' forChallenger <- 'forChallenger_example' # character | Can be used with similarTo to request similar model packages with the intent to use them as challenger models; for external model packages, instead of returning similar external model packages, similar DataRobot and Custom model packages will be retrieved.
    #' search <- 'search_example' # character | Provide a term to search for in package name, model name, or description
    #' predictionThreshold <- 3.4 # numeric | Prediction threshold used for binary classification models
    #' imported <- 'imported_example' # character | If specified, filter for either imported (true) or non-imported (false) model packages
    #' predictionEnvironmentId <- 'predictionEnvironmentId_example' # character | Can be used to filter packages by what is supported by the prediction environment
    #' modelKind <- OneOfstringarray$new() # OneOfstringarray | Return models from the registry that match a specific format.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesList(offset=offset, limit=limit, modelId=modelId, similarTo=similarTo, forChallenger=forChallenger, search=search, predictionThreshold=predictionThreshold, imported=imported, predictionEnvironmentId=predictionEnvironmentId, modelKind=modelKind)
    #' }
    ModelPackagesList = function(offset = 0, limit = 100, modelId = NULL, similarTo = NULL, forChallenger = NULL, search = NULL, predictionThreshold = NULL, imported = NULL, predictionEnvironmentId = NULL, modelKind = NULL, ...) {
      apiResponse <- private$ModelPackagesListWithHttpInfo(offset, limit, modelId, similarTo, forChallenger, search, predictionThreshold, imported, predictionEnvironmentId, modelKind, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve info about a model package.
    #' Produces: "application/json"
    #'
    #' @details Retrieve info about a model package.
    #' @param modelPackageId character. ID of the model package.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelPackageRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Either the model package does not exist or the user does not have permission to view the model package.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesRetrieve(modelPackageId)
    #' }
    ModelPackagesRetrieve = function(modelPackageId, ...) {
      apiResponse <- private$ModelPackagesRetrieveWithHttpInfo(modelPackageId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get model package&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations who have access to this template and their roles on the template.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param modelPackageId character. ID of the model package.
    #' @param id character. Only return roles for a user, group or organization with this identifier.
    #' @param name character. Only return roles for a user, group or organization with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > List access controls for recipients with this type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharingListV2Response}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The model package&#39;s access control list.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Either the Model Package does not exist or the user does not have permissions to view the Model Package.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 10 # integer | At most this many results are returned
    #' modelPackageId <- 'modelPackageId_example' # character | ID of the model package.
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ModelPackagesSharedRolesList(offset, limit, modelPackageId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    ModelPackagesSharedRolesList = function(offset, limit, modelPackageId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$ModelPackagesSharedRolesListWithHttpInfo(offset, limit, modelPackageId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create blenders using the blender builder system.
    #' Produces: NA
    #'
    #' @details Create a blender builder job, which will create one or more blenders.  The CORRELATION     method uses a combination of model accuracy score along with correlation between models to     select models for blending.  The VALIDATION method uses the raw model accuracy scores, but     can be useful for creating different types of blenders with those models.
    #' @param projectId character. The project ID
    #' @param baseBlenderBuilderCreate \link{BaseBlenderBuilderCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of blenderbuilder IDs
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' baseBlenderBuilderCreate <- BaseBlenderBuilderCreate$new() # BaseBlenderBuilderCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderBuildersCreate(projectId, baseBlenderBuilderCreate=baseBlenderBuilderCreate)
    #' }
    ProjectsBlenderBuildersCreate = function(projectId, baseBlenderBuilderCreate = NULL, ...) {
      apiResponse <- private$ProjectsBlenderBuildersCreateWithHttpInfo(projectId, baseBlenderBuilderCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get information about all blender builder jobs associated with the project.
    #' Produces: NA
    #'
    #' @details Get information about all blender builder jobs associated with the project.
    #' @param projectId character. The project ID that the blender builder is associated with.
    #' @param offset integer. The maximum number of blender builder job records to return
    #' @param limit integer. pagination offset
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of blender builder job IDs in the project
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
    #' offset <- 0 # integer | The maximum number of blender builder job records to return
    #' limit <- 100 # integer | pagination offset
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderBuildersList(projectId, offset, limit)
    #' }
    ProjectsBlenderBuildersList = function(projectId, offset, limit, ...) {
      apiResponse <- private$ProjectsBlenderBuildersListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get information about a completed blender builder job.
    #' Produces: NA
    #'
    #' @details Get information about a completed blender builder job.
    #' @param projectId character. The project ID that the blender builder is associated with.
    #' @param buildId character. The ID of the blender builder job to get data for.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Blender builder job result
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID that the blender builder is associated with.
    #' buildId <- 'buildId_example' # character | The ID of the blender builder job to get data for.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderBuildersRetrieve(projectId, buildId)
    #' }
    ProjectsBlenderBuildersRetrieve = function(projectId, buildId, ...) {
      apiResponse <- private$ProjectsBlenderBuildersRetrieveWithHttpInfo(projectId, buildId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Check if models can be blended.
    #' Produces: "application/json"
    #'
    #' @details Check if models can be blended.
    #' @param projectId character. The project ID
    #' @param blenderCreate \link{BlenderCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BlenderInfoRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Information on whether models can be blended and why.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' blenderCreate <- BlenderCreate$new() # BlenderCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderModelsBlendCheckCreate(projectId, blenderCreate=blenderCreate)
    #' }
    ProjectsBlenderModelsBlendCheckCreate = function(projectId, blenderCreate = NULL, ...) {
      apiResponse <- private$ProjectsBlenderModelsBlendCheckCreateWithHttpInfo(projectId, blenderCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a blender from other models using a specified blender method.
    #' Produces: NA
    #'
    #' @details Create a blender from other models using a specified blender method. Note: Time Series projects only allow the following blender methods: \&quot;AVG\&quot;, \&quot;MED\&quot;, \&quot;FORECAST_DISTANCE_ENET\&quot;, and \&quot;FORECAST_DISTANCE_AVG\&quot;.
    #' @param projectId character. The project ID
    #' @param blenderCreate \link{BlenderCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Model job successfully added to queue. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status of the job.
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to create a blender or request is not supported in this context.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' blenderCreate <- BlenderCreate$new() # BlenderCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderModelsCreate(projectId, blenderCreate=blenderCreate)
    #' }
    ProjectsBlenderModelsCreate = function(projectId, blenderCreate = NULL, ...) {
      apiResponse <- private$ProjectsBlenderModelsCreateWithHttpInfo(projectId, blenderCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all blenders in a project.
    #' Produces: "application/json"
    #'
    #' @details List all blenders in a project.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BlenderListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of all of the blenders in a project.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderModelsList(offset, limit, projectId)
    #' }
    ProjectsBlenderModelsList = function(offset, limit, projectId, ...) {
      apiResponse <- private$ProjectsBlenderModelsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a blender.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a blender. Blenders are a special type of models, so the response includes all attributes that would be in a response to :http:get:&#x60;/api/v2/projects/(projectId)/models/(modelId)/&#x60; as well as some additional ones.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BlenderRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The blender model.
    #' \itemize{
    #' }
    #' \item **`404`** Specified blender not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsBlenderModelsRetrieve(projectId, modelId)
    #' }
    ProjectsBlenderModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsBlenderModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all existing combined models for this project.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all existing combined models for this project. .. note::      To retrieve information on the segments for a combined model, retrieve the combined model using :http:get:&#x60;/api/v2/projects/(projectId)/combinedModels/(combinedModelId)/&#x60;
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CombinedModelListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsCombinedModelsList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsCombinedModelsList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsCombinedModelsListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve an existing combined model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve an existing combined model. If available, contains information on which champion model is used for each segment.
    #' @param projectId character. The ID of the project.
    #' @param combinedModelId character. The ID of combined model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CombinedModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project.
    #' combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsCombinedModelsRetrieve(projectId, combinedModelId)
    #' }
    ProjectsCombinedModelsRetrieve = function(projectId, combinedModelId, ...) {
      apiResponse <- private$ProjectsCombinedModelsRetrieveWithHttpInfo(projectId, combinedModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download Combined Model segments info.
    #' Produces: "text/csv"
    #'
    #' @details Download Combined Model segments info (name, related project &amp; model details) as a CSV.
    #' @param projectId character. The ID of the project.
    #' @param combinedModelId character. The ID of combined model.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project.
    #' combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsCombinedModelsSegmentsDownloadList(projectId, combinedModelId)
    #' }
    ProjectsCombinedModelsSegmentsDownloadList = function(projectId, combinedModelId, ...) {
      apiResponse <- private$ProjectsCombinedModelsSegmentsDownloadListWithHttpInfo(projectId, combinedModelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Combined Model segments info.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Combined Model segments info (name, related project &amp; model details).
    #' @param projectId character. The ID of the project.
    #' @param combinedModelId character. The ID of combined model.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param searchSegmentName character. Case insensitive search against segment name.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CombinedModelSegmentsPaginatedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project.
    #' combinedModelId <- 'combinedModelId_example' # character | The ID of combined model.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' searchSegmentName <- 'searchSegmentName_example' # character | Case insensitive search against segment name.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsCombinedModelsSegmentsList(projectId, combinedModelId, offset=offset, limit=limit, searchSegmentName=searchSegmentName)
    #' }
    ProjectsCombinedModelsSegmentsList = function(projectId, combinedModelId, offset = 0, limit = 100, searchSegmentName = NULL, ...) {
      apiResponse <- private$ProjectsCombinedModelsSegmentsListWithHttpInfo(projectId, combinedModelId, offset, limit, searchSegmentName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Score all the available backtests of a datetime model.
    #' Produces: NA
    #'
    #' @details Score all the available backtests of a datetime model.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Scoring of all the available backtests of a datetime model has been successfully requested.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsBacktestsCreate(projectId, modelId)
    #' }
    ProjectsDatetimeModelsBacktestsCreate = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsBacktestsCreateWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Train a new datetime model.
    #' Produces: "application/json"
    #'
    #' @details Train a new datetime model.  All durations and datetimes should be specified in accordance with the :ref:&#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.
    #' @param projectId character. The project ID
    #' @param trainDatetimeModel \link{TrainDatetimeModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeModelSubmissionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The model has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** There was an error submitting the specified job. See the &#x60;message&#x60; field for more details.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' trainDatetimeModel <- TrainDatetimeModel$new() # TrainDatetimeModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsCreate(projectId, trainDatetimeModel=trainDatetimeModel)
    #' }
    ProjectsDatetimeModelsCreate = function(projectId, trainDatetimeModel = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsCreateWithHttpInfo(projectId, trainDatetimeModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrain an existing datetime model with specified parameters.
    #' Produces: "application/json"
    #'
    #' @details Retrain an existing datetime model using a new training period for the model training set (with optional time window sampling) or different feature list.  All durations and datetimes should be specified in accordance with the :ref:&#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.  Note that only one of &#x60;trainingDuration&#x60; or &#x60;trainingRowCount&#x60; or &#x60;trainingStartDate&#x60; and &#x60;trainingEndDate&#x60; should be specified. If &#x60;trainingStartDate&#x60; and &#x60;trainingEndDate&#x60; are specified, the source model must be frozen.
    #' @param projectId character. The project ID
    #' @param retrainDatetimeModel \link{RetrainDatetimeModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeModelSubmissionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Retrain an existing datetime model using a new sample size and/or feature list.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permissions to manage models.
    #' \itemize{
    #' }
    #' \item **`404`** Model with specified &#x60;modelId&#x60; doesn&#39;t exist, or user does not have access to the project.
    #' \itemize{
    #' }
    #' \item **`422`** Model with specified &#x60;modelId&#x60; is deprecated, or it doesn&#39;t support retraining with specified parameters.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' retrainDatetimeModel <- RetrainDatetimeModel$new() # RetrainDatetimeModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFromModelCreate(projectId, retrainDatetimeModel=retrainDatetimeModel)
    #' }
    ProjectsDatetimeModelsFromModelCreate = function(projectId, retrainDatetimeModel = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFromModelCreateWithHttpInfo(projectId, retrainDatetimeModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List datetime partitioned project models
    #' Produces: "application/json"
    #'
    #' @details List all the models from a datetime partitioned project.
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param bulkOperationId character. the ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeModelsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The datetime partitioned project&#39;s models
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' bulkOperationId <- 'bulkOperationId_example' # character | the ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsList(projectId, offset=offset, limit=limit, bulkOperationId=bulkOperationId)
    #' }
    ProjectsDatetimeModelsList = function(projectId, offset = 0, limit = 100, bulkOperationId = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsListWithHttpInfo(projectId, offset, limit, bulkOperationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get datetime model
    #' Produces: "application/json"
    #'
    #' @details Look up a particular datetime model All durations and datetimes are specified in accordance with :ref:&#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeModelDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Datetime model
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsRetrieve(projectId, modelId)
    #' }
    ProjectsDatetimeModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Prepare a model for deployment
    #' Produces: NA
    #'
    #' @details Prepare a specific model for deployment. This model will go through the recommendation stages.
    #' @param projectId character. The project ID
    #' @param prepareForDeployment \link{PrepareForDeployment}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Start preparing the model for deployment.
    #' \itemize{
    #' }
    #' \item **`422`** An error occurred when submitting the model job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' prepareForDeployment <- PrepareForDeployment$new() # PrepareForDeployment |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsDeploymentReadyModelsCreate(projectId, prepareForDeployment=prepareForDeployment)
    #' }
    ProjectsDeploymentReadyModelsCreate = function(projectId, prepareForDeployment = NULL, ...) {
      apiResponse <- private$ProjectsDeploymentReadyModelsCreateWithHttpInfo(projectId, prepareForDeployment, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Eureqa model details plot.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Eureqa model details plot.  Available for classification projects only
    #' @param projectId character. The project ID
    #' @param solutionId character. The ID of the solution to return data for.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{EureqaDistributionDetailResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Eureqa model details plot.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsEureqaDistributionPlotRetrieve(projectId, solutionId)
    #' }
    ProjectsEureqaDistributionPlotRetrieve = function(projectId, solutionId, ...) {
      apiResponse <- private$ProjectsEureqaDistributionPlotRetrieveWithHttpInfo(projectId, solutionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Eureqa model details plot.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Eureqa model details plot.  Available for regression projects only
    #' @param projectId character. The project ID
    #' @param solutionId character. The ID of the solution to return data for.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{EureqaModelDetailResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Eureqa model details plot.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' solutionId <- 'solutionId_example' # character | The ID of the solution to return data for.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsEureqaModelDetailRetrieve(projectId, solutionId)
    #' }
    ProjectsEureqaModelDetailRetrieve = function(projectId, solutionId, ...) {
      apiResponse <- private$ProjectsEureqaModelDetailRetrieveWithHttpInfo(projectId, solutionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new model from an existing eureqa solution.
    #' Produces: NA
    #'
    #' @details Create a new model from an existing eureqa solution.
    #' @param projectId character. The project ID
    #' @param eureqaLeaderboardEntryPayload \link{EureqaLeaderboardEntryPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request accepted, creation is underway.
    #' \itemize{
    #' \item **`Location`** The location at which the new model can be retrieved.
    #' }
    #' \item **`404`** Data not found.
    #' \itemize{
    #' }
    #' \item **`422`** Model for this solution already exists.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' eureqaLeaderboardEntryPayload <- EureqaLeaderboardEntryPayload$new() # EureqaLeaderboardEntryPayload |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsEureqaModelsCreate(projectId, eureqaLeaderboardEntryPayload=eureqaLeaderboardEntryPayload)
    #' }
    ProjectsEureqaModelsCreate = function(projectId, eureqaLeaderboardEntryPayload = NULL, ...) {
      apiResponse <- private$ProjectsEureqaModelsCreateWithHttpInfo(projectId, eureqaLeaderboardEntryPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the pareto front for the specified Eureqa model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the pareto front for the specified Eureqa model.  Only the best solution in the pareto front will have a corresponding model initially. Models can be created for other solutions using :http:post:&#x60;/api/v2/projects/(projectId)/eureqaModels/&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ParetoFrontResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Pareto front for the Eureqa model.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsEureqaModelsRetrieve(projectId, modelId)
    #' }
    ProjectsEureqaModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsEureqaModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Train a frozen datetime model.
    #' Produces: "application/json"
    #'
    #' @details Train a frozen datetime model. If no training data is specified, the frozen datetime model will be trained on the most recent data using an amount of data that is equivalent to the original model. However, if the equivalent duration does not provide enough rows for training, then the duration will be extended until the minimum is met. Note that this will require the holdout of the project to be unlocked.  All durations and datetimes should be specified in accordance with the :ref:&#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.  Note that only one of &#x60;trainingDuration&#x60;, &#x60;trainingRowCount&#x60;, &#x60;trainingStartDate&#x60; and &#x60;trainingEndDate&#x60;, or &#x60;useProjectSettings&#x60; may be specified.
    #' @param projectId character. The project ID
    #' @param trainDatetimeFrozenModel \link{TrainDatetimeFrozenModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeModelSubmissionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The model has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permissions to manage models.
    #' \itemize{
    #' }
    #' \item **`404`** Model with specified &#x60;modelId&#x60; does not exist, or user does not have access to the project.
    #' \itemize{
    #' }
    #' \item **`422`** Model with specified &#x60;modelId&#x60; is deprecated, or it does not support retraining with specified parameters.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' trainDatetimeFrozenModel <- TrainDatetimeFrozenModel$new() # TrainDatetimeFrozenModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsFrozenDatetimeModelsCreate(projectId, trainDatetimeFrozenModel=trainDatetimeFrozenModel)
    #' }
    ProjectsFrozenDatetimeModelsCreate = function(projectId, trainDatetimeFrozenModel = NULL, ...) {
      apiResponse <- private$ProjectsFrozenDatetimeModelsCreateWithHttpInfo(projectId, trainDatetimeFrozenModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Train a new frozen model with parameters from an existing model.
    #' Produces: NA
    #'
    #' @details Train a new frozen model with parameters from an existing model. Frozen models use tuning parameters from another model on the leaderboard, allowing them to be retrained on a larger amount of the training data more efficiently.   To specify the amount of data to use to train the model, use either &#x60;samplePct&#x60; to express a percentage of the rows of the dataset to use or &#x60;trainingRowCount&#x60; to express the number of rows to use.   If neither &#x60;samplePct&#x60; or &#x60;trainingRowCount&#x60; is specified, the model will be trained on the maximum available training data that can be used to train an in-memory model.   For projects using smart sampling, &#x60;samplePct&#x60; and &#x60;trainingRowCount&#x60; will be interpreted as a percent or number of rows of the minority class.   When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64% of the data. Using actual integer row counts (or &#x60;project.max_training_rows&#x60;) avoids ambiguity around how many rows of data you want the model to use.
    #' @param projectId character. The project ID
    #' @param frozenModelCreate \link{FrozenModelCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The frozen model has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** Contains a url at which the job processing the model can be retrieved as with :http:get:&#x60;/api/v2/projects/(projectId)/modelJobs/(jobId)/&#x60;..
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' frozenModelCreate <- FrozenModelCreate$new() # FrozenModelCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsFrozenModelsCreate(projectId, frozenModelCreate=frozenModelCreate)
    #' }
    ProjectsFrozenModelsCreate = function(projectId, frozenModelCreate = NULL, ...) {
      apiResponse <- private$ProjectsFrozenModelsCreateWithHttpInfo(projectId, frozenModelCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all frozen models from a project.
    #' Produces: "application/json"
    #'
    #' @details List all frozen models from a project.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param projectId character. The project ID
    #' @param withMetric character. If specified, the returned models will only have scores for this metric.  If not, all metrics will be included.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FrozenModelListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of frozen models in the project.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' projectId <- 'projectId_example' # character | The project ID
    #' withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric.  If not, all metrics will be included.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsFrozenModelsList(offset, limit, projectId, withMetric=withMetric)
    #' }
    ProjectsFrozenModelsList = function(offset, limit, projectId, withMetric = NULL, ...) {
      apiResponse <- private$ProjectsFrozenModelsListWithHttpInfo(offset, limit, projectId, withMetric, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Look up a particular frozen model.
    #' Produces: "application/json"
    #'
    #' @details Look up a particular frozen model. If model with given ID exists but it&#39;s not frozen, returns 404 Not Found.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FrozenModelRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The frozen model.
    #' \itemize{
    #' }
    #' \item **`404`** No such frozen model found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsFrozenModelsRetrieve(projectId, modelId)
    #' }
    ProjectsFrozenModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsFrozenModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel a modeling job.
    #' Produces: NA
    #'
    #' @details Cancel a modeling job
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The job has been successfully cancelled.
    #' \itemize{
    #' }
    #' \item **`404`** no job with jobId found, or the job has already completed
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelJobsDelete(projectId, jobId)
    #' }
    ProjectsModelJobsDelete = function(projectId, jobId, ...) {
      apiResponse <- private$ProjectsModelJobsDeleteWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List modeling jobs
    #' Produces: "application/json"
    #'
    #' @details List modeling jobs.
    #' @param projectId character. The project ID.
    #' @param status Enum < [queue, inprogress, error] > If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{ModelingJobListResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of modeling jobs.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' status <- 'status_example' # character | If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelJobsList(projectId, status=status)
    #' }
    ProjectsModelJobsList = function(projectId, status = NULL, ...) {
      apiResponse <- private$ProjectsModelJobsListWithHttpInfo(projectId, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Look up a specific modeling job
    #' Produces: "application/json"
    #'
    #' @details Look up a particular modeling job
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A modeling job
    #' \itemize{
    #' \item **`Location`** if a status code 303 was returned, will contain a url at which the completed model can be retrieved&#x60;
    #' }
    #' \item **`303`** Task is completed, see Location header for the location of a new resource
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelJobsRetrieve(projectId, jobId)
    #' }
    ProjectsModelJobsRetrieve = function(projectId, jobId, ...) {
      apiResponse <- private$ProjectsModelJobsRetrieveWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Submit a job to make a new version of the model with different advanced tuning parameters.
    #' Produces: NA
    #'
    #' @details Submit a job to make a new version of the model with different advanced tuning parameters. Note: This route currently supports all models other than: OSS, blenders, prime, scaleout, baseline and user-created. Currently, only single-stage models (most simple models) are supported. Blueprints that run multiple steps, for example one step to predict zero vs nonzero and a second step to determine the value of nonzero predictions, are not supported. (:ref:&#x60;Advanced Tuning documentation &lt;grid_search&gt;&#x60;). Parameters may be omitted from this endpoint. If a parameter is omitted, its &#x60;currentValue&#x60; will be used. To see the possible parameter IDs and constraints on possible values, see :http:get:&#x60;/api/v2/projects/(projectId)/models/(modelId)/advancedTuning/parameters/&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param modelAdvancedTuning \link{ModelAdvancedTuning}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The job has been successfully submitted. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url at which the job processing the model can be retrieved.
    #' }
    #' \item **`403`** Permission denied creating advanced tuned model
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`413`** Tuning request is too large
    #' \itemize{
    #' }
    #' \item **`422`** Could not create new job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' modelAdvancedTuning <- ModelAdvancedTuning$new() # ModelAdvancedTuning |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsAdvancedTuningCreate(projectId, modelId, modelAdvancedTuning=modelAdvancedTuning)
    #' }
    ProjectsModelsAdvancedTuningCreate = function(projectId, modelId, modelAdvancedTuning = NULL, ...) {
      apiResponse <- private$ProjectsModelsAdvancedTuningCreateWithHttpInfo(projectId, modelId, modelAdvancedTuning, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve information about all advanced tuning parameters available for the specified model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve information about all advanced tuning parameters available for the specified model. Note: This route currently supports all models other than: OSS, blenders, prime, scaleout, baseline and user-created
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AdvancedTuningArgumentsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The information about all advanced tuning parameters available for the specified model.
    #' \itemize{
    #' }
    #' \item **`403`** Permission denied creating advanced tuned model.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** This model does not support advanced tuning.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsAdvancedTuningParametersList(projectId, modelId)
    #' }
    ProjectsModelsAdvancedTuningParametersList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsAdvancedTuningParametersListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve cluster names assigned to an unsupervised cluster model
    #' Produces: "application/json"
    #'
    #' @details Retrieve all cluster names assigned to an unsupervised cluster model
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ClusterNamesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve all cluster names for the model
    #' \itemize{
    #' }
    #' \item **`404`** Could not find unsupervised clustering model. Possible reasons include: 1. Provided model id points to a model that does not exist in specified project. 2. Provided model has incompatible type. Method requires model to be unsupervised clustering model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsClusterNamesList(projectId, modelId)
    #' }
    ProjectsModelsClusterNamesList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsClusterNamesListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update cluster names assigned to an unsupervised cluster model
    #' Produces: "application/json"
    #'
    #' @details Update and then retrieve all cluster names assigned to an unsupervised cluster model
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param clusterNamesUpdateParam \link{ClusterNamesUpdateParam}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ClusterNamesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Update cluster names and then retrieve all cluster names for the model
    #' \itemize{
    #' }
    #' \item **`404`** Could not find unsupervised clustering model. Possible reasons include: 1. Provided model id points to a model which does not exists in specified project. 2. Provided model has incompatible type. Method requires model to be unsupervised clustering model.
    #' \itemize{
    #' }
    #' \item **`422`** The request cannot be processed. Possible reasons include: 1. Mapping contains invalid current cluster name and referenced cluster was not found. 2. Mapping is invalid as after update, clusters will not be uniquely identifiable by name.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' clusterNamesUpdateParam <- ClusterNamesUpdateParam$new() # ClusterNamesUpdateParam |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsClusterNamesPatchMany(projectId, modelId, clusterNamesUpdateParam=clusterNamesUpdateParam)
    #' }
    ProjectsModelsClusterNamesPatchMany = function(projectId, modelId, clusterNamesUpdateParam = NULL, ...) {
      apiResponse <- private$ProjectsModelsClusterNamesPatchManyWithHttpInfo(projectId, modelId, clusterNamesUpdateParam, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Train a new model
    #' Produces: NA
    #'
    #' @details Train a new model. To specify the amount of data to use to train the model, use either &#x60;samplePct&#x60; to express a percentage of the rows of the dataset to use or &#x60;trainingRowCount&#x60; to express the number of rows to use. If neither &#x60;samplePct&#x60; or &#x60;trainingRowCount&#x60; is specified, the model will be trained on the maximum available training data that can be used to train an in-memory model. For projects using smart sampling, samplePct and trainingRowCount will be interpreted as a percent or number of rows of the minority class.   When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64% of the data. Using actual integer row counts (or &#x60;project.max_training_rows&#x60;) avoids ambiguity around how many rows of data you want the model to use.
    #' @param projectId character. The project ID.
    #' @param trainModel \link{TrainModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** Could not create new job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' trainModel <- TrainModel$new() # TrainModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsCreate(projectId, trainModel=trainModel)
    #' }
    ProjectsModelsCreate = function(projectId, trainModel = NULL, ...) {
      apiResponse <- private$ProjectsModelsCreateWithHttpInfo(projectId, trainModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Run Cross Validation on a model.
    #' Produces: NA
    #'
    #' @details Run Cross Validation on a model.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The model has been successfully submitted.
    #' \itemize{
    #' \item **`Location`** Contains a url at which the job processing the model can be retrieved
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' body <- NULL # object |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsCrossValidationCreate(projectId, modelId, body=body)
    #' }
    ProjectsModelsCrossValidationCreate = function(projectId, modelId, body = NULL, ...) {
      apiResponse <- private$ProjectsModelsCrossValidationCreateWithHttpInfo(projectId, modelId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get Cross Validation scores for each partition in a model.
    #' Produces: "application/json"
    #'
    #' @details          Get Cross Validation scores for each partition in a model.         .. note:: Individual partition scores are only available for newer models; older models that                   have cross validation score calculated will need to be retrained.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param metric character. Set to the name of a metric to only return results for that metric.
    #' @param partition numeric. Set to a value such as 1.0, 2.0 to only return results for the specified partition.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CrossValidationRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The Cross Validation scores for each partition in a model.
    #' \itemize{
    #' }
    #' \item **`404`** Not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' metric <- 'metric_example' # character | Set to the name of a metric to only return results for that metric.
    #' partition <- 3.4 # numeric | Set to a value such as 1.0, 2.0 to only return results for the specified partition.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsCrossValidationScoresList(projectId, modelId, metric=metric, partition=partition)
    #' }
    ProjectsModelsCrossValidationScoresList = function(projectId, modelId, metric = NULL, partition = NULL, ...) {
      apiResponse <- private$ProjectsModelsCrossValidationScoresListWithHttpInfo(projectId, modelId, metric, partition, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a model from the leaderboard.
    #' Produces: NA
    #'
    #' @details Delete a model from the leaderboard
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The model has been successfully deleted.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsDelete(projectId, modelId)
    #' }
    ProjectsModelsDelete = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsDeleteWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download exported model
    #' Produces: NA
    #'
    #' @details Download exported model
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' \item **`ContentMinusDisposition`** &#x60;attachment;filename&#x3D;&lt;filename&gt;.drx&#x60;. The filename is dynamically generated.
    #' \item **`ContentMinusType`** &#x60;application/octet-stream&#x60;
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsExportList(projectId, modelId)
    #' }
    ProjectsModelsExportList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsExportListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the features used in a model.
    #' Produces: "application/json"
    #'
    #' @details List the features used in a model
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelFeatureListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The features used in a model.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsFeaturesList(projectId, modelId)
    #' }
    ProjectsModelsFeaturesList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsFeaturesListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrain a model
    #' Produces: "application/json"
    #'
    #' @details Retrain an existing model using a new sample size and/or feature list.When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64% of the data. Using actual integer row counts (or &#x60;project.max_training_rows&#x60;) avoids ambiguity around how many rows of data you want the model to use. Note that only one of &#x60;samplePct&#x60; or &#x60;trainingRowCount&#x60; should be specified.
    #' @param projectId character. The project ID
    #' @param retrainModel \link{RetrainModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelRetrainResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Retrain an existing model using a new sample size and/or feature list.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** model with specified &#x60;modelId&#x60; is deprecated, or it doesn&#39;t support retraining using a new sample size and/or feature list
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' retrainModel <- RetrainModel$new() # RetrainModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsFromModelCreate(projectId, retrainModel=retrainModel)
    #' }
    ProjectsModelsFromModelCreate = function(projectId, retrainModel = NULL, ...) {
      apiResponse <- private$ProjectsModelsFromModelCreateWithHttpInfo(projectId, retrainModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List project models
    #' Produces: "application/json"
    #'
    #' @details Lists all the models from a project.
    #' @param projectId character. The project ID.
    #' @param bulkOperationId character. The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #' @param orderBy Enum < [metric, -metric, samplePct, -samplePct] > A comma-separated list of metrics to sort by. If metric is prefixed with a &#39;-&#39;, models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are &#x60;metric&#x60; and &#x60;samplePct&#x60;. &#x60;metric&#x60; will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so &#x60;-metric&#x60; will sort in order of decreasing &#39;goodness&#39;, which may be opposite to the natural numerical order. If not specified, &#x60;-metric&#x60; will be used.
    #' @param name character. If specified, will filter for models with model type matching &#x60;name&#x60;
    #' @param samplePct numeric. If specified, will filter for models with matching sample percentage
    #' @param withMetric character. If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
    #' @param isStarred Enum < [false, False, true, True] > If specified, will filter for models marked as starred.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{ModelDetailsResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project&#39;s models
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #' orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
    #' name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
    #' samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
    #' withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
    #' isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
    #' }
    ProjectsModelsList = function(projectId, bulkOperationId = NULL, orderBy = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
      apiResponse <- private$ProjectsModelsListWithHttpInfo(projectId, bulkOperationId, orderBy, name, samplePct, withMetric, isStarred, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a summary of how the model&#39;s subtasks handle missing values.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a summary of how the model&#39;s subtasks handle missing values         Only models built after the missing value report feature was added will have reports,         and only models with at least one imputation or encoding task, e.g. ordinal encoding,         missing value imputation. Blenders and scaleout models do not support Missing Value reports.          The report will describe how each feature&#39;s missing values were treated, and report how many         missing values were present in the training data. Features which were not processed by a         given blueprint task will not mention it: for instance, a categorical feature with many         unique values may not be considered eligible for processing by a One-Hot Encoding          Report is collected for those features which are considered eligible by given         blueprint task. For instance, categorical feature with a lot of unique values may not be         considered as eligible in One-Hot Encoding task.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MissingReportRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a summary of how the model&#39;s subtasks handle missing values.
    #' \itemize{
    #' }
    #' \item **`404`** Could not found missing value report for provided project &amp; model id.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsMissingReportList(projectId, modelId)
    #' }
    ProjectsModelsMissingReportList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsMissingReportListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get number of iterations trained
    #' Produces: "application/json"
    #'
    #' @details Retrieve the actual number of iterations or estimators trained by a tree-based early stopping model.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{NumIterationsTrainedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The number of estimators/iterations trained
    #' \itemize{
    #' }
    #' \item **`404`** Cannot retrieve early stopping information for this model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsNumIterationsTrainedList(projectId, modelId)
    #' }
    ProjectsModelsNumIterationsTrainedList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsNumIterationsTrainedListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve model parameters.
    #' Produces: "application/json"
    #'
    #' @details Retrieve model parameters. These are the parameters that appear in the webapp on the &#x60;Coefficients&#x60; tab. Note that they are only available for some models.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelParametersRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The parameters of the model.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsParametersList(projectId, modelId)
    #' }
    ProjectsModelsParametersList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsParametersListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Updates a model&#39;s attribute(s).
    #' Produces: NA
    #'
    #' @details Updates a model&#39;s attribute(s)
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param modelUpdate \link{ModelUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The model has been successfully updated with new attributes.
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' modelUpdate <- ModelUpdate$new() # ModelUpdate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPatch(projectId, modelId, modelUpdate=modelUpdate)
    #' }
    ProjectsModelsPatch = function(projectId, modelId, modelUpdate = NULL, ...) {
      apiResponse <- private$ProjectsModelsPatchWithHttpInfo(projectId, modelId, modelUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Calculate prediction intervals for the specified percentiles for this model.
    #' Produces: "application/json"
    #'
    #' @details Submit a job to calculate prediction intervals for the specified percentiles for this model.  Note that the project this model belongs to must be a time series project.
    #' @param projectId character. The project to calculate prediction intervals for. Must be a time series project.
    #' @param modelId character. The model to calculate prediction intervals for.
    #' @param predictionIntervalsCreate \link{PredictionIntervalsCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionIntervalsCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job was successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to calculate prediction intervals for. Must be a time series project.
    #' modelId <- 'modelId_example' # character | The model to calculate prediction intervals for.
    #' predictionIntervalsCreate <- PredictionIntervalsCreate$new() # PredictionIntervalsCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionIntervalsCreate(projectId, modelId, predictionIntervalsCreate=predictionIntervalsCreate)
    #' }
    ProjectsModelsPredictionIntervalsCreate = function(projectId, modelId, predictionIntervalsCreate = NULL, ...) {
      apiResponse <- private$ProjectsModelsPredictionIntervalsCreateWithHttpInfo(projectId, modelId, predictionIntervalsCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve prediction intervals that are already calculated for this model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve prediction intervals (in descending order) that are already calculated for this model. Note that the project this model belongs to must be a time series project.
    #' @param projectId character. The project to retrieve prediction intervals for. Must be a time series project.
    #' @param modelId character. The model to retrieve prediction intervals for.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionIntervalsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve prediction intervals for. Must be a time series project.
    #' modelId <- 'modelId_example' # character | The model to retrieve prediction intervals for.
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionIntervalsList(projectId, modelId, offset=offset, limit=limit)
    #' }
    ProjectsModelsPredictionIntervalsList = function(projectId, modelId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsModelsPredictionIntervalsListWithHttpInfo(projectId, modelId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Check a Model for Prime Eligibility
    #' Produces: "application/json"
    #'
    #' @details Check if a model can be approximated by DataRobot Prime
    #' @param projectId character. the project the model belongs to
    #' @param modelId character. the model to check
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PrimeInfoRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the model belongs to
    #' modelId <- 'modelId_example' # character | the model to check
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPrimeInfoList(projectId, modelId)
    #' }
    ProjectsModelsPrimeInfoList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsPrimeInfoListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create Rulesets
    #' Produces: NA
    #'
    #' @details Approximate an existing model on the leaderboard with DataRobot Prime. A request body should be an empty JSON {}
    #' @param projectId character. the project the model to approximate belongs to
    #' @param modelId character. the model to approximate
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was understood and accepted, and is now being worked on. See the Location header
    #' \itemize{
    #' \item **`Location`** a url that can be polled to check the status of the job
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the model to approximate belongs to
    #' modelId <- 'modelId_example' # character | the model to approximate
    #' body <- NULL # object |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPrimeRulesetsCreate(projectId, modelId, body=body)
    #' }
    ProjectsModelsPrimeRulesetsCreate = function(projectId, modelId, body = NULL, ...) {
      apiResponse <- private$ProjectsModelsPrimeRulesetsCreateWithHttpInfo(projectId, modelId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Rulesets
    #' Produces: "application/json"
    #'
    #' @details List all the rulesets approximating a model  When rulesets are created for the parent model, all of the rulesets are created at once, but not all rulesets have corresponding Prime models (until they are directly requested).
    #' @param projectId character. the project the model belongs to
    #' @param modelId character. the model to find approximating rulesets for
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{PrimeRulesetsListResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the model belongs to
    #' modelId <- 'modelId_example' # character | the model to find approximating rulesets for
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsPrimeRulesetsList(projectId, modelId)
    #' }
    ProjectsModelsPrimeRulesetsList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsPrimeRulesetsListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get model
    #' Produces: "application/json"
    #'
    #' @details Look up a particular model.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The model
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsRetrieve(projectId, modelId)
    #' }
    ProjectsModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Scoring Code
    #' Produces: NA
    #'
    #' @details Retrieve Scoring Code for making new predictions from an existing model offline. You need the \&quot;Scoring Code\&quot; feature enabled to use this route.  By default, returns a compiled executable JAR that can be executed locally to calculate model predictions, or it can be used as a library for a Java application. Execute it with the &#39;--help&#x60; parameters to learn how to use it as a command-line utility. See model API documentation (https://javadoc.io/doc/com.datarobot/datarobot-prediction/latest/index.html) to be able to use it inside an existing Java application.  With the sourceCode query parameter set to &#39;true&#39;, returns a source code archive that can be used to review internal calculations of the model. This JAR is NOT executable.  See \&quot;https://app.datarobot.com/docs/predictions/scoring-code/scorecode.html\&quot; in DataRobot application for more information.
    #' @param projectId character. the project that created the model
    #' @param modelId character. the model to use
    #' @param sourceCode Enum < [false, False, true, True] > If set to \&quot;true\&quot;, the downloaded JAR file will contain only the source code and will not be executable.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** JAR file
    #' \itemize{
    #' \item **`ContentMinusDisposition`** attachment; filename&#x3D;\&quot;&lt;\&quot;filename\&quot;&gt;\&quot;.jar The suggested filename for the scoring code is dynamically generated
    #' \item **`ContentMinusType`** application/java-archive
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that created the model
    #' modelId <- 'modelId_example' # character | the model to use
    #' sourceCode <- "false" # character | If set to \"true\", the downloaded JAR file will contain only the source code and will not be executable.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsScoringCodeList(projectId, modelId, sourceCode=sourceCode)
    #' }
    ProjectsModelsScoringCodeList = function(projectId, modelId, sourceCode = "false", ...) {
      apiResponse <- private$ProjectsModelsScoringCodeListWithHttpInfo(projectId, modelId, sourceCode, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get supported capabilities for a model.
    #' Produces: "application/json"
    #'
    #' @details Get supported capabilities for a model.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelCapabilitiesRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully returned model capability information.
    #' \itemize{
    #' }
    #' \item **`404`** Resource not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsModelsSupportedCapabilitiesList(projectId, modelId)
    #' }
    ProjectsModelsSupportedCapabilitiesList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsSupportedCapabilitiesListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a Prime File
    #' Produces: NA
    #'
    #' @details Request creation and validation of source code from a Prime model
    #' @param projectId character. the project the Prime model belongs to
    #' @param primeFileCreate \link{PrimeFileCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** prime validation job added to queue. See the Location header.
    #' \itemize{
    #' \item **`Location`** a url that can be polled to check the status of prime validation job
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the Prime model belongs to
    #' primeFileCreate <- PrimeFileCreate$new() # PrimeFileCreate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeFilesCreate(projectId, primeFileCreate=primeFileCreate)
    #' }
    ProjectsPrimeFilesCreate = function(projectId, primeFileCreate = NULL, ...) {
      apiResponse <- private$ProjectsPrimeFilesCreateWithHttpInfo(projectId, primeFileCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download Code
    #' Produces: NA
    #'
    #' @details Download code from an existing Prime file
    #' @param projectId character. the project the file belongs to
    #' @param primeFileId character. the Prime file to download code from
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The response will contain a file with the executable code from the Prime file
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Will be attachment;filename&#x3D;\&quot;&lt;\&quot;filename\&quot;&gt;\&quot;. The suggested filename will depend on the language Prime file was generated for.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the file belongs to
    #' primeFileId <- 'primeFileId_example' # character | the Prime file to download code from
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeFilesDownloadList(projectId, primeFileId)
    #' }
    ProjectsPrimeFilesDownloadList = function(projectId, primeFileId, ...) {
      apiResponse <- private$ProjectsPrimeFilesDownloadListWithHttpInfo(projectId, primeFileId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get Prime Files
    #' Produces: "application/json"
    #'
    #' @details List all DataRobot Prime files available for download
    #' @param projectId character. the project to list available files for
    #' @param offset integer. this many results will be skipped
    #' @param limit integer. at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' @param parentModelId character. if specified only Prime files approximating the specified parent model will be returned; otherwise all applicable Prime files will be returned.
    #' @param modelId character. if specified only Prime files with code used in the specified prime model will be returned; otherwise all applicable Prime files will be returned
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PrimeFileListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project to list available files for
    #' offset <- 0 # integer | this many results will be skipped
    #' limit <- 0 # integer | at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' parentModelId <- 'parentModelId_example' # character | if specified only Prime files approximating the specified parent model will be returned; otherwise all applicable Prime files will be returned.
    #' modelId <- 'modelId_example' # character | if specified only Prime files with code used in the specified prime model will be returned; otherwise all applicable Prime files will be returned
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeFilesList(projectId, offset=offset, limit=limit, parentModelId=parentModelId, modelId=modelId)
    #' }
    ProjectsPrimeFilesList = function(projectId, offset = 0, limit = 0, parentModelId = NULL, modelId = NULL, ...) {
      apiResponse <- private$ProjectsPrimeFilesListWithHttpInfo(projectId, offset, limit, parentModelId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve metadata about a DataRobot Prime file
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata about a DataRobot Prime file available for download
    #' @param projectId character. the project the file belongs to
    #' @param primeFileId character. the file to retrieve
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PrimeFileResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project the file belongs to
    #' primeFileId <- 'primeFileId_example' # character | the file to retrieve
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeFilesRetrieve(projectId, primeFileId)
    #' }
    ProjectsPrimeFilesRetrieve = function(projectId, primeFileId, ...) {
      apiResponse <- private$ProjectsPrimeFilesRetrieveWithHttpInfo(projectId, primeFileId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a Prime Model from a Ruleset
    #' Produces: NA
    #'
    #' @details Create a Prime model using a particular ruleset.  DataRobot Prime is not available for multiclass projects.  Once rulesets approximating a parent model have been created, using POST /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/, this route will allow creation of a Prime model using one of those rulesets.  Available rulesets can be retrieved via GET /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/.
    #' @param projectId character. the project in which to create the model
    #' @param primeModelCreatePayload \link{PrimeModelCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Prime model creation job successfully added to queue. See the Location header.
    #' \itemize{
    #' \item **`Location`** a url that can be polled to check the status of the job
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project in which to create the model
    #' primeModelCreatePayload <- PrimeModelCreatePayload$new() # PrimeModelCreatePayload |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeModelsCreate(projectId, primeModelCreatePayload=primeModelCreatePayload)
    #' }
    ProjectsPrimeModelsCreate = function(projectId, primeModelCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsPrimeModelsCreateWithHttpInfo(projectId, primeModelCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all Prime models in a project
    #' Produces: "application/json"
    #'
    #' @details List all Prime models in a project
    #' @param projectId character. the project to list models from
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PrimeModelListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project to list models from
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeModelsList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsPrimeModelsList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsPrimeModelsListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a Prime model details
    #' Produces: "application/json"
    #'
    #' @details Retrieve a Prime model details
    #' @param projectId character. the project to retrieve the model from
    #' @param modelId character. the model to retrieve
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PrimeModelDetailsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Prime models are an extension of models, so the response includes all attributes that would be in a response to GET /api/v2/projects/(projectId)/models/(modelId)/ as well as some additional ones.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project to retrieve the model from
    #' modelId <- 'modelId_example' # character | the model to retrieve
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsPrimeModelsRetrieve(projectId, modelId)
    #' }
    ProjectsPrimeModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsPrimeModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create New Models From A Rating Table
    #' Produces: NA
    #'
    #' @details Create a new rating table model from a validated rating table record
    #' @param projectId character. the project that owns this data
    #' @param createRatingTableModel \link{CreateRatingTableModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** the request was understood and accepted, and is now being worked on
    #' \itemize{
    #' \item **`Location`** a url of an asynchronous operation status object that can be polled to check the status of the job validating the new rating table
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that owns this data
    #' createRatingTableModel <- CreateRatingTableModel$new() # CreateRatingTableModel |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTableModelsCreate(projectId, createRatingTableModel=createRatingTableModel)
    #' }
    ProjectsRatingTableModelsCreate = function(projectId, createRatingTableModel = NULL, ...) {
      apiResponse <- private$ProjectsRatingTableModelsCreateWithHttpInfo(projectId, createRatingTableModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Rating Table Models
    #' Produces: "application/json"
    #'
    #' @details Lists all the models from a project that have rating tables
    #' @param projectId character. the project to list models from
    #' @param bulkOperationId character. The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #' @param orderBy Enum < [metric, -metric, samplePct, -samplePct] > A comma-separated list of metrics to sort by. If metric is prefixed with a &#39;-&#39;, models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are &#x60;metric&#x60; and &#x60;samplePct&#x60;. &#x60;metric&#x60; will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so &#x60;-metric&#x60; will sort in order of decreasing &#39;goodness&#39;, which may be opposite to the natural numerical order. If not specified, &#x60;-metric&#x60; will be used.
    #' @param name character. If specified, will filter for models with model type matching &#x60;name&#x60;
    #' @param samplePct numeric. If specified, will filter for models with matching sample percentage
    #' @param withMetric character. If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
    #' @param isStarred Enum < [false, False, true, True] > If specified, will filter for models marked as starred.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{RatingTableModelDetailsResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The response will include a json list of models in the same format as      those from GET /api/v2/projects/(projectId)/ratingTableModels/(modelId)/.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project to list models from
    #' bulkOperationId <- 'bulkOperationId_example' # character | The ID of the bulk model operation. If specified, only models submitted in scope of this operation will be shown.
    #' orderBy <- 'orderBy_example' # character | A comma-separated list of metrics to sort by. If metric is prefixed with a '-', models will be sorted by this metric in descending order, otherwise in ascending order. Valid sorting metrics are `metric` and `samplePct`. `metric` will sort models by metric value selected for this project using validation score. This accounts for the direction of the metric, so `-metric` will sort in order of decreasing 'goodness', which may be opposite to the natural numerical order. If not specified, `-metric` will be used.
    #' name <- 'name_example' # character | If specified, will filter for models with model type matching `name`
    #' samplePct <- 3.4 # numeric | If specified, will filter for models with matching sample percentage
    #' withMetric <- 'withMetric_example' # character | If specified, the returned models will only have scores for this metric. If not, all metrics will be included.
    #' isStarred <- 'isStarred_example' # character | If specified, will filter for models marked as starred.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTableModelsList(projectId, bulkOperationId=bulkOperationId, orderBy=orderBy, name=name, samplePct=samplePct, withMetric=withMetric, isStarred=isStarred)
    #' }
    ProjectsRatingTableModelsList = function(projectId, bulkOperationId = NULL, orderBy = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
      apiResponse <- private$ProjectsRatingTableModelsListWithHttpInfo(projectId, bulkOperationId, orderBy, name, samplePct, withMetric, isStarred, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Rating Table Model
    #' Produces: "application/json"
    #'
    #' @details Look up a particular rating table model
    #' @param projectId character. the project to retrieve the model from
    #' @param modelId character. the model to retrieve
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RatingTableModelDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project to retrieve the model from
    #' modelId <- 'modelId_example' # character | the model to retrieve
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTableModelsRetrieve(projectId, modelId)
    #' }
    ProjectsRatingTableModelsRetrieve = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsRatingTableModelsRetrieveWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Upload Modified Rating Table File
    #' Produces: "application/json"
    #'
    #' @details Create a new rating table from a rating table file This will create a new rating table, regardless of whether the validation succeeds. The rating table object will have a validationError which will be left blank in the case of successful validation.
    #' @param projectId character. the project that owns this data
    #' @param parentModelId character. the parent model this rating table file was derived from
    #' @param ratingTableFile data.frame. rating table file to use for the new rating table. Accepts &#x60;Content-Type:multipart/form-data&#x60;
    #' @param ratingTableName character. the name of the new rating table to create
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RatingTableCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** the request was understood and accepted, and is now being worked on
    #' \itemize{
    #' \item **`Location`** a url of an asynchronous operation status object that can be polled to check the status of the job validating the new rating table
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that owns this data
    #' parentModelId <- 'parentModelId_example' # character | the parent model this rating table file was derived from
    #' ratingTableFile <- File.new('/path/to/file') # data.frame | rating table file to use for the new rating table. Accepts `Content-Type:multipart/form-data`
    #' ratingTableName <- 'ratingTableName_example' # character | the name of the new rating table to create
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTablesCreate(projectId, parentModelId, ratingTableFile, ratingTableName)
    #' }
    ProjectsRatingTablesCreate = function(projectId, parentModelId, ratingTableFile, ratingTableName, ...) {
      apiResponse <- private$ProjectsRatingTablesCreateWithHttpInfo(projectId, parentModelId, ratingTableFile, ratingTableName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Rating Table File
    #' Produces: NA
    #'
    #' @details Retrieve the CSV file for the rating table
    #' @param projectId character. the project that owns this data
    #' @param ratingTableId character. the rating table ID to retrieve the source file from
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The response will contain a file containing the rating table in csv format
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that owns this data
    #' ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTablesFileList(projectId, ratingTableId)
    #' }
    ProjectsRatingTablesFileList = function(projectId, ratingTableId, ...) {
      apiResponse <- private$ProjectsRatingTablesFileListWithHttpInfo(projectId, ratingTableId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Rating Tables For The Project
    #' Produces: "application/json"
    #'
    #' @details List RatingTable objects for a project.     These contain metadata about the rating table and the location at which the corresponding rating      table file can be retrieved.
    #' @param projectId character. The project ID
    #' @param parentModelId character. optional. If specified, only rating tables with this parentModelId will be returned
    #' @param modelId character. optional. If specified, only rating tables with this modelId will be returned
    #' @param offset integer. optional (default: 0), this many results will be skipped
    #' @param limit integer. optional (default: no limit), at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RatingTableListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' parentModelId <- 'parentModelId_example' # character | optional. If specified, only rating tables with this parentModelId will be returned
    #' modelId <- 'modelId_example' # character | optional. If specified, only rating tables with this modelId will be returned
    #' offset <- 0 # integer | optional (default: 0), this many results will be skipped
    #' limit <- 0 # integer | optional (default: no limit), at most this many results are returned. To specify no limit, use 0. The default may change and a maximum limit may be imposed without notice.
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTablesList(projectId, parentModelId=parentModelId, modelId=modelId, offset=offset, limit=limit)
    #' }
    ProjectsRatingTablesList = function(projectId, parentModelId = NULL, modelId = NULL, offset = 0, limit = 0, ...) {
      apiResponse <- private$ProjectsRatingTablesListWithHttpInfo(projectId, parentModelId, modelId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update an uploaded rating table
    #' Produces: "application/json"
    #'
    #' @details Rating tables may only be updated if they have not yet been used to create a model.
    #' @param projectId character. the project that owns this data
    #' @param ratingTableId character. the rating table ID to retrieve the source file from
    #' @param ratingTableUpdate \link{RatingTableUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RatingTableRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** On success, will return the modified rating table record in the same      format as GET /api/v2/projects/(projectId)/ratingTables/(ratingTableId)/
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that owns this data
    #' ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from
    #' ratingTableUpdate <- RatingTableUpdate$new() # RatingTableUpdate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTablesPatch(projectId, ratingTableId, ratingTableUpdate=ratingTableUpdate)
    #' }
    ProjectsRatingTablesPatch = function(projectId, ratingTableId, ratingTableUpdate = NULL, ...) {
      apiResponse <- private$ProjectsRatingTablesPatchWithHttpInfo(projectId, ratingTableId, ratingTableUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Rating Table Information
    #' Produces: "application/json"
    #'
    #' @details Retrieves a rating table
    #' @param projectId character. the project that owns this data
    #' @param ratingTableId character. the rating table ID to retrieve the source file from
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RatingTableRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | the project that owns this data
    #' ratingTableId <- 'ratingTableId_example' # character | the rating table ID to retrieve the source file from
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRatingTablesRetrieve(projectId, ratingTableId)
    #' }
    ProjectsRatingTablesRetrieve = function(projectId, ratingTableId, ...) {
      apiResponse <- private$ProjectsRatingTablesRetrieveWithHttpInfo(projectId, ratingTableId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List recommended models for the project
    #' Produces: "application/json"
    #'
    #' @details Retrieves all of the current recommended models for the project
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{RecommendedModelResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The list of recommended models
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRecommendedModelsList(projectId)
    #' }
    ProjectsRecommendedModelsList = function(projectId, ...) {
      apiResponse <- private$ProjectsRecommendedModelsListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get recommended model
    #' Produces: "application/json"
    #'
    #' @details This route returns the simplest recommended model available. To see all the available recommended models, use :http:get:&#x60;/api/v2/projects/(projectId)/recommendedModels/&#x60;
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RecommendedModelResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The recommended model
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsRecommendedModelsRecommendedModelList(projectId)
    #' }
    ProjectsRecommendedModelsRecommendedModelList = function(projectId, ...) {
      apiResponse <- private$ProjectsRecommendedModelsRecommendedModelListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update champion model for a segment project.
    #' Produces: "application/json"
    #'
    #' @details Update champion model for a segment project.
    #' @param projectId character. The project ID
    #' @param segmentChampionModelUpdate \link{SegmentChampionModelUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SegmentChampionModelUpdateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The ID of Combined model that has been updated with new segment champion model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentChampionModelUpdate <- SegmentChampionModelUpdate$new() # SegmentChampionModelUpdate |
    #'
    #' api.instance <- ModelsApi$new()
    #' result <- api.instance$ProjectsSegmentChampionPutMany(projectId, segmentChampionModelUpdate=segmentChampionModelUpdate)
    #' }
    ProjectsSegmentChampionPutMany = function(projectId, segmentChampionModelUpdate = NULL, ...) {
      apiResponse <- private$ProjectsSegmentChampionPutManyWithHttpInfo(projectId, segmentChampionModelUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `CustomInferenceImagesFeatureImpactCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomInferenceImagesFeatureImpactCreateWithHttpInfo = function(imageId, featureImpactCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`imageId`)) {
        stop("Missing required parameter `imageId`.")
      }

      if (!missing(`featureImpactCreatePayload`) && isa(featureImpactCreatePayload, c("FeatureImpactCreatePayload", "R6"))) {
        body <- `featureImpactCreatePayload`$toJSON()
      } else {
        stop("CustomInferenceImagesFeatureImpactCreateWithHttpInfo requires parameter featureImpactCreatePayload to be of type FeatureImpactCreatePayload.")
      }

      urlPath <- "/customInferenceImages/{imageId}/featureImpact/"
      if (!missing(`imageId`)) {
        urlPath <- gsub(paste0("\\{", "imageId", "\\}"), URLencode(as.character(`imageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureImpactCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomInferenceImagesFeatureImpactList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomInferenceImagesFeatureImpactListWithHttpInfo = function(imageId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`imageId`)) {
        stop("Missing required parameter `imageId`.")
      }

      body <- NULL
      urlPath <- "/customInferenceImages/{imageId}/featureImpact/"
      if (!missing(`imageId`)) {
        urlPath <- gsub(paste0("\\{", "imageId", "\\}"), URLencode(as.character(`imageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureImpactResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelDeploymentsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelDeploymentsListWithHttpInfo = function(offset, limit, customModelIds = NULL, environmentIds = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["customModelIds"] <- customModelIds

      queryParams["environmentIds"] <- environmentIds

      body <- NULL
      urlPath <- "/customModelDeployments/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelDeploymentListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelLimitsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelLimitsListWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/customModelLimits/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelResourceLimits", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsCreateWithHttpInfo = function(customModelTests = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customModelTests`) && isa(customModelTests, c("CustomModelTests", "R6"))) {
        body <- `customModelTests`$toJSON()
      } else {
        stop("CustomModelTestsCreateWithHttpInfo requires parameter customModelTests to be of type CustomModelTests.")
      }

      urlPath <- "/customModelTests/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelAsyncOperationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsDeleteWithHttpInfo = function(customModelTestId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelTestId`)) {
        stop("Missing required parameter `customModelTestId`.")
      }

      body <- NULL
      urlPath <- "/customModelTests/{customModelTestId}/"
      if (!missing(`customModelTestId`)) {
        urlPath <- gsub(paste0("\\{", "customModelTestId", "\\}"), URLencode(as.character(`customModelTestId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsListWithHttpInfo = function(offset, limit, customModelId, maximumMemory = NULL, networkEgressPolicy = NULL, desiredMemory = NULL, replicas = NULL, requiresHa = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["maximumMemory"] <- maximumMemory

      queryParams["networkEgressPolicy"] <- networkEgressPolicy

      queryParams["desiredMemory"] <- desiredMemory

      queryParams["replicas"] <- replicas

      queryParams["requiresHa"] <- requiresHa

      queryParams["customModelId"] <- customModelId

      body <- NULL
      urlPath <- "/customModelTests/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelTestsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsLogList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsLogListWithHttpInfo = function(customModelTestId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelTestId`)) {
        stop("Missing required parameter `customModelTestId`.")
      }

      body <- NULL
      urlPath <- "/customModelTests/{customModelTestId}/log/"
      if (!missing(`customModelTestId`)) {
        urlPath <- gsub(paste0("\\{", "customModelTestId", "\\}"), URLencode(as.character(`customModelTestId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsRetrieveWithHttpInfo = function(customModelTestId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelTestId`)) {
        stop("Missing required parameter `customModelTestId`.")
      }

      body <- NULL
      urlPath <- "/customModelTests/{customModelTestId}/"
      if (!missing(`customModelTestId`)) {
        urlPath <- gsub(paste0("\\{", "customModelTestId", "\\}"), URLencode(as.character(`customModelTestId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelTestsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelTestsTailList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelTestsTailListWithHttpInfo = function(lines, customModelTestId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`lines`)) {
        stop("Missing required parameter `lines`.")
      }

      if (missing(`customModelTestId`)) {
        stop("Missing required parameter `customModelTestId`.")
      }

      queryParams["lines"] <- lines

      body <- NULL
      urlPath <- "/customModelTests/{customModelTestId}/tail/"
      if (!missing(`customModelTestId`)) {
        urlPath <- gsub(paste0("\\{", "customModelTestId", "\\}"), URLencode(as.character(`customModelTestId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelTestsLogTailResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsAccessControlListWithHttpInfo = function(offset, limit, customModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/customModels/{customModelId}/accessControl/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelAccessControlListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsAccessControlPatchManyWithHttpInfo = function(customModelId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (!missing(`sharingUpdateOrRemoveWithGrant`) && isa(sharingUpdateOrRemoveWithGrant, c("SharingUpdateOrRemoveWithGrant", "R6"))) {
        body <- `sharingUpdateOrRemoveWithGrant`$toJSON()
      } else {
        stop("CustomModelsAccessControlPatchManyWithHttpInfo requires parameter sharingUpdateOrRemoveWithGrant to be of type SharingUpdateOrRemoveWithGrant.")
      }

      urlPath <- "/customModels/{customModelId}/accessControl/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelAccessControlUpdateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsCreateWithHttpInfo = function(customModelCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customModelCreate`) && isa(customModelCreate, c("CustomModelCreate", "R6"))) {
        body <- `customModelCreate`$toJSON()
      } else {
        stop("CustomModelsCreateWithHttpInfo requires parameter customModelCreate to be of type CustomModelCreate.")
      }

      urlPath <- "/customModels/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsDeleteWithHttpInfo = function(customModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsDownloadListWithHttpInfo = function(customModelId, pps = "False", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      queryParams["pps"] <- pps

      body <- NULL
      urlPath <- "/customModels/{customModelId}/download/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsFromCustomModelCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsFromCustomModelCreateWithHttpInfo = function(customModelCopy = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customModelCopy`) && isa(customModelCopy, c("CustomModelCopy", "R6"))) {
        body <- `customModelCopy`$toJSON()
      } else {
        stop("CustomModelsFromCustomModelCreateWithHttpInfo requires parameter customModelCopy to be of type CustomModelCopy.")
      }

      urlPath <- "/customModels/fromCustomModel/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsListWithHttpInfo = function(offset, limit, customModelType = NULL, isDeployed = NULL, orderBy = NULL, searchFor = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["customModelType"] <- customModelType

      queryParams["isDeployed"] <- isDeployed

      queryParams["orderBy"] <- orderBy

      queryParams["searchFor"] <- searchFor

      body <- NULL
      urlPath <- "/customModels/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsPatchWithHttpInfo = function(customModelId, customModelUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (!missing(`customModelUpdate`) && isa(customModelUpdate, c("CustomModelUpdate", "R6"))) {
        body <- `customModelUpdate`$toJSON()
      } else {
        stop("CustomModelsPatchWithHttpInfo requires parameter customModelUpdate to be of type CustomModelUpdate.")
      }

      urlPath <- "/customModels/{customModelId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsPredictionExplanationsInitializationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsPredictionExplanationsInitializationCreateWithHttpInfo = function(customModelPredictionExplanations = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customModelPredictionExplanations`) && isa(customModelPredictionExplanations, c("CustomModelPredictionExplanations", "R6"))) {
        body <- `customModelPredictionExplanations`$toJSON()
      } else {
        stop("CustomModelsPredictionExplanationsInitializationCreateWithHttpInfo requires parameter customModelPredictionExplanations to be of type CustomModelPredictionExplanations.")
      }

      urlPath <- "/customModels/predictionExplanationsInitialization/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsRetrieveWithHttpInfo = function(customModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsTrainingDataPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsTrainingDataPatchManyWithHttpInfo = function(customModelId, trainingDataAssignment = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (!missing(`trainingDataAssignment`) && isa(trainingDataAssignment, c("TrainingDataAssignment", "R6"))) {
        body <- `trainingDataAssignment`$toJSON()
      } else {
        stop("CustomModelsTrainingDataPatchManyWithHttpInfo requires parameter trainingDataAssignment to be of type TrainingDataAssignment.")
      }

      urlPath <- "/customModels/{customModelId}/trainingData/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionCreateFromLatest`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionCreateFromLatestWithHttpInfo = function(customModelId, baseEnvironmentId, isMajorUpdate, desiredMemory = NULL, file = NULL, filePath = NULL, filesToDelete = NULL, maximumMemory = NULL, networkEgressPolicy = NULL, replicas = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, requiresHa = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`baseEnvironmentId`)) {
        stop("Missing required parameter `baseEnvironmentId`.")
      }

      if (missing(`isMajorUpdate`)) {
        stop("Missing required parameter `isMajorUpdate`.")
      }

      body <- list(
        "baseEnvironmentId" = baseEnvironmentId,
        "desiredMemory" = desiredMemory,
        "file" = httr::upload_file(file),
        "filePath" = filePath,
        "filesToDelete" = filesToDelete,
        "isMajorUpdate" = isMajorUpdate,
        "maximumMemory" = maximumMemory,
        "networkEgressPolicy" = networkEgressPolicy,
        "replicas" = replicas,
        "requiredMetadata" = requiredMetadata,
        "requiredMetadataValues" = requiredMetadataValues,
        "requiresHa" = requiresHa
      )

      urlPath <- "/customModels/{customModelId}/versions/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsConversionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsConversionsCreateWithHttpInfo = function(customModelId, customModelVersionId, conversionCreateQuery = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      if (!missing(`conversionCreateQuery`) && isa(conversionCreateQuery, c("ConversionCreateQuery", "R6"))) {
        body <- `conversionCreateQuery`$toJSON()
      } else {
        stop("CustomModelsVersionsConversionsCreateWithHttpInfo requires parameter conversionCreateQuery to be of type ConversionCreateQuery.")
      }

      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/conversions/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelConversionAsyncOperationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsConversionsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsConversionsDeleteWithHttpInfo = function(customModelId, customModelVersionId, conversionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      if (missing(`conversionId`)) {
        stop("Missing required parameter `conversionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/conversions/{conversionId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`conversionId`)) {
        urlPath <- gsub(paste0("\\{", "conversionId", "\\}"), URLencode(as.character(`conversionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsConversionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsConversionsListWithHttpInfo = function(offset, limit, customModelId, customModelVersionId, isLatest = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["isLatest"] <- isLatest

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/conversions/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ConversionListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsConversionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsConversionsRetrieveWithHttpInfo = function(customModelId, customModelVersionId, conversionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      if (missing(`conversionId`)) {
        stop("Missing required parameter `conversionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/conversions/{conversionId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`conversionId`)) {
        urlPath <- gsub(paste0("\\{", "conversionId", "\\}"), URLencode(as.character(`conversionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ConversionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsCreateWithHttpInfo = function(customModelId, isMajorUpdate, baseEnvironmentId = NULL, desiredMemory = NULL, file = NULL, filePath = NULL, maximumMemory = NULL, networkEgressPolicy = NULL, replicas = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, requiresHa = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`isMajorUpdate`)) {
        stop("Missing required parameter `isMajorUpdate`.")
      }

      body <- list(
        "baseEnvironmentId" = baseEnvironmentId,
        "desiredMemory" = desiredMemory,
        "file" = httr::upload_file(file),
        "filePath" = filePath,
        "isMajorUpdate" = isMajorUpdate,
        "maximumMemory" = maximumMemory,
        "networkEgressPolicy" = networkEgressPolicy,
        "replicas" = replicas,
        "requiredMetadata" = requiredMetadata,
        "requiredMetadataValues" = requiredMetadataValues,
        "requiresHa" = requiresHa
      )

      urlPath <- "/customModels/{customModelId}/versions/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsDependencyBuildCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsDependencyBuildCreateWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/dependencyBuild/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BaseDependencyBuildMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsDependencyBuildDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsDependencyBuildDeleteManyWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/dependencyBuild/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsDependencyBuildList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsDependencyBuildListWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/dependencyBuild/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BaseDependencyBuildMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsDependencyBuildLogList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsDependencyBuildLogListWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/dependencyBuildLog/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DependencyBuildLogResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsDownloadListWithHttpInfo = function(customModelId, customModelVersionId, pps = "False", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      queryParams["pps"] <- pps

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/download/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsFeatureImpactCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsFeatureImpactCreateWithHttpInfo = function(customModelId, customModelVersionId, featureImpactCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      if (!missing(`featureImpactCreatePayload`) && isa(featureImpactCreatePayload, c("FeatureImpactCreatePayload", "R6"))) {
        body <- `featureImpactCreatePayload`$toJSON()
      } else {
        stop("CustomModelsVersionsFeatureImpactCreateWithHttpInfo requires parameter featureImpactCreatePayload to be of type FeatureImpactCreatePayload.")
      }

      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/featureImpact/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureImpactCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsFeatureImpactList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsFeatureImpactListWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/featureImpact/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureImpactResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsFromRepositoryCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsFromRepositoryCreateWithHttpInfo = function(customModelId, customModelVersionCreateFromRepository = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (!missing(`customModelVersionCreateFromRepository`) && isa(customModelVersionCreateFromRepository, c("CustomModelVersionCreateFromRepository", "R6"))) {
        body <- `customModelVersionCreateFromRepository`$toJSON()
      } else {
        stop("CustomModelsVersionsFromRepositoryCreateWithHttpInfo requires parameter customModelVersionCreateFromRepository to be of type CustomModelVersionCreateFromRepository.")
      }

      urlPath <- "/customModels/{customModelId}/versions/fromRepository/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsFromRepositoryPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsFromRepositoryPatchManyWithHttpInfo = function(customModelId, customModelVersionCreateFromRepository = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (!missing(`customModelVersionCreateFromRepository`) && isa(customModelVersionCreateFromRepository, c("CustomModelVersionCreateFromRepository", "R6"))) {
        body <- `customModelVersionCreateFromRepository`$toJSON()
      } else {
        stop("CustomModelsVersionsFromRepositoryPatchManyWithHttpInfo requires parameter customModelVersionCreateFromRepository to be of type CustomModelVersionCreateFromRepository.")
      }

      urlPath <- "/customModels/{customModelId}/versions/fromRepository/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsListWithHttpInfo = function(offset, limit, customModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelVersionListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsPatchWithHttpInfo = function(customModelId, customModelVersionId, customModelVersionMetadataUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      if (!missing(`customModelVersionMetadataUpdate`) && isa(customModelVersionMetadataUpdate, c("CustomModelVersionMetadataUpdate", "R6"))) {
        body <- `customModelVersionMetadataUpdate`$toJSON()
      } else {
        stop("CustomModelsVersionsPatchWithHttpInfo requires parameter customModelVersionMetadataUpdate to be of type CustomModelVersionMetadataUpdate.")
      }

      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsPredictionExplanationsInitializationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsPredictionExplanationsInitializationCreateWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/predictionExplanationsInitialization/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomModelsVersionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomModelsVersionsRetrieveWithHttpInfo = function(customModelId, customModelVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customModelId`)) {
        stop("Missing required parameter `customModelId`.")
      }

      if (missing(`customModelVersionId`)) {
        stop("Missing required parameter `customModelVersionId`.")
      }

      body <- NULL
      urlPath <- "/customModels/{customModelId}/versions/{customModelVersionId}/"
      if (!missing(`customModelId`)) {
        urlPath <- gsub(paste0("\\{", "customModelId", "\\}"), URLencode(as.character(`customModelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customModelVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customModelVersionId", "\\}"), URLencode(as.character(`customModelVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomModelVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTrainingBlueprintsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTrainingBlueprintsCreateWithHttpInfo = function(customTrainingBlueprintCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customTrainingBlueprintCreate`) && isa(customTrainingBlueprintCreate, c("CustomTrainingBlueprintCreate", "R6"))) {
        body <- `customTrainingBlueprintCreate`$toJSON()
      } else {
        stop("CustomTrainingBlueprintsCreateWithHttpInfo requires parameter customTrainingBlueprintCreate to be of type CustomTrainingBlueprintCreate.")
      }

      urlPath <- "/customTrainingBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTrainingBlueprintResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTrainingBlueprintsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTrainingBlueprintsListWithHttpInfo = function(offset, limit, customModelId = NULL, reverse = "False", targetTypes = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["customModelId"] <- customModelId

      queryParams["reverse"] <- reverse

      queryParams["targetTypes"] <- targetTypes

      body <- NULL
      urlPath <- "/customTrainingBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTrainingBlueprintListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelExportsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelExportsCreateWithHttpInfo = function(modelExport = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`modelExport`) && isa(modelExport, c("ModelExport", "R6"))) {
        body <- `modelExport`$toJSON()
      } else {
        stop("ModelExportsCreateWithHttpInfo requires parameter modelExport to be of type ModelExport.")
      }

      urlPath <- "/modelExports/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesArchiveCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesArchiveCreateWithHttpInfo = function(modelPackageId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`modelPackageId`)) {
        stop("Missing required parameter `modelPackageId`.")
      }

      body <- NULL
      urlPath <- "/modelPackages/{modelPackageId}/archive/"
      if (!missing(`modelPackageId`)) {
        urlPath <- gsub(paste0("\\{", "modelPackageId", "\\}"), URLencode(as.character(`modelPackageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesFeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesFeaturesListWithHttpInfo = function(offset, limit, modelPackageId, includeNonPredictionFeatures = "false", forSegmentedAnalysis = "false", search = NULL, orderBy = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`modelPackageId`)) {
        stop("Missing required parameter `modelPackageId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["includeNonPredictionFeatures"] <- includeNonPredictionFeatures

      queryParams["forSegmentedAnalysis"] <- forSegmentedAnalysis

      queryParams["search"] <- search

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/modelPackages/{modelPackageId}/features/"
      if (!missing(`modelPackageId`)) {
        urlPath <- gsub(paste0("\\{", "modelPackageId", "\\}"), URLencode(as.character(`modelPackageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesFromLearningModelCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesFromLearningModelCreateWithHttpInfo = function(modelPackageCreateFromLearningModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`modelPackageCreateFromLearningModel`) && isa(modelPackageCreateFromLearningModel, c("ModelPackageCreateFromLearningModel", "R6"))) {
        body <- `modelPackageCreateFromLearningModel`$toJSON()
      } else {
        stop("ModelPackagesFromLearningModelCreateWithHttpInfo requires parameter modelPackageCreateFromLearningModel to be of type ModelPackageCreateFromLearningModel.")
      }

      urlPath <- "/modelPackages/fromLearningModel/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesListWithHttpInfo = function(offset = 0, limit = 100, modelId = NULL, similarTo = NULL, forChallenger = NULL, search = NULL, predictionThreshold = NULL, imported = NULL, predictionEnvironmentId = NULL, modelKind = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["modelId"] <- modelId

      queryParams["similarTo"] <- similarTo

      queryParams["forChallenger"] <- forChallenger

      queryParams["search"] <- search

      queryParams["predictionThreshold"] <- predictionThreshold

      queryParams["imported"] <- imported

      queryParams["predictionEnvironmentId"] <- predictionEnvironmentId

      queryParams["modelKind"] <- modelKind

      body <- NULL
      urlPath <- "/modelPackages/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelPackageListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesRetrieveWithHttpInfo = function(modelPackageId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`modelPackageId`)) {
        stop("Missing required parameter `modelPackageId`.")
      }

      body <- NULL
      urlPath <- "/modelPackages/{modelPackageId}/"
      if (!missing(`modelPackageId`)) {
        urlPath <- gsub(paste0("\\{", "modelPackageId", "\\}"), URLencode(as.character(`modelPackageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelPackageRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelPackagesSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelPackagesSharedRolesListWithHttpInfo = function(offset, limit, modelPackageId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`modelPackageId`)) {
        stop("Missing required parameter `modelPackageId`.")
      }

      queryParams["id"] <- id

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      body <- NULL
      urlPath <- "/modelPackages/{modelPackageId}/sharedRoles/"
      if (!missing(`modelPackageId`)) {
        urlPath <- gsub(paste0("\\{", "modelPackageId", "\\}"), URLencode(as.character(`modelPackageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharingListV2Response", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderBuildersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderBuildersCreateWithHttpInfo = function(projectId, baseBlenderBuilderCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`baseBlenderBuilderCreate`) && isa(baseBlenderBuilderCreate, c("BaseBlenderBuilderCreate", "R6"))) {
        body <- `baseBlenderBuilderCreate`$toJSON()
      } else {
        stop("ProjectsBlenderBuildersCreateWithHttpInfo requires parameter baseBlenderBuilderCreate to be of type BaseBlenderBuilderCreate.")
      }

      urlPath <- "/projects/{projectId}/blenderBuilders/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderBuildersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderBuildersListWithHttpInfo = function(projectId, offset, limit, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/blenderBuilders/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`offset`)) {
        urlPath <- gsub(paste0("\\{", "offset", "\\}"), URLencode(as.character(`offset`), reserved = TRUE), urlPath)
      }

      if (!missing(`limit`)) {
        urlPath <- gsub(paste0("\\{", "limit", "\\}"), URLencode(as.character(`limit`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderBuildersRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderBuildersRetrieveWithHttpInfo = function(projectId, buildId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`buildId`)) {
        stop("Missing required parameter `buildId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/blenderBuilders/{buildId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`buildId`)) {
        urlPath <- gsub(paste0("\\{", "buildId", "\\}"), URLencode(as.character(`buildId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderModelsBlendCheckCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderModelsBlendCheckCreateWithHttpInfo = function(projectId, blenderCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`blenderCreate`) && isa(blenderCreate, c("BlenderCreate", "R6"))) {
        body <- `blenderCreate`$toJSON()
      } else {
        stop("ProjectsBlenderModelsBlendCheckCreateWithHttpInfo requires parameter blenderCreate to be of type BlenderCreate.")
      }

      urlPath <- "/projects/{projectId}/blenderModels/blendCheck/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BlenderInfoRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderModelsCreateWithHttpInfo = function(projectId, blenderCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`blenderCreate`) && isa(blenderCreate, c("BlenderCreate", "R6"))) {
        body <- `blenderCreate`$toJSON()
      } else {
        stop("ProjectsBlenderModelsCreateWithHttpInfo requires parameter blenderCreate to be of type BlenderCreate.")
      }

      urlPath <- "/projects/{projectId}/blenderModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderModelsListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/blenderModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BlenderListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBlenderModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBlenderModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/blenderModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BlenderRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsCombinedModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsCombinedModelsListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/combinedModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CombinedModelListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsCombinedModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsCombinedModelsRetrieveWithHttpInfo = function(projectId, combinedModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`combinedModelId`)) {
        stop("Missing required parameter `combinedModelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/combinedModels/{combinedModelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`combinedModelId`)) {
        urlPath <- gsub(paste0("\\{", "combinedModelId", "\\}"), URLencode(as.character(`combinedModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CombinedModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsCombinedModelsSegmentsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsCombinedModelsSegmentsDownloadListWithHttpInfo = function(projectId, combinedModelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`combinedModelId`)) {
        stop("Missing required parameter `combinedModelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/combinedModels/{combinedModelId}/segments/download/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`combinedModelId`)) {
        urlPath <- gsub(paste0("\\{", "combinedModelId", "\\}"), URLencode(as.character(`combinedModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "character", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsCombinedModelsSegmentsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsCombinedModelsSegmentsListWithHttpInfo = function(projectId, combinedModelId, offset = 0, limit = 100, searchSegmentName = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`combinedModelId`)) {
        stop("Missing required parameter `combinedModelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["searchSegmentName"] <- searchSegmentName

      body <- NULL
      urlPath <- "/projects/{projectId}/combinedModels/{combinedModelId}/segments/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`combinedModelId`)) {
        urlPath <- gsub(paste0("\\{", "combinedModelId", "\\}"), URLencode(as.character(`combinedModelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CombinedModelSegmentsPaginatedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsBacktestsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsBacktestsCreateWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/backtests/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsCreateWithHttpInfo = function(projectId, trainDatetimeModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`trainDatetimeModel`) && isa(trainDatetimeModel, c("TrainDatetimeModel", "R6"))) {
        body <- `trainDatetimeModel`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsCreateWithHttpInfo requires parameter trainDatetimeModel to be of type TrainDatetimeModel.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeModelSubmissionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFromModelCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFromModelCreateWithHttpInfo = function(projectId, retrainDatetimeModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`retrainDatetimeModel`) && isa(retrainDatetimeModel, c("RetrainDatetimeModel", "R6"))) {
        body <- `retrainDatetimeModel`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsFromModelCreateWithHttpInfo requires parameter retrainDatetimeModel to be of type RetrainDatetimeModel.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/fromModel/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeModelSubmissionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsListWithHttpInfo = function(projectId, offset = 0, limit = 100, bulkOperationId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["bulkOperationId"] <- bulkOperationId

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeModelsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeModelDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDeploymentReadyModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDeploymentReadyModelsCreateWithHttpInfo = function(projectId, prepareForDeployment = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`prepareForDeployment`) && isa(prepareForDeployment, c("PrepareForDeployment", "R6"))) {
        body <- `prepareForDeployment`$toJSON()
      } else {
        stop("ProjectsDeploymentReadyModelsCreateWithHttpInfo requires parameter prepareForDeployment to be of type PrepareForDeployment.")
      }

      urlPath <- "/projects/{projectId}/deploymentReadyModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsEureqaDistributionPlotRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsEureqaDistributionPlotRetrieveWithHttpInfo = function(projectId, solutionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`solutionId`)) {
        stop("Missing required parameter `solutionId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/eureqaDistributionPlot/{solutionId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`solutionId`)) {
        urlPath <- gsub(paste0("\\{", "solutionId", "\\}"), URLencode(as.character(`solutionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "EureqaDistributionDetailResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsEureqaModelDetailRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsEureqaModelDetailRetrieveWithHttpInfo = function(projectId, solutionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`solutionId`)) {
        stop("Missing required parameter `solutionId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/eureqaModelDetail/{solutionId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`solutionId`)) {
        urlPath <- gsub(paste0("\\{", "solutionId", "\\}"), URLencode(as.character(`solutionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "EureqaModelDetailResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsEureqaModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsEureqaModelsCreateWithHttpInfo = function(projectId, eureqaLeaderboardEntryPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`eureqaLeaderboardEntryPayload`) && isa(eureqaLeaderboardEntryPayload, c("EureqaLeaderboardEntryPayload", "R6"))) {
        body <- `eureqaLeaderboardEntryPayload`$toJSON()
      } else {
        stop("ProjectsEureqaModelsCreateWithHttpInfo requires parameter eureqaLeaderboardEntryPayload to be of type EureqaLeaderboardEntryPayload.")
      }

      urlPath <- "/projects/{projectId}/eureqaModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsEureqaModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsEureqaModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/eureqaModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ParetoFrontResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFrozenDatetimeModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFrozenDatetimeModelsCreateWithHttpInfo = function(projectId, trainDatetimeFrozenModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`trainDatetimeFrozenModel`) && isa(trainDatetimeFrozenModel, c("TrainDatetimeFrozenModel", "R6"))) {
        body <- `trainDatetimeFrozenModel`$toJSON()
      } else {
        stop("ProjectsFrozenDatetimeModelsCreateWithHttpInfo requires parameter trainDatetimeFrozenModel to be of type TrainDatetimeFrozenModel.")
      }

      urlPath <- "/projects/{projectId}/frozenDatetimeModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeModelSubmissionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFrozenModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFrozenModelsCreateWithHttpInfo = function(projectId, frozenModelCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`frozenModelCreate`) && isa(frozenModelCreate, c("FrozenModelCreate", "R6"))) {
        body <- `frozenModelCreate`$toJSON()
      } else {
        stop("ProjectsFrozenModelsCreateWithHttpInfo requires parameter frozenModelCreate to be of type FrozenModelCreate.")
      }

      urlPath <- "/projects/{projectId}/frozenModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFrozenModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFrozenModelsListWithHttpInfo = function(offset, limit, projectId, withMetric = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["withMetric"] <- withMetric

      body <- NULL
      urlPath <- "/projects/{projectId}/frozenModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FrozenModelListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFrozenModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFrozenModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/frozenModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FrozenModelRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelJobsDeleteWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/modelJobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelJobsListWithHttpInfo = function(projectId, status = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["status"] <- status

      body <- NULL
      urlPath <- "/projects/{projectId}/modelJobs/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[ModelingJobListResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelJobsRetrieveWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/modelJobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsAdvancedTuningCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsAdvancedTuningCreateWithHttpInfo = function(projectId, modelId, modelAdvancedTuning = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`modelAdvancedTuning`) && isa(modelAdvancedTuning, c("ModelAdvancedTuning", "R6"))) {
        body <- `modelAdvancedTuning`$toJSON()
      } else {
        stop("ProjectsModelsAdvancedTuningCreateWithHttpInfo requires parameter modelAdvancedTuning to be of type ModelAdvancedTuning.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/advancedTuning/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsAdvancedTuningParametersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsAdvancedTuningParametersListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/advancedTuning/parameters/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AdvancedTuningArgumentsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsClusterNamesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsClusterNamesListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/clusterNames/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ClusterNamesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsClusterNamesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsClusterNamesPatchManyWithHttpInfo = function(projectId, modelId, clusterNamesUpdateParam = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`clusterNamesUpdateParam`) && isa(clusterNamesUpdateParam, c("ClusterNamesUpdateParam", "R6"))) {
        body <- `clusterNamesUpdateParam`$toJSON()
      } else {
        stop("ProjectsModelsClusterNamesPatchManyWithHttpInfo requires parameter clusterNamesUpdateParam to be of type ClusterNamesUpdateParam.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/clusterNames/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ClusterNamesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsCreateWithHttpInfo = function(projectId, trainModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`trainModel`) && isa(trainModel, c("TrainModel", "R6"))) {
        body <- `trainModel`$toJSON()
      } else {
        stop("ProjectsModelsCreateWithHttpInfo requires parameter trainModel to be of type TrainModel.")
      }

      urlPath <- "/projects/{projectId}/models/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsCrossValidationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsCrossValidationCreateWithHttpInfo = function(projectId, modelId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("ProjectsModelsCrossValidationCreateWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/crossValidation/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsCrossValidationScoresList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsCrossValidationScoresListWithHttpInfo = function(projectId, modelId, metric = NULL, partition = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["metric"] <- metric

      queryParams["partition"] <- partition

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/crossValidationScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CrossValidationRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDeleteWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsExportList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsExportListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/export/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeaturesListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/features/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelFeatureListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFromModelCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFromModelCreateWithHttpInfo = function(projectId, retrainModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`retrainModel`) && isa(retrainModel, c("RetrainModel", "R6"))) {
        body <- `retrainModel`$toJSON()
      } else {
        stop("ProjectsModelsFromModelCreateWithHttpInfo requires parameter retrainModel to be of type RetrainModel.")
      }

      urlPath <- "/projects/{projectId}/models/fromModel/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelRetrainResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsListWithHttpInfo = function(projectId, bulkOperationId = NULL, orderBy = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["bulkOperationId"] <- bulkOperationId

      queryParams["orderBy"] <- orderBy

      queryParams["name"] <- name

      queryParams["samplePct"] <- samplePct

      queryParams["withMetric"] <- withMetric

      queryParams["isStarred"] <- isStarred

      body <- NULL
      urlPath <- "/projects/{projectId}/models/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[ModelDetailsResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMissingReportList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMissingReportListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/missingReport/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MissingReportRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsNumIterationsTrainedList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsNumIterationsTrainedListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/numIterationsTrained/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "NumIterationsTrainedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsParametersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsParametersListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/parameters/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelParametersRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPatchWithHttpInfo = function(projectId, modelId, modelUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`modelUpdate`) && isa(modelUpdate, c("ModelUpdate", "R6"))) {
        body <- `modelUpdate`$toJSON()
      } else {
        stop("ProjectsModelsPatchWithHttpInfo requires parameter modelUpdate to be of type ModelUpdate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionIntervalsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionIntervalsCreateWithHttpInfo = function(projectId, modelId, predictionIntervalsCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`predictionIntervalsCreate`) && isa(predictionIntervalsCreate, c("PredictionIntervalsCreate", "R6"))) {
        body <- `predictionIntervalsCreate`$toJSON()
      } else {
        stop("ProjectsModelsPredictionIntervalsCreateWithHttpInfo requires parameter predictionIntervalsCreate to be of type PredictionIntervalsCreate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/predictionIntervals/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionIntervalsCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionIntervalsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionIntervalsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/predictionIntervals/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionIntervalsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPrimeInfoList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPrimeInfoListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/primeInfo/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PrimeInfoRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPrimeRulesetsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPrimeRulesetsCreateWithHttpInfo = function(projectId, modelId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("ProjectsModelsPrimeRulesetsCreateWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/primeRulesets/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPrimeRulesetsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPrimeRulesetsListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/primeRulesets/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[PrimeRulesetsListResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsScoringCodeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsScoringCodeListWithHttpInfo = function(projectId, modelId, sourceCode = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["sourceCode"] <- sourceCode

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/scoringCode/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsSupportedCapabilitiesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsSupportedCapabilitiesListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/supportedCapabilities/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelCapabilitiesRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeFilesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeFilesCreateWithHttpInfo = function(projectId, primeFileCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`primeFileCreate`) && isa(primeFileCreate, c("PrimeFileCreate", "R6"))) {
        body <- `primeFileCreate`$toJSON()
      } else {
        stop("ProjectsPrimeFilesCreateWithHttpInfo requires parameter primeFileCreate to be of type PrimeFileCreate.")
      }

      urlPath <- "/projects/{projectId}/primeFiles/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeFilesDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeFilesDownloadListWithHttpInfo = function(projectId, primeFileId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`primeFileId`)) {
        stop("Missing required parameter `primeFileId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/primeFiles/{primeFileId}/download/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`primeFileId`)) {
        urlPath <- gsub(paste0("\\{", "primeFileId", "\\}"), URLencode(as.character(`primeFileId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeFilesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeFilesListWithHttpInfo = function(projectId, offset = 0, limit = 0, parentModelId = NULL, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["parentModelId"] <- parentModelId

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/primeFiles/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PrimeFileListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeFilesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeFilesRetrieveWithHttpInfo = function(projectId, primeFileId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`primeFileId`)) {
        stop("Missing required parameter `primeFileId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/primeFiles/{primeFileId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`primeFileId`)) {
        urlPath <- gsub(paste0("\\{", "primeFileId", "\\}"), URLencode(as.character(`primeFileId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PrimeFileResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeModelsCreateWithHttpInfo = function(projectId, primeModelCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`primeModelCreatePayload`) && isa(primeModelCreatePayload, c("PrimeModelCreatePayload", "R6"))) {
        body <- `primeModelCreatePayload`$toJSON()
      } else {
        stop("ProjectsPrimeModelsCreateWithHttpInfo requires parameter primeModelCreatePayload to be of type PrimeModelCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/primeModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeModelsListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/primeModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PrimeModelListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPrimeModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPrimeModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/primeModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PrimeModelDetailsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTableModelsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTableModelsCreateWithHttpInfo = function(projectId, createRatingTableModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`createRatingTableModel`) && isa(createRatingTableModel, c("CreateRatingTableModel", "R6"))) {
        body <- `createRatingTableModel`$toJSON()
      } else {
        stop("ProjectsRatingTableModelsCreateWithHttpInfo requires parameter createRatingTableModel to be of type CreateRatingTableModel.")
      }

      urlPath <- "/projects/{projectId}/ratingTableModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTableModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTableModelsListWithHttpInfo = function(projectId, bulkOperationId = NULL, orderBy = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["bulkOperationId"] <- bulkOperationId

      queryParams["orderBy"] <- orderBy

      queryParams["name"] <- name

      queryParams["samplePct"] <- samplePct

      queryParams["withMetric"] <- withMetric

      queryParams["isStarred"] <- isStarred

      body <- NULL
      urlPath <- "/projects/{projectId}/ratingTableModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[RatingTableModelDetailsResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTableModelsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTableModelsRetrieveWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/ratingTableModels/{modelId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RatingTableModelDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTablesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTablesCreateWithHttpInfo = function(projectId, parentModelId, ratingTableFile, ratingTableName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`parentModelId`)) {
        stop("Missing required parameter `parentModelId`.")
      }

      if (missing(`ratingTableFile`)) {
        stop("Missing required parameter `ratingTableFile`.")
      }

      if (missing(`ratingTableName`)) {
        stop("Missing required parameter `ratingTableName`.")
      }

      body <- list(
        "parentModelId" = parentModelId,
        "ratingTableFile" = httr::upload_file(ratingTableFile),
        "ratingTableName" = ratingTableName
      )

      urlPath <- "/projects/{projectId}/ratingTables/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RatingTableCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTablesFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTablesFileListWithHttpInfo = function(projectId, ratingTableId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`ratingTableId`)) {
        stop("Missing required parameter `ratingTableId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/ratingTables/{ratingTableId}/file/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`ratingTableId`)) {
        urlPath <- gsub(paste0("\\{", "ratingTableId", "\\}"), URLencode(as.character(`ratingTableId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTablesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTablesListWithHttpInfo = function(projectId, parentModelId = NULL, modelId = NULL, offset = 0, limit = 0, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["parentModelId"] <- parentModelId

      queryParams["modelId"] <- modelId

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/ratingTables/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RatingTableListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTablesPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTablesPatchWithHttpInfo = function(projectId, ratingTableId, ratingTableUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`ratingTableId`)) {
        stop("Missing required parameter `ratingTableId`.")
      }

      if (!missing(`ratingTableUpdate`) && isa(ratingTableUpdate, c("RatingTableUpdate", "R6"))) {
        body <- `ratingTableUpdate`$toJSON()
      } else {
        stop("ProjectsRatingTablesPatchWithHttpInfo requires parameter ratingTableUpdate to be of type RatingTableUpdate.")
      }

      urlPath <- "/projects/{projectId}/ratingTables/{ratingTableId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`ratingTableId`)) {
        urlPath <- gsub(paste0("\\{", "ratingTableId", "\\}"), URLencode(as.character(`ratingTableId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RatingTableRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRatingTablesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRatingTablesRetrieveWithHttpInfo = function(projectId, ratingTableId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`ratingTableId`)) {
        stop("Missing required parameter `ratingTableId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/ratingTables/{ratingTableId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`ratingTableId`)) {
        urlPath <- gsub(paste0("\\{", "ratingTableId", "\\}"), URLencode(as.character(`ratingTableId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RatingTableRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRecommendedModelsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRecommendedModelsListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/recommendedModels/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[RecommendedModelResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsRecommendedModelsRecommendedModelList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsRecommendedModelsRecommendedModelListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/recommendedModels/recommendedModel/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RecommendedModelResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsSegmentChampionPutMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsSegmentChampionPutManyWithHttpInfo = function(projectId, segmentChampionModelUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`segmentChampionModelUpdate`) && isa(segmentChampionModelUpdate, c("SegmentChampionModelUpdate", "R6"))) {
        body <- `segmentChampionModelUpdate`$toJSON()
      } else {
        stop("ProjectsSegmentChampionPutManyWithHttpInfo requires parameter segmentChampionModelUpdate to be of type SegmentChampionModelUpdate.")
      }

      urlPath <- "/projects/{projectId}/segmentChampion/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SegmentChampionModelUpdateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
