# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title PredictionObject
#'
#' @description PredictionObject Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field actualValue  character [optional] In the case of an unsupervised time series project with a dataset using &#x60;&#x60;predictionsStartDate&#x60;&#x60; and &#x60;&#x60;predictionsEndDate&#x60;&#x60; for bulk predictions and a specified actual value column, the predictions will be a json array in the same format as with a forecast point with one additional element - &#x60;actualValues&#x60;. It is the actual value in the row.
#'
#' @field forecastDistance  integer [optional] (if time series project) The number of time units this prediction is away from the forecastPoint. The unit of time is determined by the timeUnit of the datetime partition column.
#'
#' @field forecastPoint  character [optional] (if time series project) The forecastPoint of the predictions. Either provided or inferred.
#'
#' @field originalFormatTimestamp  character [optional] The timestamp of this row in the prediction dataset. Unlike the &#x60;&#x60;timestamp&#x60;&#x60; field, this field will keep the same DateTime formatting as the uploaded prediction dataset. (This column is shown if enabled by your administrator.)
#'
#' @field positiveProbability  numeric [optional] For binary classification, the probability the row belongs to the positive class.
#'
#' @field prediction  \link{OneOfnumberstringarray} The prediction of the model.
#'
#' @field predictionExplanationMetadata  list( \link{PredictionExplanationsMetadataValues} ) [optional] Array containing algorithm-specific values. Varies depending on the value of &#x60;explanationAlgorithm&#x60;.
#'
#' @field predictionExplanations  list( \link{PredictionExplanationsObject} ) [optional] Array contains &#x60;predictionExplanation&#x60; objects. The total elements in the array are bounded by maxExplanations and feature count. It will be present only if &#x60;explanationAlgorithm&#x60; is not null (prediction explanations were requested).
#'
#' @field predictionIntervalLowerBound  numeric [optional] Present if &#x60;&#x60;includePredictionIntervals&#x60;&#x60; is True. Indicates a lower bound of the estimate of error based on test data.
#'
#' @field predictionIntervalUpperBound  numeric [optional] Present if &#x60;&#x60;includePredictionIntervals&#x60;&#x60; is True. Indicates an upper bound of the estimate of error based on test data.
#'
#' @field predictionThreshold  numeric [optional] Threshold used for binary classification in predictions.
#'
#' @field predictionValues  list( \link{PredictionArrayObjectValues} ) [optional] A list of predicted values for this row.
#'
#' @field rowId  integer The row in the prediction dataset this prediction corresponds to.
#'
#' @field segmentId  character [optional] The ID of the segment value for a segmented project.
#'
#' @field seriesId  character [optional] The ID of the series value for a multiseries project. For time series projects that are not a multiseries this will be a NaN.
#'
#' @field target  character [optional] In the case of a time series project with a dataset using predictionsStartDate and predictionsEndDate for bulk predictions, the predictions will be a json array in the same format as with a forecast point with one additional element - &#x60;target&#x60;. It is the target value in the row.
#'
#' @field timestamp  character [optional] (if time series project) The timestamp of this row in the prediction dataset.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
PredictionObject <- R6::R6Class(
  "PredictionObject",
  lock_objects = FALSE,
  private = list(
    # @description The properties of this object that are required to be set.
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(`actualValue` = NULL, `forecastDistance` = NULL, `forecastPoint` = NULL, `originalFormatTimestamp` = NULL, `positiveProbability` = NULL, `prediction` = NULL, `predictionExplanationMetadata` = NULL, `predictionExplanations` = NULL, `predictionIntervalLowerBound` = NULL, `predictionIntervalUpperBound` = NULL, `predictionThreshold` = NULL, `predictionValues` = NULL, `rowId` = NULL, `segmentId` = NULL, `seriesId` = NULL, `target` = NULL, `timestamp` = NULL) {
      if (!is.null(`prediction`)) {
        .setPrimitiveProperty(typeList = list("numeric", "character", "array"), propertyData = prediction)
      }
      if (!is.null(`rowId`)) {
        stopifnot(is.numeric(`rowId`), length(`rowId`) == 1)
      }
      if (!is.null(`actualValue`)) {
        stopifnot(is.character(`actualValue`), length(`actualValue`) == 1)
      }
      if (!is.null(`forecastDistance`)) {
        stopifnot(is.numeric(`forecastDistance`), length(`forecastDistance`) == 1)
      }
      if (!is.null(`forecastPoint`)) {
        stopifnot(inherits(`forecastPoint`, "POSIXt"))
      }
      if (!is.null(`originalFormatTimestamp`)) {
        stopifnot(is.character(`originalFormatTimestamp`), length(`originalFormatTimestamp`) == 1)
      }
      if (!is.null(`positiveProbability`)) {
        stopifnot(is.numeric(`positiveProbability`), length(`positiveProbability`) == 1)
      }
      if (!is.null(`predictionExplanationMetadata`)) {
        stopifnot(is.vector(`predictionExplanationMetadata`))
      }
      if (!is.null(`predictionExplanations`)) {
        stopifnot(is.vector(`predictionExplanations`))
      }
      if (!is.null(`predictionIntervalLowerBound`)) {
        stopifnot(is.numeric(`predictionIntervalLowerBound`), length(`predictionIntervalLowerBound`) == 1)
      }
      if (!is.null(`predictionIntervalUpperBound`)) {
        stopifnot(is.numeric(`predictionIntervalUpperBound`), length(`predictionIntervalUpperBound`) == 1)
      }
      if (!is.null(`predictionThreshold`)) {
        stopifnot(is.numeric(`predictionThreshold`), length(`predictionThreshold`) == 1)
      }
      if (!is.null(`predictionValues`)) {
        stopifnot(is.vector(`predictionValues`))
      }
      if (!is.null(`segmentId`)) {
        stopifnot(is.character(`segmentId`), length(`segmentId`) == 1)
      }
      if (!is.null(`seriesId`)) {
        stopifnot(is.character(`seriesId`), length(`seriesId`) == 1)
      }
      if (!is.null(`target`)) {
        stopifnot(is.character(`target`), length(`target`) == 1)
      }
      if (!is.null(`timestamp`)) {
        stopifnot(inherits(`timestamp`, "POSIXt"))
      }
    }
  ),
  public = list(
    `actualValue` = NULL,
    `forecastDistance` = NULL,
    `forecastPoint` = NULL,
    `originalFormatTimestamp` = NULL,
    `positiveProbability` = NULL,
    `prediction` = NULL,
    `predictionExplanationMetadata` = NULL,
    `predictionExplanations` = NULL,
    `predictionIntervalLowerBound` = NULL,
    `predictionIntervalUpperBound` = NULL,
    `predictionThreshold` = NULL,
    `predictionValues` = NULL,
    `rowId` = NULL,
    `segmentId` = NULL,
    `seriesId` = NULL,
    `target` = NULL,
    `timestamp` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param actualValue In the case of an unsupervised time series project with a dataset using &#x60;&#x60;predictionsStartDate&#x60;&#x60; and &#x60;&#x60;predictionsEndDate&#x60;&#x60; for bulk predictions and a specified actual value column, the predictions will be a json array in the same format as with a forecast point with one additional element - &#x60;actualValues&#x60;. It is the actual value in the row.
    #' @param forecastDistance (if time series project) The number of time units this prediction is away from the forecastPoint. The unit of time is determined by the timeUnit of the datetime partition column.
    #' @param forecastPoint (if time series project) The forecastPoint of the predictions. Either provided or inferred.
    #' @param originalFormatTimestamp The timestamp of this row in the prediction dataset. Unlike the &#x60;&#x60;timestamp&#x60;&#x60; field, this field will keep the same DateTime formatting as the uploaded prediction dataset. (This column is shown if enabled by your administrator.)
    #' @param positiveProbability For binary classification, the probability the row belongs to the positive class.
    #' @param prediction The prediction of the model.
    #' @param predictionExplanationMetadata Array containing algorithm-specific values. Varies depending on the value of &#x60;explanationAlgorithm&#x60;.
    #' @param predictionExplanations Array contains &#x60;predictionExplanation&#x60; objects. The total elements in the array are bounded by maxExplanations and feature count. It will be present only if &#x60;explanationAlgorithm&#x60; is not null (prediction explanations were requested).
    #' @param predictionIntervalLowerBound Present if &#x60;&#x60;includePredictionIntervals&#x60;&#x60; is True. Indicates a lower bound of the estimate of error based on test data.
    #' @param predictionIntervalUpperBound Present if &#x60;&#x60;includePredictionIntervals&#x60;&#x60; is True. Indicates an upper bound of the estimate of error based on test data.
    #' @param predictionThreshold Threshold used for binary classification in predictions.
    #' @param predictionValues A list of predicted values for this row.
    #' @param rowId The row in the prediction dataset this prediction corresponds to.
    #' @param segmentId The ID of the segment value for a segmented project.
    #' @param seriesId The ID of the series value for a multiseries project. For time series projects that are not a multiseries this will be a NaN.
    #' @param target In the case of a time series project with a dataset using predictionsStartDate and predictionsEndDate for bulk predictions, the predictions will be a json array in the same format as with a forecast point with one additional element - &#x60;target&#x60;. It is the target value in the row.
    #' @param timestamp (if time series project) The timestamp of this row in the prediction dataset.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`prediction` = NULL, `rowId` = NULL, `actualValue` = NULL, `forecastDistance` = NULL, `forecastPoint` = NULL, `originalFormatTimestamp` = NULL, `positiveProbability` = NULL, `predictionExplanationMetadata` = NULL, `predictionExplanations` = NULL, `predictionIntervalLowerBound` = NULL, `predictionIntervalUpperBound` = NULL, `predictionThreshold` = NULL, `predictionValues` = NULL, `segmentId` = NULL, `seriesId` = NULL, `target` = NULL, `timestamp` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      if (validateParams) {
        lapply(list(`prediction`, `rowId`), function(param) {
          stopifnot("Required param not set." = !is.null(param))
        })
        private$validateProps(actualValue, forecastDistance, forecastPoint, originalFormatTimestamp, positiveProbability, prediction, predictionExplanationMetadata, predictionExplanations, predictionIntervalLowerBound, predictionIntervalUpperBound, predictionThreshold, predictionValues, rowId, segmentId, seriesId, target, timestamp)
      }
      self$`actualValue` <- `actualValue`
      self$`forecastDistance` <- `forecastDistance`
      self$`forecastPoint` <- `forecastPoint`
      self$`originalFormatTimestamp` <- `originalFormatTimestamp`
      self$`positiveProbability` <- `positiveProbability`
      self$`prediction` <- .setPrimitiveProperty(typeList = list("numeric", "character", "array"), propertyData = prediction)
      sapply(`predictionExplanationMetadata`, function(x) stopifnot(R6::is.R6(x)))
      sapply(`predictionExplanations`, function(x) stopifnot(R6::is.R6(x)))
      self$`predictionIntervalLowerBound` <- `predictionIntervalLowerBound`
      self$`predictionIntervalUpperBound` <- `predictionIntervalUpperBound`
      self$`predictionThreshold` <- `predictionThreshold`
      sapply(`predictionValues`, function(x) stopifnot(R6::is.R6(x)))
      self$`rowId` <- `rowId`
      self$`segmentId` <- `segmentId`
      self$`seriesId` <- `seriesId`
      self$`target` <- `target`
      self$`timestamp` <- `timestamp`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    #' checking this objects set properties.
    validate = function() {
      do.call(private$validateProps, list(actualValue = self$`actualValue`, forecastDistance = self$`forecastDistance`, forecastPoint = self$`forecastPoint`, originalFormatTimestamp = self$`originalFormatTimestamp`, positiveProbability = self$`positiveProbability`, prediction = self$`prediction`, predictionExplanationMetadata = self$`predictionExplanationMetadata`, predictionExplanations = self$`predictionExplanations`, predictionIntervalLowerBound = self$`predictionIntervalLowerBound`, predictionIntervalUpperBound = self$`predictionIntervalUpperBound`, predictionThreshold = self$`predictionThreshold`, predictionValues = self$`predictionValues`, rowId = self$`rowId`, segmentId = self$`segmentId`, seriesId = self$`seriesId`, target = self$`target`, timestamp = self$`timestamp`))
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`actualValue`)) {
          sprintf(
            '"actualValue":
            "%s"
                  ',
            self$`actualValue`
          )
        },
        if (!is.null(self$`forecastDistance`)) {
          sprintf(
            '"forecastDistance":
            %d
                  ',
            self$`forecastDistance`
          )
        },
        if (!is.null(self$`forecastPoint`)) {
          sprintf(
            '"forecastPoint":
            "%s"
                  ',
            format(self$`forecastPoint`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`originalFormatTimestamp`)) {
          sprintf(
            '"originalFormatTimestamp":
            "%s"
                  ',
            self$`originalFormatTimestamp`
          )
        },
        if (!is.null(self$`positiveProbability`)) {
          sprintf(
            '"positiveProbability":
            %d
                  ',
            self$`positiveProbability`
          )
        },
        if (!is.null(self$`prediction`)) {
          sprintf(
            '"prediction":
            %s
      ',
            self$`prediction`
          )
        },
        if (!is.null(self$`predictionExplanationMetadata`)) {
          sprintf(
            '"predictionExplanationMetadata":
            [%s]
      ',
            paste(sapply(self$`predictionExplanationMetadata`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`predictionExplanations`)) {
          sprintf(
            '"predictionExplanations":
            [%s]
      ',
            paste(sapply(self$`predictionExplanations`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`predictionIntervalLowerBound`)) {
          sprintf(
            '"predictionIntervalLowerBound":
            %d
                  ',
            self$`predictionIntervalLowerBound`
          )
        },
        if (!is.null(self$`predictionIntervalUpperBound`)) {
          sprintf(
            '"predictionIntervalUpperBound":
            %d
                  ',
            self$`predictionIntervalUpperBound`
          )
        },
        if (!is.null(self$`predictionThreshold`)) {
          sprintf(
            '"predictionThreshold":
            %d
                  ',
            self$`predictionThreshold`
          )
        },
        if (!is.null(self$`predictionValues`)) {
          sprintf(
            '"predictionValues":
            [%s]
      ',
            paste(sapply(self$`predictionValues`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`rowId`)) {
          sprintf(
            '"rowId":
            %d
                  ',
            self$`rowId`
          )
        },
        if (!is.null(self$`segmentId`)) {
          sprintf(
            '"segmentId":
            "%s"
                  ',
            self$`segmentId`
          )
        },
        if (!is.null(self$`seriesId`)) {
          sprintf(
            '"seriesId":
            "%s"
                  ',
            self$`seriesId`
          )
        },
        if (!is.null(self$`target`)) {
          sprintf(
            '"target":
            "%s"
                  ',
            self$`target`
          )
        },
        if (!is.null(self$`timestamp`)) {
          sprintf(
            '"timestamp":
            "%s"
                  ',
            format(self$`timestamp`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param PredictionObjectJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(PredictionObjectJson, validateParams = FALSE) {
      PredictionObjectObject <- jsonlite::fromJSON(PredictionObjectJson)
      self$`actualValue` <- PredictionObjectObject$`actualValue`
      self$`forecastDistance` <- PredictionObjectObject$`forecastDistance`
      self$`forecastPoint` <- ParseRFC3339Timestamp(PredictionObjectObject$`forecastPoint`)
      self$`originalFormatTimestamp` <- PredictionObjectObject$`originalFormatTimestamp`
      self$`positiveProbability` <- PredictionObjectObject$`positiveProbability`
      self$`prediction` <- .setPrimitiveProperty(typeList = list("numeric", "character", "array"), propertyData = PredictionObjectObject$prediction)
      self$`predictionExplanationMetadata` <- ApiClient$new()$deserializeObj(PredictionObjectObject$`predictionExplanationMetadata`, "array[PredictionExplanationsMetadataValues]", loadNamespace("datarobot.apicore"))
      self$`predictionExplanations` <- ApiClient$new()$deserializeObj(PredictionObjectObject$`predictionExplanations`, "array[PredictionExplanationsObject]", loadNamespace("datarobot.apicore"))
      self$`predictionIntervalLowerBound` <- PredictionObjectObject$`predictionIntervalLowerBound`
      self$`predictionIntervalUpperBound` <- PredictionObjectObject$`predictionIntervalUpperBound`
      self$`predictionThreshold` <- PredictionObjectObject$`predictionThreshold`
      self$`predictionValues` <- ApiClient$new()$deserializeObj(PredictionObjectObject$`predictionValues`, "array[PredictionArrayObjectValues]", loadNamespace("datarobot.apicore"))
      self$`rowId` <- PredictionObjectObject$`rowId`
      self$`segmentId` <- PredictionObjectObject$`segmentId`
      self$`seriesId` <- PredictionObjectObject$`seriesId`
      self$`target` <- PredictionObjectObject$`target`
      self$`timestamp` <- ParseRFC3339Timestamp(PredictionObjectObject$`timestamp`)

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
