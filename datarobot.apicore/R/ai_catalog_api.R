# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title AiCatalog operations
#' @description datarobot.apicore.AiCatalog
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
AiCatalogApi <- R6::R6Class(
  "AiCatalogApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description List all catalog items accessible by the user.
    #' Produces: "application/json"
    #'
    #' @details List all catalog items accessible by the user.
    #' @details This method invokes `GET /catalogItems/` in the DataRobot Public API.
    #' @param offset integer. Specifies the number of results to skip for pagination.
    #' @param limit integer. Sets the maximum number of results returned. Enter 0 to specify no limit.
    #' @param initialCacheSize integer. The initial cache size, for Mongo search only.
    #' @param useCache Enum < [false, False, true, True] > Sets whether to use the cache, for Mongo search only.
    #' @param orderBy Enum < [originalName, -originalName, catalogName, -catalogName, description, -description, created, -created, relevance, -relevance] > The attribute sort order applied to the returned catalog list: &#39;catalogName&#39;, &#39;originalName&#39;, &#39;description&#39;, &#39;created&#39;, or &#39;relevance&#39;. For all options other than &#39;relevance&#39;, prefix the attribute name with a dash to sort in descending order. e.g., orderBy&#x3D;&#39;-catalogName&#39;. Defaults to &#39;-created&#39;.
    #' @param searchFor character. A value to search for in the dataset&#39;s name, description, tags, column names, categories, and latest errors. The search is case insensitive. If no value is provided, or if the empty string is used, or if the string contains only whitespace, no filtering occurs. Partial matching is performed on the dataset name and description fields; all other fields require an exact match.
    #' @param tag \link{OneOfstringarray}. Filter results to display only items with the specified catalog item tags, in lower case, with no spaces.
    #' @param accessType Enum < [owner, shared, any, created] > Access type used to filter returned results. Valid options are &#39;owner&#39;, &#39;shared&#39;, &#39;created&#39;, and &#39;any&#39; (the default): &#39;owner&#39; items are owned by the requester, &#39;shared&#39; items have been shared with the requester, &#39;created&#39; items have been created by the requester, and &#39;any&#39; items matches all.
    #' @param datasourceType \link{OneOfstringarray}. Data source types used for filtering.
    #' @param category \link{OneOfstringarray}. Category type(s) used for filtering. Searches are case sensitive and support &#39;&amp;&#39; and &#39;OR&#39; operators.
    #' @param filterFailed Enum < [false, False, true, True] > Sets whether to exclude from the search results all catalog items that failed during import. If True, invalid catalog items will be excluded; default is False.
    #' @param ownerUserId \link{OneOfstringarray}. Filter results to display only those owned by user(s) identified by the specified UID.
    #' @param ownerUsername \link{OneOfstringarray}. Filter results to display only those owned by user(s) identified by the specified username.
    #' @param type Enum < [data_mesh_workspace, snapshot_dataset, user_blueprint, remote_dataset, dataset] > Filter results by catalog type. The &#39;dataset&#39; option matches both &#39;snapshot_dataset&#39; and &#39;remote_dataset&#39;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CatalogListSearchResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Paginated list of catalog items is returned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Specifies the number of results to skip for pagination.
    #' limit <- 0 # integer | Sets the maximum number of results returned. Enter 0 to specify no limit.
    #' initialCacheSize <- 500 # integer | The initial cache size, for Mongo search only.
    #' useCache <- "false" # character | Sets whether to use the cache, for Mongo search only.
    #' orderBy <- 'orderBy_example' # character | The attribute sort order applied to the returned catalog list: 'catalogName', 'originalName', 'description', 'created', or 'relevance'. For all options other than 'relevance', prefix the attribute name with a dash to sort in descending order. e.g., orderBy='-catalogName'. Defaults to '-created'.
    #' searchFor <- 'searchFor_example' # character | A value to search for in the dataset's name, description, tags, column names, categories, and latest errors. The search is case insensitive. If no value is provided, or if the empty string is used, or if the string contains only whitespace, no filtering occurs. Partial matching is performed on the dataset name and description fields; all other fields require an exact match.
    #' tag <- list(c('tag_example')) # OneOfstringarray | Filter results to display only items with the specified catalog item tags, in lower case, with no spaces.
    #' accessType <- "any" # character | Access type used to filter returned results. Valid options are 'owner', 'shared', 'created', and 'any' (the default): 'owner' items are owned by the requester, 'shared' items have been shared with the requester, 'created' items have been created by the requester, and 'any' items matches all.
    #' datasourceType <- list(c('datasourceType_example')) # OneOfstringarray | Data source types used for filtering.
    #' category <- list(c('category_example')) # OneOfstringarray | Category type(s) used for filtering. Searches are case sensitive and support '&' and 'OR' operators.
    #' filterFailed <- "false" # character | Sets whether to exclude from the search results all catalog items that failed during import. If True, invalid catalog items will be excluded; default is False.
    #' ownerUserId <- list(c('ownerUserId_example')) # OneOfstringarray | Filter results to display only those owned by user(s) identified by the specified UID.
    #' ownerUsername <- list(c('ownerUsername_example')) # OneOfstringarray | Filter results to display only those owned by user(s) identified by the specified username.
    #' type <- 'type_example' # character | Filter results by catalog type. The 'dataset' option matches both 'snapshot_dataset' and 'remote_dataset'.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$CatalogItemsList(offset, limit, initialCacheSize, useCache=useCache, orderBy=orderBy, searchFor=searchFor, tag=tag, accessType=accessType, datasourceType=datasourceType, category=category, filterFailed=filterFailed, ownerUserId=ownerUserId, ownerUsername=ownerUsername, type=type)
    #' }
    CatalogItemsList = function(offset, limit, initialCacheSize, useCache = "false", orderBy = NULL, searchFor = NULL, tag = NULL, accessType = "any", datasourceType = NULL, category = NULL, filterFailed = "false", ownerUserId = NULL, ownerUsername = NULL, type = NULL, ...) {
      apiResponse <- private$CatalogItemsListWithHttpInfo(offset, limit, initialCacheSize, useCache, orderBy, searchFor, tag, accessType, datasourceType, category, filterFailed, ownerUserId, ownerUsername, type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the name, description, or tags for the requested catalog item.
    #' Produces: "application/json"
    #'
    #' @details Update the name, description, or tags for the requested catalog item.
    #' @details This method invokes `PATCH /catalogItems/{catalogId}/` in the DataRobot Public API.
    #' @param catalogId character. Catalog item ID.
    #' @param updateCatalogMetadata \link{UpdateCatalogMetadata}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CatalogExtendedDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Extended details of the updated catalog item.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to update this catalog item.
    #' \itemize{
    #' }
    #' \item **`410`** Requested catalog item was previously deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' catalogId <- 'catalogId_example' # character | Catalog item ID.
    #' updateCatalogMetadata <- UpdateCatalogMetadata$new() # UpdateCatalogMetadata |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$CatalogItemsPatch(catalogId, updateCatalogMetadata=updateCatalogMetadata)
    #' }
    CatalogItemsPatch = function(catalogId, updateCatalogMetadata = NULL, ...) {
      apiResponse <- private$CatalogItemsPatchWithHttpInfo(catalogId, updateCatalogMetadata, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieves latest version information, by ID, for catalog items.
    #' Produces: "application/json"
    #'
    #' @details Retrieves latest version information, by ID, for catalog items.
    #' @details This method invokes `GET /catalogItems/{catalogId}/` in the DataRobot Public API.
    #' @param catalogId character. Catalog item ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CatalogDetailsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Catalog item details retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' catalogId <- 'catalogId_example' # character | Catalog item ID.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$CatalogItemsRetrieve(catalogId)
    #' }
    CatalogItemsRetrieve = function(catalogId, ...) {
      apiResponse <- private$CatalogItemsRetrieveWithHttpInfo(catalogId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a data engine query generator
    #' Produces: NA
    #'
    #' @details Create a data engine query generator.
    #' @details This method invokes `POST /dataEngineQueryGenerators/` in the DataRobot Public API.
    #' @param createDataEngineQueryGenerator \link{CreateDataEngineQueryGenerator}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process data engine query generation.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' createDataEngineQueryGenerator <- CreateDataEngineQueryGenerator$new() # CreateDataEngineQueryGenerator |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DataEngineQueryGeneratorsCreate(createDataEngineQueryGenerator=createDataEngineQueryGenerator)
    #' }
    DataEngineQueryGeneratorsCreate = function(createDataEngineQueryGenerator = NULL, ...) {
      apiResponse <- private$DataEngineQueryGeneratorsCreateWithHttpInfo(createDataEngineQueryGenerator, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a data engine query generator given ID.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a data engine query generator
    #' @details This method invokes `GET /dataEngineQueryGenerators/{dataEngineQueryGeneratorId}/` in the DataRobot Public API.
    #' @param dataEngineQueryGeneratorId character. The ID of the data engine query generator.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrieveDataEngineQueryResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Specified query generator was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataEngineQueryGeneratorId <- 'dataEngineQueryGeneratorId_example' # character | The ID of the data engine query generator.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DataEngineQueryGeneratorsRetrieve(dataEngineQueryGeneratorId)
    #' }
    DataEngineQueryGeneratorsRetrieve = function(dataEngineQueryGeneratorId, ...) {
      apiResponse <- private$DataEngineQueryGeneratorsRetrieveWithHttpInfo(dataEngineQueryGeneratorId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create Data Engine workspace state
    #' Produces: "application/json"
    #'
    #' @details Create Data Engine workspace state in database.
    #' @details This method invokes `POST /dataEngineWorkspaceStates/` in the DataRobot Public API.
    #' @param createWorkspaceState \link{CreateWorkspaceState}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{WorkspaceSourceCreatedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The Data Engine Workspace state
    #' \itemize{
    #' }
    #' \item **`410`** Specified workspace state was already deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' createWorkspaceState <- CreateWorkspaceState$new() # CreateWorkspaceState |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DataEngineWorkspaceStatesCreate(createWorkspaceState=createWorkspaceState)
    #' }
    DataEngineWorkspaceStatesCreate = function(createWorkspaceState = NULL, ...) {
      apiResponse <- private$DataEngineWorkspaceStatesCreateWithHttpInfo(createWorkspaceState, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create Data Engine workspace state from a query generator
    #' Produces: "application/json"
    #'
    #' @details Create Data Engine workspace state in database from a query generator.
    #' @details This method invokes `POST /dataEngineWorkspaceStates/fromDataEngineQueryGenerator/` in the DataRobot Public API.
    #' @param createWorkspaceStateFromQueryGenerator \link{CreateWorkspaceStateFromQueryGenerator}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{WorkspaceStateCreatedFromQueryGeneratorResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** The Data Engine Workspace state
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' createWorkspaceStateFromQueryGenerator <- CreateWorkspaceStateFromQueryGenerator$new() # CreateWorkspaceStateFromQueryGenerator |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreate(createWorkspaceStateFromQueryGenerator=createWorkspaceStateFromQueryGenerator)
    #' }
    DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreate = function(createWorkspaceStateFromQueryGenerator = NULL, ...) {
      apiResponse <- private$DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreateWithHttpInfo(createWorkspaceStateFromQueryGenerator, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Read Data Engine workspace state
    #' Produces: "application/json"
    #'
    #' @details Read and return previously stored Data Engine workspace state.
    #' @details This method invokes `GET /dataEngineWorkspaceStates/{workspaceStateId}/` in the DataRobot Public API.
    #' @param workspaceStateId character. The ID of the Data Engine workspace state.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{WorkspaceStateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The Data Engine workspace state
    #' \itemize{
    #' }
    #' \item **`410`** Specified workspace state was already deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' workspaceStateId <- 'workspaceStateId_example' # character | The ID of the Data Engine workspace state.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DataEngineWorkspaceStatesRetrieve(workspaceStateId)
    #' }
    DataEngineWorkspaceStatesRetrieve = function(workspaceStateId, ...) {
      apiResponse <- private$DataEngineWorkspaceStatesRetrieveWithHttpInfo(workspaceStateId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List dataset access
    #' Produces: "application/json"
    #'
    #' @details List the users and their associated roles for the specified dataset.
    #' @details This method invokes `GET /datasets/{datasetId}/accessControl/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param datasetId character. The ID of the dataset.
    #' @param userId character. Only return the access control information for a user with this user ID.
    #' @param username character. Only return the access control information for a user with this username.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetAccessControlListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of user permissions
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' userId <- 'userId_example' # character | Only return the access control information for a user with this user ID.
    #' username <- 'username_example' # character | Only return the access control information for a user with this username.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsAccessControlList(offset, limit, datasetId, userId=userId, username=username)
    #' }
    DatasetsAccessControlList = function(offset, limit, datasetId, userId = NULL, username = NULL, ...) {
      apiResponse <- private$DatasetsAccessControlListWithHttpInfo(offset, limit, datasetId, userId, username, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Modify dataset access
    #' Produces: NA
    #'
    #' @details Grant access to the dataset at the specified role level, or remove access to the dataset.
    #' @details This method invokes `PATCH /datasets/{datasetId}/accessControl/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetAccessSet \link{DatasetAccessSet}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully modified
    #' \itemize{
    #' }
    #' \item **`409`** Duplicate entry for a user in permission list or the request would leave the dataset without an owner.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetAccessSet <- DatasetAccessSet$new() # DatasetAccessSet |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsAccessControlPatchMany(datasetId, datasetAccessSet=datasetAccessSet)
    #' }
    DatasetsAccessControlPatchMany = function(datasetId, datasetAccessSet = NULL, ...) {
      apiResponse <- private$DatasetsAccessControlPatchManyWithHttpInfo(datasetId, datasetAccessSet, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset features
    #' Produces: "application/json"
    #'
    #' @details Return detailed information on all the features and transforms for this dataset.If the Dataset Item has attribute snapshot &#x3D; True, all optional fields also appear
    #' @details This method invokes `GET /datasets/{datasetId}/allFeaturesDetails/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. This many results will be skipped.
    #' @param orderBy character. How the features should be ordered.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of feature info
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | This many results will be skipped.
    #' orderBy <- "name" # character | How the features should be ordered.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsAllFeaturesDetailsList(limit, offset, orderBy, datasetId)
    #' }
    DatasetsAllFeaturesDetailsList = function(limit, offset, orderBy, datasetId, ...) {
      apiResponse <- private$DatasetsAllFeaturesDetailsListWithHttpInfo(limit, offset, orderBy, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete dataset
    #' Produces: NA
    #'
    #' @details Marks the dataset with the given ID as deleted.
    #' @details This method invokes `DELETE /datasets/{datasetId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully deleted
    #' \itemize{
    #' }
    #' \item **`409`** Cannot delete a dataset that has refresh jobs.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsDelete(datasetId)
    #' }
    DatasetsDelete = function(datasetId, ...) {
      apiResponse <- private$DatasetsDeleteWithHttpInfo(datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Recover deleted dataset
    #' Produces: NA
    #'
    #' @details Recover the dataset item with given datasetId from deleted.
    #' @details This method invokes `PATCH /datasets/{datasetId}/deleted/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Item was not deleted: nothing to recover.
    #' \itemize{
    #' }
    #' \item **`204`** Successfully recovered
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' body <- NULL # object |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsDeletedPatchMany(datasetId, body=body)
    #' }
    DatasetsDeletedPatchMany = function(datasetId, body = NULL, ...) {
      apiResponse <- private$DatasetsDeletedPatchManyWithHttpInfo(datasetId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset feature histogram
    #' Produces: "application/json"
    #'
    #' @details Get histogram chart data for a specific feature in the specified dataset.
    #' @details This method invokes `GET /datasets/{datasetId}/featureHistograms/{featureName}/` in the DataRobot Public API.
    #' @param binLimit integer. Maximum number of bins in the returned plot.
    #' @param datasetId character. The ID of the dataset entry to retrieve.
    #' @param featureName character. The name of the feature.
    #' @param key character. Only required for the Summarized categorical feature. Name of the top 50 key for which plot to be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeatureHistogramResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature histogram
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' binLimit <- 60 # integer | Maximum number of bins in the returned plot.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry to retrieve.
    #' featureName <- 'featureName_example' # character | The name of the feature.
    #' key <- 'key_example' # character | Only required for the Summarized categorical feature. Name of the top 50 key for which plot to be retrieved.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeatureHistogramsRetrieve(binLimit, datasetId, featureName, key=key)
    #' }
    DatasetsFeatureHistogramsRetrieve = function(binLimit, datasetId, featureName, key = NULL, ...) {
      apiResponse <- private$DatasetsFeatureHistogramsRetrieveWithHttpInfo(binLimit, datasetId, featureName, key, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset feature transform
    #' Produces: NA
    #'
    #' @details Create a new feature by changing the type of an existing one.
    #' @details This method invokes `POST /datasets/{datasetId}/featureTransforms/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param featureTransform \link{FeatureTransform}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`409`** Feature name already exists.
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted.
    #' \itemize{
    #' }
    #' \item **`422`** In case of an invalid transformation or when dataset does not have profile data or sample files available.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' featureTransform <- FeatureTransform$new() # FeatureTransform |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeatureTransformsCreate(datasetId, featureTransform=featureTransform)
    #' }
    DatasetsFeatureTransformsCreate = function(datasetId, featureTransform = NULL, ...) {
      apiResponse <- private$DatasetsFeatureTransformsCreateWithHttpInfo(datasetId, featureTransform, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List dataset feature transforms
    #' Produces: "application/json"
    #'
    #' @details Retrieves the transforms of the dataset with given ID.
    #' @details This method invokes `GET /datasets/{datasetId}/featureTransforms/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. This many results will be skipped.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetTransformListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of feature transforms
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | This many results will be skipped.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeatureTransformsList(limit, offset, datasetId)
    #' }
    DatasetsFeatureTransformsList = function(limit, offset, datasetId, ...) {
      apiResponse <- private$DatasetsFeatureTransformsListWithHttpInfo(limit, offset, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset feature transform
    #' Produces: "application/json"
    #'
    #' @details Retrieve the specified feature with descriptive information.
    #' @details This method invokes `GET /datasets/{datasetId}/featureTransforms/{featureName}/` in the DataRobot Public API.
    #' @param datasetId character. The dataset to select feature from.
    #' @param featureName character. The name of the feature. Note that DataRobot renames some features, so the feature name may not be the one from your original data. Non-ascii features names should be utf-8-encoded (before URL-quoting).
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetTransformResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature transform
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The dataset to select feature from.
    #' featureName <- 'featureName_example' # character | The name of the feature. Note that DataRobot renames some features, so the feature name may not be the one from your original data. Non-ascii features names should be utf-8-encoded (before URL-quoting).
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeatureTransformsRetrieve(datasetId, featureName)
    #' }
    DatasetsFeatureTransformsRetrieve = function(datasetId, featureName, ...) {
      apiResponse <- private$DatasetsFeatureTransformsRetrieveWithHttpInfo(datasetId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset featurelist
    #' Produces: "application/json"
    #'
    #' @details Create featurelist for specified dataset.
    #' @details This method invokes `POST /datasets/{datasetId}/featurelists/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param featureListCreate \link{FeatureListCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Successfully created
    #' \itemize{
    #' }
    #' \item **`409`** Feature list with specified name already exists
    #' \itemize{
    #' }
    #' \item **`422`** One or more of the specified features does not exist in the dataset
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' featureListCreate <- FeatureListCreate$new() # FeatureListCreate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeaturelistsCreate(datasetId, featureListCreate=featureListCreate)
    #' }
    DatasetsFeaturelistsCreate = function(datasetId, featureListCreate = NULL, ...) {
      apiResponse <- private$DatasetsFeaturelistsCreateWithHttpInfo(datasetId, featureListCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete dataset featurelist
    #' Produces: NA
    #'
    #' @details Deletes the indicated featurelist of the dataset with given ID.
    #' @details This method invokes `DELETE /datasets/{datasetId}/featurelists/{featurelistId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param featurelistId character. The ID of the featurelist.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' featurelistId <- 'featurelistId_example' # character | The ID of the featurelist.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeaturelistsDelete(datasetId, featurelistId)
    #' }
    DatasetsFeaturelistsDelete = function(datasetId, featurelistId, ...) {
      apiResponse <- private$DatasetsFeaturelistsDeleteWithHttpInfo(datasetId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve dataset featurelists
    #' Produces: "application/json"
    #'
    #' @details Retrieves the featurelists of the dataset with given ID and the latest dataset version.
    #' @details This method invokes `GET /datasets/{datasetId}/featurelists/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. This many results will be skipped.
    #' @param orderBy character. How the features should be ordered.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturelistListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of featurelists
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | This many results will be skipped.
    #' orderBy <- "name" # character | How the features should be ordered.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeaturelistsList(limit, offset, orderBy, datasetId)
    #' }
    DatasetsFeaturelistsList = function(limit, offset, orderBy, datasetId, ...) {
      apiResponse <- private$DatasetsFeaturelistsListWithHttpInfo(limit, offset, orderBy, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update dataset featurelist
    #' Produces: NA
    #'
    #' @details Modifies the indicated featurelist of the dataset with given ID.
    #' @details This method invokes `PATCH /datasets/{datasetId}/featurelists/{featurelistId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param featurelistId character. The ID of the featurelist.
    #' @param featureListModify \link{FeatureListModify}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully modified
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' featurelistId <- 'featurelistId_example' # character | The ID of the featurelist.
    #' featureListModify <- FeatureListModify$new() # FeatureListModify |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeaturelistsPatch(datasetId, featurelistId, featureListModify=featureListModify)
    #' }
    DatasetsFeaturelistsPatch = function(datasetId, featurelistId, featureListModify = NULL, ...) {
      apiResponse <- private$DatasetsFeaturelistsPatchWithHttpInfo(datasetId, featurelistId, featureListModify, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset featurelist
    #' Produces: "application/json"
    #'
    #' @details Retrieves the specified featurelist of the dataset with given ID and the latest dataset version.
    #' @details This method invokes `GET /datasets/{datasetId}/featurelists/{featurelistId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param featurelistId character. The ID of the featurelist.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The featurelist
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' featurelistId <- 'featurelistId_example' # character | The ID of the featurelist.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFeaturelistsRetrieve(datasetId, featurelistId)
    #' }
    DatasetsFeaturelistsRetrieve = function(datasetId, featurelistId, ...) {
      apiResponse <- private$DatasetsFeaturelistsRetrieveWithHttpInfo(datasetId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve original dataset data
    #' Produces: "text/csv"
    #'
    #' @details Retrieve all the originally uploaded data, in CSV form.
    #' @details This method invokes `GET /datasets/{datasetId}/file/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The original dataset data
    #' \itemize{
    #' }
    #' \item **`409`** Ingest info is missing for dataset version.
    #' \itemize{
    #' }
    #' \item **`422`** Dataset cannot be downloaded. Possible reasons include \&quot;dataPersisted\&quot; being false for the dataset, the dataset not being a snapshot, and this dataset is too big to be downloaded (maximum download size depends on a config of your installation).
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFileList(datasetId)
    #' }
    DatasetsFileList = function(datasetId, ...) {
      apiResponse <- private$DatasetsFileListWithHttpInfo(datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset from Data Engine workspace
    #' Produces: "application/json"
    #'
    #' @details Create a dataset from a Data Engine workspace state.
    #' @details This method invokes `POST /datasets/fromDataEngineWorkspaceState/` in the DataRobot Public API.
    #' @param datasetCreateFromWorkspaceState \link{DatasetCreateFromWorkspaceState}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetDataEngineResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`410`** Specified query output was already deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetCreateFromWorkspaceState <- DatasetCreateFromWorkspaceState$new() # DatasetCreateFromWorkspaceState |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFromDataEngineWorkspaceStateCreate(datasetCreateFromWorkspaceState=datasetCreateFromWorkspaceState)
    #' }
    DatasetsFromDataEngineWorkspaceStateCreate = function(datasetCreateFromWorkspaceState = NULL, ...) {
      apiResponse <- private$DatasetsFromDataEngineWorkspaceStateCreateWithHttpInfo(datasetCreateFromWorkspaceState, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset from data source
    #' Produces: "application/json"
    #'
    #' @details Create a Dataset Item from a data source.
    #' @details This method invokes `POST /datasets/fromDataSource/` in the DataRobot Public API.
    #' @param datasource \link{Datasource}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasource <- Datasource$new() # Datasource |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFromDataSourceCreate(datasource=datasource)
    #' }
    DatasetsFromDataSourceCreate = function(datasource = NULL, ...) {
      apiResponse <- private$DatasetsFromDataSourceCreateWithHttpInfo(datasource, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset from file
    #' Produces: "application/json"
    #'
    #' @details Create a dataset from a file.
    #' @details This method invokes `POST /datasets/fromFile/` in the DataRobot Public API.
    #' @param file character. The data to be used for the creation.
    #' @param categories \link{OneOfstringarray}. An array of strings describing the intended use of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** The request cannot be processed. The request did not contain file contents.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' file <- '/path/to/file.csv' # character | The data to be used for the creation.
    #' categories <- list(c('categories_example')) # OneOfstringarray | An array of strings describing the intended use of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFromFileCreate(file, categories=categories)
    #' }
    DatasetsFromFileCreate = function(file, categories = NULL, ...) {
      apiResponse <- private$DatasetsFromFileCreateWithHttpInfo(file, categories, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset from HDFS URL
    #' Produces: "application/json"
    #'
    #' @details Create a Dataset Item from an HDFS URL.
    #' @details This method invokes `POST /datasets/fromHDFS/` in the DataRobot Public API.
    #' @param hdfs \link{Hdfs}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' hdfs <- Hdfs$new() # Hdfs |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFromHDFSCreate(hdfs=hdfs)
    #' }
    DatasetsFromHDFSCreate = function(hdfs = NULL, ...) {
      apiResponse <- private$DatasetsFromHDFSCreateWithHttpInfo(hdfs, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset from URL
    #' Produces: "application/json"
    #'
    #' @details Create a Dataset Item from a URL.
    #' @details This method invokes `POST /datasets/fromURL/` in the DataRobot Public API.
    #' @param url \link{Url}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' url <- Url$new() # Url |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsFromURLCreate(url=url)
    #' }
    DatasetsFromURLCreate = function(url = NULL, ...) {
      apiResponse <- private$DatasetsFromURLCreateWithHttpInfo(url, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List datasets
    #' Produces: "application/json"
    #'
    #' @details List all datasets accessible by the user.
    #' @details This method invokes `GET /datasets/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned.
    #' @param offset integer. This many results will be skipped.
    #' @param category Enum < [TRAINING, PREDICTION] > If specified, only dataset versions that have the specified category will be included in the results. Categories identify the intended use of the dataset.
    #' @param orderBy Enum < [created, -created] > Sorting order which will be applied to catalog list.
    #' @param filterFailed Enum < [false, False, true, True] > Whether datasets that failed during import should be excluded from the results. If True invalid datasets will be excluded.
    #' @param datasetVersionIds \link{OneOfstringarray}. If specified will only return datasets that are associated with specified dataset versions.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of datasets
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned.
    #' offset <- 0 # integer | This many results will be skipped.
    #' category <- 'category_example' # character | If specified, only dataset versions that have the specified category will be included in the results. Categories identify the intended use of the dataset.
    #' orderBy <- 'orderBy_example' # character | Sorting order which will be applied to catalog list.
    #' filterFailed <- "false" # character | Whether datasets that failed during import should be excluded from the results. If True invalid datasets will be excluded.
    #' datasetVersionIds <- list(c('datasetVersionIds_example')) # OneOfstringarray | If specified will only return datasets that are associated with specified dataset versions.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsList(limit, offset, category=category, orderBy=orderBy, filterFailed=filterFailed, datasetVersionIds=datasetVersionIds)
    #' }
    DatasetsList = function(limit, offset, category = NULL, orderBy = NULL, filterFailed = "false", datasetVersionIds = NULL, ...) {
      apiResponse <- private$DatasetsListWithHttpInfo(limit, offset, category, orderBy, filterFailed, datasetVersionIds, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Modify dataset
    #' Produces: "application/json"
    #'
    #' @details Modifies the specified dataset.
    #' @details This method invokes `PATCH /datasets/{datasetId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param patchDataset \link{PatchDataset}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BasicDatasetDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Dataset successfully modified
    #' \itemize{
    #' }
    #' \item **`422`** The categories are not applicable to the dataset.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' patchDataset <- PatchDataset$new() # PatchDataset |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsPatch(datasetId, patchDataset=patchDataset)
    #' }
    DatasetsPatch = function(datasetId, patchDataset = NULL, ...) {
      apiResponse <- private$DatasetsPatchWithHttpInfo(datasetId, patchDataset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Execute bulk dataset action
    #' Produces: NA
    #'
    #' @details Execute the specified bulk action on multiple datasets.
    #' @details This method invokes `PATCH /datasets/` in the DataRobot Public API.
    #' @param bulkDatasetAction \link{BulkDatasetAction}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully executed
    #' \itemize{
    #' }
    #' \item **`409`** Cannot delete a dataset that has refresh jobs.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' bulkDatasetAction <- BulkDatasetAction$new() # BulkDatasetAction |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsPatchMany(bulkDatasetAction=bulkDatasetAction)
    #' }
    DatasetsPatchMany = function(bulkDatasetAction = NULL, ...) {
      apiResponse <- private$DatasetsPatchManyWithHttpInfo(bulkDatasetAction, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Describe dataset permissions
    #' Produces: "application/json"
    #'
    #' @details Describe what permissions current user has for given dataset.
    #' @details This method invokes `GET /datasets/{datasetId}/permissions/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetDescribePermissionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The dataset permissions
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsPermissionsList(datasetId)
    #' }
    DatasetsPermissionsList = function(datasetId, ...) {
      apiResponse <- private$DatasetsPermissionsListWithHttpInfo(datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset projects
    #' Produces: "application/json"
    #'
    #' @details Retrieves a dataset&#39;s projects by dataset ID.
    #' @details This method invokes `GET /datasets/{datasetId}/projects/` in the DataRobot Public API.
    #' @param limit integer. Only this many items are returned.
    #' @param offset integer. Skip this many items.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetProjectListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of projects
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | Only this many items are returned.
    #' offset <- 0 # integer | Skip this many items.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsProjectsList(limit, offset, datasetId)
    #' }
    DatasetsProjectsList = function(limit, offset, datasetId, ...) {
      apiResponse <- private$DatasetsProjectsListWithHttpInfo(limit, offset, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Schedule dataset refresh
    #' Produces: "application/json"
    #'
    #' @details Create a dataset refresh job that will automatically create dataset snapshots on a schedule.  Optionally if the limit of enabled jobs per user is reached the following metadata will be added to the default error response payload:  - **datasetsWithJob** (*array*) - The list of datasets IDs that have at   least one enabled job. - **errorType** (*string*) - (New in version v2.21) The type of error   that happened, possible values include (but are not limited to):   &#x60;Generic Limit Reached&#x60;, &#x60;Max Job Limit Reached for Dataset&#x60;, and   &#x60;Max Job Limit Reached for User&#x60;.
    #' @details This method invokes `POST /datasets/{datasetId}/refreshJobs/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetRefreshJobCreate \link{DatasetRefreshJobCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRefreshJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Dataset refresh job created.
    #' \itemize{
    #' }
    #' \item **`409`** The maximum number of enabled jobs is reached.
    #' \itemize{
    #' }
    #' \item **`422`** Refresh job could not be created. Possible reasons include, the job does not belong to the given dataset, credential ID required when Kerberos authentication enabled, or the schedule is not valid or cannot be understood.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetRefreshJobCreate <- DatasetRefreshJobCreate$new() # DatasetRefreshJobCreate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsCreate(datasetId, datasetRefreshJobCreate=datasetRefreshJobCreate)
    #' }
    DatasetsRefreshJobsCreate = function(datasetId, datasetRefreshJobCreate = NULL, ...) {
      apiResponse <- private$DatasetsRefreshJobsCreateWithHttpInfo(datasetId, datasetRefreshJobCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Deletes an existing dataset refresh job
    #' Produces: NA
    #'
    #' @details Deletes an existing dataset refresh job.
    #' @details This method invokes `DELETE /datasets/{datasetId}/refreshJobs/{jobId}/` in the DataRobot Public API.
    #' @param datasetId character. The dataset associated with the scheduled refresh job.
    #' @param jobId character. ID of the user scheduled dataset refresh job.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Scheduled Job deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid job ID or dataset ID provided.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The dataset associated with the scheduled refresh job.
    #' jobId <- 'jobId_example' # character | ID of the user scheduled dataset refresh job.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsDelete(datasetId, jobId)
    #' }
    DatasetsRefreshJobsDelete = function(datasetId, jobId, ...) {
      apiResponse <- private$DatasetsRefreshJobsDeleteWithHttpInfo(datasetId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Results of dataset refresh job.
    #' Produces: "application/json"
    #'
    #' @details Paginated list of execution results for refresh job with the given ID and dataset with the given ID, sorted from newest to oldest.
    #' @details This method invokes `GET /datasets/{datasetId}/refreshJobs/{jobId}/executionResults/` in the DataRobot Public API.
    #' @param datasetId character. The dataset associated with the scheduled refresh job.
    #' @param jobId character. ID of the user scheduled dataset refresh job.
    #' @param limit integer. Maximum number of results returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. Number of results that will be skipped.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRefreshJobRetrieveExecutionResultsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Paginated list of dataset refresh job results, sorted from latest to oldest.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The dataset associated with the scheduled refresh job.
    #' jobId <- 'jobId_example' # character | ID of the user scheduled dataset refresh job.
    #' limit <- 20 # integer | Maximum number of results returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | Number of results that will be skipped.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsExecutionResultsList(datasetId, jobId, limit=limit, offset=offset)
    #' }
    DatasetsRefreshJobsExecutionResultsList = function(datasetId, jobId, limit = 20, offset = 0, ...) {
      apiResponse <- private$DatasetsRefreshJobsExecutionResultsListWithHttpInfo(datasetId, jobId, limit, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Information about scheduled jobs for given dataset.
    #' Produces: "application/json"
    #'
    #' @details Paginated list of scheduled jobs descriptions for a specific dataset with given dataset ID, sorted by time of the last update.
    #' @details This method invokes `GET /datasets/{datasetId}/refreshJobs/` in the DataRobot Public API.
    #' @param limit integer. Only this many items are returned.
    #' @param offset integer. Skip this many items.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRefreshJobsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of a dataset&#39;s scheduled job information retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | Only this many items are returned.
    #' offset <- 0 # integer | Skip this many items.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsList(limit, offset, datasetId)
    #' }
    DatasetsRefreshJobsList = function(limit, offset, datasetId, ...) {
      apiResponse <- private$DatasetsRefreshJobsListWithHttpInfo(limit, offset, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a dataset refresh job
    #' Produces: "application/json"
    #'
    #' @details Update a dataset refresh job.  Optionally if the limit of enabled jobs per user is reached the following metadata will be added to the default error response payload:  - **datasetsWithJob** (*array*) - The list of datasets IDs that have at   least one enabled job. - **errorType** (*string*) - (New in version v2.21) The type of error   that happened, possible values include (but are not limited to):   &#x60;Generic Limit Reached&#x60;, &#x60;Max Job Limit Reached for Dataset&#x60;, and   &#x60;Max Job Limit Reached for User&#x60;.
    #' @details This method invokes `PATCH /datasets/{datasetId}/refreshJobs/{jobId}/` in the DataRobot Public API.
    #' @param datasetId character. The dataset associated with the scheduled refresh job.
    #' @param jobId character. ID of the user scheduled dataset refresh job.
    #' @param datasetRefreshJobUpdate \link{DatasetRefreshJobUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRefreshJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Scheduled Job configuration updated.
    #' \itemize{
    #' }
    #' \item **`409`** The maximum number of enabled jobs is reached.
    #' \itemize{
    #' }
    #' \item **`422`** Refresh job could not be updated. Possible reasons include, the job does not belong to the given dataset, credential ID required when Kerberos authentication enabled, or the schedule is not valid or cannot be understood.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The dataset associated with the scheduled refresh job.
    #' jobId <- 'jobId_example' # character | ID of the user scheduled dataset refresh job.
    #' datasetRefreshJobUpdate <- DatasetRefreshJobUpdate$new() # DatasetRefreshJobUpdate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsPatch(datasetId, jobId, datasetRefreshJobUpdate=datasetRefreshJobUpdate)
    #' }
    DatasetsRefreshJobsPatch = function(datasetId, jobId, datasetRefreshJobUpdate = NULL, ...) {
      apiResponse <- private$DatasetsRefreshJobsPatchWithHttpInfo(datasetId, jobId, datasetRefreshJobUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Gets configuration of a user scheduled dataset refresh job by job ID
    #' Produces: "application/json"
    #'
    #' @details Gets configuration of a user scheduled dataset refresh job by job ID.
    #' @details This method invokes `GET /datasets/{datasetId}/refreshJobs/{jobId}/` in the DataRobot Public API.
    #' @param datasetId character. The dataset associated with the scheduled refresh job.
    #' @param jobId character. ID of the user scheduled dataset refresh job.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRefreshJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Job information retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The dataset associated with the scheduled refresh job.
    #' jobId <- 'jobId_example' # character | ID of the user scheduled dataset refresh job.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRefreshJobsRetrieve(datasetId, jobId)
    #' }
    DatasetsRefreshJobsRetrieve = function(datasetId, jobId, ...) {
      apiResponse <- private$DatasetsRefreshJobsRetrieveWithHttpInfo(datasetId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset relationship.
    #' Produces: "application/json"
    #'
    #' @details Create a dataset relationship.
    #' @details This method invokes `POST /datasets/{datasetId}/relationships/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetRelationshipCreate \link{DatasetRelationshipCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRelationshipResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Successfully created
    #' \itemize{
    #' }
    #' \item **`409`** Relationship already exists.
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Missing or unrecognized fields.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetRelationshipCreate <- DatasetRelationshipCreate$new() # DatasetRelationshipCreate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRelationshipsCreate(datasetId, datasetRelationshipCreate=datasetRelationshipCreate)
    #' }
    DatasetsRelationshipsCreate = function(datasetId, datasetRelationshipCreate = NULL, ...) {
      apiResponse <- private$DatasetsRelationshipsCreateWithHttpInfo(datasetId, datasetRelationshipCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete dataset relationship.
    #' Produces: NA
    #'
    #' @details Delete a dataset relationship.
    #' @details This method invokes `DELETE /datasets/{datasetId}/relationships/{datasetRelationshipId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetRelationshipId character. The ID of the dataset relationship to delete.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully deleted
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetRelationshipId <- 'datasetRelationshipId_example' # character | The ID of the dataset relationship to delete.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRelationshipsDelete(datasetId, datasetRelationshipId)
    #' }
    DatasetsRelationshipsDelete = function(datasetId, datasetRelationshipId, ...) {
      apiResponse <- private$DatasetsRelationshipsDeleteWithHttpInfo(datasetId, datasetRelationshipId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List related datasets
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of the dataset relationships for a specific dataset.
    #' @details This method invokes `GET /datasets/{datasetId}/relationships/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned.
    #' @param offset integer. This many results will be skipped.
    #' @param datasetId character. The ID of the dataset.
    #' @param linkedDatasetId character. Providing &#x60;linkedDatasetId&#x60; will filter such that only relationships between &#x60;datasetId&#x60; (from the path) and &#x60;linkedDatasetId&#x60; will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRelationshipListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of dataset relationships
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned.
    #' offset <- 0 # integer | This many results will be skipped.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' linkedDatasetId <- 'linkedDatasetId_example' # character | Providing `linkedDatasetId` will filter such that only relationships between `datasetId` (from the path) and `linkedDatasetId` will be returned.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRelationshipsList(limit, offset, datasetId, linkedDatasetId=linkedDatasetId)
    #' }
    DatasetsRelationshipsList = function(limit, offset, datasetId, linkedDatasetId = NULL, ...) {
      apiResponse <- private$DatasetsRelationshipsListWithHttpInfo(limit, offset, datasetId, linkedDatasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update dataset relationship.
    #' Produces: "application/json"
    #'
    #' @details Update a dataset relationship.
    #' @details This method invokes `PATCH /datasets/{datasetId}/relationships/{datasetRelationshipId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetRelationshipId character. The ID of the dataset relationship to delete.
    #' @param datasetRelationshipUpdate \link{DatasetRelationshipUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetRelationshipResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully updated
    #' \itemize{
    #' }
    #' \item **`409`** Relationship already exists
    #' \itemize{
    #' }
    #' \item **`410`** Dataset deleted
    #' \itemize{
    #' }
    #' \item **`422`** Bad payload: missing or unrecognized fields
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetRelationshipId <- 'datasetRelationshipId_example' # character | The ID of the dataset relationship to delete.
    #' datasetRelationshipUpdate <- DatasetRelationshipUpdate$new() # DatasetRelationshipUpdate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRelationshipsPatch(datasetId, datasetRelationshipId, datasetRelationshipUpdate=datasetRelationshipUpdate)
    #' }
    DatasetsRelationshipsPatch = function(datasetId, datasetRelationshipId, datasetRelationshipUpdate = NULL, ...) {
      apiResponse <- private$DatasetsRelationshipsPatchWithHttpInfo(datasetId, datasetRelationshipId, datasetRelationshipUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset details
    #' Produces: "application/json"
    #'
    #' @details Retrieves the details of the dataset with given ID.
    #' @details This method invokes `GET /datasets/{datasetId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FullDatasetDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The dataset details
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsRetrieve(datasetId)
    #' }
    DatasetsRetrieve = function(datasetId, ...) {
      apiResponse <- private$DatasetsRetrieveWithHttpInfo(datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List dataset shared roles
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations who have access to this dataset and their roles.
    #' @details This method invokes `GET /datasets/{datasetId}/sharedRoles/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param datasetId character. The ID of the dataset.
    #' @param id character. Only return the access control information for a organization, group or user with this ID.
    #' @param name character. Only return the access control information for a organization, group or user with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > It describes the recipient type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharedRolesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of user permissions
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' id <- 'id_example' # character | Only return the access control information for a organization, group or user with this ID.
    #' name <- 'name_example' # character | Only return the access control information for a organization, group or user with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | It describes the recipient type.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsSharedRolesList(offset, limit, datasetId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    DatasetsSharedRolesList = function(offset, limit, datasetId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$DatasetsSharedRolesListWithHttpInfo(offset, limit, datasetId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Modify dataset shared roles
    #' Produces: NA
    #'
    #' @details Grant access, remove access or update roles for organizations, groups or users on this dataset. Up to 100 roles may be set per array in a single request.
    #' @details This method invokes `PATCH /datasets/{datasetId}/sharedRoles/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetSharedRoles \link{DatasetSharedRoles}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully modified
    #' \itemize{
    #' }
    #' \item **`409`** Duplicate entry for the org/group/user in permission listor the request would leave the dataset without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** Request is unprocessable. For example, &#x60;name&#x60; is stated for not user recipient.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetSharedRoles <- DatasetSharedRoles$new() # DatasetSharedRoles |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsSharedRolesPatchMany(datasetId, datasetSharedRoles=datasetSharedRoles)
    #' }
    DatasetsSharedRolesPatchMany = function(datasetId, datasetSharedRoles = NULL, ...) {
      apiResponse <- private$DatasetsSharedRolesPatchManyWithHttpInfo(datasetId, datasetSharedRoles, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset features
    #' Produces: "application/json"
    #'
    #' @details Return detailed information on all the features and transforms for this dataset.If the Dataset Item has attribute snapshot &#x3D; True, all optional fields also appear
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/allFeaturesDetails/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. This many results will be skipped.
    #' @param orderBy character. How the features should be ordered.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of feature info
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | This many results will be skipped.
    #' orderBy <- "name" # character | How the features should be ordered.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsAllFeaturesDetailsList(limit, offset, orderBy, datasetId, datasetVersionId)
    #' }
    DatasetsVersionsAllFeaturesDetailsList = function(limit, offset, orderBy, datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsAllFeaturesDetailsListWithHttpInfo(limit, offset, orderBy, datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete dataset version
    #' Produces: NA
    #'
    #' @details Marks the dataset version with the given ID as deleted.
    #' @details This method invokes `DELETE /datasets/{datasetId}/versions/{datasetVersionId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsDelete(datasetId, datasetVersionId)
    #' }
    DatasetsVersionsDelete = function(datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsDeleteWithHttpInfo(datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Recover deleted dataset version
    #' Produces: NA
    #'
    #' @details Recover the dataset version item with given datasetId and datasetVersionId from deleted.
    #' @details This method invokes `PATCH /datasets/{datasetId}/versions/{datasetVersionId}/deleted/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The item was not deleted: nothing to recover.
    #' \itemize{
    #' }
    #' \item **`204`** Successfully recovered
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #' body <- NULL # object |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsDeletedPatchMany(datasetId, datasetVersionId, body=body)
    #' }
    DatasetsVersionsDeletedPatchMany = function(datasetId, datasetVersionId, body = NULL, ...) {
      apiResponse <- private$DatasetsVersionsDeletedPatchManyWithHttpInfo(datasetId, datasetVersionId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset feature histogram
    #' Produces: "application/json"
    #'
    #' @details Get histogram chart data for a specific feature in the specified dataset.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/featureHistograms/{featureName}/` in the DataRobot Public API.
    #' @param binLimit integer. Maximum number of bins in the returned plot.
    #' @param datasetId character. The ID of the dataset entry to retrieve.
    #' @param datasetVersionId character. The ID of the dataset version to retrieve.
    #' @param featureName character. The name of the feature.
    #' @param key character. Only required for the Summarized categorical feature. Name of the top 50 key for which plot to be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeatureHistogramResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature histogram
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' binLimit <- 60 # integer | Maximum number of bins in the returned plot.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry to retrieve.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version to retrieve.
    #' featureName <- 'featureName_example' # character | The name of the feature.
    #' key <- 'key_example' # character | Only required for the Summarized categorical feature. Name of the top 50 key for which plot to be retrieved.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFeatureHistogramsRetrieve(binLimit, datasetId, datasetVersionId, featureName, key=key)
    #' }
    DatasetsVersionsFeatureHistogramsRetrieve = function(binLimit, datasetId, datasetVersionId, featureName, key = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFeatureHistogramsRetrieveWithHttpInfo(binLimit, datasetId, datasetVersionId, featureName, key, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve dataset featurelists
    #' Produces: "application/json"
    #'
    #' @details Retrieves the featurelists of the dataset with given ID and the latest dataset version.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/featurelists/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' @param offset integer. This many results will be skipped.
    #' @param orderBy character. How the features should be ordered.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturelistListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of featurelists
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned. The default may change and a maximum limit may be imposed without notice.
    #' offset <- 0 # integer | This many results will be skipped.
    #' orderBy <- "name" # character | How the features should be ordered.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFeaturelistsList(limit, offset, orderBy, datasetId, datasetVersionId)
    #' }
    DatasetsVersionsFeaturelistsList = function(limit, offset, orderBy, datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsFeaturelistsListWithHttpInfo(limit, offset, orderBy, datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset featurelist
    #' Produces: "application/json"
    #'
    #' @details Retrieves the specified featurelist of the dataset with given ID and the latest dataset version.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/featurelists/{featurelistId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset to retrieve featurelist for.
    #' @param datasetVersionId character. The ID of the dataset version to retrieve featurelists for.
    #' @param featurelistId character. The ID of the featurelist.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetFeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The featurelist
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset to retrieve featurelist for.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version to retrieve featurelists for.
    #' featurelistId <- 'featurelistId_example' # character | The ID of the featurelist.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFeaturelistsRetrieve(datasetId, datasetVersionId, featurelistId)
    #' }
    DatasetsVersionsFeaturelistsRetrieve = function(datasetId, datasetVersionId, featurelistId, ...) {
      apiResponse <- private$DatasetsVersionsFeaturelistsRetrieveWithHttpInfo(datasetId, datasetVersionId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve original dataset data
    #' Produces: "text/csv"
    #'
    #' @details Retrieve all the originally uploaded data, in CSV form.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/file/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The original dataset data
    #' \itemize{
    #' }
    #' \item **`409`** Ingest info is missing for dataset version.
    #' \itemize{
    #' }
    #' \item **`422`** Dataset version cannot be downloaded. Possible reasons include \&quot;dataPersisted being false for the dataset, the dataset not being a snapshot, and this dataset version is too big to be downloaded (maximum download size depends on a config of your installation).
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFileList(datasetId, datasetVersionId)
    #' }
    DatasetsVersionsFileList = function(datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsFileListWithHttpInfo(datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from Data Engine workspace
    #' Produces: "application/json"
    #'
    #' @details Create a new dataset version for a specified dataset from a Data Engine workspace state. The new dataset version should have the same schema as the specified dataset.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromDataEngineWorkspaceState/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetCreateFromWorkspaceState \link{DatasetCreateFromWorkspaceState}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetDataEngineResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`410`** Specified workspace was already deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Type of new dataset version is incompatible with specified dataset.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetCreateFromWorkspaceState <- DatasetCreateFromWorkspaceState$new() # DatasetCreateFromWorkspaceState |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromDataEngineWorkspaceStateCreate(datasetId, datasetCreateFromWorkspaceState=datasetCreateFromWorkspaceState)
    #' }
    DatasetsVersionsFromDataEngineWorkspaceStateCreate = function(datasetId, datasetCreateFromWorkspaceState = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromDataEngineWorkspaceStateCreateWithHttpInfo(datasetId, datasetCreateFromWorkspaceState, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from Data Source
    #' Produces: "application/json"
    #'
    #' @details Create a new version for the specified dataset from specified Data Source. The dataset must have been created from a compatible data source originally.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromDataSource/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasource \link{Datasource}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasource <- Datasource$new() # Datasource |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromDataSourceCreate(datasetId, datasource=datasource)
    #' }
    DatasetsVersionsFromDataSourceCreate = function(datasetId, datasource = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromDataSourceCreateWithHttpInfo(datasetId, datasource, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from file
    #' Produces: "application/json"
    #'
    #' @details Create a new version for the specified dataset from a file.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromFile/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param datasetFromFile \link{DatasetFromFile}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' datasetFromFile <- DatasetFromFile$new() # DatasetFromFile |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromFileCreate(datasetId, datasetFromFile=datasetFromFile)
    #' }
    DatasetsVersionsFromFileCreate = function(datasetId, datasetFromFile = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromFileCreateWithHttpInfo(datasetId, datasetFromFile, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from HDFS URL
    #' Produces: "application/json"
    #'
    #' @details Create a new version for the specified dataset from a HDFS URL. The dataset must have been created from the same HDFS URL originally.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromHDFS/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param hdfs \link{Hdfs}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' hdfs <- Hdfs$new() # Hdfs |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromHDFSCreate(datasetId, hdfs=hdfs)
    #' }
    DatasetsVersionsFromHDFSCreate = function(datasetId, hdfs = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromHDFSCreateWithHttpInfo(datasetId, hdfs, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from data source
    #' Produces: "application/json"
    #'
    #' @details Create a new version of the specified dataset from the latest dataset version. This will reuse the same source of the data that was previously used. Not supported for datasets that were previously loaded from an uploaded file. If the dataset is currently a remote dataset, it will be converted to a snapshot dataset. NOTE: if the current version uses a Data Source, the user and password must be specified so the data can be accessed.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromLatestVersion/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param fromLatest \link{FromLatest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`409`** The latest version of the dataset is in an errored state.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' fromLatest <- FromLatest$new() # FromLatest |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromLatestVersionCreate(datasetId, fromLatest=fromLatest)
    #' }
    DatasetsVersionsFromLatestVersionCreate = function(datasetId, fromLatest = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromLatestVersionCreateWithHttpInfo(datasetId, fromLatest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from URL
    #' Produces: "application/json"
    #'
    #' @details Create a new version for the specified dataset from specified URL. The dataset must have been created from the same URL originally.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/fromURL/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset.
    #' @param url \link{Url}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' url <- Url$new() # Url |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromURLCreate(datasetId, url=url)
    #' }
    DatasetsVersionsFromURLCreate = function(datasetId, url = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromURLCreateWithHttpInfo(datasetId, url, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create dataset version from previous version
    #' Produces: "application/json"
    #'
    #' @details Create a new version of the specified dataset from the specified dataset version. This will reuse the same source of the data that was previously used. Not supported for datasets that were previously loaded from an uploaded file. If the dataset is currently a remote dataset, it will be converted to a snapshot dataset. NOTE: If the specified version uses a Data Source, the user and password must be specified so the data can be accessed.
    #' @details This method invokes `POST /datasets/{datasetId}/versions/{datasetVersionId}/fromVersion/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param fromSpecific \link{FromSpecific}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`409`** The dataset item&#39;s specified version is in an errored state.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #' fromSpecific <- FromSpecific$new() # FromSpecific |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsFromVersionCreate(datasetId, datasetVersionId, fromSpecific=fromSpecific)
    #' }
    DatasetsVersionsFromVersionCreate = function(datasetId, datasetVersionId, fromSpecific = NULL, ...) {
      apiResponse <- private$DatasetsVersionsFromVersionCreateWithHttpInfo(datasetId, datasetVersionId, fromSpecific, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List dataset versions
    #' Produces: "application/json"
    #'
    #' @details List all versions associated with given datasetId and which match the specified query parameters.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned.
    #' @param offset integer. This many results will be skipped.
    #' @param datasetId character. The ID of the dataset.
    #' @param category Enum < [TRAINING, PREDICTION] > If specified, only dataset versions that have the specified category will be included in the results. Categories identify the intended use of the dataset.
    #' @param orderBy Enum < [created, -created] > Sorting order which will be applied to catalog list.
    #' @param filterFailed Enum < [false, False, true, True] > Whether datasets that failed during import should be excluded from the results. If True invalid datasets will be excluded.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatasetListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of dataset versions
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned.
    #' offset <- 0 # integer | This many results will be skipped.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset.
    #' category <- 'category_example' # character | If specified, only dataset versions that have the specified category will be included in the results. Categories identify the intended use of the dataset.
    #' orderBy <- 'orderBy_example' # character | Sorting order which will be applied to catalog list.
    #' filterFailed <- "false" # character | Whether datasets that failed during import should be excluded from the results. If True invalid datasets will be excluded.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsList(limit, offset, datasetId, category=category, orderBy=orderBy, filterFailed=filterFailed)
    #' }
    DatasetsVersionsList = function(limit, offset, datasetId, category = NULL, orderBy = NULL, filterFailed = "false", ...) {
      apiResponse <- private$DatasetsVersionsListWithHttpInfo(limit, offset, datasetId, category, orderBy, filterFailed, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset projects by version
    #' Produces: "application/json"
    #'
    #' @details Retrieves a dataset&#39;s projects for the specified catalog dataset and dataset version id.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/projects/` in the DataRobot Public API.
    #' @param limit integer. Only this many items are returned.
    #' @param offset integer. Skip this many items.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{GetDatasetVersionProjectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of projects
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | Only this many items are returned.
    #' offset <- 0 # integer | Skip this many items.
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsProjectsList(limit, offset, datasetId, datasetVersionId)
    #' }
    DatasetsVersionsProjectsList = function(limit, offset, datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsProjectsListWithHttpInfo(limit, offset, datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get dataset details by version
    #' Produces: "application/json"
    #'
    #' @details Retrieves the details of the dataset with given ID and version ID.
    #' @details This method invokes `GET /datasets/{datasetId}/versions/{datasetVersionId}/` in the DataRobot Public API.
    #' @param datasetId character. The ID of the dataset entry.
    #' @param datasetVersionId character. The ID of the dataset version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FullDatasetDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The dataset details
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset entry.
    #' datasetVersionId <- 'datasetVersionId_example' # character | The ID of the dataset version.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$DatasetsVersionsRetrieve(datasetId, datasetVersionId)
    #' }
    DatasetsVersionsRetrieve = function(datasetId, datasetVersionId, ...) {
      apiResponse <- private$DatasetsVersionsRetrieveWithHttpInfo(datasetId, datasetVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Validate many user blueprints.
    #' Produces: "application/json"
    #'
    #' @details Validate many user blueprints, optionally using a specific project. Any non-existent or inaccessible user blueprints will be ignored.
    #' @details This method invokes `POST /userBlueprintsBulkValidations/` in the DataRobot Public API.
    #' @param userBlueprintBulkValidationRequest \link{UserBlueprintBulkValidationRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsBulkValidationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Validated many user blueprints successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Referenced project was not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintBulkValidationRequest <- UserBlueprintBulkValidationRequest$new() # UserBlueprintBulkValidationRequest |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsBulkValidationsCreate(userBlueprintBulkValidationRequest=userBlueprintBulkValidationRequest)
    #' }
    UserBlueprintsBulkValidationsCreate = function(userBlueprintBulkValidationRequest = NULL, ...) {
      apiResponse <- private$UserBlueprintsBulkValidationsCreateWithHttpInfo(userBlueprintBulkValidationRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a user blueprint.
    #' Produces: "application/json"
    #'
    #' @details Create a user blueprint
    #' @details This method invokes `POST /userBlueprints/` in the DataRobot Public API.
    #' @param userBlueprintCreate \link{UserBlueprintCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsDetailedItem}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Created the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Project not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintCreate <- UserBlueprintCreate$new() # UserBlueprintCreate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsCreate(userBlueprintCreate=userBlueprintCreate)
    #' }
    UserBlueprintsCreate = function(userBlueprintCreate = NULL, ...) {
      apiResponse <- private$UserBlueprintsCreateWithHttpInfo(userBlueprintCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a user blueprint.
    #' Produces: NA
    #'
    #' @details Delete a user blueprint, specified by the userBlueprintId.
    #' @details This method invokes `DELETE /userBlueprints/{userBlueprintId}/` in the DataRobot Public API.
    #' @param userBlueprintId character. Used to identify a specific user-owned blueprint.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully deleted the specified blueprint, if it existed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintId <- 'userBlueprintId_example' # character | Used to identify a specific user-owned blueprint.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsDelete(userBlueprintId)
    #' }
    UserBlueprintsDelete = function(userBlueprintId, ...) {
      apiResponse <- private$UserBlueprintsDeleteWithHttpInfo(userBlueprintId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete user blueprints.
    #' Produces: "application/json"
    #'
    #' @details Delete user blueprints, specified by userBlueprintIds.
    #' @details This method invokes `DELETE /userBlueprints/` in the DataRobot Public API.
    #' @param userBlueprintsBulkDelete \link{UserBlueprintsBulkDelete}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsBulkDeleteResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of user blueprints successfully and unsuccessfully deleted.
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintsBulkDelete <- UserBlueprintsBulkDelete$new() # UserBlueprintsBulkDelete |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsDeleteMany(userBlueprintsBulkDelete=userBlueprintsBulkDelete)
    #' }
    UserBlueprintsDeleteMany = function(userBlueprintsBulkDelete = NULL, ...) {
      apiResponse <- private$UserBlueprintsDeleteManyWithHttpInfo(userBlueprintsBulkDelete, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Clone a blueprint from a project.
    #' Produces: "application/json"
    #'
    #' @details Clone a blueprint from a project.
    #' @details This method invokes `POST /userBlueprints/fromBlueprintId/` in the DataRobot Public API.
    #' @param userBlueprintCreateFromBlueprintId \link{UserBlueprintCreateFromBlueprintId}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsDetailedItem}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Created the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Project or blueprint not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintCreateFromBlueprintId <- UserBlueprintCreateFromBlueprintId$new() # UserBlueprintCreateFromBlueprintId |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsFromBlueprintIdCreate(userBlueprintCreateFromBlueprintId=userBlueprintCreateFromBlueprintId)
    #' }
    UserBlueprintsFromBlueprintIdCreate = function(userBlueprintCreateFromBlueprintId = NULL, ...) {
      apiResponse <- private$UserBlueprintsFromBlueprintIdCreateWithHttpInfo(userBlueprintCreateFromBlueprintId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a user blueprint from a single custom task.
    #' Produces: "application/json"
    #'
    #' @details Create a user blueprint from a single custom task.
    #' @details This method invokes `POST /userBlueprints/fromCustomTaskVersionId/` in the DataRobot Public API.
    #' @param userBlueprintCreateFromCustomTaskVersionIdPayload \link{UserBlueprintCreateFromCustomTaskVersionIdPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsDetailedItem}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Created the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Custom task version or custom task not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintCreateFromCustomTaskVersionIdPayload <- UserBlueprintCreateFromCustomTaskVersionIdPayload$new() # UserBlueprintCreateFromCustomTaskVersionIdPayload |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsFromCustomTaskVersionIdCreate(userBlueprintCreateFromCustomTaskVersionIdPayload=userBlueprintCreateFromCustomTaskVersionIdPayload)
    #' }
    UserBlueprintsFromCustomTaskVersionIdCreate = function(userBlueprintCreateFromCustomTaskVersionIdPayload = NULL, ...) {
      apiResponse <- private$UserBlueprintsFromCustomTaskVersionIdCreateWithHttpInfo(userBlueprintCreateFromCustomTaskVersionIdPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Clone a user blueprint.
    #' Produces: "application/json"
    #'
    #' @details Clone a user blueprint.
    #' @details This method invokes `POST /userBlueprints/fromUserBlueprintId/` in the DataRobot Public API.
    #' @param userBlueprintCreateFromUserBlueprintId \link{UserBlueprintCreateFromUserBlueprintId}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsDetailedItem}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Created the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** User blueprint or project not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintCreateFromUserBlueprintId <- UserBlueprintCreateFromUserBlueprintId$new() # UserBlueprintCreateFromUserBlueprintId |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsFromUserBlueprintIdCreate(userBlueprintCreateFromUserBlueprintId=userBlueprintCreateFromUserBlueprintId)
    #' }
    UserBlueprintsFromUserBlueprintIdCreate = function(userBlueprintCreateFromUserBlueprintId = NULL, ...) {
      apiResponse <- private$UserBlueprintsFromUserBlueprintIdCreateWithHttpInfo(userBlueprintCreateFromUserBlueprintId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve input types.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the input types which can be used with User Blueprints.
    #' @details This method invokes `GET /userBlueprintsInputTypes/` in the DataRobot Public API.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsInputTypesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully retrieved the input types.
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsInputTypesList()
    #' }
    UserBlueprintsInputTypesList = function(...) {
      apiResponse <- private$UserBlueprintsInputTypesListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List user blueprints.
    #' Produces: "application/json"
    #'
    #' @details Fetch a list of the user blueprints the current user has access to
    #' @details This method invokes `GET /userBlueprints/` in the DataRobot Public API.
    #' @param offset integer. The number of results to skip (for pagination).
    #' @param limit integer. The max number of results to return.
    #' @param projectId character. The id of the project, used to filter for original project_id.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Fetched the list of the accessible user blueprints successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of results to skip (for pagination).
    #' limit <- 100 # integer | The max number of results to return.
    #' projectId <- 'projectId_example' # character | The id of the project, used to filter for original project_id.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsList(offset, limit, projectId=projectId)
    #' }
    UserBlueprintsList = function(offset, limit, projectId = NULL, ...) {
      apiResponse <- private$UserBlueprintsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a user blueprint.
    #' Produces: "application/json"
    #'
    #' @details Update a user blueprint
    #' @details This method invokes `PATCH /userBlueprints/{userBlueprintId}/` in the DataRobot Public API.
    #' @param userBlueprintId character. Used to identify a specific user-owned blueprint.
    #' @param userBlueprintUpdate \link{UserBlueprintUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsDetailedItem}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Updated the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** User blueprint not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintId <- 'userBlueprintId_example' # character | Used to identify a specific user-owned blueprint.
    #' userBlueprintUpdate <- UserBlueprintUpdate$new() # UserBlueprintUpdate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsPatch(userBlueprintId, userBlueprintUpdate=userBlueprintUpdate)
    #' }
    UserBlueprintsPatch = function(userBlueprintId, userBlueprintUpdate = NULL, ...) {
      apiResponse <- private$UserBlueprintsPatchWithHttpInfo(userBlueprintId, userBlueprintUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add user blueprints to a project.
    #' Produces: "application/json"
    #'
    #' @details Add a list of user blueprints, by id, to a specified (by id) project&#39;s repository.
    #' @details This method invokes `POST /userBlueprintsProjectBlueprints/` in the DataRobot Public API.
    #' @param userBlueprintAddToMenu \link{UserBlueprintAddToMenu}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintAddToMenuResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully added the user blueprints to the project&#39;s repository.
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Referenced project not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintAddToMenu <- UserBlueprintAddToMenu$new() # UserBlueprintAddToMenu |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsProjectBlueprintsCreate(userBlueprintAddToMenu=userBlueprintAddToMenu)
    #' }
    UserBlueprintsProjectBlueprintsCreate = function(userBlueprintAddToMenu = NULL, ...) {
      apiResponse <- private$UserBlueprintsProjectBlueprintsCreateWithHttpInfo(userBlueprintAddToMenu, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a user blueprint.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a user blueprint
    #' @details This method invokes `GET /userBlueprints/{userBlueprintId}/` in the DataRobot Public API.
    #' @param editMode character. Whether to retrieve the extra blueprint metadata for editing.
    #' @param decompressedBlueprint character. Whether to retrieve the blueprint in the decompressed format.
    #' @param isInplaceEditor character. Whether the request is sent from the in place user BP editor.
    #' @param userBlueprintId character. Used to identify a specific user-owned blueprint.
    #' @param projectId character. String representation of ObjectId for the currently active project. The user blueprint is retrieved when this project is active.
    #' @param getDynamicLabels character. Whether to add dynamic labels to a decompressed blueprint.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieved the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Referenced project or user blueprint not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' editMode <- FALSE # character | Whether to retrieve the extra blueprint metadata for editing.
    #' decompressedBlueprint <- FALSE # character | Whether to retrieve the blueprint in the decompressed format.
    #' isInplaceEditor <- FALSE # character | Whether the request is sent from the in place user BP editor.
    #' userBlueprintId <- 'userBlueprintId_example' # character | Used to identify a specific user-owned blueprint.
    #' projectId <- 'projectId_example' # character | String representation of ObjectId for the currently active project. The user blueprint is retrieved when this project is active.
    #' getDynamicLabels <- FALSE # character | Whether to add dynamic labels to a decompressed blueprint.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsRetrieve(editMode, decompressedBlueprint, isInplaceEditor, userBlueprintId, projectId=projectId, getDynamicLabels=getDynamicLabels)
    #' }
    UserBlueprintsRetrieve = function(editMode, decompressedBlueprint, isInplaceEditor, userBlueprintId, projectId = NULL, getDynamicLabels = FALSE, ...) {
      apiResponse <- private$UserBlueprintsRetrieveWithHttpInfo(editMode, decompressedBlueprint, isInplaceEditor, userBlueprintId, projectId, getDynamicLabels, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users, groups and organizations that have an access to this user blueprint
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations that have an access to this user blueprint
    #' @details This method invokes `GET /userBlueprints/{userBlueprintId}/sharedRoles/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param userBlueprintId character. Used to identify a specific user-owned blueprint.
    #' @param id character. Only return roles for a user, group or organization with this identifier.
    #' @param name character. Only return roles for a user, group or organization with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > List access controls for recipients with this type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintSharedRolesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully retrieved roles.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 10 # integer | At most this many results are returned
    #' userBlueprintId <- 'userBlueprintId_example' # character | Used to identify a specific user-owned blueprint.
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsSharedRolesList(offset, limit, userBlueprintId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    UserBlueprintsSharedRolesList = function(offset, limit, userBlueprintId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$UserBlueprintsSharedRolesListWithHttpInfo(offset, limit, userBlueprintId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Share a user blueprint with a user, group, or organization
    #' Produces: NA
    #'
    #' @details Share a user blueprint with a user, group, or organization
    #' @details This method invokes `PATCH /userBlueprints/{userBlueprintId}/sharedRoles/` in the DataRobot Public API.
    #' @param userBlueprintId character. Used to identify a specific user-owned blueprint.
    #' @param sharedRolesUpdate \link{SharedRolesUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully
    #' \itemize{
    #' }
    #' \item **`400`** Bad Request
    #' \itemize{
    #' }
    #' \item **`403`** User can view entity but does not have permission to grant these roles on the entity.
    #' \itemize{
    #' }
    #' \item **`404`** Either the entity does not exist or the user does not have permissions to view the entity.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the entity without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** The request was formatted improperly.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintId <- 'userBlueprintId_example' # character | Used to identify a specific user-owned blueprint.
    #' sharedRolesUpdate <- SharedRolesUpdate$new() # SharedRolesUpdate |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsSharedRolesPatchMany(userBlueprintId, sharedRolesUpdate=sharedRolesUpdate)
    #' }
    UserBlueprintsSharedRolesPatchMany = function(userBlueprintId, sharedRolesUpdate = NULL, ...) {
      apiResponse <- private$UserBlueprintsSharedRolesPatchManyWithHttpInfo(userBlueprintId, sharedRolesUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Validate task parameters.
    #' Produces: "application/json"
    #'
    #' @details Validate that each value assigned to specified task parameters are valid.
    #' @details This method invokes `POST /userBlueprintsTaskParameters/` in the DataRobot Public API.
    #' @param userBlueprintTaskParameterValidation \link{UserBlueprintTaskParameterValidation}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsValidateTaskParametersResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accepted validation parameters for a task in the context of User Blueprints.
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Custom task version not found
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintTaskParameterValidation <- UserBlueprintTaskParameterValidation$new() # UserBlueprintTaskParameterValidation |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsTaskParametersCreate(userBlueprintTaskParameterValidation=userBlueprintTaskParameterValidation)
    #' }
    UserBlueprintsTaskParametersCreate = function(userBlueprintTaskParameterValidation = NULL, ...) {
      apiResponse <- private$UserBlueprintsTaskParametersCreateWithHttpInfo(userBlueprintTaskParameterValidation, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve tasks for blueprint construction.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the available tasks, organized into categories, which can be used to create or modify User Blueprints.
    #' @details This method invokes `GET /userBlueprintsTasks/` in the DataRobot Public API.
    #' @param projectId character. The project id to use for task retrieval
    #' @param blueprintId character. The blueprint id to use for task retrieval
    #' @param userBlueprintId character. The user blueprint id to use for task retrieval
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintTasksResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Successfully retrieved the tasks.
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Referenced project or user blueprint not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project id to use for task retrieval
    #' blueprintId <- 'blueprintId_example' # character | The blueprint id to use for task retrieval
    #' userBlueprintId <- 'userBlueprintId_example' # character | The user blueprint id to use for task retrieval
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsTasksList(projectId=projectId, blueprintId=blueprintId, userBlueprintId=userBlueprintId)
    #' }
    UserBlueprintsTasksList = function(projectId = NULL, blueprintId = NULL, userBlueprintId = NULL, ...) {
      apiResponse <- private$UserBlueprintsTasksListWithHttpInfo(projectId, blueprintId, userBlueprintId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Validate a user blueprint.
    #' Produces: "application/json"
    #'
    #' @details Validate a user blueprint
    #' @details This method invokes `POST /userBlueprintsValidations/` in the DataRobot Public API.
    #' @param userBlueprintValidation \link{UserBlueprintValidation}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserBlueprintsValidationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Validated the user blueprint successfully
    #' \itemize{
    #' }
    #' \item **`401`** User is not authorized.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** Referenced project not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unprocessable Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userBlueprintValidation <- UserBlueprintValidation$new() # UserBlueprintValidation |
    #'
    #' api.instance <- AiCatalogApi$new()
    #' result <- api.instance$UserBlueprintsValidationsCreate(userBlueprintValidation=userBlueprintValidation)
    #' }
    UserBlueprintsValidationsCreate = function(userBlueprintValidation = NULL, ...) {
      apiResponse <- private$UserBlueprintsValidationsCreateWithHttpInfo(userBlueprintValidation, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `CatalogItemsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CatalogItemsListWithHttpInfo = function(offset, limit, initialCacheSize, useCache = "false", orderBy = NULL, searchFor = NULL, tag = NULL, accessType = "any", datasourceType = NULL, category = NULL, filterFailed = "false", ownerUserId = NULL, ownerUsername = NULL, type = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`initialCacheSize`)) {
        stop("Missing required parameter `initialCacheSize`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["initialCacheSize"] <- initialCacheSize

      queryParams["useCache"] <- useCache

      queryParams["orderBy"] <- orderBy

      queryParams["searchFor"] <- searchFor

      if (!is.null(tag)) {
        queryParams["tag"] <- paste0(tag, collapse = ",")
      }

      queryParams["accessType"] <- accessType

      if (!is.null(datasourceType)) {
        queryParams["datasourceType"] <- paste0(datasourceType, collapse = ",")
      }

      if (!is.null(category)) {
        queryParams["category"] <- paste0(category, collapse = ",")
      }

      queryParams["filterFailed"] <- filterFailed

      if (!is.null(ownerUserId)) {
        queryParams["ownerUserId"] <- paste0(ownerUserId, collapse = ",")
      }

      if (!is.null(ownerUsername)) {
        queryParams["ownerUsername"] <- paste0(ownerUsername, collapse = ",")
      }

      queryParams["type"] <- type

      body <- NULL
      urlPath <- "/catalogItems/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CatalogListSearchResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CatalogItemsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CatalogItemsPatchWithHttpInfo = function(catalogId, updateCatalogMetadata = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`catalogId`)) {
        stop("Missing required parameter `catalogId`.")
      }

      if (!missing(`updateCatalogMetadata`) && isa(updateCatalogMetadata, c("UpdateCatalogMetadata", "R6"))) {
        body <- `updateCatalogMetadata`$toJSON()
      } else {
        stop("CatalogItemsPatchWithHttpInfo requires parameter updateCatalogMetadata to be of type UpdateCatalogMetadata.")
      }

      urlPath <- "/catalogItems/{catalogId}/"
      if (!missing(`catalogId`)) {
        urlPath <- gsub(paste0("\\{", "catalogId", "\\}"), URLencode(as.character(`catalogId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CatalogExtendedDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CatalogItemsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CatalogItemsRetrieveWithHttpInfo = function(catalogId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`catalogId`)) {
        stop("Missing required parameter `catalogId`.")
      }

      body <- NULL
      urlPath <- "/catalogItems/{catalogId}/"
      if (!missing(`catalogId`)) {
        urlPath <- gsub(paste0("\\{", "catalogId", "\\}"), URLencode(as.character(`catalogId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CatalogDetailsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DataEngineQueryGeneratorsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DataEngineQueryGeneratorsCreateWithHttpInfo = function(createDataEngineQueryGenerator = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`createDataEngineQueryGenerator`) && isa(createDataEngineQueryGenerator, c("CreateDataEngineQueryGenerator", "R6"))) {
        body <- `createDataEngineQueryGenerator`$toJSON()
      } else {
        stop("DataEngineQueryGeneratorsCreateWithHttpInfo requires parameter createDataEngineQueryGenerator to be of type CreateDataEngineQueryGenerator.")
      }

      urlPath <- "/dataEngineQueryGenerators/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DataEngineQueryGeneratorsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DataEngineQueryGeneratorsRetrieveWithHttpInfo = function(dataEngineQueryGeneratorId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataEngineQueryGeneratorId`)) {
        stop("Missing required parameter `dataEngineQueryGeneratorId`.")
      }

      body <- NULL
      urlPath <- "/dataEngineQueryGenerators/{dataEngineQueryGeneratorId}/"
      if (!missing(`dataEngineQueryGeneratorId`)) {
        urlPath <- gsub(paste0("\\{", "dataEngineQueryGeneratorId", "\\}"), URLencode(as.character(`dataEngineQueryGeneratorId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrieveDataEngineQueryResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DataEngineWorkspaceStatesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DataEngineWorkspaceStatesCreateWithHttpInfo = function(createWorkspaceState = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`createWorkspaceState`) && isa(createWorkspaceState, c("CreateWorkspaceState", "R6"))) {
        body <- `createWorkspaceState`$toJSON()
      } else {
        stop("DataEngineWorkspaceStatesCreateWithHttpInfo requires parameter createWorkspaceState to be of type CreateWorkspaceState.")
      }

      urlPath <- "/dataEngineWorkspaceStates/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "WorkspaceSourceCreatedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreateWithHttpInfo = function(createWorkspaceStateFromQueryGenerator = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`createWorkspaceStateFromQueryGenerator`) && isa(createWorkspaceStateFromQueryGenerator, c("CreateWorkspaceStateFromQueryGenerator", "R6"))) {
        body <- `createWorkspaceStateFromQueryGenerator`$toJSON()
      } else {
        stop("DataEngineWorkspaceStatesFromDataEngineQueryGeneratorCreateWithHttpInfo requires parameter createWorkspaceStateFromQueryGenerator to be of type CreateWorkspaceStateFromQueryGenerator.")
      }

      urlPath <- "/dataEngineWorkspaceStates/fromDataEngineQueryGenerator/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "WorkspaceStateCreatedFromQueryGeneratorResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DataEngineWorkspaceStatesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DataEngineWorkspaceStatesRetrieveWithHttpInfo = function(workspaceStateId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`workspaceStateId`)) {
        stop("Missing required parameter `workspaceStateId`.")
      }

      body <- NULL
      urlPath <- "/dataEngineWorkspaceStates/{workspaceStateId}/"
      if (!missing(`workspaceStateId`)) {
        urlPath <- gsub(paste0("\\{", "workspaceStateId", "\\}"), URLencode(as.character(`workspaceStateId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "WorkspaceStateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsAccessControlListWithHttpInfo = function(offset, limit, datasetId, userId = NULL, username = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["userId"] <- userId

      queryParams["username"] <- username

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/datasets/{datasetId}/accessControl/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetAccessControlListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsAccessControlPatchManyWithHttpInfo = function(datasetId, datasetAccessSet = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetAccessSet`) && isa(datasetAccessSet, c("DatasetAccessSet", "R6"))) {
        body <- `datasetAccessSet`$toJSON()
      } else {
        stop("DatasetsAccessControlPatchManyWithHttpInfo requires parameter datasetAccessSet to be of type DatasetAccessSet.")
      }

      urlPath <- "/datasets/{datasetId}/accessControl/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsAllFeaturesDetailsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsAllFeaturesDetailsListWithHttpInfo = function(limit, offset, orderBy, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`orderBy`)) {
        stop("Missing required parameter `orderBy`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/datasets/{datasetId}/allFeaturesDetails/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsDeleteWithHttpInfo = function(datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsDeletedPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsDeletedPatchManyWithHttpInfo = function(datasetId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("DatasetsDeletedPatchManyWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/datasets/{datasetId}/deleted/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeatureHistogramsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeatureHistogramsRetrieveWithHttpInfo = function(binLimit, datasetId, featureName, key = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`binLimit`)) {
        stop("Missing required parameter `binLimit`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      queryParams["binLimit"] <- binLimit

      queryParams["key"] <- key

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featureHistograms/{featureName}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeatureHistogramResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeatureTransformsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeatureTransformsCreateWithHttpInfo = function(datasetId, featureTransform = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`featureTransform`) && isa(featureTransform, c("FeatureTransform", "R6"))) {
        body <- `featureTransform`$toJSON()
      } else {
        stop("DatasetsFeatureTransformsCreateWithHttpInfo requires parameter featureTransform to be of type FeatureTransform.")
      }

      urlPath <- "/datasets/{datasetId}/featureTransforms/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeatureTransformsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeatureTransformsListWithHttpInfo = function(limit, offset, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featureTransforms/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetTransformListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeatureTransformsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeatureTransformsRetrieveWithHttpInfo = function(datasetId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featureTransforms/{featureName}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetTransformResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeaturelistsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeaturelistsCreateWithHttpInfo = function(datasetId, featureListCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`featureListCreate`) && isa(featureListCreate, c("FeatureListCreate", "R6"))) {
        body <- `featureListCreate`$toJSON()
      } else {
        stop("DatasetsFeaturelistsCreateWithHttpInfo requires parameter featureListCreate to be of type FeatureListCreate.")
      }

      urlPath <- "/datasets/{datasetId}/featurelists/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeaturelistsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeaturelistsDeleteWithHttpInfo = function(datasetId, featurelistId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featurelists/{featurelistId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeaturelistsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeaturelistsListWithHttpInfo = function(limit, offset, orderBy, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`orderBy`)) {
        stop("Missing required parameter `orderBy`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featurelists/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturelistListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeaturelistsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeaturelistsPatchWithHttpInfo = function(datasetId, featurelistId, featureListModify = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      if (!missing(`featureListModify`) && isa(featureListModify, c("FeatureListModify", "R6"))) {
        body <- `featureListModify`$toJSON()
      } else {
        stop("DatasetsFeaturelistsPatchWithHttpInfo requires parameter featureListModify to be of type FeatureListModify.")
      }

      urlPath <- "/datasets/{datasetId}/featurelists/{featurelistId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFeaturelistsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFeaturelistsRetrieveWithHttpInfo = function(datasetId, featurelistId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/featurelists/{featurelistId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFileListWithHttpInfo = function(datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/file/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "character", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFromDataEngineWorkspaceStateCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFromDataEngineWorkspaceStateCreateWithHttpInfo = function(datasetCreateFromWorkspaceState = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`datasetCreateFromWorkspaceState`) && isa(datasetCreateFromWorkspaceState, c("DatasetCreateFromWorkspaceState", "R6"))) {
        body <- `datasetCreateFromWorkspaceState`$toJSON()
      } else {
        stop("DatasetsFromDataEngineWorkspaceStateCreateWithHttpInfo requires parameter datasetCreateFromWorkspaceState to be of type DatasetCreateFromWorkspaceState.")
      }

      urlPath <- "/datasets/fromDataEngineWorkspaceState/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetDataEngineResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFromDataSourceCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFromDataSourceCreateWithHttpInfo = function(datasource = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`datasource`) && isa(datasource, c("Datasource", "R6"))) {
        body <- `datasource`$toJSON()
      } else {
        stop("DatasetsFromDataSourceCreateWithHttpInfo requires parameter datasource to be of type Datasource.")
      }

      urlPath <- "/datasets/fromDataSource/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFromFileCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFromFileCreateWithHttpInfo = function(file, categories = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`file`)) {
        stop("Missing required parameter `file`.")
      }

      body <- list(
        "categories" = categories,
        "file" = httr::upload_file(file)
      )

      urlPath <- "/datasets/fromFile/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFromHDFSCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFromHDFSCreateWithHttpInfo = function(hdfs = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`hdfs`) && isa(hdfs, c("Hdfs", "R6"))) {
        body <- `hdfs`$toJSON()
      } else {
        stop("DatasetsFromHDFSCreateWithHttpInfo requires parameter hdfs to be of type Hdfs.")
      }

      urlPath <- "/datasets/fromHDFS/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsFromURLCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsFromURLCreateWithHttpInfo = function(url = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`url`) && isa(url, c("Url", "R6"))) {
        body <- `url`$toJSON()
      } else {
        stop("DatasetsFromURLCreateWithHttpInfo requires parameter url to be of type Url.")
      }

      urlPath <- "/datasets/fromURL/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsListWithHttpInfo = function(limit, offset, category = NULL, orderBy = NULL, filterFailed = "false", datasetVersionIds = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      queryParams["category"] <- category

      queryParams["orderBy"] <- orderBy

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["filterFailed"] <- filterFailed

      if (!is.null(datasetVersionIds)) {
        queryParams["datasetVersionIds"] <- paste0(datasetVersionIds, collapse = ",")
      }

      body <- NULL
      urlPath <- "/datasets/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsPatchWithHttpInfo = function(datasetId, patchDataset = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`patchDataset`) && isa(patchDataset, c("PatchDataset", "R6"))) {
        body <- `patchDataset`$toJSON()
      } else {
        stop("DatasetsPatchWithHttpInfo requires parameter patchDataset to be of type PatchDataset.")
      }

      urlPath <- "/datasets/{datasetId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BasicDatasetDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsPatchManyWithHttpInfo = function(bulkDatasetAction = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`bulkDatasetAction`) && isa(bulkDatasetAction, c("BulkDatasetAction", "R6"))) {
        body <- `bulkDatasetAction`$toJSON()
      } else {
        stop("DatasetsPatchManyWithHttpInfo requires parameter bulkDatasetAction to be of type BulkDatasetAction.")
      }

      urlPath <- "/datasets/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsPermissionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsPermissionsListWithHttpInfo = function(datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/permissions/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetDescribePermissionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsProjectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsProjectsListWithHttpInfo = function(limit, offset, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      body <- NULL
      urlPath <- "/datasets/{datasetId}/projects/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetProjectListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsCreateWithHttpInfo = function(datasetId, datasetRefreshJobCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetRefreshJobCreate`) && isa(datasetRefreshJobCreate, c("DatasetRefreshJobCreate", "R6"))) {
        body <- `datasetRefreshJobCreate`$toJSON()
      } else {
        stop("DatasetsRefreshJobsCreateWithHttpInfo requires parameter datasetRefreshJobCreate to be of type DatasetRefreshJobCreate.")
      }

      urlPath <- "/datasets/{datasetId}/refreshJobs/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRefreshJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsDeleteWithHttpInfo = function(datasetId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/refreshJobs/{jobId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsExecutionResultsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsExecutionResultsListWithHttpInfo = function(datasetId, jobId, limit = 20, offset = 0, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      body <- NULL
      urlPath <- "/datasets/{datasetId}/refreshJobs/{jobId}/executionResults/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRefreshJobRetrieveExecutionResultsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsListWithHttpInfo = function(limit, offset, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      body <- NULL
      urlPath <- "/datasets/{datasetId}/refreshJobs/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRefreshJobsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsPatchWithHttpInfo = function(datasetId, jobId, datasetRefreshJobUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      if (!missing(`datasetRefreshJobUpdate`) && isa(datasetRefreshJobUpdate, c("DatasetRefreshJobUpdate", "R6"))) {
        body <- `datasetRefreshJobUpdate`$toJSON()
      } else {
        stop("DatasetsRefreshJobsPatchWithHttpInfo requires parameter datasetRefreshJobUpdate to be of type DatasetRefreshJobUpdate.")
      }

      urlPath <- "/datasets/{datasetId}/refreshJobs/{jobId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRefreshJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRefreshJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRefreshJobsRetrieveWithHttpInfo = function(datasetId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/refreshJobs/{jobId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRefreshJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRelationshipsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRelationshipsCreateWithHttpInfo = function(datasetId, datasetRelationshipCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetRelationshipCreate`) && isa(datasetRelationshipCreate, c("DatasetRelationshipCreate", "R6"))) {
        body <- `datasetRelationshipCreate`$toJSON()
      } else {
        stop("DatasetsRelationshipsCreateWithHttpInfo requires parameter datasetRelationshipCreate to be of type DatasetRelationshipCreate.")
      }

      urlPath <- "/datasets/{datasetId}/relationships/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRelationshipResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRelationshipsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRelationshipsDeleteWithHttpInfo = function(datasetId, datasetRelationshipId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetRelationshipId`)) {
        stop("Missing required parameter `datasetRelationshipId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/relationships/{datasetRelationshipId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetRelationshipId`)) {
        urlPath <- gsub(paste0("\\{", "datasetRelationshipId", "\\}"), URLencode(as.character(`datasetRelationshipId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRelationshipsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRelationshipsListWithHttpInfo = function(limit, offset, datasetId, linkedDatasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["linkedDatasetId"] <- linkedDatasetId

      body <- NULL
      urlPath <- "/datasets/{datasetId}/relationships/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRelationshipListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRelationshipsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRelationshipsPatchWithHttpInfo = function(datasetId, datasetRelationshipId, datasetRelationshipUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetRelationshipId`)) {
        stop("Missing required parameter `datasetRelationshipId`.")
      }

      if (!missing(`datasetRelationshipUpdate`) && isa(datasetRelationshipUpdate, c("DatasetRelationshipUpdate", "R6"))) {
        body <- `datasetRelationshipUpdate`$toJSON()
      } else {
        stop("DatasetsRelationshipsPatchWithHttpInfo requires parameter datasetRelationshipUpdate to be of type DatasetRelationshipUpdate.")
      }

      urlPath <- "/datasets/{datasetId}/relationships/{datasetRelationshipId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetRelationshipId`)) {
        urlPath <- gsub(paste0("\\{", "datasetRelationshipId", "\\}"), URLencode(as.character(`datasetRelationshipId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetRelationshipResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsRetrieveWithHttpInfo = function(datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FullDatasetDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsSharedRolesListWithHttpInfo = function(offset, limit, datasetId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["id"] <- id

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/datasets/{datasetId}/sharedRoles/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharedRolesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsSharedRolesPatchManyWithHttpInfo = function(datasetId, datasetSharedRoles = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetSharedRoles`) && isa(datasetSharedRoles, c("DatasetSharedRoles", "R6"))) {
        body <- `datasetSharedRoles`$toJSON()
      } else {
        stop("DatasetsSharedRolesPatchManyWithHttpInfo requires parameter datasetSharedRoles to be of type DatasetSharedRoles.")
      }

      urlPath <- "/datasets/{datasetId}/sharedRoles/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsAllFeaturesDetailsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsAllFeaturesDetailsListWithHttpInfo = function(limit, offset, orderBy, datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`orderBy`)) {
        stop("Missing required parameter `orderBy`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/allFeaturesDetails/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsDeleteWithHttpInfo = function(datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsDeletedPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsDeletedPatchManyWithHttpInfo = function(datasetId, datasetVersionId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("DatasetsVersionsDeletedPatchManyWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/deleted/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFeatureHistogramsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFeatureHistogramsRetrieveWithHttpInfo = function(binLimit, datasetId, datasetVersionId, featureName, key = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`binLimit`)) {
        stop("Missing required parameter `binLimit`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      queryParams["binLimit"] <- binLimit

      queryParams["key"] <- key

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/featureHistograms/{featureName}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeatureHistogramResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFeaturelistsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFeaturelistsListWithHttpInfo = function(limit, offset, orderBy, datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`orderBy`)) {
        stop("Missing required parameter `orderBy`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/featurelists/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturelistListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFeaturelistsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFeaturelistsRetrieveWithHttpInfo = function(datasetId, datasetVersionId, featurelistId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/featurelists/{featurelistId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetFeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFileListWithHttpInfo = function(datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/file/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "character", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromDataEngineWorkspaceStateCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromDataEngineWorkspaceStateCreateWithHttpInfo = function(datasetId, datasetCreateFromWorkspaceState = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetCreateFromWorkspaceState`) && isa(datasetCreateFromWorkspaceState, c("DatasetCreateFromWorkspaceState", "R6"))) {
        body <- `datasetCreateFromWorkspaceState`$toJSON()
      } else {
        stop("DatasetsVersionsFromDataEngineWorkspaceStateCreateWithHttpInfo requires parameter datasetCreateFromWorkspaceState to be of type DatasetCreateFromWorkspaceState.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromDataEngineWorkspaceState/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetDataEngineResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromDataSourceCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromDataSourceCreateWithHttpInfo = function(datasetId, datasource = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasource`) && isa(datasource, c("Datasource", "R6"))) {
        body <- `datasource`$toJSON()
      } else {
        stop("DatasetsVersionsFromDataSourceCreateWithHttpInfo requires parameter datasource to be of type Datasource.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromDataSource/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromFileCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromFileCreateWithHttpInfo = function(datasetId, datasetFromFile = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`datasetFromFile`) && isa(datasetFromFile, c("DatasetFromFile", "R6"))) {
        body <- `datasetFromFile`$toJSON()
      } else {
        stop("DatasetsVersionsFromFileCreateWithHttpInfo requires parameter datasetFromFile to be of type DatasetFromFile.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromFile/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromHDFSCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromHDFSCreateWithHttpInfo = function(datasetId, hdfs = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`hdfs`) && isa(hdfs, c("Hdfs", "R6"))) {
        body <- `hdfs`$toJSON()
      } else {
        stop("DatasetsVersionsFromHDFSCreateWithHttpInfo requires parameter hdfs to be of type Hdfs.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromHDFS/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromLatestVersionCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromLatestVersionCreateWithHttpInfo = function(datasetId, fromLatest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`fromLatest`) && isa(fromLatest, c("FromLatest", "R6"))) {
        body <- `fromLatest`$toJSON()
      } else {
        stop("DatasetsVersionsFromLatestVersionCreateWithHttpInfo requires parameter fromLatest to be of type FromLatest.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromLatestVersion/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromURLCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromURLCreateWithHttpInfo = function(datasetId, url = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (!missing(`url`) && isa(url, c("Url", "R6"))) {
        body <- `url`$toJSON()
      } else {
        stop("DatasetsVersionsFromURLCreateWithHttpInfo requires parameter url to be of type Url.")
      }

      urlPath <- "/datasets/{datasetId}/versions/fromURL/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsFromVersionCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsFromVersionCreateWithHttpInfo = function(datasetId, datasetVersionId, fromSpecific = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      if (!missing(`fromSpecific`) && isa(fromSpecific, c("FromSpecific", "R6"))) {
        body <- `fromSpecific`$toJSON()
      } else {
        stop("DatasetsVersionsFromVersionCreateWithHttpInfo requires parameter fromSpecific to be of type FromSpecific.")
      }

      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/fromVersion/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsListWithHttpInfo = function(limit, offset, datasetId, category = NULL, orderBy = NULL, filterFailed = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["category"] <- category

      queryParams["orderBy"] <- orderBy

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["filterFailed"] <- filterFailed

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatasetListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsProjectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsProjectsListWithHttpInfo = function(limit, offset, datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/projects/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "GetDatasetVersionProjectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DatasetsVersionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DatasetsVersionsRetrieveWithHttpInfo = function(datasetId, datasetVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      if (missing(`datasetVersionId`)) {
        stop("Missing required parameter `datasetVersionId`.")
      }

      body <- NULL
      urlPath <- "/datasets/{datasetId}/versions/{datasetVersionId}/"
      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetVersionId`)) {
        urlPath <- gsub(paste0("\\{", "datasetVersionId", "\\}"), URLencode(as.character(`datasetVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FullDatasetDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsBulkValidationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsBulkValidationsCreateWithHttpInfo = function(userBlueprintBulkValidationRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintBulkValidationRequest`) && isa(userBlueprintBulkValidationRequest, c("UserBlueprintBulkValidationRequest", "R6"))) {
        body <- `userBlueprintBulkValidationRequest`$toJSON()
      } else {
        stop("UserBlueprintsBulkValidationsCreateWithHttpInfo requires parameter userBlueprintBulkValidationRequest to be of type UserBlueprintBulkValidationRequest.")
      }

      urlPath <- "/userBlueprintsBulkValidations/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsBulkValidationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsCreateWithHttpInfo = function(userBlueprintCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintCreate`) && isa(userBlueprintCreate, c("UserBlueprintCreate", "R6"))) {
        body <- `userBlueprintCreate`$toJSON()
      } else {
        stop("UserBlueprintsCreateWithHttpInfo requires parameter userBlueprintCreate to be of type UserBlueprintCreate.")
      }

      urlPath <- "/userBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsDetailedItem", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsDeleteWithHttpInfo = function(userBlueprintId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userBlueprintId`)) {
        stop("Missing required parameter `userBlueprintId`.")
      }

      body <- NULL
      urlPath <- "/userBlueprints/{userBlueprintId}/"
      if (!missing(`userBlueprintId`)) {
        urlPath <- gsub(paste0("\\{", "userBlueprintId", "\\}"), URLencode(as.character(`userBlueprintId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsDeleteManyWithHttpInfo = function(userBlueprintsBulkDelete = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintsBulkDelete`) && isa(userBlueprintsBulkDelete, c("UserBlueprintsBulkDelete", "R6"))) {
        body <- `userBlueprintsBulkDelete`$toJSON()
      } else {
        stop("UserBlueprintsDeleteManyWithHttpInfo requires parameter userBlueprintsBulkDelete to be of type UserBlueprintsBulkDelete.")
      }

      urlPath <- "/userBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsBulkDeleteResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsFromBlueprintIdCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsFromBlueprintIdCreateWithHttpInfo = function(userBlueprintCreateFromBlueprintId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintCreateFromBlueprintId`) && isa(userBlueprintCreateFromBlueprintId, c("UserBlueprintCreateFromBlueprintId", "R6"))) {
        body <- `userBlueprintCreateFromBlueprintId`$toJSON()
      } else {
        stop("UserBlueprintsFromBlueprintIdCreateWithHttpInfo requires parameter userBlueprintCreateFromBlueprintId to be of type UserBlueprintCreateFromBlueprintId.")
      }

      urlPath <- "/userBlueprints/fromBlueprintId/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsDetailedItem", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsFromCustomTaskVersionIdCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsFromCustomTaskVersionIdCreateWithHttpInfo = function(userBlueprintCreateFromCustomTaskVersionIdPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintCreateFromCustomTaskVersionIdPayload`) && isa(userBlueprintCreateFromCustomTaskVersionIdPayload, c("UserBlueprintCreateFromCustomTaskVersionIdPayload", "R6"))) {
        body <- `userBlueprintCreateFromCustomTaskVersionIdPayload`$toJSON()
      } else {
        stop("UserBlueprintsFromCustomTaskVersionIdCreateWithHttpInfo requires parameter userBlueprintCreateFromCustomTaskVersionIdPayload to be of type UserBlueprintCreateFromCustomTaskVersionIdPayload.")
      }

      urlPath <- "/userBlueprints/fromCustomTaskVersionId/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsDetailedItem", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsFromUserBlueprintIdCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsFromUserBlueprintIdCreateWithHttpInfo = function(userBlueprintCreateFromUserBlueprintId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintCreateFromUserBlueprintId`) && isa(userBlueprintCreateFromUserBlueprintId, c("UserBlueprintCreateFromUserBlueprintId", "R6"))) {
        body <- `userBlueprintCreateFromUserBlueprintId`$toJSON()
      } else {
        stop("UserBlueprintsFromUserBlueprintIdCreateWithHttpInfo requires parameter userBlueprintCreateFromUserBlueprintId to be of type UserBlueprintCreateFromUserBlueprintId.")
      }

      urlPath <- "/userBlueprints/fromUserBlueprintId/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsDetailedItem", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsInputTypesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsInputTypesListWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/userBlueprintsInputTypes/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsInputTypesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsListWithHttpInfo = function(offset, limit, projectId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["projectId"] <- projectId

      body <- NULL
      urlPath <- "/userBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsPatchWithHttpInfo = function(userBlueprintId, userBlueprintUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userBlueprintId`)) {
        stop("Missing required parameter `userBlueprintId`.")
      }

      if (!missing(`userBlueprintUpdate`) && isa(userBlueprintUpdate, c("UserBlueprintUpdate", "R6"))) {
        body <- `userBlueprintUpdate`$toJSON()
      } else {
        stop("UserBlueprintsPatchWithHttpInfo requires parameter userBlueprintUpdate to be of type UserBlueprintUpdate.")
      }

      urlPath <- "/userBlueprints/{userBlueprintId}/"
      if (!missing(`userBlueprintId`)) {
        urlPath <- gsub(paste0("\\{", "userBlueprintId", "\\}"), URLencode(as.character(`userBlueprintId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsDetailedItem", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsProjectBlueprintsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsProjectBlueprintsCreateWithHttpInfo = function(userBlueprintAddToMenu = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintAddToMenu`) && isa(userBlueprintAddToMenu, c("UserBlueprintAddToMenu", "R6"))) {
        body <- `userBlueprintAddToMenu`$toJSON()
      } else {
        stop("UserBlueprintsProjectBlueprintsCreateWithHttpInfo requires parameter userBlueprintAddToMenu to be of type UserBlueprintAddToMenu.")
      }

      urlPath <- "/userBlueprintsProjectBlueprints/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintAddToMenuResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsRetrieveWithHttpInfo = function(editMode, decompressedBlueprint, isInplaceEditor, userBlueprintId, projectId = NULL, getDynamicLabels = FALSE, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`editMode`)) {
        stop("Missing required parameter `editMode`.")
      }

      if (missing(`decompressedBlueprint`)) {
        stop("Missing required parameter `decompressedBlueprint`.")
      }

      if (missing(`isInplaceEditor`)) {
        stop("Missing required parameter `isInplaceEditor`.")
      }

      if (missing(`userBlueprintId`)) {
        stop("Missing required parameter `userBlueprintId`.")
      }

      queryParams["editMode"] <- editMode

      queryParams["decompressedBlueprint"] <- decompressedBlueprint

      queryParams["projectId"] <- projectId

      queryParams["isInplaceEditor"] <- isInplaceEditor

      queryParams["getDynamicLabels"] <- getDynamicLabels

      body <- NULL
      urlPath <- "/userBlueprints/{userBlueprintId}/"
      if (!missing(`userBlueprintId`)) {
        urlPath <- gsub(paste0("\\{", "userBlueprintId", "\\}"), URLencode(as.character(`userBlueprintId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsSharedRolesListWithHttpInfo = function(offset, limit, userBlueprintId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`userBlueprintId`)) {
        stop("Missing required parameter `userBlueprintId`.")
      }

      queryParams["id"] <- id

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      body <- NULL
      urlPath <- "/userBlueprints/{userBlueprintId}/sharedRoles/"
      if (!missing(`userBlueprintId`)) {
        urlPath <- gsub(paste0("\\{", "userBlueprintId", "\\}"), URLencode(as.character(`userBlueprintId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintSharedRolesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsSharedRolesPatchManyWithHttpInfo = function(userBlueprintId, sharedRolesUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userBlueprintId`)) {
        stop("Missing required parameter `userBlueprintId`.")
      }

      if (!missing(`sharedRolesUpdate`) && isa(sharedRolesUpdate, c("SharedRolesUpdate", "R6"))) {
        body <- `sharedRolesUpdate`$toJSON()
      } else {
        stop("UserBlueprintsSharedRolesPatchManyWithHttpInfo requires parameter sharedRolesUpdate to be of type SharedRolesUpdate.")
      }

      urlPath <- "/userBlueprints/{userBlueprintId}/sharedRoles/"
      if (!missing(`userBlueprintId`)) {
        urlPath <- gsub(paste0("\\{", "userBlueprintId", "\\}"), URLencode(as.character(`userBlueprintId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsTaskParametersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsTaskParametersCreateWithHttpInfo = function(userBlueprintTaskParameterValidation = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintTaskParameterValidation`) && isa(userBlueprintTaskParameterValidation, c("UserBlueprintTaskParameterValidation", "R6"))) {
        body <- `userBlueprintTaskParameterValidation`$toJSON()
      } else {
        stop("UserBlueprintsTaskParametersCreateWithHttpInfo requires parameter userBlueprintTaskParameterValidation to be of type UserBlueprintTaskParameterValidation.")
      }

      urlPath <- "/userBlueprintsTaskParameters/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsValidateTaskParametersResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsTasksList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsTasksListWithHttpInfo = function(projectId = NULL, blueprintId = NULL, userBlueprintId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["projectId"] <- projectId

      queryParams["blueprintId"] <- blueprintId

      queryParams["userBlueprintId"] <- userBlueprintId

      body <- NULL
      urlPath <- "/userBlueprintsTasks/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintTasksResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserBlueprintsValidationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserBlueprintsValidationsCreateWithHttpInfo = function(userBlueprintValidation = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userBlueprintValidation`) && isa(userBlueprintValidation, c("UserBlueprintValidation", "R6"))) {
        body <- `userBlueprintValidation`$toJSON()
      } else {
        stop("UserBlueprintsValidationsCreateWithHttpInfo requires parameter userBlueprintValidation to be of type UserBlueprintValidation.")
      }

      urlPath <- "/userBlueprintsValidations/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserBlueprintsValidationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
