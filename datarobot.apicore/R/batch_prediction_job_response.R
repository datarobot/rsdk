# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title BatchPredictionJobResponse
#'
#' @description BatchPredictionJobResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field batchPredictionJobDefinition  \link{BatchPredictionJobDefinitionResponse} [optional]
#'
#' @field created  character When was this job created
#'
#' @field createdBy  \link{BatchPredictionCreatedBy}
#'
#' @field elapsedTimeSec  integer Number of seconds the job has been processing for
#'
#' @field failedRows  integer Number of rows that have failed scoring
#'
#' @field hidden  character [optional] When was this job was hidden last, blank if visible
#'
#' @field id  character The ID of the Batch Prediction job
#'
#' @field intakeDatasetDisplayName  character [optional] If applicable (e.g. for AI catalog), will contain the dataset name used for the intake dataset.
#'
#' @field jobIntakeSize  integer Number of bytes in the intake dataset for this job
#'
#' @field jobOutputSize  integer Number of bytes in the output dataset for this job
#'
#' @field jobSpec  \link{BatchPredictionJobSpecResponse}
#'
#' @field links  \link{BatchPredictionJobLinks}
#'
#' @field logs  list( character ) The job log.
#'
#' @field percentageCompleted  numeric Indicates job progress which is based on number of already processed rows in dataset
#'
#' @field queuePosition  integer [optional] To ensure a dedicated prediction instance is not overloaded, only one job will be run against it at a time. This is the number of jobs that are awaiting processing before this job start running. May not be available in all environments.
#'
#' @field queued  character The job has been put on the queue for execution.
#'
#' @field resultsDeleted  character [optional] Indicates if the job was subject to garbage collection and had its artifacts deleted (output files, if any, and scoring data on local storage)
#'
#' @field scoredRows  integer Number of rows that have been successfully scored
#'
#' @field skippedRows  integer Number of rows that have been skipped during scoring. May contain non-zero value only in time-series predictions case if provided dataset contains more than required historical rows.
#'
#' @field source  character [optional] Source from which batch job was started
#'
#' @field status  character The current job status
#'
#' @field statusDetails  character Explanation for current status
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
BatchPredictionJobResponse <- R6::R6Class(
  "BatchPredictionJobResponse",
  lock_objects = FALSE,
  private = list(
    # @description The properties of this object that are required to be set.
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(`batchPredictionJobDefinition` = NULL, `created` = NULL, `createdBy` = NULL, `elapsedTimeSec` = NULL, `failedRows` = NULL, `hidden` = NULL, `id` = NULL, `intakeDatasetDisplayName` = NULL, `jobIntakeSize` = NULL, `jobOutputSize` = NULL, `jobSpec` = NULL, `links` = NULL, `logs` = NULL, `percentageCompleted` = NULL, `queuePosition` = NULL, `queued` = NULL, `resultsDeleted` = NULL, `scoredRows` = NULL, `skippedRows` = NULL, `source` = NULL, `status` = NULL, `statusDetails` = NULL) {
      if (!is.null(`created`)) {
        stopifnot(inherits(`created`, "POSIXt"))
      }
      if (!is.null(`createdBy`)) {
        stopifnot(R6::is.R6(`createdBy`))
      }
      if (!is.null(`elapsedTimeSec`)) {
        stopifnot(is.numeric(`elapsedTimeSec`), length(`elapsedTimeSec`) == 1)
      }
      if (!is.null(`failedRows`)) {
        stopifnot(is.numeric(`failedRows`), length(`failedRows`) == 1)
      }
      if (!is.null(`id`)) {
        stopifnot(is.character(`id`), length(`id`) == 1)
      }
      if (!is.null(`jobIntakeSize`)) {
        stopifnot(is.numeric(`jobIntakeSize`), length(`jobIntakeSize`) == 1)
      }
      if (!is.null(`jobOutputSize`)) {
        stopifnot(is.numeric(`jobOutputSize`), length(`jobOutputSize`) == 1)
      }
      if (!is.null(`jobSpec`)) {
        stopifnot(R6::is.R6(`jobSpec`))
      }
      if (!is.null(`links`)) {
        stopifnot(R6::is.R6(`links`))
      }
      if (!is.null(`logs`)) {
        stopifnot(is.vector(`logs`), sapply(`logs`, is.character))
      }
      if (!is.null(`percentageCompleted`)) {
      }
      if (!is.null(`queued`)) {
        stopifnot(is.logical(`queued`), length(`queued`) == 1)
      }
      if (!is.null(`scoredRows`)) {
        stopifnot(is.numeric(`scoredRows`), length(`scoredRows`) == 1)
      }
      if (!is.null(`skippedRows`)) {
        stopifnot(is.numeric(`skippedRows`), length(`skippedRows`) == 1)
      }
      if (!is.null(`status`)) {
        stopifnot(is.character(`status`), length(`status`) == 1)
      }
      if (!is.null(`statusDetails`)) {
        stopifnot(is.character(`statusDetails`), length(`statusDetails`) == 1)
      }
      if (!is.null(`batchPredictionJobDefinition`)) {
        stopifnot(R6::is.R6(`batchPredictionJobDefinition`))
      }
      if (!is.null(`hidden`)) {
        stopifnot(inherits(`hidden`, "POSIXt"))
      }
      if (!is.null(`intakeDatasetDisplayName`)) {
        stopifnot(is.character(`intakeDatasetDisplayName`), length(`intakeDatasetDisplayName`) == 1)
      }
      if (!is.null(`queuePosition`)) {
        stopifnot(is.numeric(`queuePosition`), length(`queuePosition`) == 1)
      }
      if (!is.null(`resultsDeleted`)) {
        stopifnot(is.logical(`resultsDeleted`), length(`resultsDeleted`) == 1)
      }
      if (!is.null(`source`)) {
        stopifnot(is.character(`source`), length(`source`) == 1)
      }
    }
  ),
  public = list(
    `batchPredictionJobDefinition` = NULL,
    `created` = NULL,
    `createdBy` = NULL,
    `elapsedTimeSec` = NULL,
    `failedRows` = NULL,
    `hidden` = NULL,
    `id` = NULL,
    `intakeDatasetDisplayName` = NULL,
    `jobIntakeSize` = NULL,
    `jobOutputSize` = NULL,
    `jobSpec` = NULL,
    `links` = NULL,
    `logs` = NULL,
    `percentageCompleted` = NULL,
    `queuePosition` = NULL,
    `queued` = NULL,
    `resultsDeleted` = NULL,
    `scoredRows` = NULL,
    `skippedRows` = NULL,
    `source` = NULL,
    `status` = NULL,
    `statusDetails` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param batchPredictionJobDefinition
    #' @param created When was this job created
    #' @param createdBy
    #' @param elapsedTimeSec Number of seconds the job has been processing for
    #' @param failedRows Number of rows that have failed scoring
    #' @param hidden When was this job was hidden last, blank if visible
    #' @param id The ID of the Batch Prediction job
    #' @param intakeDatasetDisplayName If applicable (e.g. for AI catalog), will contain the dataset name used for the intake dataset.
    #' @param jobIntakeSize Number of bytes in the intake dataset for this job
    #' @param jobOutputSize Number of bytes in the output dataset for this job
    #' @param jobSpec
    #' @param links
    #' @param logs The job log.
    #' @param percentageCompleted Indicates job progress which is based on number of already processed rows in dataset
    #' @param queuePosition To ensure a dedicated prediction instance is not overloaded, only one job will be run against it at a time. This is the number of jobs that are awaiting processing before this job start running. May not be available in all environments.
    #' @param queued The job has been put on the queue for execution.
    #' @param resultsDeleted Indicates if the job was subject to garbage collection and had its artifacts deleted (output files, if any, and scoring data on local storage)
    #' @param scoredRows Number of rows that have been successfully scored
    #' @param skippedRows Number of rows that have been skipped during scoring. May contain non-zero value only in time-series predictions case if provided dataset contains more than required historical rows.
    #' @param source Source from which batch job was started
    #' @param status The current job status
    #' @param statusDetails Explanation for current status
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`created` = NULL, `createdBy` = NULL, `elapsedTimeSec` = NULL, `failedRows` = NULL, `id` = NULL, `jobIntakeSize` = NULL, `jobOutputSize` = NULL, `jobSpec` = NULL, `links` = NULL, `logs` = NULL, `percentageCompleted` = NULL, `queued` = NULL, `scoredRows` = NULL, `skippedRows` = NULL, `status` = NULL, `statusDetails` = NULL, `batchPredictionJobDefinition` = NULL, `hidden` = NULL, `intakeDatasetDisplayName` = NULL, `queuePosition` = NULL, `resultsDeleted` = NULL, `source` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      if (validateParams) {
        lapply(list(`created`, `createdBy`, `elapsedTimeSec`, `failedRows`, `id`, `jobIntakeSize`, `jobOutputSize`, `jobSpec`, `links`, `logs`, `percentageCompleted`, `queued`, `scoredRows`, `skippedRows`, `status`, `statusDetails`), function(param) {
          stopifnot("Required param not set." = !is.null(param))
        })
        private$validateProps(batchPredictionJobDefinition, created, createdBy, elapsedTimeSec, failedRows, hidden, id, intakeDatasetDisplayName, jobIntakeSize, jobOutputSize, jobSpec, links, logs, percentageCompleted, queuePosition, queued, resultsDeleted, scoredRows, skippedRows, source, status, statusDetails)
      }
      self$`batchPredictionJobDefinition` <- `batchPredictionJobDefinition`
      self$`created` <- `created`
      self$`createdBy` <- `createdBy`
      self$`elapsedTimeSec` <- `elapsedTimeSec`
      self$`failedRows` <- `failedRows`
      self$`hidden` <- `hidden`
      self$`id` <- `id`
      self$`intakeDatasetDisplayName` <- `intakeDatasetDisplayName`
      self$`jobIntakeSize` <- `jobIntakeSize`
      self$`jobOutputSize` <- `jobOutputSize`
      self$`jobSpec` <- `jobSpec`
      self$`links` <- `links`
      self$`logs` <- `logs`
      self$`percentageCompleted` <- `percentageCompleted`
      self$`queuePosition` <- `queuePosition`
      self$`queued` <- `queued`
      self$`resultsDeleted` <- `resultsDeleted`
      self$`scoredRows` <- `scoredRows`
      self$`skippedRows` <- `skippedRows`
      self$`source` <- `source`
      self$`status` <- `status`
      self$`statusDetails` <- `statusDetails`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    #' checking this objects set properties.
    validate = function() {
      do.call(private$validateProps, list(batchPredictionJobDefinition = self$`batchPredictionJobDefinition`, created = self$`created`, createdBy = self$`createdBy`, elapsedTimeSec = self$`elapsedTimeSec`, failedRows = self$`failedRows`, hidden = self$`hidden`, id = self$`id`, intakeDatasetDisplayName = self$`intakeDatasetDisplayName`, jobIntakeSize = self$`jobIntakeSize`, jobOutputSize = self$`jobOutputSize`, jobSpec = self$`jobSpec`, links = self$`links`, logs = self$`logs`, percentageCompleted = self$`percentageCompleted`, queuePosition = self$`queuePosition`, queued = self$`queued`, resultsDeleted = self$`resultsDeleted`, scoredRows = self$`scoredRows`, skippedRows = self$`skippedRows`, source = self$`source`, status = self$`status`, statusDetails = self$`statusDetails`))
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`batchPredictionJobDefinition`)) {
          sprintf(
            '"batchPredictionJobDefinition":
            %s
      ',
            jsonlite::toJSON(self$`batchPredictionJobDefinition`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`created`)) {
          sprintf(
            '"created":
            "%s"
                  ',
            format(self$`created`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`createdBy`)) {
          sprintf(
            '"createdBy":
            %s
      ',
            jsonlite::toJSON(self$`createdBy`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`elapsedTimeSec`)) {
          sprintf(
            '"elapsedTimeSec":
            %d
                  ',
            self$`elapsedTimeSec`
          )
        },
        if (!is.null(self$`failedRows`)) {
          sprintf(
            '"failedRows":
            %d
                  ',
            self$`failedRows`
          )
        },
        if (!is.null(self$`hidden`)) {
          sprintf(
            '"hidden":
            "%s"
                  ',
            format(self$`hidden`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            "%s"
                  ',
            self$`id`
          )
        },
        if (!is.null(self$`intakeDatasetDisplayName`)) {
          sprintf(
            '"intakeDatasetDisplayName":
            "%s"
                  ',
            self$`intakeDatasetDisplayName`
          )
        },
        if (!is.null(self$`jobIntakeSize`)) {
          sprintf(
            '"jobIntakeSize":
            %d
                  ',
            self$`jobIntakeSize`
          )
        },
        if (!is.null(self$`jobOutputSize`)) {
          sprintf(
            '"jobOutputSize":
            %d
                  ',
            self$`jobOutputSize`
          )
        },
        if (!is.null(self$`jobSpec`)) {
          sprintf(
            '"jobSpec":
            %s
      ',
            jsonlite::toJSON(self$`jobSpec`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`links`)) {
          sprintf(
            '"links":
            %s
      ',
            jsonlite::toJSON(self$`links`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`logs`)) {
          sprintf(
            '"logs":
            [%s]
                  ',
            paste(unlist(lapply(self$`logs`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`percentageCompleted`)) {
          sprintf(
            '"percentageCompleted":
            %d
                  ',
            self$`percentageCompleted`
          )
        },
        if (!is.null(self$`queuePosition`)) {
          sprintf(
            '"queuePosition":
            %d
                  ',
            self$`queuePosition`
          )
        },
        if (!is.null(self$`queued`)) {
          sprintf(
            '"queued":
            %s
                  ',
            tolower(self$`queued`)
          )
        },
        if (!is.null(self$`resultsDeleted`)) {
          sprintf(
            '"resultsDeleted":
            %s
                  ',
            tolower(self$`resultsDeleted`)
          )
        },
        if (!is.null(self$`scoredRows`)) {
          sprintf(
            '"scoredRows":
            %d
                  ',
            self$`scoredRows`
          )
        },
        if (!is.null(self$`skippedRows`)) {
          sprintf(
            '"skippedRows":
            %d
                  ',
            self$`skippedRows`
          )
        },
        if (!is.null(self$`source`)) {
          sprintf(
            '"source":
            "%s"
                  ',
            self$`source`
          )
        },
        if (!is.null(self$`status`)) {
          sprintf(
            '"status":
            "%s"
                  ',
            self$`status`
          )
        },
        if (!is.null(self$`statusDetails`)) {
          sprintf(
            '"statusDetails":
            "%s"
                  ',
            self$`statusDetails`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param BatchPredictionJobResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(BatchPredictionJobResponseJson, validateParams = FALSE) {
      BatchPredictionJobResponseObject <- jsonlite::fromJSON(BatchPredictionJobResponseJson)
      self$`batchPredictionJobDefinition` <- BatchPredictionJobDefinitionResponse$new()$fromJSON(jsonlite::toJSON(BatchPredictionJobResponseObject$batchPredictionJobDefinition, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`created` <- ParseRFC3339Timestamp(BatchPredictionJobResponseObject$`created`)
      self$`createdBy` <- BatchPredictionCreatedBy$new()$fromJSON(jsonlite::toJSON(BatchPredictionJobResponseObject$createdBy, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`elapsedTimeSec` <- BatchPredictionJobResponseObject$`elapsedTimeSec`
      self$`failedRows` <- BatchPredictionJobResponseObject$`failedRows`
      self$`hidden` <- ParseRFC3339Timestamp(BatchPredictionJobResponseObject$`hidden`)
      self$`id` <- BatchPredictionJobResponseObject$`id`
      self$`intakeDatasetDisplayName` <- BatchPredictionJobResponseObject$`intakeDatasetDisplayName`
      self$`jobIntakeSize` <- BatchPredictionJobResponseObject$`jobIntakeSize`
      self$`jobOutputSize` <- BatchPredictionJobResponseObject$`jobOutputSize`
      self$`jobSpec` <- BatchPredictionJobSpecResponse$new()$fromJSON(jsonlite::toJSON(BatchPredictionJobResponseObject$jobSpec, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`links` <- BatchPredictionJobLinks$new()$fromJSON(jsonlite::toJSON(BatchPredictionJobResponseObject$links, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`logs` <- ApiClient$new()$deserializeObj(BatchPredictionJobResponseObject$`logs`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`percentageCompleted` <- BatchPredictionJobResponseObject$`percentageCompleted`
      self$`queuePosition` <- BatchPredictionJobResponseObject$`queuePosition`
      self$`queued` <- BatchPredictionJobResponseObject$`queued`
      self$`resultsDeleted` <- BatchPredictionJobResponseObject$`resultsDeleted`
      self$`scoredRows` <- BatchPredictionJobResponseObject$`scoredRows`
      self$`skippedRows` <- BatchPredictionJobResponseObject$`skippedRows`
      self$`source` <- BatchPredictionJobResponseObject$`source`
      self$`status` <- BatchPredictionJobResponseObject$`status`
      self$`statusDetails` <- BatchPredictionJobResponseObject$`statusDetails`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
