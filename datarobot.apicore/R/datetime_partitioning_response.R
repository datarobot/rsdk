# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title DatetimePartitioningResponse
#'
#' @description DatetimePartitioningResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field aggregationType  character [optional] For multiseries projects only. The aggregation type to apply when creating cross-series features.
#'
#' @field autopilotDataSelectionMethod  character The Data Selection method to be used by autopilot when creating models for datetime-partitioned datasets.
#'
#' @field availableTrainingDuration  character The duration of available training duration for scoring the holdout.
#'
#' @field availableTrainingEndDate  character The end date of available training data for scoring the holdout.
#'
#' @field availableTrainingStartDate  character The start date of available training data for scoring the holdout.
#'
#' @field backtests  list( \link{BacktestResponse} ) An array of the configured backtests.
#'
#' @field calendarId  character [optional] The ID of the calendar to be used in this project.
#'
#' @field calendarName  character [optional] The name of the calendar used in this project.
#'
#' @field crossSeriesGroupByColumns  list( character ) [optional] For multiseries projects with cross-series features enabled only. List of columns (currently of length 1). Setting that indicates how to further split series into related groups. For example, if every series is sales of an individual product, the series group-by could be the product category with values like \&quot;men&#39;s clothing\&quot;, \&quot;sports equipment\&quot;, etc.
#'
#' @field dateFormat  character The date format of the partition column.
#'
#' @field datetimePartitionColumn  character The date column that will be used as a datetime partition column.
#'
#' @field defaultToAPriori  character Renamed to &#x60;defaultToKnownInAdvance&#x60;.
#'
#' @field defaultToDoNotDerive  character For time series projects only. Sets whether all features default to being treated as do-not-derive features, excluding them from feature derivation. Individual features can be set to a value different than the default by using the &#x60;featureSettings&#x60; parameter.
#'
#' @field defaultToKnownInAdvance  character For time series projects only. Sets whether all features default to being treated as known in advance features, which are features that are known into the future. Features marked as known in advance must be specified into the future when making predictions. The default is false, all features are not known in advance. Individual features can be set to a value different than the default using the &#x60;featureSettings&#x60; parameter. See the :ref:&#x60;Time Series Overview &lt;time_series_overview&gt;&#x60; for more context.
#'
#' @field differencingMethod  character For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems &#x60;simple&#x60; and &#x60;seasonal&#x60; are not allowed. Parameter &#x60;periodicities&#x60; must be specified if &#x60;seasonal&#x60; is chosen. Defaults to &#x60;auto&#x60;.
#'
#' @field disableHoldout  character A boolean value indicating whether date partitioning skipped allocating a holdout fold.
#'
#' @field featureDerivationWindowEnd  integer For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should end.
#'
#' @field featureDerivationWindowStart  integer For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should begin.
#'
#' @field featureSettings  list( \link{FeatureSetting} ) An array specifying per feature settings. Features can be left unspecified.
#'
#' @field forecastWindowEnd  integer For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should end.
#'
#' @field forecastWindowStart  integer For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should start.
#'
#' @field gapDuration  character The duration of the gap between the training and holdout scoring data.
#'
#' @field gapEndDate  character The end date of the gap between the training and holdout scoring data.
#'
#' @field gapStartDate  character The start date of the gap between the training and holdout scoring data.
#'
#' @field holdoutDuration  character The duration of the holdout scoring data.
#'
#' @field holdoutEndDate  character The end date of holdout scoring data.
#'
#' @field holdoutStartDate  character The start date of holdout scoring data.
#'
#' @field isHoldoutModified  character [optional] A boolean value indicating whether holdout settings (start/end dates) have been modified by user.
#'
#' @field modelSplits  integer [optional] Sets the cap on the number of jobs per model used when building models to control number of jobs in the queue. Higher number of modelSplits will allow for less downsampling leading to the use of more post-processed data.
#'
#' @field multiseriesIdColumns  list( character ) May be used only with time series projects. An array of the column names identifying  the series to which each row of the dataset belongs. Currently only one multiseries ID column is supported. See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; section of the time series documentation for more context.
#'
#' @field numberOfBacktests  integer The number of backtests to use. If omitted, defaults to a positive value selected by the server based on the validation and gap durations.
#'
#' @field numberOfDoNotDeriveFeatures  integer Number of features that are marked as \&quot;do not derive\&quot;.
#'
#' @field numberOfKnownInAdvanceFeatures  integer Number of features that are marked as \&quot;known in advance\&quot;.
#'
#' @field partitioningWarnings  list( \link{PartitioningWarning} ) An array of available warnings about potential problems with the chosen partitioning that could cause issues during modeling, although the partitioning may be successfully submitted.
#'
#' @field periodicities  list( \link{Periodicity} ) A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter &#39;differencing_method&#39; will default to &#39;seasonal&#39; if not provided or &#39;auto&#39;.
#'
#' @field primaryTrainingDuration  character The duration of primary training duration for scoring the holdout.
#'
#' @field primaryTrainingEndDate  character The end date of primary training data for scoring the holdout.
#'
#' @field primaryTrainingStartDate  character The start date of primary training data for scoring the holdout.
#'
#' @field projectId  character The ID of the project.
#'
#' @field treatAsExponential  character For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems &#x60;always&#x60; is not allowed. Defaults to &#x60;auto&#x60;.
#'
#' @field useCrossSeriesFeatures  character [optional] For multiseries projects only. Indicating whether to use cross-series features.
#'
#' @field useTimeSeries  character A boolean value indicating whether a time series project should be created instead of a regular project which uses datetime partitioning.
#'
#' @field validationDuration  character The default validation duration for all backtests. If the primary date/time feature in a time series project is irregular, you cannot set a default validation length. Instead, set each duration individually.
#'
#' @field windowsBasisUnit  character For time series projects only. Indicates which unit is basis for feature derivation window and forecast window. Valid options are detected time unit or &#x60;ROW&#x60;. If omitted, the default value is detected time unit.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
DatetimePartitioningResponse <- R6::R6Class(
  "DatetimePartitioningResponse",
  lock_objects = FALSE,
  private = list(
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(aggregationType = NULL, autopilotDataSelectionMethod = NULL, availableTrainingDuration = NULL, availableTrainingEndDate = NULL, availableTrainingStartDate = NULL, backtests = NULL, calendarId = NULL, calendarName = NULL, crossSeriesGroupByColumns = NULL, dateFormat = NULL, datetimePartitionColumn = NULL, defaultToAPriori = NULL, defaultToDoNotDerive = NULL, defaultToKnownInAdvance = NULL, differencingMethod = NULL, disableHoldout = NULL, featureDerivationWindowEnd = NULL, featureDerivationWindowStart = NULL, featureSettings = NULL, forecastWindowEnd = NULL, forecastWindowStart = NULL, gapDuration = NULL, gapEndDate = NULL, gapStartDate = NULL, holdoutDuration = NULL, holdoutEndDate = NULL, holdoutStartDate = NULL, isHoldoutModified = NULL, modelSplits = NULL, multiseriesIdColumns = NULL, numberOfBacktests = NULL, numberOfDoNotDeriveFeatures = NULL, numberOfKnownInAdvanceFeatures = NULL, partitioningWarnings = NULL, periodicities = NULL, primaryTrainingDuration = NULL, primaryTrainingEndDate = NULL, primaryTrainingStartDate = NULL, projectId = NULL, treatAsExponential = NULL, useCrossSeriesFeatures = NULL, useTimeSeries = NULL, validationDuration = NULL, windowsBasisUnit = NULL) {
      if (!is.null(`autopilotDataSelectionMethod`)) {
        stopifnot(is.character(`autopilotDataSelectionMethod`), length(`autopilotDataSelectionMethod`) == 1)
      }
      if (!is.null(`availableTrainingDuration`)) {
        stopifnot(is.character(`availableTrainingDuration`), length(`availableTrainingDuration`) == 1)
      }
      if (!is.null(`availableTrainingEndDate`)) {
        stopifnot(inherits(`availableTrainingEndDate`, "POSIXt"))
      }
      if (!is.null(`availableTrainingStartDate`)) {
        stopifnot(inherits(`availableTrainingStartDate`, "POSIXt"))
      }
      if (!is.null(`backtests`)) {
        stopifnot(is.vector(`backtests`))
      }
      if (!is.null(`dateFormat`)) {
        stopifnot(is.character(`dateFormat`), length(`dateFormat`) == 1)
      }
      if (!is.null(`datetimePartitionColumn`)) {
        stopifnot(is.character(`datetimePartitionColumn`), length(`datetimePartitionColumn`) == 1)
      }
      if (!is.null(`defaultToAPriori`)) {
        stopifnot(is.logical(`defaultToAPriori`), length(`defaultToAPriori`) == 1)
      }
      if (!is.null(`defaultToDoNotDerive`)) {
        stopifnot(is.logical(`defaultToDoNotDerive`), length(`defaultToDoNotDerive`) == 1)
      }
      if (!is.null(`defaultToKnownInAdvance`)) {
        stopifnot(is.logical(`defaultToKnownInAdvance`), length(`defaultToKnownInAdvance`) == 1)
      }
      if (!is.null(`differencingMethod`)) {
        stopifnot(is.character(`differencingMethod`), length(`differencingMethod`) == 1)
      }
      if (!is.null(`disableHoldout`)) {
        stopifnot(is.logical(`disableHoldout`), length(`disableHoldout`) == 1)
      }
      if (!is.null(`featureDerivationWindowEnd`)) {
        stopifnot(is.numeric(`featureDerivationWindowEnd`), length(`featureDerivationWindowEnd`) == 1)
      }
      if (!is.null(`featureDerivationWindowStart`)) {
        stopifnot(is.numeric(`featureDerivationWindowStart`), length(`featureDerivationWindowStart`) == 1)
      }
      if (!is.null(`featureSettings`)) {
        stopifnot(is.vector(`featureSettings`))
      }
      if (!is.null(`forecastWindowEnd`)) {
        stopifnot(is.numeric(`forecastWindowEnd`), length(`forecastWindowEnd`) == 1)
      }
      if (!is.null(`forecastWindowStart`)) {
        stopifnot(is.numeric(`forecastWindowStart`), length(`forecastWindowStart`) == 1)
      }
      if (!is.null(`gapDuration`)) {
        stopifnot(is.character(`gapDuration`), length(`gapDuration`) == 1)
      }
      if (!is.null(`gapEndDate`)) {
        stopifnot(inherits(`gapEndDate`, "POSIXt"))
      }
      if (!is.null(`gapStartDate`)) {
        stopifnot(inherits(`gapStartDate`, "POSIXt"))
      }
      if (!is.null(`holdoutDuration`)) {
        stopifnot(is.character(`holdoutDuration`), length(`holdoutDuration`) == 1)
      }
      if (!is.null(`holdoutEndDate`)) {
        stopifnot(inherits(`holdoutEndDate`, "POSIXt"))
      }
      if (!is.null(`holdoutStartDate`)) {
        stopifnot(inherits(`holdoutStartDate`, "POSIXt"))
      }
      if (!is.null(`multiseriesIdColumns`)) {
        stopifnot(is.vector(`multiseriesIdColumns`))
      }
      if (!is.null(`numberOfBacktests`)) {
        stopifnot(is.numeric(`numberOfBacktests`), length(`numberOfBacktests`) == 1)
      }
      if (!is.null(`numberOfDoNotDeriveFeatures`)) {
        stopifnot(is.numeric(`numberOfDoNotDeriveFeatures`), length(`numberOfDoNotDeriveFeatures`) == 1)
      }
      if (!is.null(`numberOfKnownInAdvanceFeatures`)) {
        stopifnot(is.numeric(`numberOfKnownInAdvanceFeatures`), length(`numberOfKnownInAdvanceFeatures`) == 1)
      }
      if (!is.null(`partitioningWarnings`)) {
        stopifnot(is.vector(`partitioningWarnings`))
      }
      if (!is.null(`periodicities`)) {
        stopifnot(is.vector(`periodicities`))
      }
      if (!is.null(`primaryTrainingDuration`)) {
        stopifnot(is.character(`primaryTrainingDuration`), length(`primaryTrainingDuration`) == 1)
      }
      if (!is.null(`primaryTrainingEndDate`)) {
        stopifnot(inherits(`primaryTrainingEndDate`, "POSIXt"))
      }
      if (!is.null(`primaryTrainingStartDate`)) {
        stopifnot(inherits(`primaryTrainingStartDate`, "POSIXt"))
      }
      if (!is.null(`projectId`)) {
        stopifnot(is.character(`projectId`), length(`projectId`) == 1)
      }
      if (!is.null(`treatAsExponential`)) {
        stopifnot(is.character(`treatAsExponential`), length(`treatAsExponential`) == 1)
      }
      if (!is.null(`useTimeSeries`)) {
        stopifnot(is.logical(`useTimeSeries`), length(`useTimeSeries`) == 1)
      }
      if (!is.null(`validationDuration`)) {
        stopifnot(is.character(`validationDuration`), length(`validationDuration`) == 1)
      }
      if (!is.null(`windowsBasisUnit`)) {
        stopifnot(is.character(`windowsBasisUnit`), length(`windowsBasisUnit`) == 1)
      }
      if (!is.null(`aggregationType`)) {
        stopifnot(is.character(`aggregationType`), length(`aggregationType`) == 1)
      }
      if (!is.null(`calendarId`)) {
        stopifnot(is.character(`calendarId`), length(`calendarId`) == 1)
      }
      if (!is.null(`calendarName`)) {
        stopifnot(is.character(`calendarName`), length(`calendarName`) == 1)
      }
      if (!is.null(`crossSeriesGroupByColumns`)) {
        stopifnot(is.vector(`crossSeriesGroupByColumns`))
      }
      if (!is.null(`isHoldoutModified`)) {
        stopifnot(is.logical(`isHoldoutModified`), length(`isHoldoutModified`) == 1)
      }
      if (!is.null(`modelSplits`)) {
        stopifnot(is.numeric(`modelSplits`), length(`modelSplits`) == 1)
      }
      if (!is.null(`useCrossSeriesFeatures`)) {
        stopifnot(is.logical(`useCrossSeriesFeatures`), length(`useCrossSeriesFeatures`) == 1)
      }
    }
  ),
  public = list(
    `aggregationType` = NULL,
    `autopilotDataSelectionMethod` = NULL,
    `availableTrainingDuration` = NULL,
    `availableTrainingEndDate` = NULL,
    `availableTrainingStartDate` = NULL,
    `backtests` = NULL,
    `calendarId` = NULL,
    `calendarName` = NULL,
    `crossSeriesGroupByColumns` = NULL,
    `dateFormat` = NULL,
    `datetimePartitionColumn` = NULL,
    `defaultToAPriori` = NULL,
    `defaultToDoNotDerive` = NULL,
    `defaultToKnownInAdvance` = NULL,
    `differencingMethod` = NULL,
    `disableHoldout` = NULL,
    `featureDerivationWindowEnd` = NULL,
    `featureDerivationWindowStart` = NULL,
    `featureSettings` = NULL,
    `forecastWindowEnd` = NULL,
    `forecastWindowStart` = NULL,
    `gapDuration` = NULL,
    `gapEndDate` = NULL,
    `gapStartDate` = NULL,
    `holdoutDuration` = NULL,
    `holdoutEndDate` = NULL,
    `holdoutStartDate` = NULL,
    `isHoldoutModified` = NULL,
    `modelSplits` = NULL,
    `multiseriesIdColumns` = NULL,
    `numberOfBacktests` = NULL,
    `numberOfDoNotDeriveFeatures` = NULL,
    `numberOfKnownInAdvanceFeatures` = NULL,
    `partitioningWarnings` = NULL,
    `periodicities` = NULL,
    `primaryTrainingDuration` = NULL,
    `primaryTrainingEndDate` = NULL,
    `primaryTrainingStartDate` = NULL,
    `projectId` = NULL,
    `treatAsExponential` = NULL,
    `useCrossSeriesFeatures` = NULL,
    `useTimeSeries` = NULL,
    `validationDuration` = NULL,
    `windowsBasisUnit` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param aggregationType For multiseries projects only. The aggregation type to apply when creating cross-series features.
    #' @param autopilotDataSelectionMethod The Data Selection method to be used by autopilot when creating models for datetime-partitioned datasets.
    #' @param availableTrainingDuration The duration of available training duration for scoring the holdout.
    #' @param availableTrainingEndDate The end date of available training data for scoring the holdout.
    #' @param availableTrainingStartDate The start date of available training data for scoring the holdout.
    #' @param backtests An array of the configured backtests.
    #' @param calendarId The ID of the calendar to be used in this project.
    #' @param calendarName The name of the calendar used in this project.
    #' @param crossSeriesGroupByColumns For multiseries projects with cross-series features enabled only. List of columns (currently of length 1). Setting that indicates how to further split series into related groups. For example, if every series is sales of an individual product, the series group-by could be the product category with values like \&quot;men&#39;s clothing\&quot;, \&quot;sports equipment\&quot;, etc.
    #' @param dateFormat The date format of the partition column.
    #' @param datetimePartitionColumn The date column that will be used as a datetime partition column.
    #' @param defaultToAPriori Renamed to &#x60;defaultToKnownInAdvance&#x60;.
    #' @param defaultToDoNotDerive For time series projects only. Sets whether all features default to being treated as do-not-derive features, excluding them from feature derivation. Individual features can be set to a value different than the default by using the &#x60;featureSettings&#x60; parameter.
    #' @param defaultToKnownInAdvance For time series projects only. Sets whether all features default to being treated as known in advance features, which are features that are known into the future. Features marked as known in advance must be specified into the future when making predictions. The default is false, all features are not known in advance. Individual features can be set to a value different than the default using the &#x60;featureSettings&#x60; parameter. See the :ref:&#x60;Time Series Overview &lt;time_series_overview&gt;&#x60; for more context.
    #' @param differencingMethod For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems &#x60;simple&#x60; and &#x60;seasonal&#x60; are not allowed. Parameter &#x60;periodicities&#x60; must be specified if &#x60;seasonal&#x60; is chosen. Defaults to &#x60;auto&#x60;.
    #' @param disableHoldout A boolean value indicating whether date partitioning skipped allocating a holdout fold.
    #' @param featureDerivationWindowEnd For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should end.
    #' @param featureDerivationWindowStart For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should begin.
    #' @param featureSettings An array specifying per feature settings. Features can be left unspecified.
    #' @param forecastWindowEnd For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should end.
    #' @param forecastWindowStart For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should start.
    #' @param gapDuration The duration of the gap between the training and holdout scoring data.
    #' @param gapEndDate The end date of the gap between the training and holdout scoring data.
    #' @param gapStartDate The start date of the gap between the training and holdout scoring data.
    #' @param holdoutDuration The duration of the holdout scoring data.
    #' @param holdoutEndDate The end date of holdout scoring data.
    #' @param holdoutStartDate The start date of holdout scoring data.
    #' @param isHoldoutModified A boolean value indicating whether holdout settings (start/end dates) have been modified by user.
    #' @param modelSplits Sets the cap on the number of jobs per model used when building models to control number of jobs in the queue. Higher number of modelSplits will allow for less downsampling leading to the use of more post-processed data.
    #' @param multiseriesIdColumns May be used only with time series projects. An array of the column names identifying  the series to which each row of the dataset belongs. Currently only one multiseries ID column is supported. See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; section of the time series documentation for more context.
    #' @param numberOfBacktests The number of backtests to use. If omitted, defaults to a positive value selected by the server based on the validation and gap durations.
    #' @param numberOfDoNotDeriveFeatures Number of features that are marked as \&quot;do not derive\&quot;.
    #' @param numberOfKnownInAdvanceFeatures Number of features that are marked as \&quot;known in advance\&quot;.
    #' @param partitioningWarnings An array of available warnings about potential problems with the chosen partitioning that could cause issues during modeling, although the partitioning may be successfully submitted.
    #' @param periodicities A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter &#39;differencing_method&#39; will default to &#39;seasonal&#39; if not provided or &#39;auto&#39;.
    #' @param primaryTrainingDuration The duration of primary training duration for scoring the holdout.
    #' @param primaryTrainingEndDate The end date of primary training data for scoring the holdout.
    #' @param primaryTrainingStartDate The start date of primary training data for scoring the holdout.
    #' @param projectId The ID of the project.
    #' @param treatAsExponential For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems &#x60;always&#x60; is not allowed. Defaults to &#x60;auto&#x60;.
    #' @param useCrossSeriesFeatures For multiseries projects only. Indicating whether to use cross-series features.
    #' @param useTimeSeries A boolean value indicating whether a time series project should be created instead of a regular project which uses datetime partitioning.
    #' @param validationDuration The default validation duration for all backtests. If the primary date/time feature in a time series project is irregular, you cannot set a default validation length. Instead, set each duration individually.
    #' @param windowsBasisUnit For time series projects only. Indicates which unit is basis for feature derivation window and forecast window. Valid options are detected time unit or &#x60;ROW&#x60;. If omitted, the default value is detected time unit.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`autopilotDataSelectionMethod` = NULL, `availableTrainingDuration` = NULL, `availableTrainingEndDate` = NULL, `availableTrainingStartDate` = NULL, `backtests` = NULL, `dateFormat` = NULL, `datetimePartitionColumn` = NULL, `defaultToAPriori` = NULL, `defaultToDoNotDerive` = NULL, `defaultToKnownInAdvance` = NULL, `differencingMethod` = NULL, `disableHoldout` = NULL, `featureDerivationWindowEnd` = NULL, `featureDerivationWindowStart` = NULL, `featureSettings` = NULL, `forecastWindowEnd` = NULL, `forecastWindowStart` = NULL, `gapDuration` = NULL, `gapEndDate` = NULL, `gapStartDate` = NULL, `holdoutDuration` = NULL, `holdoutEndDate` = NULL, `holdoutStartDate` = NULL, `multiseriesIdColumns` = NULL, `numberOfBacktests` = NULL, `numberOfDoNotDeriveFeatures` = NULL, `numberOfKnownInAdvanceFeatures` = NULL, `partitioningWarnings` = NULL, `periodicities` = NULL, `primaryTrainingDuration` = NULL, `primaryTrainingEndDate` = NULL, `primaryTrainingStartDate` = NULL, `projectId` = NULL, `treatAsExponential` = NULL, `useTimeSeries` = NULL, `validationDuration` = NULL, `windowsBasisUnit` = NULL, `aggregationType` = NULL, `calendarId` = NULL, `calendarName` = NULL, `crossSeriesGroupByColumns` = NULL, `isHoldoutModified` = NULL, `modelSplits` = NULL, `useCrossSeriesFeatures` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      requiredProps <- list(`autopilotDataSelectionMethod`, `availableTrainingDuration`, `availableTrainingEndDate`, `availableTrainingStartDate`, `backtests`, `dateFormat`, `datetimePartitionColumn`, `defaultToAPriori`, `defaultToDoNotDerive`, `defaultToKnownInAdvance`, `differencingMethod`, `disableHoldout`, `featureDerivationWindowEnd`, `featureDerivationWindowStart`, `featureSettings`, `forecastWindowEnd`, `forecastWindowStart`, `gapDuration`, `gapEndDate`, `gapStartDate`, `holdoutDuration`, `holdoutEndDate`, `holdoutStartDate`, `multiseriesIdColumns`, `numberOfBacktests`, `numberOfDoNotDeriveFeatures`, `numberOfKnownInAdvanceFeatures`, `partitioningWarnings`, `periodicities`, `primaryTrainingDuration`, `primaryTrainingEndDate`, `primaryTrainingStartDate`, `projectId`, `treatAsExponential`, `useTimeSeries`, `validationDuration`, `windowsBasisUnit`)
      if (validateParams) {
        lapply(requiredProps, missing)
        private$validateProps(aggregationType, autopilotDataSelectionMethod, availableTrainingDuration, availableTrainingEndDate, availableTrainingStartDate, backtests, calendarId, calendarName, crossSeriesGroupByColumns, dateFormat, datetimePartitionColumn, defaultToAPriori, defaultToDoNotDerive, defaultToKnownInAdvance, differencingMethod, disableHoldout, featureDerivationWindowEnd, featureDerivationWindowStart, featureSettings, forecastWindowEnd, forecastWindowStart, gapDuration, gapEndDate, gapStartDate, holdoutDuration, holdoutEndDate, holdoutStartDate, isHoldoutModified, modelSplits, multiseriesIdColumns, numberOfBacktests, numberOfDoNotDeriveFeatures, numberOfKnownInAdvanceFeatures, partitioningWarnings, periodicities, primaryTrainingDuration, primaryTrainingEndDate, primaryTrainingStartDate, projectId, treatAsExponential, useCrossSeriesFeatures, useTimeSeries, validationDuration, windowsBasisUnit)
      }
      self$`aggregationType` <- `aggregationType`
      self$`autopilotDataSelectionMethod` <- `autopilotDataSelectionMethod`
      self$`availableTrainingDuration` <- `availableTrainingDuration`
      self$`availableTrainingEndDate` <- `availableTrainingEndDate`
      self$`availableTrainingStartDate` <- `availableTrainingStartDate`
      sapply(`backtests`, function(x) stopifnot(R6::is.R6(x)))
      self$`calendarId` <- `calendarId`
      self$`calendarName` <- `calendarName`
      sapply(`crossSeriesGroupByColumns`, function(x) stopifnot(is.character(x)))
      self$`dateFormat` <- `dateFormat`
      self$`datetimePartitionColumn` <- `datetimePartitionColumn`
      self$`defaultToAPriori` <- `defaultToAPriori`
      self$`defaultToDoNotDerive` <- `defaultToDoNotDerive`
      self$`defaultToKnownInAdvance` <- `defaultToKnownInAdvance`
      self$`differencingMethod` <- `differencingMethod`
      self$`disableHoldout` <- `disableHoldout`
      self$`featureDerivationWindowEnd` <- `featureDerivationWindowEnd`
      self$`featureDerivationWindowStart` <- `featureDerivationWindowStart`
      sapply(`featureSettings`, function(x) stopifnot(R6::is.R6(x)))
      self$`forecastWindowEnd` <- `forecastWindowEnd`
      self$`forecastWindowStart` <- `forecastWindowStart`
      self$`gapDuration` <- `gapDuration`
      self$`gapEndDate` <- `gapEndDate`
      self$`gapStartDate` <- `gapStartDate`
      self$`holdoutDuration` <- `holdoutDuration`
      self$`holdoutEndDate` <- `holdoutEndDate`
      self$`holdoutStartDate` <- `holdoutStartDate`
      self$`isHoldoutModified` <- `isHoldoutModified`
      self$`modelSplits` <- `modelSplits`
      sapply(`multiseriesIdColumns`, function(x) stopifnot(is.character(x)))
      self$`numberOfBacktests` <- `numberOfBacktests`
      self$`numberOfDoNotDeriveFeatures` <- `numberOfDoNotDeriveFeatures`
      self$`numberOfKnownInAdvanceFeatures` <- `numberOfKnownInAdvanceFeatures`
      sapply(`partitioningWarnings`, function(x) stopifnot(R6::is.R6(x)))
      sapply(`periodicities`, function(x) stopifnot(R6::is.R6(x)))
      self$`primaryTrainingDuration` <- `primaryTrainingDuration`
      self$`primaryTrainingEndDate` <- `primaryTrainingEndDate`
      self$`primaryTrainingStartDate` <- `primaryTrainingStartDate`
      self$`projectId` <- `projectId`
      self$`treatAsExponential` <- `treatAsExponential`
      self$`useCrossSeriesFeatures` <- `useCrossSeriesFeatures`
      self$`useTimeSeries` <- `useTimeSeries`
      self$`validationDuration` <- `validationDuration`
      self$`windowsBasisUnit` <- `windowsBasisUnit`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    validate = function() {
      props <- list(aggregationType = self$`aggregationType`, autopilotDataSelectionMethod = self$`autopilotDataSelectionMethod`, availableTrainingDuration = self$`availableTrainingDuration`, availableTrainingEndDate = self$`availableTrainingEndDate`, availableTrainingStartDate = self$`availableTrainingStartDate`, backtests = self$`backtests`, calendarId = self$`calendarId`, calendarName = self$`calendarName`, crossSeriesGroupByColumns = self$`crossSeriesGroupByColumns`, dateFormat = self$`dateFormat`, datetimePartitionColumn = self$`datetimePartitionColumn`, defaultToAPriori = self$`defaultToAPriori`, defaultToDoNotDerive = self$`defaultToDoNotDerive`, defaultToKnownInAdvance = self$`defaultToKnownInAdvance`, differencingMethod = self$`differencingMethod`, disableHoldout = self$`disableHoldout`, featureDerivationWindowEnd = self$`featureDerivationWindowEnd`, featureDerivationWindowStart = self$`featureDerivationWindowStart`, featureSettings = self$`featureSettings`, forecastWindowEnd = self$`forecastWindowEnd`, forecastWindowStart = self$`forecastWindowStart`, gapDuration = self$`gapDuration`, gapEndDate = self$`gapEndDate`, gapStartDate = self$`gapStartDate`, holdoutDuration = self$`holdoutDuration`, holdoutEndDate = self$`holdoutEndDate`, holdoutStartDate = self$`holdoutStartDate`, isHoldoutModified = self$`isHoldoutModified`, modelSplits = self$`modelSplits`, multiseriesIdColumns = self$`multiseriesIdColumns`, numberOfBacktests = self$`numberOfBacktests`, numberOfDoNotDeriveFeatures = self$`numberOfDoNotDeriveFeatures`, numberOfKnownInAdvanceFeatures = self$`numberOfKnownInAdvanceFeatures`, partitioningWarnings = self$`partitioningWarnings`, periodicities = self$`periodicities`, primaryTrainingDuration = self$`primaryTrainingDuration`, primaryTrainingEndDate = self$`primaryTrainingEndDate`, primaryTrainingStartDate = self$`primaryTrainingStartDate`, projectId = self$`projectId`, treatAsExponential = self$`treatAsExponential`, useCrossSeriesFeatures = self$`useCrossSeriesFeatures`, useTimeSeries = self$`useTimeSeries`, validationDuration = self$`validationDuration`, windowsBasisUnit = self$`windowsBasisUnit`)
      do.call(private$validateProps, props)
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`aggregationType`)) {
          sprintf(
            '"aggregationType":
            "%s"
                  ',
            self$`aggregationType`
          )
        },
        if (!is.null(self$`autopilotDataSelectionMethod`)) {
          sprintf(
            '"autopilotDataSelectionMethod":
            "%s"
                  ',
            self$`autopilotDataSelectionMethod`
          )
        },
        if (!is.null(self$`availableTrainingDuration`)) {
          sprintf(
            '"availableTrainingDuration":
            "%s"
                  ',
            self$`availableTrainingDuration`
          )
        },
        if (!is.null(self$`availableTrainingEndDate`)) {
          sprintf(
            '"availableTrainingEndDate":
            "%s"
                  ',
            format(self$`availableTrainingEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`availableTrainingStartDate`)) {
          sprintf(
            '"availableTrainingStartDate":
            "%s"
                  ',
            format(self$`availableTrainingStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`backtests`)) {
          sprintf(
            '"backtests":
            [%s]
',
            paste(sapply(self$`backtests`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`calendarId`)) {
          sprintf(
            '"calendarId":
            "%s"
                  ',
            self$`calendarId`
          )
        },
        if (!is.null(self$`calendarName`)) {
          sprintf(
            '"calendarName":
            "%s"
                  ',
            self$`calendarName`
          )
        },
        if (!is.null(self$`crossSeriesGroupByColumns`)) {
          sprintf(
            '"crossSeriesGroupByColumns":
              [%s]
            ',
            paste(unlist(lapply(self$`crossSeriesGroupByColumns`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`dateFormat`)) {
          sprintf(
            '"dateFormat":
            "%s"
                  ',
            self$`dateFormat`
          )
        },
        if (!is.null(self$`datetimePartitionColumn`)) {
          sprintf(
            '"datetimePartitionColumn":
            "%s"
                  ',
            self$`datetimePartitionColumn`
          )
        },
        if (!is.null(self$`defaultToAPriori`)) {
          sprintf(
            '"defaultToAPriori":
            %s
                  ',
            tolower(self$`defaultToAPriori`)
          )
        },
        if (!is.null(self$`defaultToDoNotDerive`)) {
          sprintf(
            '"defaultToDoNotDerive":
            %s
                  ',
            tolower(self$`defaultToDoNotDerive`)
          )
        },
        if (!is.null(self$`defaultToKnownInAdvance`)) {
          sprintf(
            '"defaultToKnownInAdvance":
            %s
                  ',
            tolower(self$`defaultToKnownInAdvance`)
          )
        },
        if (!is.null(self$`differencingMethod`)) {
          sprintf(
            '"differencingMethod":
            "%s"
                  ',
            self$`differencingMethod`
          )
        },
        if (!is.null(self$`disableHoldout`)) {
          sprintf(
            '"disableHoldout":
            %s
                  ',
            tolower(self$`disableHoldout`)
          )
        },
        if (!is.null(self$`featureDerivationWindowEnd`)) {
          sprintf(
            '"featureDerivationWindowEnd":
            %d
                  ',
            self$`featureDerivationWindowEnd`
          )
        },
        if (!is.null(self$`featureDerivationWindowStart`)) {
          sprintf(
            '"featureDerivationWindowStart":
            %d
                  ',
            self$`featureDerivationWindowStart`
          )
        },
        if (!is.null(self$`featureSettings`)) {
          sprintf(
            '"featureSettings":
            [%s]
',
            paste(sapply(self$`featureSettings`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`forecastWindowEnd`)) {
          sprintf(
            '"forecastWindowEnd":
            %d
                  ',
            self$`forecastWindowEnd`
          )
        },
        if (!is.null(self$`forecastWindowStart`)) {
          sprintf(
            '"forecastWindowStart":
            %d
                  ',
            self$`forecastWindowStart`
          )
        },
        if (!is.null(self$`gapDuration`)) {
          sprintf(
            '"gapDuration":
            "%s"
                  ',
            self$`gapDuration`
          )
        },
        if (!is.null(self$`gapEndDate`)) {
          sprintf(
            '"gapEndDate":
            "%s"
                  ',
            format(self$`gapEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`gapStartDate`)) {
          sprintf(
            '"gapStartDate":
            "%s"
                  ',
            format(self$`gapStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`holdoutDuration`)) {
          sprintf(
            '"holdoutDuration":
            "%s"
                  ',
            self$`holdoutDuration`
          )
        },
        if (!is.null(self$`holdoutEndDate`)) {
          sprintf(
            '"holdoutEndDate":
            "%s"
                  ',
            format(self$`holdoutEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`holdoutStartDate`)) {
          sprintf(
            '"holdoutStartDate":
            "%s"
                  ',
            format(self$`holdoutStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`isHoldoutModified`)) {
          sprintf(
            '"isHoldoutModified":
            %s
                  ',
            tolower(self$`isHoldoutModified`)
          )
        },
        if (!is.null(self$`modelSplits`)) {
          sprintf(
            '"modelSplits":
            %d
                  ',
            self$`modelSplits`
          )
        },
        if (!is.null(self$`multiseriesIdColumns`)) {
          sprintf(
            '"multiseriesIdColumns":
              [%s]
            ',
            paste(unlist(lapply(self$`multiseriesIdColumns`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`numberOfBacktests`)) {
          sprintf(
            '"numberOfBacktests":
            %d
                  ',
            self$`numberOfBacktests`
          )
        },
        if (!is.null(self$`numberOfDoNotDeriveFeatures`)) {
          sprintf(
            '"numberOfDoNotDeriveFeatures":
            %d
                  ',
            self$`numberOfDoNotDeriveFeatures`
          )
        },
        if (!is.null(self$`numberOfKnownInAdvanceFeatures`)) {
          sprintf(
            '"numberOfKnownInAdvanceFeatures":
            %d
                  ',
            self$`numberOfKnownInAdvanceFeatures`
          )
        },
        if (!is.null(self$`partitioningWarnings`)) {
          sprintf(
            '"partitioningWarnings":
            [%s]
',
            paste(sapply(self$`partitioningWarnings`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`periodicities`)) {
          sprintf(
            '"periodicities":
            [%s]
',
            paste(sapply(self$`periodicities`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`primaryTrainingDuration`)) {
          sprintf(
            '"primaryTrainingDuration":
            "%s"
                  ',
            self$`primaryTrainingDuration`
          )
        },
        if (!is.null(self$`primaryTrainingEndDate`)) {
          sprintf(
            '"primaryTrainingEndDate":
            "%s"
                  ',
            format(self$`primaryTrainingEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`primaryTrainingStartDate`)) {
          sprintf(
            '"primaryTrainingStartDate":
            "%s"
                  ',
            format(self$`primaryTrainingStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`projectId`)) {
          sprintf(
            '"projectId":
            "%s"
                  ',
            self$`projectId`
          )
        },
        if (!is.null(self$`treatAsExponential`)) {
          sprintf(
            '"treatAsExponential":
            "%s"
                  ',
            self$`treatAsExponential`
          )
        },
        if (!is.null(self$`useCrossSeriesFeatures`)) {
          sprintf(
            '"useCrossSeriesFeatures":
            %s
                  ',
            tolower(self$`useCrossSeriesFeatures`)
          )
        },
        if (!is.null(self$`useTimeSeries`)) {
          sprintf(
            '"useTimeSeries":
            %s
                  ',
            tolower(self$`useTimeSeries`)
          )
        },
        if (!is.null(self$`validationDuration`)) {
          sprintf(
            '"validationDuration":
            "%s"
                  ',
            self$`validationDuration`
          )
        },
        if (!is.null(self$`windowsBasisUnit`)) {
          sprintf(
            '"windowsBasisUnit":
            "%s"
                  ',
            self$`windowsBasisUnit`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param DatetimePartitioningResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(DatetimePartitioningResponseJson, validateParams = FALSE) {
      DatetimePartitioningResponseObject <- jsonlite::fromJSON(DatetimePartitioningResponseJson)
      self$`aggregationType` <- DatetimePartitioningResponseObject$`aggregationType`
      self$`autopilotDataSelectionMethod` <- DatetimePartitioningResponseObject$`autopilotDataSelectionMethod`
      self$`availableTrainingDuration` <- DatetimePartitioningResponseObject$`availableTrainingDuration`
      self$`availableTrainingEndDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`availableTrainingEndDate`)
      self$`availableTrainingStartDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`availableTrainingStartDate`)
      self$`backtests` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`backtests`, "array[BacktestResponse]", loadNamespace("datarobot.apicore"))
      self$`calendarId` <- DatetimePartitioningResponseObject$`calendarId`
      self$`calendarName` <- DatetimePartitioningResponseObject$`calendarName`
      self$`crossSeriesGroupByColumns` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`crossSeriesGroupByColumns`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`dateFormat` <- DatetimePartitioningResponseObject$`dateFormat`
      self$`datetimePartitionColumn` <- DatetimePartitioningResponseObject$`datetimePartitionColumn`
      self$`defaultToAPriori` <- DatetimePartitioningResponseObject$`defaultToAPriori`
      self$`defaultToDoNotDerive` <- DatetimePartitioningResponseObject$`defaultToDoNotDerive`
      self$`defaultToKnownInAdvance` <- DatetimePartitioningResponseObject$`defaultToKnownInAdvance`
      self$`differencingMethod` <- DatetimePartitioningResponseObject$`differencingMethod`
      self$`disableHoldout` <- DatetimePartitioningResponseObject$`disableHoldout`
      self$`featureDerivationWindowEnd` <- DatetimePartitioningResponseObject$`featureDerivationWindowEnd`
      self$`featureDerivationWindowStart` <- DatetimePartitioningResponseObject$`featureDerivationWindowStart`
      self$`featureSettings` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`featureSettings`, "array[FeatureSetting]", loadNamespace("datarobot.apicore"))
      self$`forecastWindowEnd` <- DatetimePartitioningResponseObject$`forecastWindowEnd`
      self$`forecastWindowStart` <- DatetimePartitioningResponseObject$`forecastWindowStart`
      self$`gapDuration` <- DatetimePartitioningResponseObject$`gapDuration`
      self$`gapEndDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`gapEndDate`)
      self$`gapStartDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`gapStartDate`)
      self$`holdoutDuration` <- DatetimePartitioningResponseObject$`holdoutDuration`
      self$`holdoutEndDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`holdoutEndDate`)
      self$`holdoutStartDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`holdoutStartDate`)
      self$`isHoldoutModified` <- DatetimePartitioningResponseObject$`isHoldoutModified`
      self$`modelSplits` <- DatetimePartitioningResponseObject$`modelSplits`
      self$`multiseriesIdColumns` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`multiseriesIdColumns`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`numberOfBacktests` <- DatetimePartitioningResponseObject$`numberOfBacktests`
      self$`numberOfDoNotDeriveFeatures` <- DatetimePartitioningResponseObject$`numberOfDoNotDeriveFeatures`
      self$`numberOfKnownInAdvanceFeatures` <- DatetimePartitioningResponseObject$`numberOfKnownInAdvanceFeatures`
      self$`partitioningWarnings` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`partitioningWarnings`, "array[PartitioningWarning]", loadNamespace("datarobot.apicore"))
      self$`periodicities` <- ApiClient$new()$deserializeObj(DatetimePartitioningResponseObject$`periodicities`, "array[Periodicity]", loadNamespace("datarobot.apicore"))
      self$`primaryTrainingDuration` <- DatetimePartitioningResponseObject$`primaryTrainingDuration`
      self$`primaryTrainingEndDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`primaryTrainingEndDate`)
      self$`primaryTrainingStartDate` <- ParseRFC3339Timestamp(DatetimePartitioningResponseObject$`primaryTrainingStartDate`)
      self$`projectId` <- DatetimePartitioningResponseObject$`projectId`
      self$`treatAsExponential` <- DatetimePartitioningResponseObject$`treatAsExponential`
      self$`useCrossSeriesFeatures` <- DatetimePartitioningResponseObject$`useCrossSeriesFeatures`
      self$`useTimeSeries` <- DatetimePartitioningResponseObject$`useTimeSeries`
      self$`validationDuration` <- DatetimePartitioningResponseObject$`validationDuration`
      self$`windowsBasisUnit` <- DatetimePartitioningResponseObject$`windowsBasisUnit`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
