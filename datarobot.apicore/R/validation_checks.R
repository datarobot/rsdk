# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title ValidationChecks
#'
#' @description ValidationChecks Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field combinedModelSegments  \link{ValidationCheck} [optional]
#'
#' @field containsTrackedSegmentAttributes  \link{ValidationCheck} [optional]
#'
#' @field driftTracking  \link{ValidationCheck} [optional]
#'
#' @field featureDataTypes  \link{ValidationCheck} [optional]
#'
#' @field features  \link{ValidationCheck} [optional]
#'
#' @field humilityRules  \link{ValidationCheck} [optional]
#'
#' @field modelCanBeDeployed  \link{ValidationCheck} [optional]
#'
#' @field modelStatus  \link{ValidationCheck} [optional]
#'
#' @field notCurrentModel  \link{ValidationCheck} [optional]
#'
#' @field permission  \link{ValidationCheck} [optional]
#'
#' @field predictionIntervals  \link{ValidationCheck} [optional]
#'
#' @field predictionReady  \link{ValidationCheck} [optional]
#'
#' @field seriesType  \link{ValidationCheck} [optional]
#'
#' @field supported  \link{ValidationCheck} [optional]
#'
#' @field target  \link{ValidationCheck} [optional]
#'
#' @field targetClasses  \link{ValidationCheck} [optional]
#'
#' @field targetType  \link{ValidationCheck} [optional]
#'
#' @field timeSeriesCompatibility  \link{ValidationCheck} [optional]
#'
#' @field validChallenger  \link{ValidationCheck} [optional]
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
ValidationChecks <- R6::R6Class(
  "ValidationChecks",
  lock_objects = FALSE,
  private = list(
    # @description The properties of this object that are required to be set.
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(`combinedModelSegments` = NULL, `containsTrackedSegmentAttributes` = NULL, `driftTracking` = NULL, `featureDataTypes` = NULL, `features` = NULL, `humilityRules` = NULL, `modelCanBeDeployed` = NULL, `modelStatus` = NULL, `notCurrentModel` = NULL, `permission` = NULL, `predictionIntervals` = NULL, `predictionReady` = NULL, `seriesType` = NULL, `supported` = NULL, `target` = NULL, `targetClasses` = NULL, `targetType` = NULL, `timeSeriesCompatibility` = NULL, `validChallenger` = NULL) {
      if (!is.null(`combinedModelSegments`)) {
        stopifnot(R6::is.R6(`combinedModelSegments`))
      }
      if (!is.null(`containsTrackedSegmentAttributes`)) {
        stopifnot(R6::is.R6(`containsTrackedSegmentAttributes`))
      }
      if (!is.null(`driftTracking`)) {
        stopifnot(R6::is.R6(`driftTracking`))
      }
      if (!is.null(`featureDataTypes`)) {
        stopifnot(R6::is.R6(`featureDataTypes`))
      }
      if (!is.null(`features`)) {
        stopifnot(R6::is.R6(`features`))
      }
      if (!is.null(`humilityRules`)) {
        stopifnot(R6::is.R6(`humilityRules`))
      }
      if (!is.null(`modelCanBeDeployed`)) {
        stopifnot(R6::is.R6(`modelCanBeDeployed`))
      }
      if (!is.null(`modelStatus`)) {
        stopifnot(R6::is.R6(`modelStatus`))
      }
      if (!is.null(`notCurrentModel`)) {
        stopifnot(R6::is.R6(`notCurrentModel`))
      }
      if (!is.null(`permission`)) {
        stopifnot(R6::is.R6(`permission`))
      }
      if (!is.null(`predictionIntervals`)) {
        stopifnot(R6::is.R6(`predictionIntervals`))
      }
      if (!is.null(`predictionReady`)) {
        stopifnot(R6::is.R6(`predictionReady`))
      }
      if (!is.null(`seriesType`)) {
        stopifnot(R6::is.R6(`seriesType`))
      }
      if (!is.null(`supported`)) {
        stopifnot(R6::is.R6(`supported`))
      }
      if (!is.null(`target`)) {
        stopifnot(R6::is.R6(`target`))
      }
      if (!is.null(`targetClasses`)) {
        stopifnot(R6::is.R6(`targetClasses`))
      }
      if (!is.null(`targetType`)) {
        stopifnot(R6::is.R6(`targetType`))
      }
      if (!is.null(`timeSeriesCompatibility`)) {
        stopifnot(R6::is.R6(`timeSeriesCompatibility`))
      }
      if (!is.null(`validChallenger`)) {
        stopifnot(R6::is.R6(`validChallenger`))
      }
    }
  ),
  public = list(
    `combinedModelSegments` = NULL,
    `containsTrackedSegmentAttributes` = NULL,
    `driftTracking` = NULL,
    `featureDataTypes` = NULL,
    `features` = NULL,
    `humilityRules` = NULL,
    `modelCanBeDeployed` = NULL,
    `modelStatus` = NULL,
    `notCurrentModel` = NULL,
    `permission` = NULL,
    `predictionIntervals` = NULL,
    `predictionReady` = NULL,
    `seriesType` = NULL,
    `supported` = NULL,
    `target` = NULL,
    `targetClasses` = NULL,
    `targetType` = NULL,
    `timeSeriesCompatibility` = NULL,
    `validChallenger` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param combinedModelSegments
    #' @param containsTrackedSegmentAttributes
    #' @param driftTracking
    #' @param featureDataTypes
    #' @param features
    #' @param humilityRules
    #' @param modelCanBeDeployed
    #' @param modelStatus
    #' @param notCurrentModel
    #' @param permission
    #' @param predictionIntervals
    #' @param predictionReady
    #' @param seriesType
    #' @param supported
    #' @param target
    #' @param targetClasses
    #' @param targetType
    #' @param timeSeriesCompatibility
    #' @param validChallenger
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`combinedModelSegments` = NULL, `containsTrackedSegmentAttributes` = NULL, `driftTracking` = NULL, `featureDataTypes` = NULL, `features` = NULL, `humilityRules` = NULL, `modelCanBeDeployed` = NULL, `modelStatus` = NULL, `notCurrentModel` = NULL, `permission` = NULL, `predictionIntervals` = NULL, `predictionReady` = NULL, `seriesType` = NULL, `supported` = NULL, `target` = NULL, `targetClasses` = NULL, `targetType` = NULL, `timeSeriesCompatibility` = NULL, `validChallenger` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      if (validateParams) {
        lapply(list(), function(param) {
          stopifnot("Required param not set." = !is.null(param))
        })
        private$validateProps(combinedModelSegments, containsTrackedSegmentAttributes, driftTracking, featureDataTypes, features, humilityRules, modelCanBeDeployed, modelStatus, notCurrentModel, permission, predictionIntervals, predictionReady, seriesType, supported, target, targetClasses, targetType, timeSeriesCompatibility, validChallenger)
      }
      self$`combinedModelSegments` <- `combinedModelSegments`
      self$`containsTrackedSegmentAttributes` <- `containsTrackedSegmentAttributes`
      self$`driftTracking` <- `driftTracking`
      self$`featureDataTypes` <- `featureDataTypes`
      self$`features` <- `features`
      self$`humilityRules` <- `humilityRules`
      self$`modelCanBeDeployed` <- `modelCanBeDeployed`
      self$`modelStatus` <- `modelStatus`
      self$`notCurrentModel` <- `notCurrentModel`
      self$`permission` <- `permission`
      self$`predictionIntervals` <- `predictionIntervals`
      self$`predictionReady` <- `predictionReady`
      self$`seriesType` <- `seriesType`
      self$`supported` <- `supported`
      self$`target` <- `target`
      self$`targetClasses` <- `targetClasses`
      self$`targetType` <- `targetType`
      self$`timeSeriesCompatibility` <- `timeSeriesCompatibility`
      self$`validChallenger` <- `validChallenger`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    #' checking this objects set properties.
    validate = function() {
      do.call(private$validateProps, list(combinedModelSegments = self$`combinedModelSegments`, containsTrackedSegmentAttributes = self$`containsTrackedSegmentAttributes`, driftTracking = self$`driftTracking`, featureDataTypes = self$`featureDataTypes`, features = self$`features`, humilityRules = self$`humilityRules`, modelCanBeDeployed = self$`modelCanBeDeployed`, modelStatus = self$`modelStatus`, notCurrentModel = self$`notCurrentModel`, permission = self$`permission`, predictionIntervals = self$`predictionIntervals`, predictionReady = self$`predictionReady`, seriesType = self$`seriesType`, supported = self$`supported`, target = self$`target`, targetClasses = self$`targetClasses`, targetType = self$`targetType`, timeSeriesCompatibility = self$`timeSeriesCompatibility`, validChallenger = self$`validChallenger`))
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`combinedModelSegments`)) {
          sprintf(
            '"combinedModelSegments":
            %s
      ',
            jsonlite::toJSON(self$`combinedModelSegments`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`containsTrackedSegmentAttributes`)) {
          sprintf(
            '"containsTrackedSegmentAttributes":
            %s
      ',
            jsonlite::toJSON(self$`containsTrackedSegmentAttributes`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`driftTracking`)) {
          sprintf(
            '"driftTracking":
            %s
      ',
            jsonlite::toJSON(self$`driftTracking`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`featureDataTypes`)) {
          sprintf(
            '"featureDataTypes":
            %s
      ',
            jsonlite::toJSON(self$`featureDataTypes`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`features`)) {
          sprintf(
            '"features":
            %s
      ',
            jsonlite::toJSON(self$`features`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`humilityRules`)) {
          sprintf(
            '"humilityRules":
            %s
      ',
            jsonlite::toJSON(self$`humilityRules`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`modelCanBeDeployed`)) {
          sprintf(
            '"modelCanBeDeployed":
            %s
      ',
            jsonlite::toJSON(self$`modelCanBeDeployed`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`modelStatus`)) {
          sprintf(
            '"modelStatus":
            %s
      ',
            jsonlite::toJSON(self$`modelStatus`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`notCurrentModel`)) {
          sprintf(
            '"notCurrentModel":
            %s
      ',
            jsonlite::toJSON(self$`notCurrentModel`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`permission`)) {
          sprintf(
            '"permission":
            %s
      ',
            jsonlite::toJSON(self$`permission`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`predictionIntervals`)) {
          sprintf(
            '"predictionIntervals":
            %s
      ',
            jsonlite::toJSON(self$`predictionIntervals`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`predictionReady`)) {
          sprintf(
            '"predictionReady":
            %s
      ',
            jsonlite::toJSON(self$`predictionReady`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`seriesType`)) {
          sprintf(
            '"seriesType":
            %s
      ',
            jsonlite::toJSON(self$`seriesType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`supported`)) {
          sprintf(
            '"supported":
            %s
      ',
            jsonlite::toJSON(self$`supported`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`target`)) {
          sprintf(
            '"target":
            %s
      ',
            jsonlite::toJSON(self$`target`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`targetClasses`)) {
          sprintf(
            '"targetClasses":
            %s
      ',
            jsonlite::toJSON(self$`targetClasses`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`targetType`)) {
          sprintf(
            '"targetType":
            %s
      ',
            jsonlite::toJSON(self$`targetType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`timeSeriesCompatibility`)) {
          sprintf(
            '"timeSeriesCompatibility":
            %s
      ',
            jsonlite::toJSON(self$`timeSeriesCompatibility`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`validChallenger`)) {
          sprintf(
            '"validChallenger":
            %s
      ',
            jsonlite::toJSON(self$`validChallenger`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param ValidationChecksJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(ValidationChecksJson, validateParams = FALSE) {
      ValidationChecksObject <- jsonlite::fromJSON(ValidationChecksJson)
      self$`combinedModelSegments` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$combinedModelSegments, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`containsTrackedSegmentAttributes` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$containsTrackedSegmentAttributes, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`driftTracking` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$driftTracking, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`featureDataTypes` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$featureDataTypes, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`features` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$features, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`humilityRules` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$humilityRules, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`modelCanBeDeployed` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$modelCanBeDeployed, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`modelStatus` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$modelStatus, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`notCurrentModel` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$notCurrentModel, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`permission` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$permission, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`predictionIntervals` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$predictionIntervals, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`predictionReady` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$predictionReady, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`seriesType` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$seriesType, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`supported` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$supported, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`target` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$target, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`targetClasses` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$targetClasses, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`targetType` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$targetType, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`timeSeriesCompatibility` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$timeSeriesCompatibility, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`validChallenger` <- ValidationCheck$new()$fromJSON(jsonlite::toJSON(ValidationChecksObject$validChallenger, auto_unbox = TRUE, digits = NA, null = "null"))

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
