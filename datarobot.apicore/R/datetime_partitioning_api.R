# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title DatetimePartitioning operations
#' @description datarobot.apicore.DatetimePartitioning
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
DatetimePartitioningApi <- R6::R6Class(
  "DatetimePartitioningApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Preview the fully specified datetime partitioning generated by the requested configuration.
    #' Produces: "application/json"
    #'
    #' @details Preview the fully specified datetime partitioning generated by the requested configuration.  Populates the full datetime partitioning that would be used if the same arguments were passed to :&lt;http:patch&gt;:/api/v2/projects/(projectId)/aim/ based on the requested configuration, generating defaults for all non-specified values, so that potential configurations can be tested prior to setting the target and applying a configuration.  useTimeSeries controls whether a time series project should be created or a normal project that uses datetime partitioning. See &#x60;Time-Series Projects&lt;time_series_overview&gt;&#x60; for more detail on the differences between time series projects and datetime partitioned projects. Time-series projects are only available to some users and use the additional settings of featureDerivationWindowStart and featureDerivationWindowEnd to establish feature derivation window and forecastWindowStart and forecastWindowEnd to establish a forecast window. The overview referenced above provides more information about using feature derivation and forecast windows.  When specifying a feature derivation window of a forecast window, the number of units it spans (end - start) must be an integer multiple of the timeStep of the datetimePartitionColumn.  All durations and datetimes should be specified in accordance with the &#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.
    #' @details This method invokes `POST /projects/{projectId}/datetimePartitioning/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param datetimePartitioningDataForOpenApi \link{DatetimePartitioningDataForOpenApi}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimePartitioningResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Generated datetime partitioning.
    #' \itemize{
    #' }
    #' \item **`404`** Requested feature was not found.
    #' \itemize{
    #' }
    #' \item **`422`** Partitioning generation failed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' datetimePartitioningDataForOpenApi <- DatetimePartitioningDataForOpenApi$new() # DatetimePartitioningDataForOpenApi |
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsDatetimePartitioningCreate(projectId, datetimePartitioningDataForOpenApi=datetimePartitioningDataForOpenApi)
    #' }
    ProjectsDatetimePartitioningCreate = function(projectId, datetimePartitioningDataForOpenApi = NULL, ...) {
      apiResponse <- private$ProjectsDatetimePartitioningCreateWithHttpInfo(projectId, datetimePartitioningDataForOpenApi, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve datetime partitioning configuration.
    #' Produces: "application/json"
    #'
    #' @details Retrieve datetime partitioning configuration  The datetime partition object in the response describes the full partitioning parameters. Since it becomes available after the target has been fully specified and the project is ready for modeling, there are some additional fields available compared to the response from :&lt;http:post&gt;:/api/v2/projects/(projectId)/datetimePartitioning/.  The available training data corresponds to all the data available for training, while the primary training data corresponds to the data that can be used to train while ensuring that all backtests are available. If a model is trained with more data than is available in the primary training data, then all backtests may not have scores available.  All durations and datetimes will be specified in accordance with the &#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimePartitioning/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FinalDatetimePartitioningResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Generated datetime partitioning.
    #' \itemize{
    #' }
    #' \item **`422`** Partitioning has not been set.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsDatetimePartitioningList(projectId)
    #' }
    ProjectsDatetimePartitioningList = function(projectId, ...) {
      apiResponse <- private$ProjectsDatetimePartitioningListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create an optimized datetime partitioning configuration using the target.
    #' Produces: "application/json"
    #'
    #' @details Create an optimized datetime partitioning configuration using the target.  Initializes a job to construct an optimized datetime partitioning using the date and target information to ensure that backtests sufficiently cover regions of interest in the target. This is an asynchronous job. The results of the asynchronous job (backtests and other parameters can be used in the synchronous version.  useTimeSeries controls whether a time series project should be created or a normal project that uses datetime partitioning. See &#x60;Time-Series Projects&lt;time_series_overview&gt;&#x60; for more detail on the differences between time series projects and datetime partitioned projects. Time-series projects are only available to some users and use the additional settings of featureDerivationWindowStart and featureDerivationWindowEnd to establish feature derivation window and forecastWindowStart and forecastWindowEnd to establish a forecast window. The overview referenced above provides more information about using feature derivation and forecast windows.  When specifying a feature derivation window of a forecast window, the number of units it spans (end - start) must be an integer multiple of the timeStep of the datetimePartitionColumn.  All durations and datetimes should be specified in accordance with the &#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.
    #' @details This method invokes `POST /projects/{projectId}/optimizedDatetimePartitionings/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param optimizedDatetimePartitioningData \link{OptimizedDatetimePartitioningData}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimePartitioningResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Generated datetime partitioning.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' optimizedDatetimePartitioningData <- OptimizedDatetimePartitioningData$new() # OptimizedDatetimePartitioningData |
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsOptimizedDatetimePartitioningsCreate(projectId, optimizedDatetimePartitioningData=optimizedDatetimePartitioningData)
    #' }
    ProjectsOptimizedDatetimePartitioningsCreate = function(projectId, optimizedDatetimePartitioningData = NULL, ...) {
      apiResponse <- private$ProjectsOptimizedDatetimePartitioningsCreateWithHttpInfo(projectId, optimizedDatetimePartitioningData, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all created optimized datetime partitioning configurations
    #' Produces: "application/json"
    #'
    #' @details List all created optimized datetime partitioning configurations
    #' @details This method invokes `GET /projects/{projectId}/optimizedDatetimePartitionings/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned.
    #' @param projectId character. The project ID
    #' @param offset integer. This many results will be skipped.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OptimizedDatetimePartitioningListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of optimized datetime partitionings for projectId
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 10 # integer | At most this many results are returned.
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | This many results will be skipped.
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsOptimizedDatetimePartitioningsList(limit, projectId, offset=offset)
    #' }
    ProjectsOptimizedDatetimePartitioningsList = function(limit, projectId, offset = 0, ...) {
      apiResponse <- private$ProjectsOptimizedDatetimePartitioningsListWithHttpInfo(limit, projectId, offset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve optimized datetime partitioning configuration
    #' Produces: "application/json"
    #'
    #' @details Retrieve optimized datetime partitioning configuration  The optimized datetime partition objects are structurally identical to the original datetime partition objects, however they are retrieved from a mongo database after creation as opposed to being calculated synchronously. The datetime partition object in the response describes the full partitioning parameters.  The available training data corresponds to all the data available for training, while the primary training data corresponds to the data that can be used to train while ensuring that all backtests are available. If a model is trained with more data than is available in the primary training data, then all backtests may not have scores available.  Note  All durations and datetimes should be specified in accordance with the &#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/optimizedDatetimePartitionings/{datetimePartitioningId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param datetimePartitioningId character. The ID of the datetime partitioning to retrieve.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimePartitioningResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Optimized datetime partitioning configuration
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' datetimePartitioningId <- 'datetimePartitioningId_example' # character | The ID of the datetime partitioning to retrieve.
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsOptimizedDatetimePartitioningsRetrieve(projectId, datetimePartitioningId)
    #' }
    ProjectsOptimizedDatetimePartitioningsRetrieve = function(projectId, datetimePartitioningId, ...) {
      apiResponse <- private$ProjectsOptimizedDatetimePartitioningsRetrieveWithHttpInfo(projectId, datetimePartitioningId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a text file containing the time series project feature log
    #' Produces: NA
    #'
    #' @details Retrieve a text file containing the time series project feature log.  The Time Series Feature Log provides details about the feature generation process for a time series project. It includes information about which features are generated and their priority,as well as the detected properties of the time series data such as whether the series is stationary, and periodicities detected.  This route is only supported for time series projects that have finished partitioning.  The feature derivation log will include information about:  - Maximum number of feature to be generated, e.g.,   &#x60;Limit on the maximum number of feature in this project is 500&#x60; - Number of derived features tested during the feature generation   process, e.g.,   &#x60;Total number of derived features during the feature generation process is 571&#x60; - Number of generated features removed during the feature reduction   process e.g.   &#x60;Total number of features removed during the feature reduction process is 472&#x60; - Number of remaining features after the combined feature generation and   reduction process, e.g., &#x60;The finalized number of features is 99&#x60; - Detected stationarity of the series, e.g.,   &#x60;Series detected as non-stationary&#x60; - Detected presence of multiplicative trend in the series, e.g.,   &#x60;Multiplicative trend detected&#x60; - Detected periodicities in the series, e.g.,   &#x60;Detected periodicities: 7 day&#x60; - Window sizes used in rolling statistics / lag extractors, e.g.,   &#x60;The window sizes chosen to be: 2 months (because the time step is 1 month and Feature Derivation Window is 2 months)&#x60; - Features that are specified as known-in-advance, e.g.,   &#x60;Variables treated as apriori: holiday&#x60; - Details about why certain variables are transformed in the input data,   e.g.,   &#x60;Generating variable \&quot;y (log)\&quot; from \&quot;y\&quot; because multiplicative trend is detected&#x60; - Details about features generated as time series features, and their   priority, e.g.,   &#x60;Generating feature \&quot;date (actual)\&quot; from \&quot;date\&quot; (priority: 1)&#x60;
    #' @details This method invokes `GET /projects/{projectId}/timeSeriesFeatureLog/file/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' \item **`ContentMinusDisposition`** &#x60;attachment;filename&#x3D;&lt;filename&gt;.txt&#x60; The suggested filename is dynamically generated
    #' \item **`ContentMinusType`** MIME type of the returned data
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsTimeSeriesFeatureLogFileList(projectId)
    #' }
    ProjectsTimeSeriesFeatureLogFileList = function(projectId, ...) {
      apiResponse <- private$ProjectsTimeSeriesFeatureLogFileListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the feature derivation log content and log length for a time series project as JSON.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the feature derivation log content and log length for a time series project as JSON.  The Time Series Feature Log provides details about the feature generation process for a time series project. It includes information about which features are generated and their priority,as well as the detected properties of the time series data such as whether the series is stationary, and periodicities detected.  This route is only supported for time series projects that have finished partitioning.  The feature derivation log will include information about:  - Detected stationarity of the series, e.g.,   &#x60;Series detected as non-stationary&#x60; - Detected presence of multiplicative trend in the series, e.g.,   &#x60;Multiplicative trend detected&#x60; - Detected periodicities in the series, e.g.,   &#x60;Detected periodicities: 7 day&#x60; - Maximum number of feature to be generated, e.g.,   &#x60;Maximum number of feature to be generated is 1440&#x60; - Window sizes used in rolling statistics / lag extractors, e.g.,   &#x60;The window sizes chosen to be: 2 months&#x60; - Features that are specified as known-in-advance, e.g.,   &#x60;Variables treated as apriori: holiday&#x60; - Details about features generated as timeseries features, and their   priority, e.g.,   &#x60;Generating feature \&quot;date (actual)\&quot; from \&quot;date\&quot; (priority: 1)&#x60; - Details about why certain variables are transformed in the input data,   e.g.,   &#x60;Generating variable \&quot;y (log)\&quot; from \&quot;y\&quot; because multiplicative trend is detected&#x60;
    #' @details This method invokes `GET /projects/{projectId}/timeSeriesFeatureLog/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{TimeSeriesFeatureLogListControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- DatetimePartitioningApi$new()
    #' result <- api.instance$ProjectsTimeSeriesFeatureLogList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsTimeSeriesFeatureLogList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsTimeSeriesFeatureLogListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `ProjectsDatetimePartitioningCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimePartitioningCreateWithHttpInfo = function(projectId, datetimePartitioningDataForOpenApi = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`datetimePartitioningDataForOpenApi`) && isa(datetimePartitioningDataForOpenApi, c("DatetimePartitioningDataForOpenApi", "R6"))) {
        body <- `datetimePartitioningDataForOpenApi`$toJSON()
      } else {
        stop("ProjectsDatetimePartitioningCreateWithHttpInfo requires parameter datetimePartitioningDataForOpenApi to be of type DatetimePartitioningDataForOpenApi.")
      }

      urlPath <- "/projects/{projectId}/datetimePartitioning/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimePartitioningResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimePartitioningList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimePartitioningListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimePartitioning/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FinalDatetimePartitioningResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsOptimizedDatetimePartitioningsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsOptimizedDatetimePartitioningsCreateWithHttpInfo = function(projectId, optimizedDatetimePartitioningData = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`optimizedDatetimePartitioningData`) && isa(optimizedDatetimePartitioningData, c("OptimizedDatetimePartitioningData", "R6"))) {
        body <- `optimizedDatetimePartitioningData`$toJSON()
      } else {
        stop("ProjectsOptimizedDatetimePartitioningsCreateWithHttpInfo requires parameter optimizedDatetimePartitioningData to be of type OptimizedDatetimePartitioningData.")
      }

      urlPath <- "/projects/{projectId}/optimizedDatetimePartitionings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimePartitioningResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsOptimizedDatetimePartitioningsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsOptimizedDatetimePartitioningsListWithHttpInfo = function(limit, projectId, offset = 0, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/optimizedDatetimePartitionings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OptimizedDatetimePartitioningListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsOptimizedDatetimePartitioningsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsOptimizedDatetimePartitioningsRetrieveWithHttpInfo = function(projectId, datetimePartitioningId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`datetimePartitioningId`)) {
        stop("Missing required parameter `datetimePartitioningId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/optimizedDatetimePartitionings/{datetimePartitioningId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datetimePartitioningId`)) {
        urlPath <- gsub(paste0("\\{", "datetimePartitioningId", "\\}"), URLencode(as.character(`datetimePartitioningId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimePartitioningResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsTimeSeriesFeatureLogFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsTimeSeriesFeatureLogFileListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/timeSeriesFeatureLog/file/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsTimeSeriesFeatureLogList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsTimeSeriesFeatureLogListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/timeSeriesFeatureLog/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "TimeSeriesFeatureLogListControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
