# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title ProjectFeatureResponse
#'
#' @description ProjectFeatureResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field dataQualities  character [optional] Data Quality Status
#'
#' @field dateFormat  character the date format string for how this feature was interpreted (or null if not a date feature).  If not null, it will be compatible with https://docs.python.org/2/library/time.html#time.strftime .
#'
#' @field featureLineageId  character id of a lineage for automatically generated features.
#'
#' @field featureType  character Feature type.
#'
#' @field id  integer the feature ID. (Note: Throughout the API, features are specified using their names, not this ID.)
#'
#' @field importance  numeric numeric measure of the strength of relationship between the feature and target (independent of any model or other features)
#'
#' @field isRestoredAfterReduction  character [optional] Whether feature is restored after feature reduction
#'
#' @field isZeroInflated  character [optional] Whether feature has an excessive number of zeros
#'
#' @field keySummary  \link{OneOfFeatureKeySummaryResponseValidatorSummarizedCategoricalarray} [optional] Per key summaries for Summarized Categorical or Multicategorical columns
#'
#' @field lowInformation  character whether feature has too few values to be informative
#'
#' @field max  \link{OneOfstringnumber} maximum value of the EDA sample of the feature.
#'
#' @field mean  \link{OneOfstringnumber} arithmetic mean of the EDA sample of the feature.
#'
#' @field median  \link{OneOfstringnumber} median of the EDA sample of the feature.
#'
#' @field min  \link{OneOfstringnumber} minimum value of the EDA sample of the feature.
#'
#' @field multilabelInsights  \link{MultilabelInsightsResponse} [optional]
#'
#' @field naCount  integer number of missing values
#'
#' @field name  character feature name
#'
#' @field parentFeatureNames  list( character ) [optional] an array of string feature names indicating which features in the input data were used to create this feature if the feature is a transformation.
#'
#' @field projectId  character the ID of the project the feature belongs to
#'
#' @field stdDev  \link{OneOfstringnumber} standard deviation of EDA sample of the feature.
#'
#' @field targetLeakage  character the detected level of risk for target leakage, if any. &#39;SKIPPED_DETECTION&#39; indicates leakage detection was not run on the feature, &#39;FALSE&#39; indicates no leakage, &#39;MODERATE_RISK&#39; indicates a moderate risk of target leakage, and &#39;HIGH_RISK&#39; indicates a high risk of target leakage.
#'
#' @field targetLeakageReason  character descriptive sentence explaining the reason for target leakage.
#'
#' @field timeSeriesEligibilityReason  character why the feature is ineligible for time series projects, or &#39;suitable&#39; if it is eligible.
#'
#' @field timeSeriesEligible  character whether this feature can be used as a datetime partitioning feature for time series projects.  Only sufficiently regular date features can be selected as the datetime feature for time series projects.  Always false for non-date features.  Date features that cannot be used in datetime partitioning for a time series project may be eligible for an OTV project, which has less stringent requirements.
#'
#' @field timeStep  integer The minimum time step that can be used to specify time series windows.  The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  When specifying windows for time series projects, all windows must have durations that are integer multiples of this number.  Only present for date features that are eligible for time series projects and null otherwise.
#'
#' @field timeUnit  character the unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  When specifying windows for time series projects, the windows are expressed in terms of this unit.  Only present for date features eligible for time series projects, and null otherwise.
#'
#' @field uniqueCount  integer [optional] number of unique values
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
ProjectFeatureResponse <- R6::R6Class(
  "ProjectFeatureResponse",
  lock_objects = FALSE,
  private = list(
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(dataQualities = NULL, dateFormat = NULL, featureLineageId = NULL, featureType = NULL, id = NULL, importance = NULL, isRestoredAfterReduction = NULL, isZeroInflated = NULL, keySummary = NULL, lowInformation = NULL, max = NULL, mean = NULL, median = NULL, min = NULL, multilabelInsights = NULL, naCount = NULL, name = NULL, parentFeatureNames = NULL, projectId = NULL, stdDev = NULL, targetLeakage = NULL, targetLeakageReason = NULL, timeSeriesEligibilityReason = NULL, timeSeriesEligible = NULL, timeStep = NULL, timeUnit = NULL, uniqueCount = NULL) {
      if (!is.null(`dateFormat`)) {
        stopifnot(is.character(`dateFormat`), length(`dateFormat`) == 1)
      }
      if (!is.null(`featureLineageId`)) {
        stopifnot(is.character(`featureLineageId`), length(`featureLineageId`) == 1)
      }
      if (!is.null(`featureType`)) {
        stopifnot(is.character(`featureType`), length(`featureType`) == 1)
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
      }
      if (!is.null(`importance`)) {
      }
      if (!is.null(`lowInformation`)) {
        stopifnot(is.logical(`lowInformation`), length(`lowInformation`) == 1)
      }
      if (!is.null(`max`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = max)
      }
      if (!is.null(`mean`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = mean)
      }
      if (!is.null(`median`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = median)
      }
      if (!is.null(`min`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = min)
      }
      if (!is.null(`naCount`)) {
        stopifnot(is.numeric(`naCount`), length(`naCount`) == 1)
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
      }
      if (!is.null(`projectId`)) {
        stopifnot(is.character(`projectId`), length(`projectId`) == 1)
      }
      if (!is.null(`stdDev`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = stdDev)
      }
      if (!is.null(`targetLeakage`)) {
        stopifnot(is.character(`targetLeakage`), length(`targetLeakage`) == 1)
      }
      if (!is.null(`targetLeakageReason`)) {
        stopifnot(is.character(`targetLeakageReason`), length(`targetLeakageReason`) == 1)
      }
      if (!is.null(`timeSeriesEligibilityReason`)) {
        stopifnot(is.character(`timeSeriesEligibilityReason`), length(`timeSeriesEligibilityReason`) == 1)
      }
      if (!is.null(`timeSeriesEligible`)) {
        stopifnot(is.logical(`timeSeriesEligible`), length(`timeSeriesEligible`) == 1)
      }
      if (!is.null(`timeStep`)) {
        stopifnot(is.numeric(`timeStep`), length(`timeStep`) == 1)
      }
      if (!is.null(`timeUnit`)) {
        stopifnot(is.character(`timeUnit`), length(`timeUnit`) == 1)
      }
      if (!is.null(`dataQualities`)) {
        stopifnot(is.character(`dataQualities`), length(`dataQualities`) == 1)
      }
      if (!is.null(`isRestoredAfterReduction`)) {
        stopifnot(is.logical(`isRestoredAfterReduction`), length(`isRestoredAfterReduction`) == 1)
      }
      if (!is.null(`isZeroInflated`)) {
        stopifnot(is.logical(`isZeroInflated`), length(`isZeroInflated`) == 1)
      }
      if (!is.null(`keySummary`)) {
        .setMixedProperty(typeList = list(FeatureKeySummaryResponseValidatorSummarizedCategorical, array), propertyData = keySummary)
      }
      if (!is.null(`multilabelInsights`)) {
        stopifnot(R6::is.R6(`multilabelInsights`))
      }
      if (!is.null(`parentFeatureNames`)) {
        stopifnot(is.vector(`parentFeatureNames`))
      }
      if (!is.null(`uniqueCount`)) {
        stopifnot(is.numeric(`uniqueCount`), length(`uniqueCount`) == 1)
      }
    }
  ),
  public = list(
    `dataQualities` = NULL,
    `dateFormat` = NULL,
    `featureLineageId` = NULL,
    `featureType` = NULL,
    `id` = NULL,
    `importance` = NULL,
    `isRestoredAfterReduction` = NULL,
    `isZeroInflated` = NULL,
    `keySummary` = NULL,
    `lowInformation` = NULL,
    `max` = NULL,
    `mean` = NULL,
    `median` = NULL,
    `min` = NULL,
    `multilabelInsights` = NULL,
    `naCount` = NULL,
    `name` = NULL,
    `parentFeatureNames` = NULL,
    `projectId` = NULL,
    `stdDev` = NULL,
    `targetLeakage` = NULL,
    `targetLeakageReason` = NULL,
    `timeSeriesEligibilityReason` = NULL,
    `timeSeriesEligible` = NULL,
    `timeStep` = NULL,
    `timeUnit` = NULL,
    `uniqueCount` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param dataQualities Data Quality Status
    #' @param dateFormat the date format string for how this feature was interpreted (or null if not a date feature).  If not null, it will be compatible with https://docs.python.org/2/library/time.html#time.strftime .
    #' @param featureLineageId id of a lineage for automatically generated features.
    #' @param featureType Feature type.
    #' @param id the feature ID. (Note: Throughout the API, features are specified using their names, not this ID.)
    #' @param importance numeric measure of the strength of relationship between the feature and target (independent of any model or other features)
    #' @param isRestoredAfterReduction Whether feature is restored after feature reduction
    #' @param isZeroInflated Whether feature has an excessive number of zeros
    #' @param keySummary Per key summaries for Summarized Categorical or Multicategorical columns
    #' @param lowInformation whether feature has too few values to be informative
    #' @param max maximum value of the EDA sample of the feature.
    #' @param mean arithmetic mean of the EDA sample of the feature.
    #' @param median median of the EDA sample of the feature.
    #' @param min minimum value of the EDA sample of the feature.
    #' @param multilabelInsights
    #' @param naCount number of missing values
    #' @param name feature name
    #' @param parentFeatureNames an array of string feature names indicating which features in the input data were used to create this feature if the feature is a transformation.
    #' @param projectId the ID of the project the feature belongs to
    #' @param stdDev standard deviation of EDA sample of the feature.
    #' @param targetLeakage the detected level of risk for target leakage, if any. &#39;SKIPPED_DETECTION&#39; indicates leakage detection was not run on the feature, &#39;FALSE&#39; indicates no leakage, &#39;MODERATE_RISK&#39; indicates a moderate risk of target leakage, and &#39;HIGH_RISK&#39; indicates a high risk of target leakage.
    #' @param targetLeakageReason descriptive sentence explaining the reason for target leakage.
    #' @param timeSeriesEligibilityReason why the feature is ineligible for time series projects, or &#39;suitable&#39; if it is eligible.
    #' @param timeSeriesEligible whether this feature can be used as a datetime partitioning feature for time series projects.  Only sufficiently regular date features can be selected as the datetime feature for time series projects.  Always false for non-date features.  Date features that cannot be used in datetime partitioning for a time series project may be eligible for an OTV project, which has less stringent requirements.
    #' @param timeStep The minimum time step that can be used to specify time series windows.  The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  When specifying windows for time series projects, all windows must have durations that are integer multiples of this number.  Only present for date features that are eligible for time series projects and null otherwise.
    #' @param timeUnit the unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  When specifying windows for time series projects, the windows are expressed in terms of this unit.  Only present for date features eligible for time series projects, and null otherwise.
    #' @param uniqueCount number of unique values
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`dateFormat` = NULL, `featureLineageId` = NULL, `featureType` = NULL, `id` = NULL, `importance` = NULL, `lowInformation` = NULL, `max` = NULL, `mean` = NULL, `median` = NULL, `min` = NULL, `naCount` = NULL, `name` = NULL, `projectId` = NULL, `stdDev` = NULL, `targetLeakage` = NULL, `targetLeakageReason` = NULL, `timeSeriesEligibilityReason` = NULL, `timeSeriesEligible` = NULL, `timeStep` = NULL, `timeUnit` = NULL, `dataQualities` = NULL, `isRestoredAfterReduction` = NULL, `isZeroInflated` = NULL, `keySummary` = NULL, `multilabelInsights` = NULL, `parentFeatureNames` = NULL, `uniqueCount` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      requiredProps <- list(`dateFormat`, `featureLineageId`, `featureType`, `id`, `importance`, `lowInformation`, `max`, `mean`, `median`, `min`, `naCount`, `name`, `projectId`, `stdDev`, `targetLeakage`, `targetLeakageReason`, `timeSeriesEligibilityReason`, `timeSeriesEligible`, `timeStep`, `timeUnit`)
      if (validateParams) {
        lapply(requiredProps, missing)
        private$validateProps(dataQualities, dateFormat, featureLineageId, featureType, id, importance, isRestoredAfterReduction, isZeroInflated, keySummary, lowInformation, max, mean, median, min, multilabelInsights, naCount, name, parentFeatureNames, projectId, stdDev, targetLeakage, targetLeakageReason, timeSeriesEligibilityReason, timeSeriesEligible, timeStep, timeUnit, uniqueCount)
      }
      self$`dataQualities` <- `dataQualities`
      self$`dateFormat` <- `dateFormat`
      self$`featureLineageId` <- `featureLineageId`
      self$`featureType` <- `featureType`
      self$`id` <- `id`
      self$`importance` <- `importance`
      self$`isRestoredAfterReduction` <- `isRestoredAfterReduction`
      self$`isZeroInflated` <- `isZeroInflated`
      self$`keySummary` <- `keySummary`
      self$`lowInformation` <- `lowInformation`
      self$`max` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = max)
      self$`mean` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = mean)
      self$`median` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = median)
      self$`min` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = min)
      self$`multilabelInsights` <- `multilabelInsights`
      self$`naCount` <- `naCount`
      self$`name` <- `name`
      sapply(`parentFeatureNames`, function(x) stopifnot(is.character(x)))
      self$`projectId` <- `projectId`
      self$`stdDev` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = stdDev)
      self$`targetLeakage` <- `targetLeakage`
      self$`targetLeakageReason` <- `targetLeakageReason`
      self$`timeSeriesEligibilityReason` <- `timeSeriesEligibilityReason`
      self$`timeSeriesEligible` <- `timeSeriesEligible`
      self$`timeStep` <- `timeStep`
      self$`timeUnit` <- `timeUnit`
      self$`uniqueCount` <- `uniqueCount`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    validate = function() {
      props <- list(dataQualities = self$`dataQualities`, dateFormat = self$`dateFormat`, featureLineageId = self$`featureLineageId`, featureType = self$`featureType`, id = self$`id`, importance = self$`importance`, isRestoredAfterReduction = self$`isRestoredAfterReduction`, isZeroInflated = self$`isZeroInflated`, keySummary = self$`keySummary`, lowInformation = self$`lowInformation`, max = self$`max`, mean = self$`mean`, median = self$`median`, min = self$`min`, multilabelInsights = self$`multilabelInsights`, naCount = self$`naCount`, name = self$`name`, parentFeatureNames = self$`parentFeatureNames`, projectId = self$`projectId`, stdDev = self$`stdDev`, targetLeakage = self$`targetLeakage`, targetLeakageReason = self$`targetLeakageReason`, timeSeriesEligibilityReason = self$`timeSeriesEligibilityReason`, timeSeriesEligible = self$`timeSeriesEligible`, timeStep = self$`timeStep`, timeUnit = self$`timeUnit`, uniqueCount = self$`uniqueCount`)
      do.call(private$validateProps, props)
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`dataQualities`)) {
          sprintf(
            '"dataQualities":
            "%s"
                  ',
            self$`dataQualities`
          )
        },
        if (!is.null(self$`dateFormat`)) {
          sprintf(
            '"dateFormat":
            "%s"
                  ',
            self$`dateFormat`
          )
        },
        if (!is.null(self$`featureLineageId`)) {
          sprintf(
            '"featureLineageId":
            "%s"
                  ',
            self$`featureLineageId`
          )
        },
        if (!is.null(self$`featureType`)) {
          sprintf(
            '"featureType":
            "%s"
                  ',
            self$`featureType`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                  ',
            self$`id`
          )
        },
        if (!is.null(self$`importance`)) {
          sprintf(
            '"importance":
            %d
                  ',
            self$`importance`
          )
        },
        if (!is.null(self$`isRestoredAfterReduction`)) {
          sprintf(
            '"isRestoredAfterReduction":
            %s
                  ',
            tolower(self$`isRestoredAfterReduction`)
          )
        },
        if (!is.null(self$`isZeroInflated`)) {
          sprintf(
            '"isZeroInflated":
            %s
                  ',
            tolower(self$`isZeroInflated`)
          )
        },
        if (!is.null(self$`keySummary`)) {
          sprintf(
            '"keySummary":
          %s
        ',
          )
        },
        if (!is.null(self$`lowInformation`)) {
          sprintf(
            '"lowInformation":
            %s
                  ',
            tolower(self$`lowInformation`)
          )
        },
        if (!is.null(self$`max`)) {
          sprintf(
            '"max":
          %s
        ',
            self$`max`
          )
        },
        if (!is.null(self$`mean`)) {
          sprintf(
            '"mean":
          %s
        ',
            self$`mean`
          )
        },
        if (!is.null(self$`median`)) {
          sprintf(
            '"median":
          %s
        ',
            self$`median`
          )
        },
        if (!is.null(self$`min`)) {
          sprintf(
            '"min":
          %s
        ',
            self$`min`
          )
        },
        if (!is.null(self$`multilabelInsights`)) {
          sprintf(
            '"multilabelInsights":
          %s
        ',
            jsonlite::toJSON(self$`multilabelInsights`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`naCount`)) {
          sprintf(
            '"naCount":
            %d
                  ',
            self$`naCount`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                  ',
            self$`name`
          )
        },
        if (!is.null(self$`parentFeatureNames`)) {
          sprintf(
            '"parentFeatureNames":
              [%s]
            ',
            paste(unlist(lapply(self$`parentFeatureNames`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`projectId`)) {
          sprintf(
            '"projectId":
            "%s"
                  ',
            self$`projectId`
          )
        },
        if (!is.null(self$`stdDev`)) {
          sprintf(
            '"stdDev":
          %s
        ',
            self$`stdDev`
          )
        },
        if (!is.null(self$`targetLeakage`)) {
          sprintf(
            '"targetLeakage":
            "%s"
                  ',
            self$`targetLeakage`
          )
        },
        if (!is.null(self$`targetLeakageReason`)) {
          sprintf(
            '"targetLeakageReason":
            "%s"
                  ',
            self$`targetLeakageReason`
          )
        },
        if (!is.null(self$`timeSeriesEligibilityReason`)) {
          sprintf(
            '"timeSeriesEligibilityReason":
            "%s"
                  ',
            self$`timeSeriesEligibilityReason`
          )
        },
        if (!is.null(self$`timeSeriesEligible`)) {
          sprintf(
            '"timeSeriesEligible":
            %s
                  ',
            tolower(self$`timeSeriesEligible`)
          )
        },
        if (!is.null(self$`timeStep`)) {
          sprintf(
            '"timeStep":
            %d
                  ',
            self$`timeStep`
          )
        },
        if (!is.null(self$`timeUnit`)) {
          sprintf(
            '"timeUnit":
            "%s"
                  ',
            self$`timeUnit`
          )
        },
        if (!is.null(self$`uniqueCount`)) {
          sprintf(
            '"uniqueCount":
            %d
                  ',
            self$`uniqueCount`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param ProjectFeatureResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(ProjectFeatureResponseJson, validateParams = FALSE) {
      ProjectFeatureResponseObject <- jsonlite::fromJSON(ProjectFeatureResponseJson)
      self$`dataQualities` <- ProjectFeatureResponseObject$`dataQualities`
      self$`dateFormat` <- ProjectFeatureResponseObject$`dateFormat`
      self$`featureLineageId` <- ProjectFeatureResponseObject$`featureLineageId`
      self$`featureType` <- ProjectFeatureResponseObject$`featureType`
      self$`id` <- ProjectFeatureResponseObject$`id`
      self$`importance` <- ProjectFeatureResponseObject$`importance`
      self$`isRestoredAfterReduction` <- ProjectFeatureResponseObject$`isRestoredAfterReduction`
      self$`isZeroInflated` <- ProjectFeatureResponseObject$`isZeroInflated`
      self$`lowInformation` <- ProjectFeatureResponseObject$`lowInformation`
      self$`max` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = ProjectFeatureResponseObject$max)
      self$`mean` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = ProjectFeatureResponseObject$mean)
      self$`median` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = ProjectFeatureResponseObject$median)
      self$`min` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = ProjectFeatureResponseObject$min)
      self$`multilabelInsights` <- MultilabelInsightsResponse$new()$fromJSON(jsonlite::toJSON(ProjectFeatureResponseObject$multilabelInsights, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`naCount` <- ProjectFeatureResponseObject$`naCount`
      self$`name` <- ProjectFeatureResponseObject$`name`
      self$`parentFeatureNames` <- ApiClient$new()$deserializeObj(ProjectFeatureResponseObject$`parentFeatureNames`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`projectId` <- ProjectFeatureResponseObject$`projectId`
      self$`stdDev` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = ProjectFeatureResponseObject$stdDev)
      self$`targetLeakage` <- ProjectFeatureResponseObject$`targetLeakage`
      self$`targetLeakageReason` <- ProjectFeatureResponseObject$`targetLeakageReason`
      self$`timeSeriesEligibilityReason` <- ProjectFeatureResponseObject$`timeSeriesEligibilityReason`
      self$`timeSeriesEligible` <- ProjectFeatureResponseObject$`timeSeriesEligible`
      self$`timeStep` <- ProjectFeatureResponseObject$`timeStep`
      self$`timeUnit` <- ProjectFeatureResponseObject$`timeUnit`
      self$`uniqueCount` <- ProjectFeatureResponseObject$`uniqueCount`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
