# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Deployments operations
#' @description datarobot.apicore.Deployments
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
DeploymentsApi <- R6::R6Class(
  "DeploymentsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description List deleted deployments
    #' Produces: "application/json"
    #'
    #' @details List deleted deployments.Only available as part of an enterprise (on-prem) installation. Requires a CAN_DELETE_APP_PROJECTS permission to execute.
    #' @details This method invokes `GET /deletedDeployments/` in the DataRobot Public API.
    #' @param offset integer. The number of deleted deployments to skip.
    #' @param limit integer. The number of deleted deployments to return.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeletedDeploymentListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The deleted deployments
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of deleted deployments to skip.
    #' limit <- 20 # integer | The number of deleted deployments to return.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeletedDeploymentsList(offset, limit)
    #' }
    DeletedDeploymentsList = function(offset, limit, ...) {
      apiResponse <- private$DeletedDeploymentsListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Erase deleted deployments
    #' Produces: NA
    #'
    #' @details Permanently erase data for deleted deployments. Only available as part of an on-premise or private/hybrid cloud deployment. Requires a CAN_DELETE_APP_PROJECTS permission to execute.
    #' @details This method invokes `PATCH /deletedDeployments/` in the DataRobot Public API.
    #' @param deploymentPermanentDelete \link{DeploymentPermanentDelete}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** URL for tracking deployment permanently erase job status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentPermanentDelete <- DeploymentPermanentDelete$new() # DeploymentPermanentDelete |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeletedDeploymentsPatchMany(deploymentPermanentDelete=deploymentPermanentDelete)
    #' }
    DeletedDeploymentsPatchMany = function(deploymentPermanentDelete = NULL, ...) {
      apiResponse <- private$DeletedDeploymentsPatchManyWithHttpInfo(deploymentPermanentDelete, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve accuracy metric
    #' Produces: "application/json"
    #'
    #' @details Retrieve accuracy metric for a certain time period.
    #' @details This method invokes `GET /deployments/{deploymentId}/accuracy/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param modelId character. The id of the model for which metrics are being retrieved.
    #' @param segmentAttribute character. The name of the segment on which segment analysis is being performed.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param targetClasses character. Comma separated list of target classes to filter out response
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AccuracyRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Deployment accuracy metrics are retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' modelId <- 'modelId_example' # character | The id of the model for which metrics are being retrieved.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of the segment on which segment analysis is being performed.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' targetClasses <- 'targetClasses_example' # character | Comma separated list of target classes to filter out response
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsAccuracyList(deploymentId, start=start, end=end, modelId=modelId, segmentAttribute=segmentAttribute, segmentValue=segmentValue, targetClasses=targetClasses)
    #' }
    DeploymentsAccuracyList = function(deploymentId, start = NULL, end = NULL, modelId = NULL, segmentAttribute = NULL, segmentValue = "", targetClasses = NULL, ...) {
      apiResponse <- private$DeploymentsAccuracyListWithHttpInfo(deploymentId, start, end, modelId, segmentAttribute, segmentValue, targetClasses, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve accuracy over time data for one single metric.
    #' Produces: "application/json"
    #'
    #' @details &gt; Retrieve accuracy over time data for one single metric. &gt; &gt; The following metrics can be retrieved. &gt; &gt; &gt; For classification deployments: &gt; &gt; &gt; &gt; - Accuracy &gt; &gt; - AUC &gt; &gt; - Balanced Accuracy &gt; &gt; - FVE Binomial &gt; &gt; - Gini Norm &gt; &gt; - Kolmogorov-Smirnov &gt; &gt; - LogLoss (default) &gt; &gt; - &lt;Rate@Top5&gt;% &gt; &gt; - &lt;Rate@Top10&gt;% &gt; &gt; &gt; &gt; For regression deployments: &gt; &gt; &gt; &gt; - Gamma Deviance (default) &gt; &gt; - FVE Gamma &gt; &gt; - FVE Poisson &gt; &gt; - FVE Tweedie &gt; &gt; - MAD &gt; &gt; - MAE &gt; &gt; - MAPE &gt; &gt; - Poisson Deviance &gt; &gt; - R Squared &gt; &gt; - RMSE &gt; &gt; - RMSLE &gt; &gt; - Tweedie Deviance
    #' @details This method invokes `GET /deployments/{deploymentId}/accuracyOverTime/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. Start of the period to retrieve metric stats, defaults to 7 days ago from the end of the period.
    #' @param end character. End of the period to retrieve metric stats, defaults to the next top of the hour.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param modelId character. The id of the model for which metrics are being retrieved.
    #' @param metric character. Name of the metric.
    #' @param segmentAttribute character. The name of the segment on which segment analysis is being performed.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param targetClasses character. List of target classes to filter out response
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AccuracyOverTimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accuracy over time info retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | Start of the period to retrieve metric stats, defaults to 7 days ago from the end of the period.
    #' end <- 'end_example' # character | End of the period to retrieve metric stats, defaults to the next top of the hour.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' modelId <- 'modelId_example' # character | The id of the model for which metrics are being retrieved.
    #' metric <- 'metric_example' # character | Name of the metric.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of the segment on which segment analysis is being performed.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' targetClasses <- 'targetClasses_example' # character | List of target classes to filter out response
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsAccuracyOverTimeList(deploymentId, start=start, end=end, bucketSize=bucketSize, modelId=modelId, metric=metric, segmentAttribute=segmentAttribute, segmentValue=segmentValue, targetClasses=targetClasses)
    #' }
    DeploymentsAccuracyOverTimeList = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, modelId = NULL, metric = NULL, segmentAttribute = NULL, segmentValue = "", targetClasses = NULL, ...) {
      apiResponse <- private$DeploymentsAccuracyOverTimeListWithHttpInfo(deploymentId, start, end, bucketSize, modelId, metric, segmentAttribute, segmentValue, targetClasses, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Submit actuals values from AI Catalog
    #' Produces: NA
    #'
    #' @details Submit actuals values for processing using catalog item. Submission of actuals is limited to 10,000,000 actuals per hour. For time series deployments, total actuals &#x3D; number of actuals \\* number of forecast distances. For example, submitting 10 actuals for a deployment with 50 forecast distances &#x3D; 500 total actuals. For multiclass deployments, a similar calculation is made where total actuals &#x3D; number of actuals \\* number of classes. For example, submitting 10 actuals for a deployment with 20 classes &#x3D; 200 actuals.
    #' @details This method invokes `POST /deployments/{deploymentId}/actuals/fromDataset/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentDatasetCreate \link{DeploymentDatasetCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Submitted successfully. See Location header.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Unable to process the Actuals submission request.
    #' \itemize{
    #' }
    #' \item **`429`** The number of actuals uploaded this hour exceeds the limit of 10000000 rows.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentDatasetCreate <- DeploymentDatasetCreate$new() # DeploymentDatasetCreate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsActualsFromDatasetCreate(deploymentId, deploymentDatasetCreate=deploymentDatasetCreate)
    #' }
    DeploymentsActualsFromDatasetCreate = function(deploymentId, deploymentDatasetCreate = NULL, ...) {
      apiResponse <- private$DeploymentsActualsFromDatasetCreateWithHttpInfo(deploymentId, deploymentDatasetCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Submit actuals values
    #' Produces: NA
    #'
    #' @details Submit actuals values for processing. Values are not processed immediately and may take some time to propagate through deployment systems. Submission of actuals is limited to 10,000,000 actuals per hour. For time series deployments, total actuals &#x3D; number of actuals \\* number of forecast distances. For example, submitting 10 actuals for a deployment with 50 forecast distances &#x3D; 500 total actuals. For multiclass deployments, a similar calculation is made where total actuals &#x3D; number of actuals \\* number of classes. For example, submitting 10 actuals for a deployment with 20 classes &#x3D; 200 actuals.
    #' @details This method invokes `POST /deployments/{deploymentId}/actuals/fromJSON/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentActuals \link{DeploymentActuals}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Submitted successfully. See Location header.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Unable to process the Actuals submission request.
    #' \itemize{
    #' }
    #' \item **`429`** The number of actuals uploaded this hour exceeds the limit of 10000000 rows.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentActuals <- DeploymentActuals$new() # DeploymentActuals |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsActualsFromJSONCreate(deploymentId, deploymentActuals=deploymentActuals)
    #' }
    DeploymentsActualsFromJSONCreate = function(deploymentId, deploymentActuals = NULL, ...) {
      apiResponse <- private$DeploymentsActualsFromJSONCreateWithHttpInfo(deploymentId, deploymentActuals, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve capabilities.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the capabilities for the deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/capabilities/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentCapabilitiesRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsCapabilitiesList(deploymentId)
    #' }
    DeploymentsCapabilitiesList = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsCapabilitiesListWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Score challenger models
    #' Produces: NA
    #'
    #' @details Score main model prediction requests against challenger model requests.
    #' @details This method invokes `POST /deployments/{deploymentId}/challengerPredictions/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param challengerScore \link{ChallengerScore}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** URL to poll to track challenger scoring progress.
    #' }
    #' \item **`422`** Unable to process the challenger scoring request.
    #' \itemize{
    #' }
    #' \item **`429`** Another challenger scoring job is running. See the Location header to track the running job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' challengerScore <- ChallengerScore$new() # ChallengerScore |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengerPredictionsCreate(deploymentId, challengerScore=challengerScore)
    #' }
    DeploymentsChallengerPredictionsCreate = function(deploymentId, challengerScore = NULL, ...) {
      apiResponse <- private$DeploymentsChallengerPredictionsCreateWithHttpInfo(deploymentId, challengerScore, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create challenger model
    #' Produces: NA
    #'
    #' @details Create new challenger model.
    #' @details This method invokes `POST /deployments/{deploymentId}/challengers/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param challengerCreate \link{ChallengerCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted successfully. See Location header.
    #' \itemize{
    #' \item **`Location`** URL to poll to track challenger creation has finished.
    #' }
    #' \item **`422`** Unable to process the challenger creation request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' challengerCreate <- ChallengerCreate$new() # ChallengerCreate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengersCreate(deploymentId, challengerCreate=challengerCreate)
    #' }
    DeploymentsChallengersCreate = function(deploymentId, challengerCreate = NULL, ...) {
      apiResponse <- private$DeploymentsChallengersCreateWithHttpInfo(deploymentId, challengerCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete challenger model
    #' Produces: NA
    #'
    #' @details Delete challenger model.
    #' @details This method invokes `DELETE /deployments/{deploymentId}/challengers/{challengerId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param challengerId character. Unique identifier of the challenger.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Model successfully deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' challengerId <- 'challengerId_example' # character | Unique identifier of the challenger.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengersDelete(deploymentId, challengerId)
    #' }
    DeploymentsChallengersDelete = function(deploymentId, challengerId, ...) {
      apiResponse <- private$DeploymentsChallengersDeleteWithHttpInfo(deploymentId, challengerId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List challenger models
    #' Produces: "application/json"
    #'
    #' @details List challenger models for deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/challengers/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ChallengerListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The challenger models
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengersList(deploymentId)
    #' }
    DeploymentsChallengersList = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsChallengersListWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update challenger model
    #' Produces: "application/json"
    #'
    #' @details Update challenger model.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/challengers/{challengerId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param challengerId character. Unique identifier of the challenger.
    #' @param challengerUpdate \link{ChallengerUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ChallengerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Model successfully updated.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' challengerId <- 'challengerId_example' # character | Unique identifier of the challenger.
    #' challengerUpdate <- ChallengerUpdate$new() # ChallengerUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengersPatch(deploymentId, challengerId, challengerUpdate=challengerUpdate)
    #' }
    DeploymentsChallengersPatch = function(deploymentId, challengerId, challengerUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsChallengersPatchWithHttpInfo(deploymentId, challengerId, challengerUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get challenger model
    #' Produces: "application/json"
    #'
    #' @details Retrieve challenger model.
    #' @details This method invokes `GET /deployments/{deploymentId}/challengers/{challengerId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param challengerId character. Unique identifier of the challenger.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ChallengerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The challenger model
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' challengerId <- 'challengerId_example' # character | Unique identifier of the challenger.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsChallengersRetrieve(deploymentId, challengerId)
    #' }
    DeploymentsChallengersRetrieve = function(deploymentId, challengerId, ...) {
      apiResponse <- private$DeploymentsChallengersRetrieveWithHttpInfo(deploymentId, challengerId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete deployment
    #' Produces: NA
    #'
    #' @details Delete a deployment.
    #' @details This method invokes `DELETE /deployments/{deploymentId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ignoreManagementAgent Enum < [false, False, true, True] > Do not wait for management agent to delete the deployment first.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Deployment successfully deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' ignoreManagementAgent <- "false" # character | Do not wait for management agent to delete the deployment first.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsDelete(deploymentId, ignoreManagementAgent=ignoreManagementAgent)
    #' }
    DeploymentsDelete = function(deploymentId, ignoreManagementAgent = "false", ...) {
      apiResponse <- private$DeploymentsDeleteWithHttpInfo(deploymentId, ignoreManagementAgent, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature drift scores
    #' Produces: "application/json"
    #'
    #' @details Retrieve drift scores for features of the deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/featureDrift/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param modelId character. ID of the model in the deployment. If not set, defaults to the deployment current model.
    #' @param metric Enum < [psi, kl_divergence, dissimilarity, hellinger, js_divergence] > Name of the metric used to calculate the drift. Can be one of psi, kl_divergence, dissimilarity, hellinger, and js_divergence. Defaults to psi.
    #' @param offset integer. The number of features to skip, defaults to 0.
    #' @param limit integer. The number of features to return, defaults to 25.
    #' @param segmentAttribute character. The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentFeatureDriftResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Features drift over specified time period retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' modelId <- 'modelId_example' # character | ID of the model in the deployment. If not set, defaults to the deployment current model.
    #' metric <- "psi" # character | Name of the metric used to calculate the drift. Can be one of psi, kl_divergence, dissimilarity, hellinger, and js_divergence. Defaults to psi.
    #' offset <- 0 # integer | The number of features to skip, defaults to 0.
    #' limit <- 200 # integer | The number of features to return, defaults to 25.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsFeatureDriftList(deploymentId, start=start, end=end, modelId=modelId, metric=metric, offset=offset, limit=limit, segmentAttribute=segmentAttribute, segmentValue=segmentValue)
    #' }
    DeploymentsFeatureDriftList = function(deploymentId, start = NULL, end = NULL, modelId = NULL, metric = "psi", offset = 0, limit = 200, segmentAttribute = NULL, segmentValue = "", ...) {
      apiResponse <- private$DeploymentsFeatureDriftListWithHttpInfo(deploymentId, start, end, modelId, metric, offset, limit, segmentAttribute, segmentValue, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve drift over time info for a feature of the deployment.
    #' Produces: "application/json"
    #'
    #' @details Retrieve drift over time info for a feature of the deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/featureDriftOverTime/` in the DataRobot Public API.
    #' @param featureNames \link{OneOfstringarray}. List of feature names, limited to two per request.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param modelId character. The id of the model for which the features drift is being retrieved.
    #' @param metric Enum < [psi, kl_divergence, dissimilarity, hellinger, js_divergence] > Name of the metric used to calculate the drift. Can be one of psi, kl_divergence, dissimilarity, hellinger, and js_divergence. Defaults to psi.
    #' @param segmentAttribute character. The name of the segment on which segment analysis is being performed.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureDriftOverTimeRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Feature drift over time info of the deployment retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' featureNames <- list(c('featureNames_example')) # OneOfstringarray | List of feature names, limited to two per request.
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' modelId <- 'modelId_example' # character | The id of the model for which the features drift is being retrieved.
    #' metric <- "psi" # character | Name of the metric used to calculate the drift. Can be one of psi, kl_divergence, dissimilarity, hellinger, and js_divergence. Defaults to psi.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of the segment on which segment analysis is being performed.
    #' segmentValue <- 'segmentValue_example' # character | The value of the `segmentAttribute` to segment on.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsFeatureDriftOverTimeList(featureNames, deploymentId, start=start, end=end, bucketSize=bucketSize, modelId=modelId, metric=metric, segmentAttribute=segmentAttribute, segmentValue=segmentValue)
    #' }
    DeploymentsFeatureDriftOverTimeList = function(featureNames, deploymentId, start = NULL, end = NULL, bucketSize = NULL, modelId = NULL, metric = "psi", segmentAttribute = NULL, segmentValue = NULL, ...) {
      apiResponse <- private$DeploymentsFeatureDriftOverTimeListWithHttpInfo(featureNames, deploymentId, start, end, bucketSize, modelId, metric, segmentAttribute, segmentValue, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get deployment features
    #' Produces: "application/json"
    #'
    #' @details Retrieve features contained within the universe dataset associated with a specific deployment. By default, this returns all raw features required for predictions.
    #' @details This method invokes `GET /deployments/{deploymentId}/features/` in the DataRobot Public API.
    #' @param offset integer. The number of features to skip, defaults to 0.
    #' @param limit integer. The number of features to return, defaults to 0.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param includeNonPredictionFeatures Enum < [false, False, true, True] > When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
    #' @param forSegmentedAnalysis Enum < [false, False, true, True] > When True, features returned will be filtered to those usable for segmented analysis.
    #' @param search character. Case insensitive search against names of the deployment&#39;s features.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The deployment&#39;s features
    #' \itemize{
    #' }
    #' \item **`422`** Feature list retrieval is not supported on this deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of features to skip, defaults to 0.
    #' limit <- 50 # integer | The number of features to return, defaults to 0.
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' includeNonPredictionFeatures <- "false" # character | When True will return all raw features in the universe dataset associated with the deployment, and when False will return only those raw features used to make predictions on the deployment.
    #' forSegmentedAnalysis <- "false" # character | When True, features returned will be filtered to those usable for segmented analysis.
    #' search <- 'search_example' # character | Case insensitive search against names of the deployment's features.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsFeaturesList(offset, limit, deploymentId, includeNonPredictionFeatures=includeNonPredictionFeatures, forSegmentedAnalysis=forSegmentedAnalysis, search=search)
    #' }
    DeploymentsFeaturesList = function(offset, limit, deploymentId, includeNonPredictionFeatures = "false", forSegmentedAnalysis = "false", search = NULL, ...) {
      apiResponse <- private$DeploymentsFeaturesListWithHttpInfo(offset, limit, deploymentId, includeNonPredictionFeatures, forSegmentedAnalysis, search, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create deployment from DataRobot model
    #' Produces: "application/json"
    #'
    #' @details Create a deployment from a DataRobot model.
    #' @details This method invokes `POST /deployments/fromLearningModel/` in the DataRobot Public API.
    #' @param deploymentCreateFromLearningModel \link{DeploymentCreateFromLearningModel}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Deployment successfully created
    #' \itemize{
    #' }
    #' \item **`202`** Job submitted. The URL at the Location header can be used to track when the deployment is ready for predictions.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`403`** User does not have permission to create a deployment.
    #' \itemize{
    #' }
    #' \item **`409`** User&#39;s organization has reached the maximum number of deployments.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the deployment creation request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentCreateFromLearningModel <- DeploymentCreateFromLearningModel$new() # DeploymentCreateFromLearningModel |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsFromLearningModelCreate(deploymentCreateFromLearningModel=deploymentCreateFromLearningModel)
    #' }
    DeploymentsFromLearningModelCreate = function(deploymentCreateFromLearningModel = NULL, ...) {
      apiResponse <- private$DeploymentsFromLearningModelCreateWithHttpInfo(deploymentCreateFromLearningModel, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve humility stats
    #' Produces: "application/json"
    #'
    #' @details Retrieve humility rule service triggers statistics overview.
    #' @details This method invokes `GET /deployments/{deploymentId}/humilityStats/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. Start of the period to retrieve service health stats, defaults to 7 days ago from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. End of the period to retrieve service health stats, defaults to the next top of the hour.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param segmentAttribute Enum < [DataRobot-Consumer, DataRobot-Remote-IP, DataRobot-Host-Name] > The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param modelId character. The ID of the model to retrieve service health stats. If provided, only the service health stats for that  specific model will be retrieved. If not provided, the service healthstats for the deployment&#x60;s current model will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{HumilityStatsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Humility service health statistics overview retrieved.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | Start of the period to retrieve service health stats, defaults to 7 days ago from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | End of the period to retrieve service health stats, defaults to the next top of the hour.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' modelId <- 'modelId_example' # character | The ID of the model to retrieve service health stats. If provided, only the service health stats for that  specific model will be retrieved. If not provided, the service healthstats for the deployment`s current model will be retrieved.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsHumilityStatsList(deploymentId, start=start, end=end, bucketSize=bucketSize, segmentAttribute=segmentAttribute, segmentValue=segmentValue, modelId=modelId)
    #' }
    DeploymentsHumilityStatsList = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      apiResponse <- private$DeploymentsHumilityStatsListWithHttpInfo(deploymentId, start, end, bucketSize, segmentAttribute, segmentValue, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve humility stats over time
    #' Produces: "application/json"
    #'
    #' @details Retrieve humility service statistics over time.
    #' @details This method invokes `GET /deployments/{deploymentId}/humilityStatsOverTime/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. Start of the period to retrieve service health stats, defaults to 7 days ago from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. End of the period to retrieve service health stats, defaults to the next top of the hour.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param segmentAttribute Enum < [DataRobot-Consumer, DataRobot-Remote-IP, DataRobot-Host-Name] > The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param modelId character. The ID of the model to retrieve service health stats. If provided, only the service health stats for that  specific model will be retrieved. If not provided, the service healthstats for the deployment&#x60;s current model will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{HumilityStatsOverTimeRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Humility statistics for deployment retrieved.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | Start of the period to retrieve service health stats, defaults to 7 days ago from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | End of the period to retrieve service health stats, defaults to the next top of the hour.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' modelId <- 'modelId_example' # character | The ID of the model to retrieve service health stats. If provided, only the service health stats for that  specific model will be retrieved. If not provided, the service healthstats for the deployment`s current model will be retrieved.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsHumilityStatsOverTimeList(deploymentId, start=start, end=end, bucketSize=bucketSize, segmentAttribute=segmentAttribute, segmentValue=segmentValue, modelId=modelId)
    #' }
    DeploymentsHumilityStatsOverTimeList = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      apiResponse <- private$DeploymentsHumilityStatsOverTimeListWithHttpInfo(deploymentId, start, end, bucketSize, segmentAttribute, segmentValue, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List deployments
    #' Produces: "application/json"
    #'
    #' @details List deployments a user can view.
    #' @details This method invokes `GET /deployments/` in the DataRobot Public API.
    #' @param offset integer. The number of deployments to skip. Defaults to 0.
    #' @param limit integer. The number of deployments (greater than zero, max 100) to return. Defaults to 20.
    #' @param orderBy Enum < [label, -label, serviceHealth, -serviceHealth, modelHealth, -modelHealth, accuracyHealth, -accuracyHealth, recentPredictions, -recentPredictions, lastPredictionTimestamp, -lastPredictionTimestamp, currentModelDeployedTimestamp, -currentModelDeployedTimestamp, createdAtTimestamp, -createdAtTimestamp, importance, -importance, fairnessHealth, -fairnessHealth] > The order to sort the deployments.Defaults to order by deployment last prediction timestamp in descending order.
    #' @param search character. Case insensitive search against deployment&#39;s label and description.
    #' @param serviceHealth Enum < [unknown, warning, passing, unavailable, failing] > Filters deployments by their service health status.
    #' @param modelHealth Enum < [unknown, warning, passing, unavailable, failing] > Filters deployments by their model health status.
    #' @param accuracyHealth Enum < [unknown, warning, passing, unavailable, failing] > Filters deployments by their accuracy health status.
    #' @param role Enum < [OWNER, USER] > Filter deployments to only those that the authenticated user has the specified role for.
    #' @param status Enum < [active, inactive, stopping, launching, archived, replacingModel, errored] > Filters deployments by their status
    #' @param importance Enum < [CRITICAL, HIGH, MODERATE, LOW] > Filters deployments by their importance
    #' @param lastPredictionTimestampStart character. Only include deployments that have had a prediction request on or after the specified timestamp.
    #' @param lastPredictionTimestampEnd character. Only include deployments that have had a prediction request before the specified timestamp.
    #' @param predictionUsageDailyAvgGreaterThan integer. only include deployments that have had more than the specified number of predictions per day on average over the past week.
    #' @param predictionUsageDailyAvgLessThan integer. Only include deployments that have had fewer than the specified number of predictions per day on average over the past week.
    #' @param defaultPredictionServerId list( character )
    #' @param buildEnvironmentType Enum < [DataRobot, Python, R, Java, Julia, Legacy, Other] > Filter deployments based on the type of their current model&#39;s build environment type.
    #' @param executionEnvironmentType Enum < [datarobot, external] > Filter deployments based on the type of their execution environment.
    #' @param predictionEnvironmentPlatform Enum < [aws, gcp, azure, onPremise, datarobot, openShift, other, snowflake] > Filter deployments based on prediction environment platform
    #' @param hasDecisionFlow Enum < [false, False, true, True] > Filter deployments based if it is a decision flow
    #' @param createdByMe Enum < [false, False, true, True] > Filter deployments to those created by the current user.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The deployments
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of deployments to skip. Defaults to 0.
    #' limit <- 20 # integer | The number of deployments (greater than zero, max 100) to return. Defaults to 20.
    #' orderBy <- 'orderBy_example' # character | The order to sort the deployments.Defaults to order by deployment last prediction timestamp in descending order.
    #' search <- 'search_example' # character | Case insensitive search against deployment's label and description.
    #' serviceHealth <- ['serviceHealth_example'] # array[character] | Filters deployments by their service health status.
    #' modelHealth <- ['modelHealth_example'] # array[character] | Filters deployments by their model health status.
    #' accuracyHealth <- ['accuracyHealth_example'] # array[character] | Filters deployments by their accuracy health status.
    #' role <- 'role_example' # character | Filter deployments to only those that the authenticated user has the specified role for.
    #' status <- ['status_example'] # array[character] | Filters deployments by their status
    #' importance <- ['importance_example'] # array[character] | Filters deployments by their importance
    #' lastPredictionTimestampStart <- 'lastPredictionTimestampStart_example' # character | Only include deployments that have had a prediction request on or after the specified timestamp.
    #' lastPredictionTimestampEnd <- 'lastPredictionTimestampEnd_example' # character | Only include deployments that have had a prediction request before the specified timestamp.
    #' predictionUsageDailyAvgGreaterThan <- 56 # integer | only include deployments that have had more than the specified number of predictions per day on average over the past week.
    #' predictionUsageDailyAvgLessThan <- 56 # integer | Only include deployments that have had fewer than the specified number of predictions per day on average over the past week.
    #' defaultPredictionServerId <- ['defaultPredictionServerId_example'] # array[character] | Filter deployments to those whose default prediction server has the specified id.
    #' buildEnvironmentType <- ['buildEnvironmentType_example'] # array[character] | Filter deployments based on the type of their current model's build environment type.
    #' executionEnvironmentType <- ['executionEnvironmentType_example'] # array[character] | Filter deployments based on the type of their execution environment.
    #' predictionEnvironmentPlatform <- ['predictionEnvironmentPlatform_example'] # array[character] | Filter deployments based on prediction environment platform
    #' hasDecisionFlow <- 'hasDecisionFlow_example' # character | Filter deployments based if it is a decision flow
    #' createdByMe <- 'createdByMe_example' # character | Filter deployments to those created by the current user.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsList(offset, limit, orderBy=orderBy, search=search, serviceHealth=serviceHealth, modelHealth=modelHealth, accuracyHealth=accuracyHealth, role=role, status=status, importance=importance, lastPredictionTimestampStart=lastPredictionTimestampStart, lastPredictionTimestampEnd=lastPredictionTimestampEnd, predictionUsageDailyAvgGreaterThan=predictionUsageDailyAvgGreaterThan, predictionUsageDailyAvgLessThan=predictionUsageDailyAvgLessThan, defaultPredictionServerId=defaultPredictionServerId, buildEnvironmentType=buildEnvironmentType, executionEnvironmentType=executionEnvironmentType, predictionEnvironmentPlatform=predictionEnvironmentPlatform, hasDecisionFlow=hasDecisionFlow, createdByMe=createdByMe)
    #' }
    DeploymentsList = function(offset, limit, orderBy = NULL, search = NULL, serviceHealth = NULL, modelHealth = NULL, accuracyHealth = NULL, role = NULL, status = NULL, importance = NULL, lastPredictionTimestampStart = NULL, lastPredictionTimestampEnd = NULL, predictionUsageDailyAvgGreaterThan = NULL, predictionUsageDailyAvgLessThan = NULL, defaultPredictionServerId = NULL, buildEnvironmentType = NULL, executionEnvironmentType = NULL, predictionEnvironmentPlatform = NULL, hasDecisionFlow = NULL, createdByMe = NULL, ...) {
      apiResponse <- private$DeploymentsListWithHttpInfo(offset, limit, orderBy, search, serviceHealth, modelHealth, accuracyHealth, role, status, importance, lastPredictionTimestampStart, lastPredictionTimestampEnd, predictionUsageDailyAvgGreaterThan, predictionUsageDailyAvgLessThan, defaultPredictionServerId, buildEnvironmentType, executionEnvironmentType, predictionEnvironmentPlatform, hasDecisionFlow, createdByMe, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Model Replacement.
    #' Produces: "application/json"
    #'
    #' @details Replace the model used to make predictions for the deployment. A validation process will be performed to make sure the new model is eligible as a replacement. If the validation fails, the model replacement will not occur.The Model Replacement Validation endpoint can be used to confirm the new model is eligible as a replacement.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/model/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param modelReplacementSubmission \link{ModelReplacementSubmission}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelReplacementValidationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' modelReplacementSubmission <- ModelReplacementSubmission$new() # ModelReplacementSubmission |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsModelPatchMany(deploymentId, modelReplacementSubmission=modelReplacementSubmission)
    #' }
    DeploymentsModelPatchMany = function(deploymentId, modelReplacementSubmission = NULL, ...) {
      apiResponse <- private$DeploymentsModelPatchManyWithHttpInfo(deploymentId, modelReplacementSubmission, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the secondary datasets configuration history for a deployment
    #' Produces: "application/json"
    #'
    #' @details List all the secondary datasets configuration used by a given Feature Discovery deployment
    #' @details This method invokes `GET /deployments/{deploymentId}/model/secondaryDatasetConfigurationHistory/` in the DataRobot Public API.
    #' @param offset integer. Number of items to skip. Defaults to 0 if not provided.
    #' @param limit integer. Number of items to return, defaults to 100 if not provided.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SecondaryDatasetsConfigListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Secondary Datasets Configuration history.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Number of items to skip. Defaults to 0 if not provided.
    #' limit <- 100 # integer | Number of items to return, defaults to 100 if not provided.
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsModelSecondaryDatasetConfigurationHistoryList(offset, limit, deploymentId)
    #' }
    DeploymentsModelSecondaryDatasetConfigurationHistoryList = function(offset, limit, deploymentId, ...) {
      apiResponse <- private$DeploymentsModelSecondaryDatasetConfigurationHistoryListWithHttpInfo(offset, limit, deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve secondary datasets configuration for a deployment.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the secondary datasets configuration used by a deployed Feature discovery model.
    #' @details This method invokes `GET /deployments/{deploymentId}/model/secondaryDatasetConfiguration/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SecondaryDatasetConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Secondary datasets configuration.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or secondary datasets configuration cannot be found for the deployed model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsModelSecondaryDatasetConfigurationList(deploymentId)
    #' }
    DeploymentsModelSecondaryDatasetConfigurationList = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsModelSecondaryDatasetConfigurationListWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the secondary datasets configuration for the deployed model.
    #' Produces: NA
    #'
    #' @details Update the secondary datasets configuration used by the deployed feature discovery model.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/model/secondaryDatasetConfiguration/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param secondaryDatasetConfigUpdate \link{SecondaryDatasetConfigUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Secondary Datasets Configuration updated successfully.
    #' \itemize{
    #' }
    #' \item **`403`** Invalid credentials for secondary datasets configuration.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' secondaryDatasetConfigUpdate <- SecondaryDatasetConfigUpdate$new() # SecondaryDatasetConfigUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsModelSecondaryDatasetConfigurationPatchMany(deploymentId, secondaryDatasetConfigUpdate=secondaryDatasetConfigUpdate)
    #' }
    DeploymentsModelSecondaryDatasetConfigurationPatchMany = function(deploymentId, secondaryDatasetConfigUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsModelSecondaryDatasetConfigurationPatchManyWithHttpInfo(deploymentId, secondaryDatasetConfigUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Model Replacement Validation.
    #' Produces: "application/json"
    #'
    #' @details Validate that a model can be used to replace the current model of the deployment.
    #' @details This method invokes `POST /deployments/{deploymentId}/model/validation/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param modelReplacementValidationRequest \link{ModelReplacementValidationRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelReplacementValidationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' modelReplacementValidationRequest <- ModelReplacementValidationRequest$new() # ModelReplacementValidationRequest |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsModelValidationCreate(deploymentId, modelReplacementValidationRequest=modelReplacementValidationRequest)
    #' }
    DeploymentsModelValidationCreate = function(deploymentId, modelReplacementValidationRequest = NULL, ...) {
      apiResponse <- private$DeploymentsModelValidationCreateWithHttpInfo(deploymentId, modelReplacementValidationRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for deleting deployment monitoring data.
    #' Produces: NA
    #'
    #' @details Delete deployment monitoring data.
    #' @details This method invokes `POST /deployments/{deploymentId}/monitoringDataDeletions/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param monitoringDataDeletePayload \link{MonitoringDataDeletePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or model not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' monitoringDataDeletePayload <- MonitoringDataDeletePayload$new() # MonitoringDataDeletePayload |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsMonitoringDataDeletionsCreate(deploymentId, monitoringDataDeletePayload=monitoringDataDeletePayload)
    #' }
    DeploymentsMonitoringDataDeletionsCreate = function(deploymentId, monitoringDataDeletePayload = NULL, ...) {
      apiResponse <- private$DeploymentsMonitoringDataDeletionsCreateWithHttpInfo(deploymentId, monitoringDataDeletePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add report to execution queue.
    #' Produces: NA
    #'
    #' @details Add report to execution queue.
    #' @details This method invokes `POST /deployments/{deploymentId}/onDemandReports/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param scheduledReportOnDemmand \link{ScheduledReportOnDemmand}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Scheduled report job was addded to execution.
    #' \itemize{
    #' \item **`Location`** URL to poll to track report generation has finished.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' scheduledReportOnDemmand <- ScheduledReportOnDemmand$new() # ScheduledReportOnDemmand |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsOnDemandReportsCreate(deploymentId, scheduledReportOnDemmand=scheduledReportOnDemmand)
    #' }
    DeploymentsOnDemandReportsCreate = function(deploymentId, scheduledReportOnDemmand = NULL, ...) {
      apiResponse <- private$DeploymentsOnDemandReportsCreateWithHttpInfo(deploymentId, scheduledReportOnDemmand, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update deployment
    #' Produces: NA
    #'
    #' @details Update a deployment&#39;s label and description.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentUpdate \link{DeploymentUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Deployment successfully updated
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentUpdate <- DeploymentUpdate$new() # DeploymentUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsPatch(deploymentId, deploymentUpdate=deploymentUpdate)
    #' }
    DeploymentsPatch = function(deploymentId, deploymentUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsPatchWithHttpInfo(deploymentId, deploymentUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Submit external deployment prediction data.
    #' Produces: NA
    #'
    #' @details Assigns prediction dataset to the external deployment to enable the analysis of historical model performance. Multiple datasets containing historical predictions for the external deployment can be uploaded. This requires one request for each dataset. For a regression deployment, predictions can be either an int or float. For a classification (binary/multiclass) deployment, predictions must be lists with each list containing probabilities for each class.
    #' @details This method invokes `POST /deployments/{deploymentId}/predictionInputs/fromDataset/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param predictionDatasetAssignment \link{PredictionDatasetAssignment}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Submitted successfully.
    #' \itemize{
    #' }
    #' \item **`405`** Data can only be uploaded to an external deployment.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process predictions upload.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' predictionDatasetAssignment <- PredictionDatasetAssignment$new() # PredictionDatasetAssignment |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsPredictionInputsFromDatasetCreate(deploymentId, predictionDatasetAssignment=predictionDatasetAssignment)
    #' }
    DeploymentsPredictionInputsFromDatasetCreate = function(deploymentId, predictionDatasetAssignment = NULL, ...) {
      apiResponse <- private$DeploymentsPredictionInputsFromDatasetCreateWithHttpInfo(deploymentId, predictionDatasetAssignment, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve predictions results.
    #' Produces: "application/json", "text/csv"
    #'
    #' @details Retrieve predictions results of the deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/predictionResults/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param modelId character. The id of the model for which prediction results are being retrieved.
    #' @param actualsPresent character. Filters predictions results to only those who have actuals present or with missing actuals.
    #' @param accept Enum < [application/json, text/csv] > Requested MIME type for the returned data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionResultsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' modelId <- 'modelId_example' # character | The id of the model for which prediction results are being retrieved.
    #' actualsPresent <- 'actualsPresent_example' # character | Filters predictions results to only those who have actuals present or with missing actuals.
    #' accept <- 'accept_example' # character | Requested MIME type for the returned data
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsPredictionResultsList(deploymentId, start=start, end=end, offset=offset, limit=limit, modelId=modelId, actualsPresent=actualsPresent, accept=accept)
    #' }
    DeploymentsPredictionResultsList = function(deploymentId, start = NULL, end = NULL, offset = 0, limit = 100, modelId = NULL, actualsPresent = NULL, accept = NULL, ...) {
      apiResponse <- private$DeploymentsPredictionResultsListWithHttpInfo(deploymentId, start, end, offset, limit, modelId, actualsPresent, accept, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute predictions synchronously
    #' Produces: "application/json"
    #'
    #' @details The route can be used for low-latency (hence synchronous) predictions. Scoring dataset, however, must be up to 50 MB and is limited by comma-delimited CSV and record oriented JSON. All other formats are not supported.
    #' @details This method invokes `POST /deployments/{deploymentId}/predictions/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param passthroughColumns list( character )
    #' @param passthroughColumnsSet Enum < [all] > If &#x60;passthroughColumnsSet&#x3D;all&#x60; is passed, all columns from the scoring dataset are returned in the prediction response. All other values for this parameter are invalid. Mutually exclusive with &#x60;passthroughColumns&#x60;.
    #' @param maxExplanations \link{OneOfintegerstring}. The maximum number of prediction explanations to supply per row of the dataset. The default &#x60;maxExplanations&#x60; is &#x60;3&#x60; when &#x60;xemp&#x60; based explanations are requested.  The default &#x60;maxExplanations&#x60; is &#x60;all&#x60; (no limit) when &#x60;shap&#x60; based explanations are requested.
    #' @param maxCodes \link{OneOfintegerstring}. Deprecated alias of &#x60;maxExplanations&#x60;.
    #' @param thresholdHigh numeric. The high threshold, above which a prediction must score in order for prediction explanations to be computed for a row in the dataset. If neither &#x60;thresholdHigh&#x60; nor &#x60;thresholdLow&#x60; is specified, prediction explanations will be computed for all rows. This option is ignored when &#x60;shap&#x60; based explanations are requested.
    #' @param thresholdLow numeric. The lower threshold, below which a prediction must score in order for prediction explanations to be computed for a row in the dataset. If neither &#x60;thresholdHigh&#x60; nor &#x60;thresholdLow&#x60; is specified, prediction explanations will be computed for all rows. This option is ignored when &#x60;shap&#x60; based explanations are requested.
    #' @param excludeAdjustedPredictions character. If &#x60;false&#x60;, include exposure-adjusted predictions in the response.
    #' @param forecastPoint character. The time in the dataset relative to which predictions are generated. If not specified the default value is the value in the row with the latest specified timestamp.
    #' @param predictionsStartDate character. The time in the dataset starting from which bulk predictions are generated. Should be defined together with &#x60;predictionsEndDate&#x60;. &#x60;forecastPoint&#x60; param can not be used if either &#x60;predictionsStartDate&#x60; or &#x60;predictionsEndDate&#x60; is passed.
    #' @param predictionsEndDate character. The time in the dataset until which bulk predictions are generated. Should be defined together with &#x60;predictionsStartDate&#x60;. &#x60;forecastPoint&#x60; param can not be used if either &#x60;predictionsStartDate&#x60; or &#x60;predictionsEndDate&#x60; is passed.
    #' @param relaxKnownInAdvanceFeaturesCheck character. If &#x60;true&#x60;, missing values in the known in advance features are allowed in the forecast window at the prediction time. If omitted or &#x60;false&#x60;, missing values are not allowed.
    #' @param predictionWarningEnabled character. If &#x60;true&#x60; is passed, predictions response will include &#x60;isOutlierPrediction&#x60; key for each record with result of outlier check.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionProxyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Predictions and/or prediction explanations
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' passthroughColumns <- ['passthroughColumns_example'] # array[character] | List of columns from a scoring dataset to return in the prediction response. If not specified, no columns will be present in the response. Mutually exclusive with `passthroughColumnsSet`.
    #' passthroughColumnsSet <- 'passthroughColumnsSet_example' # character | If `passthroughColumnsSet=all` is passed, all columns from the scoring dataset are returned in the prediction response. All other values for this parameter are invalid. Mutually exclusive with `passthroughColumns`.
    #' maxExplanations <- 'maxExplanations_example' # OneOfintegerstring | The maximum number of prediction explanations to supply per row of the dataset. The default `maxExplanations` is `3` when `xemp` based explanations are requested.  The default `maxExplanations` is `all` (no limit) when `shap` based explanations are requested.
    #' maxCodes <- 'maxCodes_example' # OneOfintegerstring | Deprecated alias of `maxExplanations`.
    #' thresholdHigh <- 3.4 # numeric | The high threshold, above which a prediction must score in order for prediction explanations to be computed for a row in the dataset. If neither `thresholdHigh` nor `thresholdLow` is specified, prediction explanations will be computed for all rows. This option is ignored when `shap` based explanations are requested.
    #' thresholdLow <- 3.4 # numeric | The lower threshold, below which a prediction must score in order for prediction explanations to be computed for a row in the dataset. If neither `thresholdHigh` nor `thresholdLow` is specified, prediction explanations will be computed for all rows. This option is ignored when `shap` based explanations are requested.
    #' excludeAdjustedPredictions <- TRUE # character | If `false`, include exposure-adjusted predictions in the response.
    #' forecastPoint <- 'forecastPoint_example' # character | The time in the dataset relative to which predictions are generated. If not specified the default value is the value in the row with the latest specified timestamp.
    #' predictionsStartDate <- 'predictionsStartDate_example' # character | The time in the dataset starting from which bulk predictions are generated. Should be defined together with `predictionsEndDate`. `forecastPoint` param can not be used if either `predictionsStartDate` or `predictionsEndDate` is passed.
    #' predictionsEndDate <- 'predictionsEndDate_example' # character | The time in the dataset until which bulk predictions are generated. Should be defined together with `predictionsStartDate`. `forecastPoint` param can not be used if either `predictionsStartDate` or `predictionsEndDate` is passed.
    #' relaxKnownInAdvanceFeaturesCheck <- 'relaxKnownInAdvanceFeaturesCheck_example' # character | If `true`, missing values in the known in advance features are allowed in the forecast window at the prediction time. If omitted or `false`, missing values are not allowed.
    #' predictionWarningEnabled <- 'predictionWarningEnabled_example' # character | If `true` is passed, predictions response will include `isOutlierPrediction` key for each record with result of outlier check.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsPredictionsCreate(deploymentId, passthroughColumns=passthroughColumns, passthroughColumnsSet=passthroughColumnsSet, maxExplanations=maxExplanations, maxCodes=maxCodes, thresholdHigh=thresholdHigh, thresholdLow=thresholdLow, excludeAdjustedPredictions=excludeAdjustedPredictions, forecastPoint=forecastPoint, predictionsStartDate=predictionsStartDate, predictionsEndDate=predictionsEndDate, relaxKnownInAdvanceFeaturesCheck=relaxKnownInAdvanceFeaturesCheck, predictionWarningEnabled=predictionWarningEnabled)
    #' }
    DeploymentsPredictionsCreate = function(deploymentId, passthroughColumns = NULL, passthroughColumnsSet = NULL, maxExplanations = NULL, maxCodes = NULL, thresholdHigh = NULL, thresholdLow = NULL, excludeAdjustedPredictions = TRUE, forecastPoint = NULL, predictionsStartDate = NULL, predictionsEndDate = NULL, relaxKnownInAdvanceFeaturesCheck = NULL, predictionWarningEnabled = NULL, ...) {
      apiResponse <- private$DeploymentsPredictionsCreateWithHttpInfo(deploymentId, passthroughColumns, passthroughColumnsSet, maxExplanations, maxCodes, thresholdHigh, thresholdLow, excludeAdjustedPredictions, forecastPoint, predictionsStartDate, predictionsEndDate, relaxKnownInAdvanceFeaturesCheck, predictionWarningEnabled, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for creating a deployment retraining policy.
    #' Produces: "application/json"
    #'
    #' @details Create a deployment retraining policy.
    #' @details This method invokes `POST /deployments/{deploymentId}/retrainingPolicies/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyCreate \link{RetrainingPolicyCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Deployment not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyCreate <- RetrainingPolicyCreate$new() # RetrainingPolicyCreate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesCreate(deploymentId, retrainingPolicyCreate=retrainingPolicyCreate)
    #' }
    DeploymentsRetrainingPoliciesCreate = function(deploymentId, retrainingPolicyCreate = NULL, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesCreateWithHttpInfo(deploymentId, retrainingPolicyCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for deleting a deployment retraining policy.
    #' Produces: NA
    #'
    #' @details Delete a deployment retraining policy.
    #' @details This method invokes `DELETE /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Delete a deployment retraining policy.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesDelete(deploymentId, retrainingPolicyId)
    #' }
    DeploymentsRetrainingPoliciesDelete = function(deploymentId, retrainingPolicyId, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesDeleteWithHttpInfo(deploymentId, retrainingPolicyId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for fetching a list of deployment retraining policies.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of deployment retraining policies.
    #' @details This method invokes `GET /deployments/{deploymentId}/retrainingPolicies/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a list of deployment retraining policies.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesList(deploymentId, offset=offset, limit=limit)
    #' }
    DeploymentsRetrainingPoliciesList = function(deploymentId, offset = 0, limit = 100, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesListWithHttpInfo(deploymentId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for updating a deployment retraining policy.
    #' Produces: "application/json"
    #'
    #' @details Update a deployment retraining policy.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param retrainingPolicyUpdate \link{RetrainingPolicyUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #' retrainingPolicyUpdate <- RetrainingPolicyUpdate$new() # RetrainingPolicyUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesPatch(deploymentId, retrainingPolicyId, retrainingPolicyUpdate=retrainingPolicyUpdate)
    #' }
    DeploymentsRetrainingPoliciesPatch = function(deploymentId, retrainingPolicyId, retrainingPolicyUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesPatchWithHttpInfo(deploymentId, retrainingPolicyId, retrainingPolicyUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for fetching a deployment retraining policy.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a deployment retraining policy.
    #' @details This method invokes `GET /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a deployment retraining policy.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesRetrieve(deploymentId, retrainingPolicyId)
    #' }
    DeploymentsRetrainingPoliciesRetrieve = function(deploymentId, retrainingPolicyId, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesRetrieveWithHttpInfo(deploymentId, retrainingPolicyId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for initiating a deployment retraining policy run.
    #' Produces: NA
    #'
    #' @details Initiate a deployment retraining policy run.
    #' @details This method invokes `POST /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesRunsCreate(deploymentId, retrainingPolicyId)
    #' }
    DeploymentsRetrainingPoliciesRunsCreate = function(deploymentId, retrainingPolicyId, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesRunsCreateWithHttpInfo(deploymentId, retrainingPolicyId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for fetching a list of deployment retraining policy runs.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of deployment retraining policy runs.
    #' @details This method invokes `GET /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRunListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a list of deployment retraining policy runs.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesRunsList(deploymentId, retrainingPolicyId, offset=offset, limit=limit)
    #' }
    DeploymentsRetrainingPoliciesRunsList = function(deploymentId, retrainingPolicyId, offset = 0, limit = 100, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesRunsListWithHttpInfo(deploymentId, retrainingPolicyId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for updating a single deployment retraining policy run.
    #' Produces: "application/json"
    #'
    #' @details Update a single deployment retraining policy run.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/{runId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param runId character. ID of the retraining policy run.
    #' @param retrainingPolicyRunUpdate \link{RetrainingPolicyRunUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRunRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Update a single deployment retraining policy run.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #' runId <- 'runId_example' # character | ID of the retraining policy run.
    #' retrainingPolicyRunUpdate <- RetrainingPolicyRunUpdate$new() # RetrainingPolicyRunUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesRunsPatch(deploymentId, retrainingPolicyId, runId, retrainingPolicyRunUpdate=retrainingPolicyRunUpdate)
    #' }
    DeploymentsRetrainingPoliciesRunsPatch = function(deploymentId, retrainingPolicyId, runId, retrainingPolicyRunUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesRunsPatchWithHttpInfo(deploymentId, retrainingPolicyId, runId, retrainingPolicyRunUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for fetching a single deployment retraining policy run.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a single deployment retraining policy run.
    #' @details This method invokes `GET /deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/{runId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingPolicyId character. ID of the retraining policy.
    #' @param runId character. ID of the retraining policy run.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingPolicyRunRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a single deployment retraining policy run.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment or retraining policy not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingPolicyId <- 'retrainingPolicyId_example' # character | ID of the retraining policy.
    #' runId <- 'runId_example' # character | ID of the retraining policy run.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingPoliciesRunsRetrieve(deploymentId, retrainingPolicyId, runId)
    #' }
    DeploymentsRetrainingPoliciesRunsRetrieve = function(deploymentId, retrainingPolicyId, runId, ...) {
      apiResponse <- private$DeploymentsRetrainingPoliciesRunsRetrieveWithHttpInfo(deploymentId, retrainingPolicyId, runId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for fetching deployment retraining settings.
    #' Produces: "application/json"
    #'
    #' @details Retrieve deployment retraining settings.
    #' @details This method invokes `GET /deployments/{deploymentId}/retrainingSettings/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RetrainingSettingsRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve deployment retraining settings.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingSettingsList(deploymentId)
    #' }
    DeploymentsRetrainingSettingsList = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsRetrainingSettingsListWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Endpoint for updating deployment retraining settings.
    #' Produces: NA
    #'
    #' @details Update deployment retraining settings.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/retrainingSettings/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param retrainingSettingsUpdate \link{RetrainingSettingsUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Update deployment retraining settings.
    #' \itemize{
    #' }
    #' \item **`404`** Deployment not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' retrainingSettingsUpdate <- RetrainingSettingsUpdate$new() # RetrainingSettingsUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrainingSettingsPatchMany(deploymentId, retrainingSettingsUpdate=retrainingSettingsUpdate)
    #' }
    DeploymentsRetrainingSettingsPatchMany = function(deploymentId, retrainingSettingsUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsRetrainingSettingsPatchManyWithHttpInfo(deploymentId, retrainingSettingsUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve deployment
    #' Produces: "application/json"
    #'
    #' @details Retrieve a deployment.
    #' @details This method invokes `GET /deployments/{deploymentId}/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The deployment
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsRetrieve(deploymentId)
    #' }
    DeploymentsRetrieve = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsRetrieveWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Build Java package containing Scoring Code with agent integration.
    #' Produces: NA
    #'
    #' @details Build Java package containing Scoring Code with agent integration.
    #' @details This method invokes `POST /deployments/{deploymentId}/scoringCodeBuilds/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentsScoringCodeBuildPayload \link{DeploymentsScoringCodeBuildPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentsScoringCodeBuildPayload <- DeploymentsScoringCodeBuildPayload$new() # DeploymentsScoringCodeBuildPayload |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsScoringCodeBuildsCreate(deploymentId, deploymentsScoringCodeBuildPayload=deploymentsScoringCodeBuildPayload)
    #' }
    DeploymentsScoringCodeBuildsCreate = function(deploymentId, deploymentsScoringCodeBuildPayload = NULL, ...) {
      apiResponse <- private$DeploymentsScoringCodeBuildsCreateWithHttpInfo(deploymentId, deploymentsScoringCodeBuildPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Scoring Code
    #' Produces: NA
    #'
    #' @details Retrieve Scoring Code of the current deployed model for making predictions outside of a DataRobot prediction server. You need the \&quot;Scoring Code\&quot; feature enabled to use this route.  By default, returns a compiled executable JAR that can be executed locally to calculate model predictions, or it can be used as a library for a Java application. Execute it with the &#39;--help\\&#x60; parameters to learn how to use it as a command-line utility. See model API documentation at &lt;https://javadoc.io/doc/com.datarobot/datarobot-prediction/latest/index.html&gt; to be able to use it inside an existing Java application.  With sourceCode query parameter set to &#39;true&#39;, returns a source code archive that can be used to review internal calculations of the model. This JAR is NOT executable.  See \&quot;&lt;https://app.datarobot.com/docs/predictions/scoring-code/scorecode.html&gt;\&quot; documentation in DataRobot application for more information.  *Note* Cannot retrieve source code if agent is included.
    #' @details This method invokes `GET /deployments/{deploymentId}/scoringCode/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param sourceCode Enum < [false, False, true, True] > Whether source code or binary of the Scoring Code will be retrieved
    #' @param includeAgent Enum < [false, False, true, True] > Whether the Scoring code retrieved will include tracking agent
    #' @param includePe Enum < [false, False, true, True] > Please use includePredictionExplanations parameter instead
    #' @param includePredictionExplanations Enum < [false, False, true, True] > Whether the Scoring Code retrieved will include prediction explanations
    #' @param includePredictionIntervals Enum < [false, False, true, True] > Whether the Scoring Code retrieved will include prediction intervals
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** JAR file
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Indicating the content is supposed to be downloaded as an attachment
    #' \item **`ContentMinusType`** application/java-archive
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' sourceCode <- "false" # character | Whether source code or binary of the Scoring Code will be retrieved
    #' includeAgent <- "false" # character | Whether the Scoring code retrieved will include tracking agent
    #' includePe <- "false" # character | Please use includePredictionExplanations parameter instead
    #' includePredictionExplanations <- "false" # character | Whether the Scoring Code retrieved will include prediction explanations
    #' includePredictionIntervals <- "false" # character | Whether the Scoring Code retrieved will include prediction intervals
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsScoringCodeList(deploymentId, sourceCode=sourceCode, includeAgent=includeAgent, includePe=includePe, includePredictionExplanations=includePredictionExplanations, includePredictionIntervals=includePredictionIntervals)
    #' }
    DeploymentsScoringCodeList = function(deploymentId, sourceCode = "false", includeAgent = "false", includePe = "false", includePredictionExplanations = "false", includePredictionIntervals = "false", ...) {
      apiResponse <- private$DeploymentsScoringCodeListWithHttpInfo(deploymentId, sourceCode, includeAgent, includePe, includePredictionExplanations, includePredictionIntervals, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve service statistics
    #' Produces: "application/json"
    #'
    #' @details Retrieve deployment service health statistics overview.
    #' @details This method invokes `GET /deployments/{deploymentId}/serviceStats/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param segmentAttribute Enum < [DataRobot-Consumer, DataRobot-Remote-IP, DataRobot-Host-IP] > The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param modelId character. The id of the model for which metrics are being retrieved.
    #' @param executionTimeQuantile numeric. Quantile for &#x60;executionTime&#x60; metric, defaults to 0.5.
    #' @param responseTimeQuantile numeric. Quantile for &#x60;responseTime&#x60; metric, defaults to 0.5.
    #' @param slowRequestsThreshold integer. Threshold for &#x60;slowRequests&#x60; metric, defaults to 1000.
    #' @param monitoringType Enum < [serviceHealth, dataDrift, accuracy, humility] > The monitoring type for which segment attributes and segment values are being retrieved. Can be one of three options which corresponds to a deployment monitoring tab
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ServiceStatsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Service health statistics overview retrieved.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' modelId <- 'modelId_example' # character | The id of the model for which metrics are being retrieved.
    #' executionTimeQuantile <- 0.5 # numeric | Quantile for `executionTime` metric, defaults to 0.5.
    #' responseTimeQuantile <- 0.5 # numeric | Quantile for `responseTime` metric, defaults to 0.5.
    #' slowRequestsThreshold <- 1000 # integer | Threshold for `slowRequests` metric, defaults to 1000.
    #' monitoringType <- "serviceHealth" # character | The monitoring type for which segment attributes and segment values are being retrieved. Can be one of three options which corresponds to a deployment monitoring tab
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsServiceStatsList(deploymentId, start=start, end=end, bucketSize=bucketSize, segmentAttribute=segmentAttribute, segmentValue=segmentValue, modelId=modelId, executionTimeQuantile=executionTimeQuantile, responseTimeQuantile=responseTimeQuantile, slowRequestsThreshold=slowRequestsThreshold, monitoringType=monitoringType)
    #' }
    DeploymentsServiceStatsList = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, executionTimeQuantile = 0.5, responseTimeQuantile = 0.5, slowRequestsThreshold = 1000, monitoringType = "serviceHealth", ...) {
      apiResponse <- private$DeploymentsServiceStatsListWithHttpInfo(deploymentId, start, end, bucketSize, segmentAttribute, segmentValue, modelId, executionTimeQuantile, responseTimeQuantile, slowRequestsThreshold, monitoringType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve service statistics over time
    #' Produces: "application/json"
    #'
    #' @details Retrieve deployment service health statistics over time data for one single metric.
    #' @details This method invokes `GET /deployments/{deploymentId}/serviceStatsOverTime/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param bucketSize character. The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' @param metric Enum < [totalPredictions, totalRequests, slowRequests, executionTime, responseTime, userErrorRate, serverErrorRate, numConsumers, cacheHitRatio, medianLoad, peakLoad] > Name of the metric. See below for a list of supported metrics.
    #' @param quantile numeric. A quantile for resulting data, used if &#x60;metric&#x60; is &#x60;executionTime&#x60; or &#x60;responseTime&#x60;, defaults to 0.5.
    #' @param threshold integer. A threshold for filtering results, used if &#x60;metric&#x60; is &#x60;slowQueries&#x60;, defaults to 1000.
    #' @param segmentAttribute Enum < [DataRobot-Consumer, DataRobot-Remote-IP, DataRobot-Host-IP] > The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param modelId character. The id of the model for which metrics are being retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ServiceStatsOverTimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Service health statistics for metric retrieved.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' bucketSize <- 'bucketSize_example' # character | The time duration of a bucket. Needs to be multiple of one hour. Can not be longer than the total length of the period. If not set, a default value will be calculated based on the start and end time.
    #' metric <- "totalPredictions" # character | Name of the metric. See below for a list of supported metrics.
    #' quantile <- 3.4 # numeric | A quantile for resulting data, used if `metric` is `executionTime` or `responseTime`, defaults to 0.5.
    #' threshold <- 56 # integer | A threshold for filtering results, used if `metric` is `slowQueries`, defaults to 1000.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #' modelId <- 'modelId_example' # character | The id of the model for which metrics are being retrieved.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsServiceStatsOverTimeList(deploymentId, start=start, end=end, bucketSize=bucketSize, metric=metric, quantile=quantile, threshold=threshold, segmentAttribute=segmentAttribute, segmentValue=segmentValue, modelId=modelId)
    #' }
    DeploymentsServiceStatsOverTimeList = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, metric = "totalPredictions", quantile = NULL, threshold = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      apiResponse <- private$DeploymentsServiceStatsOverTimeListWithHttpInfo(deploymentId, start, end, bucketSize, metric, quantile, threshold, segmentAttribute, segmentValue, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get deployment settings
    #' Produces: "application/json"
    #'
    #' @details Retrieve deployment settings.
    #' @details This method invokes `GET /deployments/{deploymentId}/settings/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentSettingsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The deployment settings
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or the user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsSettingsList(deploymentId)
    #' }
    DeploymentsSettingsList = function(deploymentId, ...) {
      apiResponse <- private$DeploymentsSettingsListWithHttpInfo(deploymentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update deployment settings
    #' Produces: NA
    #'
    #' @details Updates deployment settings.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/settings/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentSettingsUpdate \link{DeploymentSettingsUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted.  See Location header.
    #' \itemize{
    #' \item **`Location`** the location to poll for settings update status
    #' }
    #' \item **`403`** User can view deployment but does not have permission to update settings.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or the user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' \item **`409`** The proposed settings changes are invalid and would result in a logical conflict.
    #' \itemize{
    #' }
    #' \item **`422`** The provided settings changes could not be processed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentSettingsUpdate <- DeploymentSettingsUpdate$new() # DeploymentSettingsUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsSettingsPatchMany(deploymentId, deploymentSettingsUpdate=deploymentSettingsUpdate)
    #' }
    DeploymentsSettingsPatchMany = function(deploymentId, deploymentSettingsUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsSettingsPatchManyWithHttpInfo(deploymentId, deploymentSettingsUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get model deployment&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations who have access to this deployment and their roles.
    #' @details This method invokes `GET /deployments/{deploymentId}/sharedRoles/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param deploymentId character. The deployment ID.
    #' @param id character. Only return roles for a user, group or organization with this identifier.
    #' @param name character. Only return roles for a user, group or organization with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > List access controls for recipients with this type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharingListV2Response}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or the user does not have permissions to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 10 # integer | At most this many results are returned
    #' deploymentId <- 'deploymentId_example' # character | The deployment ID.
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsSharedRolesList(offset, limit, deploymentId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    DeploymentsSharedRolesList = function(offset, limit, deploymentId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$DeploymentsSharedRolesListWithHttpInfo(offset, limit, deploymentId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update model deployment&#39;s controls
    #' Produces: NA
    #'
    #' @details Set roles for users on this model deployment.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/sharedRoles/` in the DataRobot Public API.
    #' @param deploymentId character. The deployment ID.
    #' @param sharedRolesUpdateWithGrant \link{SharedRolesUpdateWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the project without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | The deployment ID.
    #' sharedRolesUpdateWithGrant <- SharedRolesUpdateWithGrant$new() # SharedRolesUpdateWithGrant |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsSharedRolesPatchMany(deploymentId, sharedRolesUpdateWithGrant=sharedRolesUpdateWithGrant)
    #' }
    DeploymentsSharedRolesPatchMany = function(deploymentId, sharedRolesUpdateWithGrant = NULL, ...) {
      apiResponse <- private$DeploymentsSharedRolesPatchManyWithHttpInfo(deploymentId, sharedRolesUpdateWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Change deployment status
    #' Produces: NA
    #'
    #' @details Change deployment status.
    #' @details This method invokes `PATCH /deployments/{deploymentId}/status/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param deploymentStatusUpdate \link{DeploymentStatusUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`409`** Deployment is already in process of status change or already in requested status.
    #' \itemize{
    #' }
    #' \item **`422`** Deployment status change request could not be processed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' deploymentStatusUpdate <- DeploymentStatusUpdate$new() # DeploymentStatusUpdate |
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsStatusPatchMany(deploymentId, deploymentStatusUpdate=deploymentStatusUpdate)
    #' }
    DeploymentsStatusPatchMany = function(deploymentId, deploymentStatusUpdate = NULL, ...) {
      apiResponse <- private$DeploymentsStatusPatchManyWithHttpInfo(deploymentId, deploymentStatusUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve target drift
    #' Produces: "application/json"
    #'
    #' @details Retrieve target drift data.
    #' @details This method invokes `GET /deployments/{deploymentId}/targetDrift/` in the DataRobot Public API.
    #' @param deploymentId character. Unique identifier of the deployment.
    #' @param start character. RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param end character. RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: &#x60;&#x60;2019-08-01T00:00:00Z&#x60;&#x60;.
    #' @param modelId character. An ID of the model in the deployment. If not set, defaults to the deployment current model.
    #' @param metric Enum < [psi, kl_divergence, dissimilarity, hellinger, js_divergence] > Metric used to calculate drift score.
    #' @param segmentAttribute character. The name of a segment attribute used for segment analysis.
    #' @param segmentValue character. The value of the &#x60;segmentAttribute&#x60; to segment on.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeploymentTargetDriftResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Target drift over specified time period retrieved.
    #' \itemize{
    #' }
    #' \item **`400`** Request invalid, refer to messages for detail.
    #' \itemize{
    #' }
    #' \item **`403`** Model Deployments and/or Monitoring are not enabled.
    #' \itemize{
    #' }
    #' \item **`404`** Either the deployment does not exist or user does not have permission to view the deployment.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' deploymentId <- 'deploymentId_example' # character | Unique identifier of the deployment.
    #' start <- 'start_example' # character | RFC3339 datetime. Start of time period to retrieve the features drift for. If not set, defaults to 1 week from the end of the period.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' end <- 'end_example' # character | RFC3339 datetime. End of time period to retrieve the features drift for. If not set, defaults to the next top of the hour from now.Note: this field only accepts top of the hour RFC3339 datetime strings For example: ``2019-08-01T00:00:00Z``.
    #' modelId <- 'modelId_example' # character | An ID of the model in the deployment. If not set, defaults to the deployment current model.
    #' metric <- "psi" # character | Metric used to calculate drift score.
    #' segmentAttribute <- 'segmentAttribute_example' # character | The name of a segment attribute used for segment analysis.
    #' segmentValue <- "" # character | The value of the `segmentAttribute` to segment on.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$DeploymentsTargetDriftList(deploymentId, start=start, end=end, modelId=modelId, metric=metric, segmentAttribute=segmentAttribute, segmentValue=segmentValue)
    #' }
    DeploymentsTargetDriftList = function(deploymentId, start = NULL, end = NULL, modelId = NULL, metric = "psi", segmentAttribute = NULL, segmentValue = "", ...) {
      apiResponse <- private$DeploymentsTargetDriftListWithHttpInfo(deploymentId, start, end, modelId, metric, segmentAttribute, segmentValue, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List prediction servers.
    #' Produces: "application/json"
    #'
    #' @details List prediction servers available for a user.
    #' @details This method invokes `GET /predictionServers/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionServerListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #'
    #' api.instance <- DeploymentsApi$new()
    #' result <- api.instance$PredictionServersList(offset=offset, limit=limit)
    #' }
    PredictionServersList = function(offset = 0, limit = 100, ...) {
      apiResponse <- private$PredictionServersListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `DeletedDeploymentsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeletedDeploymentsListWithHttpInfo = function(offset, limit, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/deletedDeployments/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeletedDeploymentListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeletedDeploymentsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeletedDeploymentsPatchManyWithHttpInfo = function(deploymentPermanentDelete = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`deploymentPermanentDelete`) && isa(deploymentPermanentDelete, c("DeploymentPermanentDelete", "R6"))) {
        body <- `deploymentPermanentDelete`$toJSON()
      } else {
        stop("DeletedDeploymentsPatchManyWithHttpInfo requires parameter deploymentPermanentDelete to be of type DeploymentPermanentDelete.")
      }

      urlPath <- "/deletedDeployments/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsAccuracyList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsAccuracyListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, modelId = NULL, segmentAttribute = NULL, segmentValue = "", targetClasses = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["modelId"] <- modelId

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["targetClasses"] <- targetClasses

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/accuracy/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AccuracyRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsAccuracyOverTimeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsAccuracyOverTimeListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, modelId = NULL, metric = NULL, segmentAttribute = NULL, segmentValue = "", targetClasses = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["modelId"] <- modelId

      queryParams["metric"] <- metric

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["targetClasses"] <- targetClasses

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/accuracyOverTime/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AccuracyOverTimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsActualsFromDatasetCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsActualsFromDatasetCreateWithHttpInfo = function(deploymentId, deploymentDatasetCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentDatasetCreate`) && isa(deploymentDatasetCreate, c("DeploymentDatasetCreate", "R6"))) {
        body <- `deploymentDatasetCreate`$toJSON()
      } else {
        stop("DeploymentsActualsFromDatasetCreateWithHttpInfo requires parameter deploymentDatasetCreate to be of type DeploymentDatasetCreate.")
      }

      urlPath <- "/deployments/{deploymentId}/actuals/fromDataset/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsActualsFromJSONCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsActualsFromJSONCreateWithHttpInfo = function(deploymentId, deploymentActuals = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentActuals`) && isa(deploymentActuals, c("DeploymentActuals", "R6"))) {
        body <- `deploymentActuals`$toJSON()
      } else {
        stop("DeploymentsActualsFromJSONCreateWithHttpInfo requires parameter deploymentActuals to be of type DeploymentActuals.")
      }

      urlPath <- "/deployments/{deploymentId}/actuals/fromJSON/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsCapabilitiesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsCapabilitiesListWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/capabilities/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentCapabilitiesRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengerPredictionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengerPredictionsCreateWithHttpInfo = function(deploymentId, challengerScore = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`challengerScore`) && isa(challengerScore, c("ChallengerScore", "R6"))) {
        body <- `challengerScore`$toJSON()
      } else {
        stop("DeploymentsChallengerPredictionsCreateWithHttpInfo requires parameter challengerScore to be of type ChallengerScore.")
      }

      urlPath <- "/deployments/{deploymentId}/challengerPredictions/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengersCreateWithHttpInfo = function(deploymentId, challengerCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`challengerCreate`) && isa(challengerCreate, c("ChallengerCreate", "R6"))) {
        body <- `challengerCreate`$toJSON()
      } else {
        stop("DeploymentsChallengersCreateWithHttpInfo requires parameter challengerCreate to be of type ChallengerCreate.")
      }

      urlPath <- "/deployments/{deploymentId}/challengers/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengersDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengersDeleteWithHttpInfo = function(deploymentId, challengerId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`challengerId`)) {
        stop("Missing required parameter `challengerId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/challengers/{challengerId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`challengerId`)) {
        urlPath <- gsub(paste0("\\{", "challengerId", "\\}"), URLencode(as.character(`challengerId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengersListWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/challengers/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ChallengerListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengersPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengersPatchWithHttpInfo = function(deploymentId, challengerId, challengerUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`challengerId`)) {
        stop("Missing required parameter `challengerId`.")
      }

      if (!missing(`challengerUpdate`) && isa(challengerUpdate, c("ChallengerUpdate", "R6"))) {
        body <- `challengerUpdate`$toJSON()
      } else {
        stop("DeploymentsChallengersPatchWithHttpInfo requires parameter challengerUpdate to be of type ChallengerUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/challengers/{challengerId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`challengerId`)) {
        urlPath <- gsub(paste0("\\{", "challengerId", "\\}"), URLencode(as.character(`challengerId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ChallengerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsChallengersRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsChallengersRetrieveWithHttpInfo = function(deploymentId, challengerId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`challengerId`)) {
        stop("Missing required parameter `challengerId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/challengers/{challengerId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`challengerId`)) {
        urlPath <- gsub(paste0("\\{", "challengerId", "\\}"), URLencode(as.character(`challengerId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ChallengerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsDeleteWithHttpInfo = function(deploymentId, ignoreManagementAgent = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["ignoreManagementAgent"] <- ignoreManagementAgent

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsFeatureDriftList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsFeatureDriftListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, modelId = NULL, metric = "psi", offset = 0, limit = 200, segmentAttribute = NULL, segmentValue = "", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["modelId"] <- modelId

      queryParams["metric"] <- metric

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/featureDrift/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentFeatureDriftResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsFeatureDriftOverTimeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsFeatureDriftOverTimeListWithHttpInfo = function(featureNames, deploymentId, start = NULL, end = NULL, bucketSize = NULL, modelId = NULL, metric = "psi", segmentAttribute = NULL, segmentValue = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`featureNames`)) {
        stop("Missing required parameter `featureNames`.")
      }

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["modelId"] <- modelId

      if (!is.null(featureNames)) {
        queryParams["featureNames"] <- paste0(featureNames, collapse = ",")
      }

      queryParams["metric"] <- metric

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/featureDriftOverTime/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureDriftOverTimeRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsFeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsFeaturesListWithHttpInfo = function(offset, limit, deploymentId, includeNonPredictionFeatures = "false", forSegmentedAnalysis = "false", search = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["includeNonPredictionFeatures"] <- includeNonPredictionFeatures

      queryParams["forSegmentedAnalysis"] <- forSegmentedAnalysis

      queryParams["search"] <- search

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/features/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsFromLearningModelCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsFromLearningModelCreateWithHttpInfo = function(deploymentCreateFromLearningModel = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`deploymentCreateFromLearningModel`) && isa(deploymentCreateFromLearningModel, c("DeploymentCreateFromLearningModel", "R6"))) {
        body <- `deploymentCreateFromLearningModel`$toJSON()
      } else {
        stop("DeploymentsFromLearningModelCreateWithHttpInfo requires parameter deploymentCreateFromLearningModel to be of type DeploymentCreateFromLearningModel.")
      }

      urlPath <- "/deployments/fromLearningModel/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsHumilityStatsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsHumilityStatsListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/humilityStats/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "HumilityStatsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsHumilityStatsOverTimeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsHumilityStatsOverTimeListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/humilityStatsOverTime/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "HumilityStatsOverTimeRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsListWithHttpInfo = function(offset, limit, orderBy = NULL, search = NULL, serviceHealth = NULL, modelHealth = NULL, accuracyHealth = NULL, role = NULL, status = NULL, importance = NULL, lastPredictionTimestampStart = NULL, lastPredictionTimestampEnd = NULL, predictionUsageDailyAvgGreaterThan = NULL, predictionUsageDailyAvgLessThan = NULL, defaultPredictionServerId = NULL, buildEnvironmentType = NULL, executionEnvironmentType = NULL, predictionEnvironmentPlatform = NULL, hasDecisionFlow = NULL, createdByMe = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["search"] <- search

      if (!is.null(serviceHealth)) {
        queryParams["serviceHealth"] <- paste0(serviceHealth, collapse = ",")
      }

      if (!is.null(modelHealth)) {
        queryParams["modelHealth"] <- paste0(modelHealth, collapse = ",")
      }

      if (!is.null(accuracyHealth)) {
        queryParams["accuracyHealth"] <- paste0(accuracyHealth, collapse = ",")
      }

      queryParams["role"] <- role

      if (!is.null(status)) {
        queryParams["status"] <- paste0(status, collapse = ",")
      }

      if (!is.null(importance)) {
        queryParams["importance"] <- paste0(importance, collapse = ",")
      }

      queryParams["lastPredictionTimestampStart"] <- lastPredictionTimestampStart

      queryParams["lastPredictionTimestampEnd"] <- lastPredictionTimestampEnd

      queryParams["predictionUsageDailyAvgGreaterThan"] <- predictionUsageDailyAvgGreaterThan

      queryParams["predictionUsageDailyAvgLessThan"] <- predictionUsageDailyAvgLessThan

      if (!is.null(defaultPredictionServerId)) {
        queryParams["defaultPredictionServerId"] <- paste0(defaultPredictionServerId, collapse = ",")
      }

      if (!is.null(buildEnvironmentType)) {
        queryParams["buildEnvironmentType"] <- paste0(buildEnvironmentType, collapse = ",")
      }

      if (!is.null(executionEnvironmentType)) {
        queryParams["executionEnvironmentType"] <- paste0(executionEnvironmentType, collapse = ",")
      }

      if (!is.null(predictionEnvironmentPlatform)) {
        queryParams["predictionEnvironmentPlatform"] <- paste0(predictionEnvironmentPlatform, collapse = ",")
      }

      queryParams["hasDecisionFlow"] <- hasDecisionFlow

      queryParams["createdByMe"] <- createdByMe

      body <- NULL
      urlPath <- "/deployments/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsModelPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsModelPatchManyWithHttpInfo = function(deploymentId, modelReplacementSubmission = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`modelReplacementSubmission`) && isa(modelReplacementSubmission, c("ModelReplacementSubmission", "R6"))) {
        body <- `modelReplacementSubmission`$toJSON()
      } else {
        stop("DeploymentsModelPatchManyWithHttpInfo requires parameter modelReplacementSubmission to be of type ModelReplacementSubmission.")
      }

      urlPath <- "/deployments/{deploymentId}/model/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelReplacementValidationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsModelSecondaryDatasetConfigurationHistoryList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsModelSecondaryDatasetConfigurationHistoryListWithHttpInfo = function(offset, limit, deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/model/secondaryDatasetConfigurationHistory/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SecondaryDatasetsConfigListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsModelSecondaryDatasetConfigurationList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsModelSecondaryDatasetConfigurationListWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/model/secondaryDatasetConfiguration/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SecondaryDatasetConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsModelSecondaryDatasetConfigurationPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsModelSecondaryDatasetConfigurationPatchManyWithHttpInfo = function(deploymentId, secondaryDatasetConfigUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`secondaryDatasetConfigUpdate`) && isa(secondaryDatasetConfigUpdate, c("SecondaryDatasetConfigUpdate", "R6"))) {
        body <- `secondaryDatasetConfigUpdate`$toJSON()
      } else {
        stop("DeploymentsModelSecondaryDatasetConfigurationPatchManyWithHttpInfo requires parameter secondaryDatasetConfigUpdate to be of type SecondaryDatasetConfigUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/model/secondaryDatasetConfiguration/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsModelValidationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsModelValidationCreateWithHttpInfo = function(deploymentId, modelReplacementValidationRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`modelReplacementValidationRequest`) && isa(modelReplacementValidationRequest, c("ModelReplacementValidationRequest", "R6"))) {
        body <- `modelReplacementValidationRequest`$toJSON()
      } else {
        stop("DeploymentsModelValidationCreateWithHttpInfo requires parameter modelReplacementValidationRequest to be of type ModelReplacementValidationRequest.")
      }

      urlPath <- "/deployments/{deploymentId}/model/validation/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelReplacementValidationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsMonitoringDataDeletionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsMonitoringDataDeletionsCreateWithHttpInfo = function(deploymentId, monitoringDataDeletePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`monitoringDataDeletePayload`) && isa(monitoringDataDeletePayload, c("MonitoringDataDeletePayload", "R6"))) {
        body <- `monitoringDataDeletePayload`$toJSON()
      } else {
        stop("DeploymentsMonitoringDataDeletionsCreateWithHttpInfo requires parameter monitoringDataDeletePayload to be of type MonitoringDataDeletePayload.")
      }

      urlPath <- "/deployments/{deploymentId}/monitoringDataDeletions/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsOnDemandReportsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsOnDemandReportsCreateWithHttpInfo = function(deploymentId, scheduledReportOnDemmand = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`scheduledReportOnDemmand`) && isa(scheduledReportOnDemmand, c("ScheduledReportOnDemmand", "R6"))) {
        body <- `scheduledReportOnDemmand`$toJSON()
      } else {
        stop("DeploymentsOnDemandReportsCreateWithHttpInfo requires parameter scheduledReportOnDemmand to be of type ScheduledReportOnDemmand.")
      }

      urlPath <- "/deployments/{deploymentId}/onDemandReports/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsPatchWithHttpInfo = function(deploymentId, deploymentUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentUpdate`) && isa(deploymentUpdate, c("DeploymentUpdate", "R6"))) {
        body <- `deploymentUpdate`$toJSON()
      } else {
        stop("DeploymentsPatchWithHttpInfo requires parameter deploymentUpdate to be of type DeploymentUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsPredictionInputsFromDatasetCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsPredictionInputsFromDatasetCreateWithHttpInfo = function(deploymentId, predictionDatasetAssignment = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`predictionDatasetAssignment`) && isa(predictionDatasetAssignment, c("PredictionDatasetAssignment", "R6"))) {
        body <- `predictionDatasetAssignment`$toJSON()
      } else {
        stop("DeploymentsPredictionInputsFromDatasetCreateWithHttpInfo requires parameter predictionDatasetAssignment to be of type PredictionDatasetAssignment.")
      }

      urlPath <- "/deployments/{deploymentId}/predictionInputs/fromDataset/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsPredictionResultsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsPredictionResultsListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, offset = 0, limit = 100, modelId = NULL, actualsPresent = NULL, accept = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      headerParams["Accept"] <- `accept`

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["modelId"] <- modelId

      queryParams["actualsPresent"] <- actualsPresent

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/predictionResults/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionResultsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsPredictionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsPredictionsCreateWithHttpInfo = function(deploymentId, passthroughColumns = NULL, passthroughColumnsSet = NULL, maxExplanations = NULL, maxCodes = NULL, thresholdHigh = NULL, thresholdLow = NULL, excludeAdjustedPredictions = TRUE, forecastPoint = NULL, predictionsStartDate = NULL, predictionsEndDate = NULL, relaxKnownInAdvanceFeaturesCheck = NULL, predictionWarningEnabled = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!is.null(passthroughColumns)) {
        queryParams["passthroughColumns"] <- paste0(passthroughColumns, collapse = ",")
      }

      queryParams["passthroughColumnsSet"] <- passthroughColumnsSet

      if (!is.null(maxExplanations)) {
        queryParams["maxExplanations"] <- paste0(maxExplanations, collapse = ",")
      }

      if (!is.null(maxCodes)) {
        queryParams["maxCodes"] <- paste0(maxCodes, collapse = ",")
      }

      queryParams["thresholdHigh"] <- thresholdHigh

      queryParams["thresholdLow"] <- thresholdLow

      queryParams["excludeAdjustedPredictions"] <- excludeAdjustedPredictions

      queryParams["forecastPoint"] <- forecastPoint

      queryParams["predictionsStartDate"] <- predictionsStartDate

      queryParams["predictionsEndDate"] <- predictionsEndDate

      queryParams["relaxKnownInAdvanceFeaturesCheck"] <- relaxKnownInAdvanceFeaturesCheck

      queryParams["predictionWarningEnabled"] <- predictionWarningEnabled

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/predictions/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionProxyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesCreateWithHttpInfo = function(deploymentId, retrainingPolicyCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`retrainingPolicyCreate`) && isa(retrainingPolicyCreate, c("RetrainingPolicyCreate", "R6"))) {
        body <- `retrainingPolicyCreate`$toJSON()
      } else {
        stop("DeploymentsRetrainingPoliciesCreateWithHttpInfo requires parameter retrainingPolicyCreate to be of type RetrainingPolicyCreate.")
      }

      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesDeleteWithHttpInfo = function(deploymentId, retrainingPolicyId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesListWithHttpInfo = function(deploymentId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesPatchWithHttpInfo = function(deploymentId, retrainingPolicyId, retrainingPolicyUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      if (!missing(`retrainingPolicyUpdate`) && isa(retrainingPolicyUpdate, c("RetrainingPolicyUpdate", "R6"))) {
        body <- `retrainingPolicyUpdate`$toJSON()
      } else {
        stop("DeploymentsRetrainingPoliciesPatchWithHttpInfo requires parameter retrainingPolicyUpdate to be of type RetrainingPolicyUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesRetrieveWithHttpInfo = function(deploymentId, retrainingPolicyId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesRunsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesRunsCreateWithHttpInfo = function(deploymentId, retrainingPolicyId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesRunsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesRunsListWithHttpInfo = function(deploymentId, retrainingPolicyId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRunListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesRunsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesRunsPatchWithHttpInfo = function(deploymentId, retrainingPolicyId, runId, retrainingPolicyRunUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      if (missing(`runId`)) {
        stop("Missing required parameter `runId`.")
      }

      if (!missing(`retrainingPolicyRunUpdate`) && isa(retrainingPolicyRunUpdate, c("RetrainingPolicyRunUpdate", "R6"))) {
        body <- `retrainingPolicyRunUpdate`$toJSON()
      } else {
        stop("DeploymentsRetrainingPoliciesRunsPatchWithHttpInfo requires parameter retrainingPolicyRunUpdate to be of type RetrainingPolicyRunUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/{runId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }

      if (!missing(`runId`)) {
        urlPath <- gsub(paste0("\\{", "runId", "\\}"), URLencode(as.character(`runId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRunRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingPoliciesRunsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingPoliciesRunsRetrieveWithHttpInfo = function(deploymentId, retrainingPolicyId, runId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (missing(`retrainingPolicyId`)) {
        stop("Missing required parameter `retrainingPolicyId`.")
      }

      if (missing(`runId`)) {
        stop("Missing required parameter `runId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingPolicies/{retrainingPolicyId}/runs/{runId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }

      if (!missing(`retrainingPolicyId`)) {
        urlPath <- gsub(paste0("\\{", "retrainingPolicyId", "\\}"), URLencode(as.character(`retrainingPolicyId`), reserved = TRUE), urlPath)
      }

      if (!missing(`runId`)) {
        urlPath <- gsub(paste0("\\{", "runId", "\\}"), URLencode(as.character(`runId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingPolicyRunRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingSettingsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingSettingsListWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/retrainingSettings/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RetrainingSettingsRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrainingSettingsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrainingSettingsPatchManyWithHttpInfo = function(deploymentId, retrainingSettingsUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`retrainingSettingsUpdate`) && isa(retrainingSettingsUpdate, c("RetrainingSettingsUpdate", "R6"))) {
        body <- `retrainingSettingsUpdate`$toJSON()
      } else {
        stop("DeploymentsRetrainingSettingsPatchManyWithHttpInfo requires parameter retrainingSettingsUpdate to be of type RetrainingSettingsUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/retrainingSettings/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsRetrieveWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsScoringCodeBuildsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsScoringCodeBuildsCreateWithHttpInfo = function(deploymentId, deploymentsScoringCodeBuildPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentsScoringCodeBuildPayload`) && isa(deploymentsScoringCodeBuildPayload, c("DeploymentsScoringCodeBuildPayload", "R6"))) {
        body <- `deploymentsScoringCodeBuildPayload`$toJSON()
      } else {
        stop("DeploymentsScoringCodeBuildsCreateWithHttpInfo requires parameter deploymentsScoringCodeBuildPayload to be of type DeploymentsScoringCodeBuildPayload.")
      }

      urlPath <- "/deployments/{deploymentId}/scoringCodeBuilds/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsScoringCodeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsScoringCodeListWithHttpInfo = function(deploymentId, sourceCode = "false", includeAgent = "false", includePe = "false", includePredictionExplanations = "false", includePredictionIntervals = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["sourceCode"] <- sourceCode

      queryParams["includeAgent"] <- includeAgent

      queryParams["includePe"] <- includePe

      queryParams["includePredictionExplanations"] <- includePredictionExplanations

      queryParams["includePredictionIntervals"] <- includePredictionIntervals

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/scoringCode/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsServiceStatsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsServiceStatsListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, executionTimeQuantile = 0.5, responseTimeQuantile = 0.5, slowRequestsThreshold = 1000, monitoringType = "serviceHealth", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["modelId"] <- modelId

      queryParams["executionTimeQuantile"] <- executionTimeQuantile

      queryParams["responseTimeQuantile"] <- responseTimeQuantile

      queryParams["slowRequestsThreshold"] <- slowRequestsThreshold

      queryParams["monitoringType"] <- monitoringType

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/serviceStats/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ServiceStatsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsServiceStatsOverTimeList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsServiceStatsOverTimeListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, bucketSize = NULL, metric = "totalPredictions", quantile = NULL, threshold = NULL, segmentAttribute = NULL, segmentValue = "", modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["bucketSize"] <- bucketSize

      queryParams["metric"] <- metric

      queryParams["quantile"] <- quantile

      queryParams["threshold"] <- threshold

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/serviceStatsOverTime/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ServiceStatsOverTimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsSettingsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsSettingsListWithHttpInfo = function(deploymentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/settings/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentSettingsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsSettingsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsSettingsPatchManyWithHttpInfo = function(deploymentId, deploymentSettingsUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentSettingsUpdate`) && isa(deploymentSettingsUpdate, c("DeploymentSettingsUpdate", "R6"))) {
        body <- `deploymentSettingsUpdate`$toJSON()
      } else {
        stop("DeploymentsSettingsPatchManyWithHttpInfo requires parameter deploymentSettingsUpdate to be of type DeploymentSettingsUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/settings/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsSharedRolesListWithHttpInfo = function(offset, limit, deploymentId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["id"] <- id

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/sharedRoles/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharingListV2Response", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsSharedRolesPatchManyWithHttpInfo = function(deploymentId, sharedRolesUpdateWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`sharedRolesUpdateWithGrant`) && isa(sharedRolesUpdateWithGrant, c("SharedRolesUpdateWithGrant", "R6"))) {
        body <- `sharedRolesUpdateWithGrant`$toJSON()
      } else {
        stop("DeploymentsSharedRolesPatchManyWithHttpInfo requires parameter sharedRolesUpdateWithGrant to be of type SharedRolesUpdateWithGrant.")
      }

      urlPath <- "/deployments/{deploymentId}/sharedRoles/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsStatusPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsStatusPatchManyWithHttpInfo = function(deploymentId, deploymentStatusUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      if (!missing(`deploymentStatusUpdate`) && isa(deploymentStatusUpdate, c("DeploymentStatusUpdate", "R6"))) {
        body <- `deploymentStatusUpdate`$toJSON()
      } else {
        stop("DeploymentsStatusPatchManyWithHttpInfo requires parameter deploymentStatusUpdate to be of type DeploymentStatusUpdate.")
      }

      urlPath <- "/deployments/{deploymentId}/status/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeploymentsTargetDriftList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeploymentsTargetDriftListWithHttpInfo = function(deploymentId, start = NULL, end = NULL, modelId = NULL, metric = "psi", segmentAttribute = NULL, segmentValue = "", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`deploymentId`)) {
        stop("Missing required parameter `deploymentId`.")
      }

      queryParams["start"] <- start

      queryParams["end"] <- end

      queryParams["modelId"] <- modelId

      queryParams["metric"] <- metric

      queryParams["segmentAttribute"] <- segmentAttribute

      queryParams["segmentValue"] <- segmentValue

      body <- NULL
      urlPath <- "/deployments/{deploymentId}/targetDrift/"
      if (!missing(`deploymentId`)) {
        urlPath <- gsub(paste0("\\{", "deploymentId", "\\}"), URLencode(as.character(`deploymentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeploymentTargetDriftResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `PredictionServersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    PredictionServersListWithHttpInfo = function(offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/predictionServers/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionServerListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
