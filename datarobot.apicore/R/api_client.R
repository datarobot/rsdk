# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

#' A generic API client for accessing an OpenAPI. This client handles the client-server communication
#' communication, and is invariant across implementations. It was originally auto generated by OpenAPI
#' Generator (https://openapi-generator.tech) but is now static, and includes a few customizations
#' for the DataRobot API.
#'
#' @docType class
#' @title ApiClient
#' @description ApiClient Class
#' @format An \code{R6Class} generator object
#' @importFrom httr add_headers accept timeout content
#' @export
ApiClient <- R6::R6Class(
  "ApiClient",
  public = list(
    #' @field basePath Base path for all requests. May be set by environment variable.
    basePath = "https://app.datarobot.com/api/v2",
    #' @field userAgent Default user agent in the HTTP request.
    userAgent = "DataRobotRClientAPICore/0.1.0.9000",
    #' @field defaultHeaders Default HTTP headers to use with all API requests.
    defaultHeaders = NULL,
    #' @field username Username for HTTP basic authentication. Unused.
    username = NULL,
    #' @field password Password for HTTP basic authentication. Unused.
    password = NULL,
    #' @field apiKeys API keys for HTTP token authentication. Unused.
    apiKeys = NULL,
    #' @field accessToken Access token for HTTP token authentication. May be set by environment variable.
    accessToken = NULL,
    #' @field timeout Default timeout in seconds.
    timeout = NULL,
    #' @field retryStatusCodes Vector of status codes to retry.
    retryStatusCodes = NULL,
    #' @field maxRetryAttempts Maximum number of retries for the status codes.
    maxRetryAttempts = NULL,

    #' @description
    #' Create a new ApiClient object.
    #' @param basePath Base path for all requests. May be set by environment variable.
    #' @param userAgent Default user agent in the HTTP request.
    #' @param defaultHeaders Default HTTP headers to use with all API requests.
    #' @param username Username for HTTP basic authentication. Unused.
    #' @param password Password for HTTP basic authentication. Unused.
    #' @param apiKeys API keys for HTTP token authentication. Unused.
    #' @param accessToken Access token for HTTP token authentication. May be set by environment variable.
    #' @param timeout Default timeout in seconds.
    #' @param retryStatusCodes Vector of status codes to retry.
    #' @param maxRetryAttempts Maximum number of retries for the status codes.
    initialize = function(basePath = NULL, userAgent = NULL, defaultHeaders = NULL, username = NULL, password = NULL, apiKeys = NULL, accessToken = NULL, timeout = NULL, retryStatusCodes = NULL, maxRetryAttempts = NULL) {
      if (!is.null(basePath)) {
        self$basePath <- basePath
      } else if (!is.na(self$envEndpoint())) {
        self$basePath <- self$envEndpoint()
      }

      if (!is.null(defaultHeaders)) {
        self$defaultHeaders <- defaultHeaders
      }

      if (!is.null(username)) {
        self$username <- username
      }

      if (!is.null(password)) {
        self$password <- password
      }

      if (!is.null(accessToken)) {
        self$accessToken <- accessToken
      } else if (!is.na(self$envToken())) {
        self$accessToken <- self$envToken()
      }

      if (!is.null(apiKeys)) {
        self$apiKeys <- apiKeys
      } else {
        self$apiKeys <- list()
      }

      if (!is.null(userAgent)) {
        self$`userAgent` <- userAgent
      }

      if (!is.null(timeout)) {
        self$timeout <- timeout
      }

      if (!is.null(retryStatusCodes)) {
        self$retryStatusCodes <- retryStatusCodes
      }

      if (!is.null(maxRetryAttempts)) {
        self$maxRetryAttempts <- maxRetryAttempts
      }
    },

    #' @description
    #' Invokes the underlying API for this client, with automatic retry logic. All
    #' params are passed to [Execute()].
    #' @param url The URL of the page to retrieve.
    #' @param method The HTTP method for this request. Examples: "GET", "POST", etc.
    #' @param queryParams A vector of named query parameters for this request. See [httr::modify_url()] for more information.
    #' @param headerParams A vector of named header parameters for this request. These should be exclusive of the list produced by [DataRobotDefaultHeaders].
    #' @param body The body for an HTTP request. It can be nearly anything, see [httr::VERB()] for more information.
    #' @param encode How the body should be encoded. Options: "multipart", "form", "json", "raw". By default, this is "json".
    #' @param filename If present for GET requests, causes the content of the response to be saved to disk at the specified path. See [https://httr.r-lib.org/reference/write_disk.html] for more information.
    #' @param ... Further named parameters that may be passed on to the `httr` library. See [httr::VERB()] for more information.
    CallApi = function(url, method, queryParams, headerParams, body, encode = "json", filename = NULL, ...) {
      resp <- self$Execute(url, method, queryParams, headerParams, body, encode, filename, ...)
      if (private$ResponseHasDeprecationHeader(resp)) {
        # DSX-2384 warn about deprecated/disabled resources that have the Deprecation header set
        private$DeprecatedHeaderMessage(resp)
      }

      statusCode <- httr::status_code(resp)

      if (is.null(self$maxRetryAttempts)) {
        self$maxRetryAttempts <- 3
      }

      if (!is.null(self$retryStatusCodes)) {
        for (i in 1:self$maxRetryAttempts) {
          if (statusCode %in% self$retryStatusCodes) {
            Sys.sleep((2^i) + stats::runif(n = 1, min = 0, max = 1))
            resp <- self$Execute(url, method, queryParams, headerParams, body, ...)
            statusCode <- httr::status_code(resp)
          } else {
            break
          }
        }
      }

      resp
    },

    #' @description
    #' Helper function that delegates to the [httr] library for making HTTP requests.
    #' @param url The URL of the page to retrieve.
    #' @param method The HTTP method for this request. Examples: "GET", "POST", etc.
    #' @param queryParams A vector of named query parameters for this request. See [httr::modify_url()] for more information.
    #' @param headerParams A vector of named header parameters for this request. These should be exclusive of the list produced by [DataRobotDefaultHeaders].
    #' @param body The body for an HTTP request. It can be nearly anything, see [httr::VERB()] for more information.
    #' @param encode How the body should be encoded. Options: "multipart", "form", "json", "raw". By default, this is "json".
    #' @param filename If present for GET requests, causes the content of the response to be saved to disk at the specified path. See [https://httr.r-lib.org/reference/write_disk.html] for more information.
    #' @param ... Further named parameters that may be passed on to the `httr` library. See [httr::VERB()] for more information.
    Execute = function(url, method, queryParams, headerParams, body, encode = "json", filename = NULL, ...) {
      headers <- httr::add_headers(c(
        headerParams,
        self$DataRobotDefaultHeaders(),
        self$defaultHeaders
      ))

      if (encode == "json") {
        headers <- c(headers, httr::content_type_json())
      }

      httpTimeout <- NULL
      if (!is.null(self$timeout)) {
        httpTimeout <- httr::timeout(self$timeout)
      }

      if (method == "GET") {
        args <- list(url = url, query = queryParams, headers, httpTimeout, httr::user_agent(self$`userAgent`), ...)
        if (!is.null(filename)) {
          args$config <- httr::write_disk(filename)
        }
        do.call(httr::GET, args)
      } else if (method == "POST") {
        httr::POST(url, query = queryParams, headers, body = body, encode = encode, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "PUT") {
        httr::PUT(url, query = queryParams, headers, body = body, encode = encode, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "PATCH") {
        httr::PATCH(url, query = queryParams, headers, body = body, encode = encode, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "HEAD") {
        httr::HEAD(url, query = queryParams, headers, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "DELETE") {
        httr::DELETE(url, query = queryParams, headers, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else {
        errMsg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
        stop(errMsg)
      }
    },

    #' @description
    #' Returns a list of default request headers for use with the DataRobot API.
    DataRobotDefaultHeaders = function() {
      # nearly all APIs require accessToken, so retrieve it
      # from the class object or fail
      if (!is.null(self$accessToken)) {
        c("Authorization" = paste("Bearer", self$accessToken))
      } else {
        stop("DataRobot API token not set.")
      }
    },

    #' @description
    #' Retrieves the DataRobot API endpoint from environment variables. DataRobot generally expects this env var to be set.
    envEndpoint = function() {
      Sys.getenv("DATAROBOT_API_ENDPOINT", unset = NA)
    },

    #' @description
    #' Retrieves the DataRobot API token from environment variables. DataRobot generally expects this env var to be set.
    envToken = function() {
      Sys.getenv("DATAROBOT_API_TOKEN", unset = NA)
    },

    #' @description
    #' Deserializes the content of an API response to the given type.
    #' @return Depends on content type, response can be R6 instance (for application/json), a list (for text/csv), or a character vector (for text/html).
    #' @param resp An httr response object.
    #' @param returnType The name of the returnType to attempt to deserialize to. Required for JSON content.
    #' @param pkgEnv This package. Required for JSON content.
    #' @examples
    #' \dontrun{
    #' apiClient <- ApiClient$new()
    #' apiClient$deserialize(resp, "CatalogExtendedDetailsResponse", loadNamespace("datarobot.apicore"))
    #' }
    deserialize = function(resp, returnType = NULL, pkgEnv = NULL) {
      contentType <- resp$headers$`content-type`
      if (contentType == "text/csv") {
        self$deserializeCSV(resp)
      } else if (contentType == "application/json") {
        self$deserializeJSON(resp, returnType, pkgEnv)
      } else {
        httr::content(resp, as = "text")
      }
    },

    #' @description
    #' Deserializes the JSON content of an API response to the given type.
    #' @param resp An httr response object.
    #' @param returnType The name of the returnType to attempt to deserialize to.
    #' @param pkgEnv This package.
    #' @examples
    #' \dontrun{
    #' apiClient <- ApiClient$new()
    #' apiClient$deserializeJSON(resp, "CatalogExtendedDetailsResponse", loadNamespace("datarobot.apicore"))
    #' }
    deserializeJSON = function(resp, returnType, pkgEnv) {
      respObj <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      self$deserializeObj(respObj, returnType, pkgEnv)
    },

    #' @description
    #' Deserializes the CSV content of an API response.
    #' @param resp An httr response object.
    #' @examples
    #' library(readr)
    #' example_resp <- httr:::response(
    #'   url = "/",
    #'   status_code = 200L,
    #'   headers = list(httr::content_type("text/csv")),
    #'   content = charToRaw(readr::format_csv(mtcars))
    #' )
    #' apiClient <- ApiClient$new()
    #' apiClient$deserializeCSV(example_resp)
    deserializeCSV = function(resp) {
      read.csv(text = httr::content(resp, "text", encoding = "UTF-8"))
    },

    #' @description
    #' Deserialize the response from jsonlite object based on the given type
    #' by handling complex and nested types by iterating recursively
    #' Example returnTypes will be like "array[integer]", "map(Pet)", "array[map(Tag)]", etc.,
    #' @param obj A JSON object, expected to have been retrieved from the content of an HTTP response.
    #' @param returnType The name of the returnType to attempt to deserialize to.
    #' @param pkgEnv This package.
    deserializeObj = function(obj, returnType, pkgEnv) {
      returnObj <- NULL
      primitiveTypes <- c("character", "numeric", "integer", "logical", "complex")

      # To handle the "map" type
      if (startsWith(returnType, "map(")) {
        innerReturnType <- regmatches(returnType, regexec(pattern = "map\\((.*)\\)", returnType))[[1]][2]
        returnObj <- lapply(names(obj), function(name) {
          self$deserializeObj(obj[[name]], innerReturnType, pkgEnv)
        })
        names(returnObj) <- names(obj)
      }

      # To handle the "array" type
      else if (startsWith(returnType, "array[")) {
        innerReturnType <- regmatches(returnType, regexec(pattern = "array\\[(.*)\\]", returnType))[[1]][2]
        if (c(innerReturnType) %in% primitiveTypes) {
          returnObj <- vector("list", length = length(obj))
          if (length(obj) > 0) {
            for (row in 1:length(obj)) {
              returnObj[[row]] <- self$deserializeObj(obj[row], innerReturnType, pkgEnv)
            }
          }
        } else {
          if (!is.null(nrow(obj))) {
            returnObj <- vector("list", length = nrow(obj))
            if (nrow(obj) > 0) {
              for (row in 1:nrow(obj)) {
                returnObj[[row]] <- self$deserializeObj(obj[row, , drop = FALSE], innerReturnType, pkgEnv)
              }
            }
          }
        }
      }

      # To handle model objects which are not array or map containers. Ex:"Pet"
      else if (exists(returnType, pkgEnv) && !(c(returnType) %in% primitiveTypes)) {
        returnType <- get(returnType, envir = as.environment(pkgEnv))
        returnObj <- returnType$new()
        returnObj$fromJSON(
          jsonlite::toJSON(obj, digits = NA, auto_unbox = TRUE, null = "null")
        )
      }

      # To handle primitive type
      else {
        returnObj <- obj
      }
      returnObj
    }
  ),
  private = list(
    #' @return The URL for the DataRobot platform docs on Python 3 migration / Python 2 deprecation.
    Py2DeprecationUrl = function() {
      dataRobotUrl <- strsplit(self$basePath, "/api/v2")[[1]][1]
      return(paste0(dataRobotUrl, "/docs/release/deprecations-and-migrations/python2.html"))
    },
    #' @description
    #' Helpful warning related to DataRobot deprecation messages.
    ##' @param rawResponse An httr response object.
    DeprecatedHeaderMessage = function(rawResponse) {
      # This assumes that the mere existence of a Deprecation: true header in a response from the
      # DataRobot Public API indicates a resource has been deprecated. We will use the string
      # returned from the server in the header unless that string is either empty of "true" in
      # which case we use a default message.
      # It does not use .Deprecated() as this marker is specific to deprecated R code.

      headers <- httr::headers(rawResponse)
      headerDeprecationMessage <- headers$Deprecation

      defaultWarningMsg <- paste(
        sep = "\"",
        "The resource you are trying to access will be or is deprecated. For additional guidance, run `browseURL(",
        private$Py2DeprecationUrl(),
        ")` or login to the DataRobot app for this project."
      )

      if (tolower(headerDeprecationMessage) == "true" || headerDeprecationMessage == "") {
        warningMessage <- defaultWarningMsg
      } else {
        warningMessage <- headerDeprecationMessage
      }

      warning(
        strwrap(
          warningMessage,
          prefix = " ", initial = ""
        ),
        call. = FALSE
      )
    },

    #' @param rawResponse An httr response object.
    #' @return TRUE if the 'Deprecation' responder header is set, FALSE otherwise.
    ResponseHasDeprecationHeader = function(rawResponse) {
      tryCatch(
        {
          headers <- httr::headers(rawResponse)
          if (is.null(headers) || is.null(headers$Deprecation)) {
            return(FALSE)
          }
          return(TRUE)
        },
        error = function(e) {
          # This code really only catches errors with poor test mocks that
          # don't set up a full httr:::response properly
          return(FALSE)
        }
      )
    }
  )
)
