# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Comments operations
#' @description datarobot.apicore.Comments
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
CommentsApi <- R6::R6Class(
  "CommentsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Post a comment
    #' Produces: "application/json"
    #'
    #' @details Post a comment
    #' @details This method invokes `POST /comments/` in the DataRobot Public API.
    #' @param comment \link{Comment}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CommentRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`201`** The comment was successfully created
    #' \itemize{
    #' }
    #' \item **`422`** The request was formatted improperly
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' comment <- Comment$new() # Comment |
    #'
    #' api.instance <- CommentsApi$new()
    #' result <- api.instance$CommentsCreate(comment=comment)
    #' }
    CommentsCreate = function(comment = NULL, ...) {
      apiResponse <- private$CommentsCreateWithHttpInfo(comment, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a comment
    #' Produces: NA
    #'
    #' @details Delete a comment
    #' @details This method invokes `DELETE /comments/{commentId}/` in the DataRobot Public API.
    #' @param commentId character. The ID of the comment
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The use case comment was deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' commentId <- 'commentId_example' # character | The ID of the comment
    #'
    #' api.instance <- CommentsApi$new()
    #' result <- api.instance$CommentsDelete(commentId)
    #' }
    CommentsDelete = function(commentId, ...) {
      apiResponse <- private$CommentsDeleteWithHttpInfo(commentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List comments
    #' Produces: NA
    #'
    #' @details List comments
    #' @details This method invokes `GET /comments/{entityType}/{entityId}/` in the DataRobot Public API.
    #' @param entityId character. ID of the entity to retrieve comments of
    #' @param entityType Enum < [useCase, model, catalog] > Type of the entity to retrieve a comments of, currently only useCase is supported
    #' @param offset integer. The number of records to skip over. Default 0.
    #' @param limit integer. The number of records to return in the range from 1 to 100. Default 100.
    #' @param orderBy Enum < [createdAt, -createdAt, updatedAt, -updatedAt] > Sort comments by a field of the comment.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' entityId <- 'entityId_example' # character | ID of the entity to retrieve comments of
    #' entityType <- 'entityType_example' # character | Type of the entity to retrieve a comments of, currently only useCase is supported
    #' offset <- 0 # integer | The number of records to skip over. Default 0.
    #' limit <- 100 # integer | The number of records to return in the range from 1 to 100. Default 100.
    #' orderBy <- 'orderBy_example' # character | Sort comments by a field of the comment.
    #'
    #' api.instance <- CommentsApi$new()
    #' result <- api.instance$CommentsList(entityId, entityType, offset=offset, limit=limit, orderBy=orderBy)
    #' }
    CommentsList = function(entityId, entityType, offset = 0, limit = 100, orderBy = NULL, ...) {
      apiResponse <- private$CommentsListWithHttpInfo(entityId, entityType, offset, limit, orderBy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a comment
    #' Produces: NA
    #'
    #' @details Update a comment
    #' @details This method invokes `PATCH /comments/{commentId}/` in the DataRobot Public API.
    #' @param commentId character. The ID of the comment
    #' @param commentUpdate \link{CommentUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`204`** The comment was successfully updated
    #' \itemize{
    #' }
    #' \item **`422`** The request was formatted improperly
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' commentId <- 'commentId_example' # character | The ID of the comment
    #' commentUpdate <- CommentUpdate$new() # CommentUpdate |
    #'
    #' api.instance <- CommentsApi$new()
    #' result <- api.instance$CommentsPatch(commentId, commentUpdate=commentUpdate)
    #' }
    CommentsPatch = function(commentId, commentUpdate = NULL, ...) {
      apiResponse <- private$CommentsPatchWithHttpInfo(commentId, commentUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a comment
    #' Produces: "application/json"
    #'
    #' @details Retrieve a comment
    #' @details This method invokes `GET /comments/{commentId}/` in the DataRobot Public API.
    #' @param commentId character. The ID of the comment
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CommentRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' commentId <- 'commentId_example' # character | The ID of the comment
    #'
    #' api.instance <- CommentsApi$new()
    #' result <- api.instance$CommentsRetrieve(commentId)
    #' }
    CommentsRetrieve = function(commentId, ...) {
      apiResponse <- private$CommentsRetrieveWithHttpInfo(commentId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `CommentsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CommentsCreateWithHttpInfo = function(comment = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`comment`) && isa(comment, c("Comment", "R6"))) {
        body <- `comment`$toJSON()
      } else {
        stop("CommentsCreateWithHttpInfo requires parameter comment to be of type Comment.")
      }

      urlPath <- "/comments/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CommentRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CommentsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CommentsDeleteWithHttpInfo = function(commentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`commentId`)) {
        stop("Missing required parameter `commentId`.")
      }

      body <- NULL
      urlPath <- "/comments/{commentId}/"
      if (!missing(`commentId`)) {
        urlPath <- gsub(paste0("\\{", "commentId", "\\}"), URLencode(as.character(`commentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CommentsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CommentsListWithHttpInfo = function(entityId, entityType, offset = 0, limit = 100, orderBy = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`entityId`)) {
        stop("Missing required parameter `entityId`.")
      }

      if (missing(`entityType`)) {
        stop("Missing required parameter `entityType`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/comments/{entityType}/{entityId}/"
      if (!missing(`entityId`)) {
        urlPath <- gsub(paste0("\\{", "entityId", "\\}"), URLencode(as.character(`entityId`), reserved = TRUE), urlPath)
      }

      if (!missing(`entityType`)) {
        urlPath <- gsub(paste0("\\{", "entityType", "\\}"), URLencode(as.character(`entityType`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CommentsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CommentsPatchWithHttpInfo = function(commentId, commentUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`commentId`)) {
        stop("Missing required parameter `commentId`.")
      }

      if (!missing(`commentUpdate`) && isa(commentUpdate, c("CommentUpdate", "R6"))) {
        body <- `commentUpdate`$toJSON()
      } else {
        stop("CommentsPatchWithHttpInfo requires parameter commentUpdate to be of type CommentUpdate.")
      }

      urlPath <- "/comments/{commentId}/"
      if (!missing(`commentId`)) {
        urlPath <- gsub(paste0("\\{", "commentId", "\\}"), URLencode(as.character(`commentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CommentsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CommentsRetrieveWithHttpInfo = function(commentId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`commentId`)) {
        stop("Missing required parameter `commentId`.")
      }

      body <- NULL
      urlPath <- "/comments/{commentId}/"
      if (!missing(`commentId`)) {
        urlPath <- gsub(paste0("\\{", "commentId", "\\}"), URLencode(as.character(`commentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CommentRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
