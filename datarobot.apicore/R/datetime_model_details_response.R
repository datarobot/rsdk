# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title DatetimeModelDetailsResponse
#'
#' @description DatetimeModelDetailsResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field backtests  list( \link{BacktestStatusResponse} ) information on each backtesting fold of the model
#'
#' @field blueprintId  character the blueprint used to construct the model
#'
#' @field dataSelectionMethod  character Identifies which setting defines the training size of the model when making predictions and scoring.
#'
#' @field effectiveFeatureDerivationWindowEnd  integer Only available for time series projects. How many timeUnits into the past relative to the forecast point the feature derivation window should end.
#'
#' @field effectiveFeatureDerivationWindowStart  integer Only available for time series projects. How many timeUnits into the past relative to the forecast point the user needs to provide history for at prediction time. This can differ from the &#x60;featureDerivationWindowStart&#x60; set on the project due to the differencing method and period selected.
#'
#' @field featurelistId  character the ID of the featurelist used by the model
#'
#' @field featurelistName  character the name of the featurelist used by the model
#'
#' @field forecastWindowEnd  integer Only available for time series projects. How many timeUnits into the future relative to the forecast point the forecast window should end.
#'
#' @field forecastWindowStart  integer Only available for time series projects. How many timeUnits into the future relative to the forecast point the forecast window should start.
#'
#' @field holdoutScore  numeric the holdout score of the model according to the project metric, if the score is available and the holdout is unlocked
#'
#' @field holdoutStatus  character the status of the holdout fold
#'
#' @field id  character the ID of the model
#'
#' @field isFrozen  character indicating whether the model is frozen, i.e. uses tuning parameters from a parent model
#'
#' @field isStarred  character whether the model has been starred
#'
#' @field linkFunction  character the link function the final modeler uses in the blueprint. If no link function exists, returns null
#'
#' @field metrics  object Object where each metric has validation, backtesting, backtestingScores and holdout scores reported, or null if they have not been computed. The &#x60;validation&#x60; score will be the score of the first backtest, which will be computed during initial model training.  The &#x60;backtesting&#x60; and  &#x60;backtestingScores&#x60; scores are computed when requested via :http:post:&#x60;/api/v2/projects/(projectId)/datetimeModels/(modelId)/backtests/&#x60;. The &#x60;backtesting&#x60; score is the average score across all backtests. The &#x60;backtestingScores&#x60; is an array of scores for each backtest, with the scores reported as null if the backtest score is unavailable. The &#x60;holdout&#x60; score is the score against the holdout data, using the training data defined in &#x60;trainingInfo&#x60;.
#'
#' @field modelCategory  character indicates what kind of model it is - will be &#x60;prime&#x60; for DataRobot Prime models, &#x60;blend&#x60; for blender models, &#x60;scaleout&#x60; for scaleout models, and &#x60;model&#x60; for all other models
#'
#' @field modelFamily  character the family model belongs to, e.g. SVM, GMB, etc.
#'
#' @field modelNumber  integer number of the model on leaderboard.
#'
#' @field modelType  character identifies the model, e.g. &#x60;Nystroem Kernel SVM Regressor&#x60;
#'
#' @field monotonicDecreasingFeaturelistId  character the ID of the featurelist that defines the set of features with a monotonically decreasing relationship to the target. If null, no such constraints are enforced.
#'
#' @field monotonicIncreasingFeaturelistId  character the ID of the featurelist that defines the set of features with a monotonically increasing relationship to the target. If null, no such constraints are enforced.
#'
#' @field parentModelId  character if this model is frozen, this is the ID of the parent model. Otherwise Null.
#'
#' @field predictionThreshold  numeric threshold used for binary classification in predictions.
#'
#' @field predictionThresholdReadOnly  character indicates whether modification of a predictions threshold is forbidden. Since v2.22 threshold modification is allowed.
#'
#' @field processes  list( character ) list of processes used by the model
#'
#' @field projectId  character the ID of the project to which the model belongs
#'
#' @field samplePct  character always null for datetime models
#'
#' @field samplingMethod  character [optional] indicates sampling method used to select training data. For row-based project this is the way how requested number of rows are selected.For other projects (duration-based, start/end, project settings) - how specified percent of rows (timeWindowSamplePct) is selected from specified time window.
#'
#' @field supportsComposableMl  character indicates whether this model is supported in Composable ML.
#'
#' @field supportsMonotonicConstraints  character whether this model supports enforcing monotonic constraints
#'
#' @field timeWindowSamplePct  integer An integer between 1 and 99, indicating the percentage of sampling within the time window. The points kept are determined by samplingMethod option. Will be null if no sampling was specified.
#'
#' @field trainingDuration  character the duration spanned by the dates in the partition column for the data used to train the model
#'
#' @field trainingEndDate  character the end date of the dates in the partition column for the data used to train the model
#'
#' @field trainingInfo  \link{TrainingInfoResponse}
#'
#' @field trainingRowCount  integer the number of rows used to train the model
#'
#' @field trainingStartDate  character the start date of the dates in the partition column for the data used to train the model
#'
#' @field windowsBasisUnit  character Only available for time series projects. Indicates which unit is the basis for the feature derivation window and the forecast window.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
DatetimeModelDetailsResponse <- R6::R6Class(
  "DatetimeModelDetailsResponse",
  lock_objects = FALSE,
  private = list(
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(backtests = NULL, blueprintId = NULL, dataSelectionMethod = NULL, effectiveFeatureDerivationWindowEnd = NULL, effectiveFeatureDerivationWindowStart = NULL, featurelistId = NULL, featurelistName = NULL, forecastWindowEnd = NULL, forecastWindowStart = NULL, holdoutScore = NULL, holdoutStatus = NULL, id = NULL, isFrozen = NULL, isStarred = NULL, linkFunction = NULL, metrics = NULL, modelCategory = NULL, modelFamily = NULL, modelNumber = NULL, modelType = NULL, monotonicDecreasingFeaturelistId = NULL, monotonicIncreasingFeaturelistId = NULL, parentModelId = NULL, predictionThreshold = NULL, predictionThresholdReadOnly = NULL, processes = NULL, projectId = NULL, samplePct = NULL, samplingMethod = NULL, supportsComposableMl = NULL, supportsMonotonicConstraints = NULL, timeWindowSamplePct = NULL, trainingDuration = NULL, trainingEndDate = NULL, trainingInfo = NULL, trainingRowCount = NULL, trainingStartDate = NULL, windowsBasisUnit = NULL) {
      if (!is.null(`backtests`)) {
        stopifnot(is.vector(`backtests`))
      }
      if (!is.null(`blueprintId`)) {
        stopifnot(is.character(`blueprintId`), length(`blueprintId`) == 1)
      }
      if (!is.null(`dataSelectionMethod`)) {
        stopifnot(is.character(`dataSelectionMethod`), length(`dataSelectionMethod`) == 1)
      }
      if (!is.null(`effectiveFeatureDerivationWindowEnd`)) {
        stopifnot(is.numeric(`effectiveFeatureDerivationWindowEnd`), length(`effectiveFeatureDerivationWindowEnd`) == 1)
      }
      if (!is.null(`effectiveFeatureDerivationWindowStart`)) {
        stopifnot(is.numeric(`effectiveFeatureDerivationWindowStart`), length(`effectiveFeatureDerivationWindowStart`) == 1)
      }
      if (!is.null(`featurelistId`)) {
        stopifnot(is.character(`featurelistId`), length(`featurelistId`) == 1)
      }
      if (!is.null(`featurelistName`)) {
        stopifnot(is.character(`featurelistName`), length(`featurelistName`) == 1)
      }
      if (!is.null(`forecastWindowEnd`)) {
        stopifnot(is.numeric(`forecastWindowEnd`), length(`forecastWindowEnd`) == 1)
      }
      if (!is.null(`forecastWindowStart`)) {
        stopifnot(is.numeric(`forecastWindowStart`), length(`forecastWindowStart`) == 1)
      }
      if (!is.null(`holdoutScore`)) {
      }
      if (!is.null(`holdoutStatus`)) {
        stopifnot(is.character(`holdoutStatus`), length(`holdoutStatus`) == 1)
      }
      if (!is.null(`id`)) {
        stopifnot(is.character(`id`), length(`id`) == 1)
      }
      if (!is.null(`isFrozen`)) {
        stopifnot(is.logical(`isFrozen`), length(`isFrozen`) == 1)
      }
      if (!is.null(`isStarred`)) {
        stopifnot(is.logical(`isStarred`), length(`isStarred`) == 1)
      }
      if (!is.null(`linkFunction`)) {
        stopifnot(is.character(`linkFunction`), length(`linkFunction`) == 1)
      }
      if (!is.null(`metrics`)) {
      }
      if (!is.null(`modelCategory`)) {
        stopifnot(is.character(`modelCategory`), length(`modelCategory`) == 1)
      }
      if (!is.null(`modelFamily`)) {
        stopifnot(is.character(`modelFamily`), length(`modelFamily`) == 1)
      }
      if (!is.null(`modelNumber`)) {
        stopifnot(is.numeric(`modelNumber`), length(`modelNumber`) == 1)
      }
      if (!is.null(`modelType`)) {
        stopifnot(is.character(`modelType`), length(`modelType`) == 1)
      }
      if (!is.null(`monotonicDecreasingFeaturelistId`)) {
        stopifnot(is.character(`monotonicDecreasingFeaturelistId`), length(`monotonicDecreasingFeaturelistId`) == 1)
      }
      if (!is.null(`monotonicIncreasingFeaturelistId`)) {
        stopifnot(is.character(`monotonicIncreasingFeaturelistId`), length(`monotonicIncreasingFeaturelistId`) == 1)
      }
      if (!is.null(`parentModelId`)) {
        stopifnot(is.character(`parentModelId`), length(`parentModelId`) == 1)
      }
      if (!is.null(`predictionThreshold`)) {
      }
      if (!is.null(`predictionThresholdReadOnly`)) {
        stopifnot(is.logical(`predictionThresholdReadOnly`), length(`predictionThresholdReadOnly`) == 1)
      }
      if (!is.null(`processes`)) {
        stopifnot(is.vector(`processes`))
      }
      if (!is.null(`projectId`)) {
        stopifnot(is.character(`projectId`), length(`projectId`) == 1)
      }
      if (!is.null(`samplePct`)) {
        stopifnot(is.character(`samplePct`), length(`samplePct`) == 1)
      }
      if (!is.null(`supportsComposableMl`)) {
        stopifnot(is.logical(`supportsComposableMl`), length(`supportsComposableMl`) == 1)
      }
      if (!is.null(`supportsMonotonicConstraints`)) {
        stopifnot(is.logical(`supportsMonotonicConstraints`), length(`supportsMonotonicConstraints`) == 1)
      }
      if (!is.null(`timeWindowSamplePct`)) {
        stopifnot(is.numeric(`timeWindowSamplePct`), length(`timeWindowSamplePct`) == 1)
      }
      if (!is.null(`trainingDuration`)) {
        stopifnot(is.character(`trainingDuration`), length(`trainingDuration`) == 1)
      }
      if (!is.null(`trainingEndDate`)) {
        stopifnot(inherits(`trainingEndDate`, "POSIXt"))
      }
      if (!is.null(`trainingInfo`)) {
        stopifnot(R6::is.R6(`trainingInfo`))
      }
      if (!is.null(`trainingRowCount`)) {
        stopifnot(is.numeric(`trainingRowCount`), length(`trainingRowCount`) == 1)
      }
      if (!is.null(`trainingStartDate`)) {
        stopifnot(inherits(`trainingStartDate`, "POSIXt"))
      }
      if (!is.null(`windowsBasisUnit`)) {
        stopifnot(is.character(`windowsBasisUnit`), length(`windowsBasisUnit`) == 1)
      }
      if (!is.null(`samplingMethod`)) {
        stopifnot(is.character(`samplingMethod`), length(`samplingMethod`) == 1)
      }
    }
  ),
  public = list(
    `backtests` = NULL,
    `blueprintId` = NULL,
    `dataSelectionMethod` = NULL,
    `effectiveFeatureDerivationWindowEnd` = NULL,
    `effectiveFeatureDerivationWindowStart` = NULL,
    `featurelistId` = NULL,
    `featurelistName` = NULL,
    `forecastWindowEnd` = NULL,
    `forecastWindowStart` = NULL,
    `holdoutScore` = NULL,
    `holdoutStatus` = NULL,
    `id` = NULL,
    `isFrozen` = NULL,
    `isStarred` = NULL,
    `linkFunction` = NULL,
    `metrics` = NULL,
    `modelCategory` = NULL,
    `modelFamily` = NULL,
    `modelNumber` = NULL,
    `modelType` = NULL,
    `monotonicDecreasingFeaturelistId` = NULL,
    `monotonicIncreasingFeaturelistId` = NULL,
    `parentModelId` = NULL,
    `predictionThreshold` = NULL,
    `predictionThresholdReadOnly` = NULL,
    `processes` = NULL,
    `projectId` = NULL,
    `samplePct` = NULL,
    `samplingMethod` = NULL,
    `supportsComposableMl` = NULL,
    `supportsMonotonicConstraints` = NULL,
    `timeWindowSamplePct` = NULL,
    `trainingDuration` = NULL,
    `trainingEndDate` = NULL,
    `trainingInfo` = NULL,
    `trainingRowCount` = NULL,
    `trainingStartDate` = NULL,
    `windowsBasisUnit` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param backtests information on each backtesting fold of the model
    #' @param blueprintId the blueprint used to construct the model
    #' @param dataSelectionMethod Identifies which setting defines the training size of the model when making predictions and scoring.
    #' @param effectiveFeatureDerivationWindowEnd Only available for time series projects. How many timeUnits into the past relative to the forecast point the feature derivation window should end.
    #' @param effectiveFeatureDerivationWindowStart Only available for time series projects. How many timeUnits into the past relative to the forecast point the user needs to provide history for at prediction time. This can differ from the &#x60;featureDerivationWindowStart&#x60; set on the project due to the differencing method and period selected.
    #' @param featurelistId the ID of the featurelist used by the model
    #' @param featurelistName the name of the featurelist used by the model
    #' @param forecastWindowEnd Only available for time series projects. How many timeUnits into the future relative to the forecast point the forecast window should end.
    #' @param forecastWindowStart Only available for time series projects. How many timeUnits into the future relative to the forecast point the forecast window should start.
    #' @param holdoutScore the holdout score of the model according to the project metric, if the score is available and the holdout is unlocked
    #' @param holdoutStatus the status of the holdout fold
    #' @param id the ID of the model
    #' @param isFrozen indicating whether the model is frozen, i.e. uses tuning parameters from a parent model
    #' @param isStarred whether the model has been starred
    #' @param linkFunction the link function the final modeler uses in the blueprint. If no link function exists, returns null
    #' @param metrics Object where each metric has validation, backtesting, backtestingScores and holdout scores reported, or null if they have not been computed. The &#x60;validation&#x60; score will be the score of the first backtest, which will be computed during initial model training.  The &#x60;backtesting&#x60; and  &#x60;backtestingScores&#x60; scores are computed when requested via :http:post:&#x60;/api/v2/projects/(projectId)/datetimeModels/(modelId)/backtests/&#x60;. The &#x60;backtesting&#x60; score is the average score across all backtests. The &#x60;backtestingScores&#x60; is an array of scores for each backtest, with the scores reported as null if the backtest score is unavailable. The &#x60;holdout&#x60; score is the score against the holdout data, using the training data defined in &#x60;trainingInfo&#x60;.
    #' @param modelCategory indicates what kind of model it is - will be &#x60;prime&#x60; for DataRobot Prime models, &#x60;blend&#x60; for blender models, &#x60;scaleout&#x60; for scaleout models, and &#x60;model&#x60; for all other models
    #' @param modelFamily the family model belongs to, e.g. SVM, GMB, etc.
    #' @param modelNumber number of the model on leaderboard.
    #' @param modelType identifies the model, e.g. &#x60;Nystroem Kernel SVM Regressor&#x60;
    #' @param monotonicDecreasingFeaturelistId the ID of the featurelist that defines the set of features with a monotonically decreasing relationship to the target. If null, no such constraints are enforced.
    #' @param monotonicIncreasingFeaturelistId the ID of the featurelist that defines the set of features with a monotonically increasing relationship to the target. If null, no such constraints are enforced.
    #' @param parentModelId if this model is frozen, this is the ID of the parent model. Otherwise Null.
    #' @param predictionThreshold threshold used for binary classification in predictions.
    #' @param predictionThresholdReadOnly indicates whether modification of a predictions threshold is forbidden. Since v2.22 threshold modification is allowed.
    #' @param processes list of processes used by the model
    #' @param projectId the ID of the project to which the model belongs
    #' @param samplePct always null for datetime models
    #' @param samplingMethod indicates sampling method used to select training data. For row-based project this is the way how requested number of rows are selected.For other projects (duration-based, start/end, project settings) - how specified percent of rows (timeWindowSamplePct) is selected from specified time window.
    #' @param supportsComposableMl indicates whether this model is supported in Composable ML.
    #' @param supportsMonotonicConstraints whether this model supports enforcing monotonic constraints
    #' @param timeWindowSamplePct An integer between 1 and 99, indicating the percentage of sampling within the time window. The points kept are determined by samplingMethod option. Will be null if no sampling was specified.
    #' @param trainingDuration the duration spanned by the dates in the partition column for the data used to train the model
    #' @param trainingEndDate the end date of the dates in the partition column for the data used to train the model
    #' @param trainingInfo
    #' @param trainingRowCount the number of rows used to train the model
    #' @param trainingStartDate the start date of the dates in the partition column for the data used to train the model
    #' @param windowsBasisUnit Only available for time series projects. Indicates which unit is the basis for the feature derivation window and the forecast window.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`backtests` = NULL, `blueprintId` = NULL, `dataSelectionMethod` = NULL, `effectiveFeatureDerivationWindowEnd` = NULL, `effectiveFeatureDerivationWindowStart` = NULL, `featurelistId` = NULL, `featurelistName` = NULL, `forecastWindowEnd` = NULL, `forecastWindowStart` = NULL, `holdoutScore` = NULL, `holdoutStatus` = NULL, `id` = NULL, `isFrozen` = NULL, `isStarred` = NULL, `linkFunction` = NULL, `metrics` = NULL, `modelCategory` = NULL, `modelFamily` = NULL, `modelNumber` = NULL, `modelType` = NULL, `monotonicDecreasingFeaturelistId` = NULL, `monotonicIncreasingFeaturelistId` = NULL, `parentModelId` = NULL, `predictionThreshold` = NULL, `predictionThresholdReadOnly` = NULL, `processes` = NULL, `projectId` = NULL, `samplePct` = NULL, `supportsComposableMl` = NULL, `supportsMonotonicConstraints` = NULL, `timeWindowSamplePct` = NULL, `trainingDuration` = NULL, `trainingEndDate` = NULL, `trainingInfo` = NULL, `trainingRowCount` = NULL, `trainingStartDate` = NULL, `windowsBasisUnit` = NULL, `samplingMethod` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      requiredProps <- list(`backtests`, `blueprintId`, `dataSelectionMethod`, `effectiveFeatureDerivationWindowEnd`, `effectiveFeatureDerivationWindowStart`, `featurelistId`, `featurelistName`, `forecastWindowEnd`, `forecastWindowStart`, `holdoutScore`, `holdoutStatus`, `id`, `isFrozen`, `isStarred`, `linkFunction`, `metrics`, `modelCategory`, `modelFamily`, `modelNumber`, `modelType`, `monotonicDecreasingFeaturelistId`, `monotonicIncreasingFeaturelistId`, `parentModelId`, `predictionThreshold`, `predictionThresholdReadOnly`, `processes`, `projectId`, `samplePct`, `supportsComposableMl`, `supportsMonotonicConstraints`, `timeWindowSamplePct`, `trainingDuration`, `trainingEndDate`, `trainingInfo`, `trainingRowCount`, `trainingStartDate`, `windowsBasisUnit`)
      if (validateParams) {
        lapply(requiredProps, missing)
        private$validateProps(backtests, blueprintId, dataSelectionMethod, effectiveFeatureDerivationWindowEnd, effectiveFeatureDerivationWindowStart, featurelistId, featurelistName, forecastWindowEnd, forecastWindowStart, holdoutScore, holdoutStatus, id, isFrozen, isStarred, linkFunction, metrics, modelCategory, modelFamily, modelNumber, modelType, monotonicDecreasingFeaturelistId, monotonicIncreasingFeaturelistId, parentModelId, predictionThreshold, predictionThresholdReadOnly, processes, projectId, samplePct, samplingMethod, supportsComposableMl, supportsMonotonicConstraints, timeWindowSamplePct, trainingDuration, trainingEndDate, trainingInfo, trainingRowCount, trainingStartDate, windowsBasisUnit)
      }
      sapply(`backtests`, function(x) stopifnot(R6::is.R6(x)))
      self$`blueprintId` <- `blueprintId`
      self$`dataSelectionMethod` <- `dataSelectionMethod`
      self$`effectiveFeatureDerivationWindowEnd` <- `effectiveFeatureDerivationWindowEnd`
      self$`effectiveFeatureDerivationWindowStart` <- `effectiveFeatureDerivationWindowStart`
      self$`featurelistId` <- `featurelistId`
      self$`featurelistName` <- `featurelistName`
      self$`forecastWindowEnd` <- `forecastWindowEnd`
      self$`forecastWindowStart` <- `forecastWindowStart`
      self$`holdoutScore` <- `holdoutScore`
      self$`holdoutStatus` <- `holdoutStatus`
      self$`id` <- `id`
      self$`isFrozen` <- `isFrozen`
      self$`isStarred` <- `isStarred`
      self$`linkFunction` <- `linkFunction`
      self$`metrics` <- `metrics`
      self$`modelCategory` <- `modelCategory`
      self$`modelFamily` <- `modelFamily`
      self$`modelNumber` <- `modelNumber`
      self$`modelType` <- `modelType`
      self$`monotonicDecreasingFeaturelistId` <- `monotonicDecreasingFeaturelistId`
      self$`monotonicIncreasingFeaturelistId` <- `monotonicIncreasingFeaturelistId`
      self$`parentModelId` <- `parentModelId`
      self$`predictionThreshold` <- `predictionThreshold`
      self$`predictionThresholdReadOnly` <- `predictionThresholdReadOnly`
      sapply(`processes`, function(x) stopifnot(is.character(x)))
      self$`projectId` <- `projectId`
      self$`samplePct` <- `samplePct`
      self$`samplingMethod` <- `samplingMethod`
      self$`supportsComposableMl` <- `supportsComposableMl`
      self$`supportsMonotonicConstraints` <- `supportsMonotonicConstraints`
      self$`timeWindowSamplePct` <- `timeWindowSamplePct`
      self$`trainingDuration` <- `trainingDuration`
      self$`trainingEndDate` <- `trainingEndDate`
      self$`trainingInfo` <- `trainingInfo`
      self$`trainingRowCount` <- `trainingRowCount`
      self$`trainingStartDate` <- `trainingStartDate`
      self$`windowsBasisUnit` <- `windowsBasisUnit`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    validate = function() {
      props <- list(backtests = self$`backtests`, blueprintId = self$`blueprintId`, dataSelectionMethod = self$`dataSelectionMethod`, effectiveFeatureDerivationWindowEnd = self$`effectiveFeatureDerivationWindowEnd`, effectiveFeatureDerivationWindowStart = self$`effectiveFeatureDerivationWindowStart`, featurelistId = self$`featurelistId`, featurelistName = self$`featurelistName`, forecastWindowEnd = self$`forecastWindowEnd`, forecastWindowStart = self$`forecastWindowStart`, holdoutScore = self$`holdoutScore`, holdoutStatus = self$`holdoutStatus`, id = self$`id`, isFrozen = self$`isFrozen`, isStarred = self$`isStarred`, linkFunction = self$`linkFunction`, metrics = self$`metrics`, modelCategory = self$`modelCategory`, modelFamily = self$`modelFamily`, modelNumber = self$`modelNumber`, modelType = self$`modelType`, monotonicDecreasingFeaturelistId = self$`monotonicDecreasingFeaturelistId`, monotonicIncreasingFeaturelistId = self$`monotonicIncreasingFeaturelistId`, parentModelId = self$`parentModelId`, predictionThreshold = self$`predictionThreshold`, predictionThresholdReadOnly = self$`predictionThresholdReadOnly`, processes = self$`processes`, projectId = self$`projectId`, samplePct = self$`samplePct`, samplingMethod = self$`samplingMethod`, supportsComposableMl = self$`supportsComposableMl`, supportsMonotonicConstraints = self$`supportsMonotonicConstraints`, timeWindowSamplePct = self$`timeWindowSamplePct`, trainingDuration = self$`trainingDuration`, trainingEndDate = self$`trainingEndDate`, trainingInfo = self$`trainingInfo`, trainingRowCount = self$`trainingRowCount`, trainingStartDate = self$`trainingStartDate`, windowsBasisUnit = self$`windowsBasisUnit`)
      do.call(private$validateProps, props)
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`backtests`)) {
          sprintf(
            '"backtests":
            [%s]
',
            paste(sapply(self$`backtests`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`blueprintId`)) {
          sprintf(
            '"blueprintId":
            "%s"
                  ',
            self$`blueprintId`
          )
        },
        if (!is.null(self$`dataSelectionMethod`)) {
          sprintf(
            '"dataSelectionMethod":
            "%s"
                  ',
            self$`dataSelectionMethod`
          )
        },
        if (!is.null(self$`effectiveFeatureDerivationWindowEnd`)) {
          sprintf(
            '"effectiveFeatureDerivationWindowEnd":
            %d
                  ',
            self$`effectiveFeatureDerivationWindowEnd`
          )
        },
        if (!is.null(self$`effectiveFeatureDerivationWindowStart`)) {
          sprintf(
            '"effectiveFeatureDerivationWindowStart":
            %d
                  ',
            self$`effectiveFeatureDerivationWindowStart`
          )
        },
        if (!is.null(self$`featurelistId`)) {
          sprintf(
            '"featurelistId":
            "%s"
                  ',
            self$`featurelistId`
          )
        },
        if (!is.null(self$`featurelistName`)) {
          sprintf(
            '"featurelistName":
            "%s"
                  ',
            self$`featurelistName`
          )
        },
        if (!is.null(self$`forecastWindowEnd`)) {
          sprintf(
            '"forecastWindowEnd":
            %d
                  ',
            self$`forecastWindowEnd`
          )
        },
        if (!is.null(self$`forecastWindowStart`)) {
          sprintf(
            '"forecastWindowStart":
            %d
                  ',
            self$`forecastWindowStart`
          )
        },
        if (!is.null(self$`holdoutScore`)) {
          sprintf(
            '"holdoutScore":
            %d
                  ',
            self$`holdoutScore`
          )
        },
        if (!is.null(self$`holdoutStatus`)) {
          sprintf(
            '"holdoutStatus":
            "%s"
                  ',
            self$`holdoutStatus`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            "%s"
                  ',
            self$`id`
          )
        },
        if (!is.null(self$`isFrozen`)) {
          sprintf(
            '"isFrozen":
            %s
                  ',
            tolower(self$`isFrozen`)
          )
        },
        if (!is.null(self$`isStarred`)) {
          sprintf(
            '"isStarred":
            %s
                  ',
            tolower(self$`isStarred`)
          )
        },
        if (!is.null(self$`linkFunction`)) {
          sprintf(
            '"linkFunction":
            "%s"
                  ',
            self$`linkFunction`
          )
        },
        if (!is.null(self$`metrics`)) {
          sprintf(
            '"metrics":
            "%s"
                  ',
            self$`metrics`
          )
        },
        if (!is.null(self$`modelCategory`)) {
          sprintf(
            '"modelCategory":
            "%s"
                  ',
            self$`modelCategory`
          )
        },
        if (!is.null(self$`modelFamily`)) {
          sprintf(
            '"modelFamily":
            "%s"
                  ',
            self$`modelFamily`
          )
        },
        if (!is.null(self$`modelNumber`)) {
          sprintf(
            '"modelNumber":
            %d
                  ',
            self$`modelNumber`
          )
        },
        if (!is.null(self$`modelType`)) {
          sprintf(
            '"modelType":
            "%s"
                  ',
            self$`modelType`
          )
        },
        if (!is.null(self$`monotonicDecreasingFeaturelistId`)) {
          sprintf(
            '"monotonicDecreasingFeaturelistId":
            "%s"
                  ',
            self$`monotonicDecreasingFeaturelistId`
          )
        },
        if (!is.null(self$`monotonicIncreasingFeaturelistId`)) {
          sprintf(
            '"monotonicIncreasingFeaturelistId":
            "%s"
                  ',
            self$`monotonicIncreasingFeaturelistId`
          )
        },
        if (!is.null(self$`parentModelId`)) {
          sprintf(
            '"parentModelId":
            "%s"
                  ',
            self$`parentModelId`
          )
        },
        if (!is.null(self$`predictionThreshold`)) {
          sprintf(
            '"predictionThreshold":
            %d
                  ',
            self$`predictionThreshold`
          )
        },
        if (!is.null(self$`predictionThresholdReadOnly`)) {
          sprintf(
            '"predictionThresholdReadOnly":
            %s
                  ',
            tolower(self$`predictionThresholdReadOnly`)
          )
        },
        if (!is.null(self$`processes`)) {
          sprintf(
            '"processes":
              [%s]
            ',
            paste(unlist(lapply(self$`processes`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`projectId`)) {
          sprintf(
            '"projectId":
            "%s"
                  ',
            self$`projectId`
          )
        },
        if (!is.null(self$`samplePct`)) {
          sprintf(
            '"samplePct":
            "%s"
                  ',
            self$`samplePct`
          )
        },
        if (!is.null(self$`samplingMethod`)) {
          sprintf(
            '"samplingMethod":
            "%s"
                  ',
            self$`samplingMethod`
          )
        },
        if (!is.null(self$`supportsComposableMl`)) {
          sprintf(
            '"supportsComposableMl":
            %s
                  ',
            tolower(self$`supportsComposableMl`)
          )
        },
        if (!is.null(self$`supportsMonotonicConstraints`)) {
          sprintf(
            '"supportsMonotonicConstraints":
            %s
                  ',
            tolower(self$`supportsMonotonicConstraints`)
          )
        },
        if (!is.null(self$`timeWindowSamplePct`)) {
          sprintf(
            '"timeWindowSamplePct":
            %d
                  ',
            self$`timeWindowSamplePct`
          )
        },
        if (!is.null(self$`trainingDuration`)) {
          sprintf(
            '"trainingDuration":
            "%s"
                  ',
            self$`trainingDuration`
          )
        },
        if (!is.null(self$`trainingEndDate`)) {
          sprintf(
            '"trainingEndDate":
            "%s"
                  ',
            format(self$`trainingEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`trainingInfo`)) {
          sprintf(
            '"trainingInfo":
          %s
        ',
            jsonlite::toJSON(self$`trainingInfo`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`trainingRowCount`)) {
          sprintf(
            '"trainingRowCount":
            %d
                  ',
            self$`trainingRowCount`
          )
        },
        if (!is.null(self$`trainingStartDate`)) {
          sprintf(
            '"trainingStartDate":
            "%s"
                  ',
            format(self$`trainingStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`windowsBasisUnit`)) {
          sprintf(
            '"windowsBasisUnit":
            "%s"
                  ',
            self$`windowsBasisUnit`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param DatetimeModelDetailsResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(DatetimeModelDetailsResponseJson, validateParams = FALSE) {
      DatetimeModelDetailsResponseObject <- jsonlite::fromJSON(DatetimeModelDetailsResponseJson)
      self$`backtests` <- ApiClient$new()$deserializeObj(DatetimeModelDetailsResponseObject$`backtests`, "array[BacktestStatusResponse]", loadNamespace("datarobot.apicore"))
      self$`blueprintId` <- DatetimeModelDetailsResponseObject$`blueprintId`
      self$`dataSelectionMethod` <- DatetimeModelDetailsResponseObject$`dataSelectionMethod`
      self$`effectiveFeatureDerivationWindowEnd` <- DatetimeModelDetailsResponseObject$`effectiveFeatureDerivationWindowEnd`
      self$`effectiveFeatureDerivationWindowStart` <- DatetimeModelDetailsResponseObject$`effectiveFeatureDerivationWindowStart`
      self$`featurelistId` <- DatetimeModelDetailsResponseObject$`featurelistId`
      self$`featurelistName` <- DatetimeModelDetailsResponseObject$`featurelistName`
      self$`forecastWindowEnd` <- DatetimeModelDetailsResponseObject$`forecastWindowEnd`
      self$`forecastWindowStart` <- DatetimeModelDetailsResponseObject$`forecastWindowStart`
      self$`holdoutScore` <- DatetimeModelDetailsResponseObject$`holdoutScore`
      self$`holdoutStatus` <- DatetimeModelDetailsResponseObject$`holdoutStatus`
      self$`id` <- DatetimeModelDetailsResponseObject$`id`
      self$`isFrozen` <- DatetimeModelDetailsResponseObject$`isFrozen`
      self$`isStarred` <- DatetimeModelDetailsResponseObject$`isStarred`
      self$`linkFunction` <- DatetimeModelDetailsResponseObject$`linkFunction`
      self$`metrics` <- DatetimeModelDetailsResponseObject$`metrics`
      self$`modelCategory` <- DatetimeModelDetailsResponseObject$`modelCategory`
      self$`modelFamily` <- DatetimeModelDetailsResponseObject$`modelFamily`
      self$`modelNumber` <- DatetimeModelDetailsResponseObject$`modelNumber`
      self$`modelType` <- DatetimeModelDetailsResponseObject$`modelType`
      self$`monotonicDecreasingFeaturelistId` <- DatetimeModelDetailsResponseObject$`monotonicDecreasingFeaturelistId`
      self$`monotonicIncreasingFeaturelistId` <- DatetimeModelDetailsResponseObject$`monotonicIncreasingFeaturelistId`
      self$`parentModelId` <- DatetimeModelDetailsResponseObject$`parentModelId`
      self$`predictionThreshold` <- DatetimeModelDetailsResponseObject$`predictionThreshold`
      self$`predictionThresholdReadOnly` <- DatetimeModelDetailsResponseObject$`predictionThresholdReadOnly`
      self$`processes` <- ApiClient$new()$deserializeObj(DatetimeModelDetailsResponseObject$`processes`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`projectId` <- DatetimeModelDetailsResponseObject$`projectId`
      self$`samplePct` <- DatetimeModelDetailsResponseObject$`samplePct`
      self$`samplingMethod` <- DatetimeModelDetailsResponseObject$`samplingMethod`
      self$`supportsComposableMl` <- DatetimeModelDetailsResponseObject$`supportsComposableMl`
      self$`supportsMonotonicConstraints` <- DatetimeModelDetailsResponseObject$`supportsMonotonicConstraints`
      self$`timeWindowSamplePct` <- DatetimeModelDetailsResponseObject$`timeWindowSamplePct`
      self$`trainingDuration` <- DatetimeModelDetailsResponseObject$`trainingDuration`
      self$`trainingEndDate` <- ParseRFC3339Timestamp(DatetimeModelDetailsResponseObject$`trainingEndDate`)
      self$`trainingInfo` <- TrainingInfoResponse$new()$fromJSON(jsonlite::toJSON(DatetimeModelDetailsResponseObject$trainingInfo, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`trainingRowCount` <- DatetimeModelDetailsResponseObject$`trainingRowCount`
      self$`trainingStartDate` <- ParseRFC3339Timestamp(DatetimeModelDetailsResponseObject$`trainingStartDate`)
      self$`windowsBasisUnit` <- DatetimeModelDetailsResponseObject$`windowsBasisUnit`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
