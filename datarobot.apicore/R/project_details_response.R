# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title ProjectDetailsResponse
#'
#' @description ProjectDetailsResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field advancedOptions  \link{ProjectAdvancedOptionsResponse}
#'
#' @field autopilotClusterList  list( integer ) [optional] Optional. A list of integers where each value will be used as the number of clusters in Autopilot model(s) for unsupervised clustering projects. Cannot be specified unless unsupervisedMode is true and unsupervisedType is set to &#39;clustering&#39;.
#'
#' @field autopilotMode  integer The current autopilot mode, 0 for full autopilot, 2 for manual mode, 3 for quick mode, 4 for comprehensive mode
#'
#' @field created  character The time of project creation.
#'
#' @field featureEngineeringPredictionPoint  character [optional] The date column to be used as prediction point for time-based feature engineering.
#'
#' @field fileName  character The name of the dataset used to create the project.
#'
#' @field holdoutUnlocked  character whether the holdout has been unlocked
#'
#' @field id  character The ID of a project.
#'
#' @field maxClusters  integer [optional] Only valid when unsupervisedMode is True and unsupervisedType is &#39;clustering&#39;. The maximum number of clusters allowed when training clustering models. If specified cannot be exceed the number of rows in a project&#39;s dataset divided by 50 and must be less than or equal to &#x60;minClusters&#x60;. If unsupervisedMode is True and unsupervisedType is &#39;clustering&#39; then defaults to the number of rows in the project&#39;s dataset divided by 50 or 100 if that number of greater than 100.
#'
#' @field maxTrainPct  numeric the maximum percentage of the dataset that can be used to successfully train a model without going into the validation data.
#'
#' @field maxTrainRows  integer the maximum number of rows of the dataset that can be used to successfully train a model without going into the validation data
#'
#' @field metric  character the metric used to select the best-performing models.
#'
#' @field minClusters  integer [optional] Only valid when unsupervisedMode is True and unsupervisedType is &#39;clustering&#39;. The minimum number of clusters allowed when training clustering models. If specified cannot be exceed the number of rows in a project&#39;s dataset divided by 50 and must be less than or equal to &#x60;maxClusters&#x60;. If unsupervisedMode is True and  unsupervisedType is &#39;clustering&#39; then defaults to 2.
#'
#' @field partition  \link{ProjectPartitionResponse}
#'
#' @field positiveClass  numeric if the project uses binary classification, the class designated to be the positive class.  Otherwise, null.
#'
#' @field projectName  character The name of a project.
#'
#' @field stage  character the stage of the project - if modeling, then the target is successfully set, and modeling or predictions can proceed.
#'
#' @field target  character the target of the project, null if project is unsupervised.
#'
#' @field targetType  character The target type of the project.
#'
#' @field unsupervisedMode  character indicates whether a project is unsupervised.
#'
#' @field unsupervisedType  character [optional] Only valid when unsupervisedMode is True. The type of unsupervised project, anomaly or clustering. If unsupervisedMode, defaults to &#39;anomaly&#39;.
#'
#' @field useFeatureDiscovery  character A boolean value indicating whether a feature discovery project was created as opposed to a regular project.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
ProjectDetailsResponse <- R6::R6Class(
  "ProjectDetailsResponse",
  lock_objects = FALSE,
  private = list(
    # @description The properties of this object that are required to be set.
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(`advancedOptions` = NULL, `autopilotClusterList` = NULL, `autopilotMode` = NULL, `created` = NULL, `featureEngineeringPredictionPoint` = NULL, `fileName` = NULL, `holdoutUnlocked` = NULL, `id` = NULL, `maxClusters` = NULL, `maxTrainPct` = NULL, `maxTrainRows` = NULL, `metric` = NULL, `minClusters` = NULL, `partition` = NULL, `positiveClass` = NULL, `projectName` = NULL, `stage` = NULL, `target` = NULL, `targetType` = NULL, `unsupervisedMode` = NULL, `unsupervisedType` = NULL, `useFeatureDiscovery` = NULL) {
      if (!is.null(`advancedOptions`)) {
        stopifnot(R6::is.R6(`advancedOptions`))
      }
      if (!is.null(`autopilotMode`)) {
        stopifnot(is.numeric(`autopilotMode`), length(`autopilotMode`) == 1)
      }
      if (!is.null(`created`)) {
        stopifnot(inherits(`created`, "POSIXt"))
      }
      if (!is.null(`fileName`)) {
        stopifnot(is.character(`fileName`), length(`fileName`) == 1)
      }
      if (!is.null(`holdoutUnlocked`)) {
        stopifnot(is.logical(`holdoutUnlocked`), length(`holdoutUnlocked`) == 1)
      }
      if (!is.null(`id`)) {
        stopifnot(is.character(`id`), length(`id`) == 1)
      }
      if (!is.null(`maxTrainPct`)) {
      }
      if (!is.null(`maxTrainRows`)) {
        stopifnot(is.numeric(`maxTrainRows`), length(`maxTrainRows`) == 1)
      }
      if (!is.null(`metric`)) {
        stopifnot(is.character(`metric`), length(`metric`) == 1)
      }
      if (!is.null(`partition`)) {
        stopifnot(R6::is.R6(`partition`))
      }
      if (!is.null(`positiveClass`)) {
      }
      if (!is.null(`projectName`)) {
        stopifnot(is.character(`projectName`), length(`projectName`) == 1)
      }
      if (!is.null(`stage`)) {
        stopifnot(is.character(`stage`), length(`stage`) == 1)
      }
      if (!is.null(`target`)) {
        stopifnot(is.character(`target`), length(`target`) == 1)
      }
      if (!is.null(`targetType`)) {
        stopifnot(is.character(`targetType`), length(`targetType`) == 1)
      }
      if (!is.null(`unsupervisedMode`)) {
        stopifnot(is.logical(`unsupervisedMode`), length(`unsupervisedMode`) == 1)
      }
      if (!is.null(`useFeatureDiscovery`)) {
        stopifnot(is.logical(`useFeatureDiscovery`), length(`useFeatureDiscovery`) == 1)
      }
      if (!is.null(`autopilotClusterList`)) {
        stopifnot(is.vector(`autopilotClusterList`))
      }
      if (!is.null(`featureEngineeringPredictionPoint`)) {
        stopifnot(is.character(`featureEngineeringPredictionPoint`), length(`featureEngineeringPredictionPoint`) == 1)
      }
      if (!is.null(`maxClusters`)) {
        stopifnot(is.numeric(`maxClusters`), length(`maxClusters`) == 1)
      }
      if (!is.null(`minClusters`)) {
        stopifnot(is.numeric(`minClusters`), length(`minClusters`) == 1)
      }
      if (!is.null(`unsupervisedType`)) {
        stopifnot(is.character(`unsupervisedType`), length(`unsupervisedType`) == 1)
      }
    }
  ),
  public = list(
    `advancedOptions` = NULL,
    `autopilotClusterList` = NULL,
    `autopilotMode` = NULL,
    `created` = NULL,
    `featureEngineeringPredictionPoint` = NULL,
    `fileName` = NULL,
    `holdoutUnlocked` = NULL,
    `id` = NULL,
    `maxClusters` = NULL,
    `maxTrainPct` = NULL,
    `maxTrainRows` = NULL,
    `metric` = NULL,
    `minClusters` = NULL,
    `partition` = NULL,
    `positiveClass` = NULL,
    `projectName` = NULL,
    `stage` = NULL,
    `target` = NULL,
    `targetType` = NULL,
    `unsupervisedMode` = NULL,
    `unsupervisedType` = NULL,
    `useFeatureDiscovery` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param advancedOptions
    #' @param autopilotClusterList Optional. A list of integers where each value will be used as the number of clusters in Autopilot model(s) for unsupervised clustering projects. Cannot be specified unless unsupervisedMode is true and unsupervisedType is set to &#39;clustering&#39;.
    #' @param autopilotMode The current autopilot mode, 0 for full autopilot, 2 for manual mode, 3 for quick mode, 4 for comprehensive mode
    #' @param created The time of project creation.
    #' @param featureEngineeringPredictionPoint The date column to be used as prediction point for time-based feature engineering.
    #' @param fileName The name of the dataset used to create the project.
    #' @param holdoutUnlocked whether the holdout has been unlocked
    #' @param id The ID of a project.
    #' @param maxClusters Only valid when unsupervisedMode is True and unsupervisedType is &#39;clustering&#39;. The maximum number of clusters allowed when training clustering models. If specified cannot be exceed the number of rows in a project&#39;s dataset divided by 50 and must be less than or equal to &#x60;minClusters&#x60;. If unsupervisedMode is True and unsupervisedType is &#39;clustering&#39; then defaults to the number of rows in the project&#39;s dataset divided by 50 or 100 if that number of greater than 100.
    #' @param maxTrainPct the maximum percentage of the dataset that can be used to successfully train a model without going into the validation data.
    #' @param maxTrainRows the maximum number of rows of the dataset that can be used to successfully train a model without going into the validation data
    #' @param metric the metric used to select the best-performing models.
    #' @param minClusters Only valid when unsupervisedMode is True and unsupervisedType is &#39;clustering&#39;. The minimum number of clusters allowed when training clustering models. If specified cannot be exceed the number of rows in a project&#39;s dataset divided by 50 and must be less than or equal to &#x60;maxClusters&#x60;. If unsupervisedMode is True and  unsupervisedType is &#39;clustering&#39; then defaults to 2.
    #' @param partition
    #' @param positiveClass if the project uses binary classification, the class designated to be the positive class.  Otherwise, null.
    #' @param projectName The name of a project.
    #' @param stage the stage of the project - if modeling, then the target is successfully set, and modeling or predictions can proceed.
    #' @param target the target of the project, null if project is unsupervised.
    #' @param targetType The target type of the project.
    #' @param unsupervisedMode indicates whether a project is unsupervised.
    #' @param unsupervisedType Only valid when unsupervisedMode is True. The type of unsupervised project, anomaly or clustering. If unsupervisedMode, defaults to &#39;anomaly&#39;.
    #' @param useFeatureDiscovery A boolean value indicating whether a feature discovery project was created as opposed to a regular project.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`advancedOptions` = NULL, `autopilotMode` = NULL, `created` = NULL, `fileName` = NULL, `holdoutUnlocked` = NULL, `id` = NULL, `maxTrainPct` = NULL, `maxTrainRows` = NULL, `metric` = NULL, `partition` = NULL, `positiveClass` = NULL, `projectName` = NULL, `stage` = NULL, `target` = NULL, `targetType` = NULL, `unsupervisedMode` = NULL, `useFeatureDiscovery` = NULL, `autopilotClusterList` = NULL, `featureEngineeringPredictionPoint` = NULL, `maxClusters` = NULL, `minClusters` = NULL, `unsupervisedType` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      if (validateParams) {
        lapply(list(`advancedOptions`, `autopilotMode`, `created`, `fileName`, `holdoutUnlocked`, `id`, `maxTrainPct`, `maxTrainRows`, `metric`, `partition`, `positiveClass`, `projectName`, `stage`, `target`, `targetType`, `unsupervisedMode`, `useFeatureDiscovery`), function(param) {
          stopifnot("Required param not set." = !is.null(param))
        })
        private$validateProps(advancedOptions, autopilotClusterList, autopilotMode, created, featureEngineeringPredictionPoint, fileName, holdoutUnlocked, id, maxClusters, maxTrainPct, maxTrainRows, metric, minClusters, partition, positiveClass, projectName, stage, target, targetType, unsupervisedMode, unsupervisedType, useFeatureDiscovery)
      }
      self$`advancedOptions` <- `advancedOptions`
      sapply(`autopilotClusterList`, function(x) stopifnot(is.character(x)))
      self$`autopilotMode` <- `autopilotMode`
      self$`created` <- `created`
      self$`featureEngineeringPredictionPoint` <- `featureEngineeringPredictionPoint`
      self$`fileName` <- `fileName`
      self$`holdoutUnlocked` <- `holdoutUnlocked`
      self$`id` <- `id`
      self$`maxClusters` <- `maxClusters`
      self$`maxTrainPct` <- `maxTrainPct`
      self$`maxTrainRows` <- `maxTrainRows`
      self$`metric` <- `metric`
      self$`minClusters` <- `minClusters`
      self$`partition` <- `partition`
      self$`positiveClass` <- `positiveClass`
      self$`projectName` <- `projectName`
      self$`stage` <- `stage`
      self$`target` <- `target`
      self$`targetType` <- `targetType`
      self$`unsupervisedMode` <- `unsupervisedMode`
      self$`unsupervisedType` <- `unsupervisedType`
      self$`useFeatureDiscovery` <- `useFeatureDiscovery`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    #' checking this objects set properties.
    validate = function() {
      do.call(private$validateProps, list(advancedOptions = self$`advancedOptions`, autopilotClusterList = self$`autopilotClusterList`, autopilotMode = self$`autopilotMode`, created = self$`created`, featureEngineeringPredictionPoint = self$`featureEngineeringPredictionPoint`, fileName = self$`fileName`, holdoutUnlocked = self$`holdoutUnlocked`, id = self$`id`, maxClusters = self$`maxClusters`, maxTrainPct = self$`maxTrainPct`, maxTrainRows = self$`maxTrainRows`, metric = self$`metric`, minClusters = self$`minClusters`, partition = self$`partition`, positiveClass = self$`positiveClass`, projectName = self$`projectName`, stage = self$`stage`, target = self$`target`, targetType = self$`targetType`, unsupervisedMode = self$`unsupervisedMode`, unsupervisedType = self$`unsupervisedType`, useFeatureDiscovery = self$`useFeatureDiscovery`))
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`advancedOptions`)) {
          sprintf(
            '"advancedOptions":
            %s
      ',
            jsonlite::toJSON(self$`advancedOptions`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`autopilotClusterList`)) {
          sprintf(
            '"autopilotClusterList":
            [%s]
                  ',
            paste(unlist(lapply(self$`autopilotClusterList`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`autopilotMode`)) {
          sprintf(
            '"autopilotMode":
            %d
                  ',
            self$`autopilotMode`
          )
        },
        if (!is.null(self$`created`)) {
          sprintf(
            '"created":
            "%s"
                  ',
            format(self$`created`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`featureEngineeringPredictionPoint`)) {
          sprintf(
            '"featureEngineeringPredictionPoint":
            "%s"
                  ',
            self$`featureEngineeringPredictionPoint`
          )
        },
        if (!is.null(self$`fileName`)) {
          sprintf(
            '"fileName":
            "%s"
                  ',
            self$`fileName`
          )
        },
        if (!is.null(self$`holdoutUnlocked`)) {
          sprintf(
            '"holdoutUnlocked":
            %s
                  ',
            tolower(self$`holdoutUnlocked`)
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            "%s"
                  ',
            self$`id`
          )
        },
        if (!is.null(self$`maxClusters`)) {
          sprintf(
            '"maxClusters":
            %d
                  ',
            self$`maxClusters`
          )
        },
        if (!is.null(self$`maxTrainPct`)) {
          sprintf(
            '"maxTrainPct":
            %d
                  ',
            self$`maxTrainPct`
          )
        },
        if (!is.null(self$`maxTrainRows`)) {
          sprintf(
            '"maxTrainRows":
            %d
                  ',
            self$`maxTrainRows`
          )
        },
        if (!is.null(self$`metric`)) {
          sprintf(
            '"metric":
            "%s"
                  ',
            self$`metric`
          )
        },
        if (!is.null(self$`minClusters`)) {
          sprintf(
            '"minClusters":
            %d
                  ',
            self$`minClusters`
          )
        },
        if (!is.null(self$`partition`)) {
          sprintf(
            '"partition":
            %s
      ',
            jsonlite::toJSON(self$`partition`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`positiveClass`)) {
          sprintf(
            '"positiveClass":
            %d
                  ',
            self$`positiveClass`
          )
        },
        if (!is.null(self$`projectName`)) {
          sprintf(
            '"projectName":
            "%s"
                  ',
            self$`projectName`
          )
        },
        if (!is.null(self$`stage`)) {
          sprintf(
            '"stage":
            "%s"
                  ',
            self$`stage`
          )
        },
        if (!is.null(self$`target`)) {
          sprintf(
            '"target":
            "%s"
                  ',
            self$`target`
          )
        },
        if (!is.null(self$`targetType`)) {
          sprintf(
            '"targetType":
            "%s"
                  ',
            self$`targetType`
          )
        },
        if (!is.null(self$`unsupervisedMode`)) {
          sprintf(
            '"unsupervisedMode":
            %s
                  ',
            tolower(self$`unsupervisedMode`)
          )
        },
        if (!is.null(self$`unsupervisedType`)) {
          sprintf(
            '"unsupervisedType":
            "%s"
                  ',
            self$`unsupervisedType`
          )
        },
        if (!is.null(self$`useFeatureDiscovery`)) {
          sprintf(
            '"useFeatureDiscovery":
            %s
                  ',
            tolower(self$`useFeatureDiscovery`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param ProjectDetailsResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(ProjectDetailsResponseJson, validateParams = FALSE) {
      ProjectDetailsResponseObject <- jsonlite::fromJSON(ProjectDetailsResponseJson)
      self$`advancedOptions` <- ProjectAdvancedOptionsResponse$new()$fromJSON(jsonlite::toJSON(ProjectDetailsResponseObject$advancedOptions, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`autopilotClusterList` <- ApiClient$new()$deserializeObj(ProjectDetailsResponseObject$`autopilotClusterList`, "array[integer]", loadNamespace("datarobot.apicore"))
      self$`autopilotMode` <- ProjectDetailsResponseObject$`autopilotMode`
      self$`created` <- ParseRFC3339Timestamp(ProjectDetailsResponseObject$`created`)
      self$`featureEngineeringPredictionPoint` <- ProjectDetailsResponseObject$`featureEngineeringPredictionPoint`
      self$`fileName` <- ProjectDetailsResponseObject$`fileName`
      self$`holdoutUnlocked` <- ProjectDetailsResponseObject$`holdoutUnlocked`
      self$`id` <- ProjectDetailsResponseObject$`id`
      self$`maxClusters` <- ProjectDetailsResponseObject$`maxClusters`
      self$`maxTrainPct` <- ProjectDetailsResponseObject$`maxTrainPct`
      self$`maxTrainRows` <- ProjectDetailsResponseObject$`maxTrainRows`
      self$`metric` <- ProjectDetailsResponseObject$`metric`
      self$`minClusters` <- ProjectDetailsResponseObject$`minClusters`
      self$`partition` <- ProjectPartitionResponse$new()$fromJSON(jsonlite::toJSON(ProjectDetailsResponseObject$partition, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`positiveClass` <- ProjectDetailsResponseObject$`positiveClass`
      self$`projectName` <- ProjectDetailsResponseObject$`projectName`
      self$`stage` <- ProjectDetailsResponseObject$`stage`
      self$`target` <- ProjectDetailsResponseObject$`target`
      self$`targetType` <- ProjectDetailsResponseObject$`targetType`
      self$`unsupervisedMode` <- ProjectDetailsResponseObject$`unsupervisedMode`
      self$`unsupervisedType` <- ProjectDetailsResponseObject$`unsupervisedType`
      self$`useFeatureDiscovery` <- ProjectDetailsResponseObject$`useFeatureDiscovery`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
