# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title DataConnectivity operations
#' @description datarobot.apicore.DataConnectivity
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
DataConnectivityApi <- R6::R6Class(
  "DataConnectivityApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Upload JDBC driver from file.
    #' Produces: "application/json"
    #'
    #' @details Upload JDBC driver from file. Only Java archive (.jar) files are supported.
    #' @param driverUploadRequest \link{DriverUploadRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverUploadResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`413`** JDBC driver JAR file size exceeds the configured limit.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' driverUploadRequest <- DriverUploadRequest$new() # DriverUploadRequest |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriverFileCreate(driverUploadRequest=driverUploadRequest)
    #' }
    ExternalDataDriverFileCreate = function(driverUploadRequest = NULL, ...) {
      apiResponse <- private$ExternalDataDriverFileCreateWithHttpInfo(driverUploadRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Driver configuration details.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the driver configuration with the specified ID.
    #' @param driverId character. Driver ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverConfigurationRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Driver configuration retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' driverId <- 'driverId_example' # character | Driver ID.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversConfigurationList(driverId)
    #' }
    ExternalDataDriversConfigurationList = function(driverId, ...) {
      apiResponse <- private$ExternalDataDriversConfigurationListWithHttpInfo(driverId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new JDBC driver.
    #' Produces: "application/json"
    #'
    #' @details Create a new JDBC driver. To create connections from fields, rather than supplying a JDBC URL, use &#39;configurationId&#39;. When using &#39;configurationId&#39;, do not include &#39;canonicalName&#39; or &#39;className&#39; as they are part of the driver configuration. Specifying a &#39;version&#39; is required as it is used in the construction of the canonicalName.
    #' @param createDriverRequest \link{CreateDriverRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Details about new driver entity.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' createDriverRequest <- CreateDriverRequest$new() # CreateDriverRequest |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversCreate(createDriverRequest=createDriverRequest)
    #' }
    ExternalDataDriversCreate = function(createDriverRequest = NULL, ...) {
      apiResponse <- private$ExternalDataDriversCreateWithHttpInfo(createDriverRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete the driver.
    #' Produces: NA
    #'
    #' @details Delete the driver with given ID if it is not used by any data store or data source.
    #' @param driverId character. Driver ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Driver deleted successfully.
    #' \itemize{
    #' }
    #' \item **`409`** Driver is in use by one or more data store or data source
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' driverId <- 'driverId_example' # character | Driver ID.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversDelete(driverId)
    #' }
    ExternalDataDriversDelete = function(driverId, ...) {
      apiResponse <- private$ExternalDataDriversDeleteWithHttpInfo(driverId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List drivers
    #' Produces: "application/json"
    #'
    #' @details Fetch all drivers a user has access to.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Drivers accessible by the user.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversList()
    #' }
    ExternalDataDriversList = function(...) {
      apiResponse <- private$ExternalDataDriversListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update properties of an existing JDBC Driver.
    #' Produces: "application/json"
    #'
    #' @details Update properties of an existing JDBC driver. To change the canonicalName and className, you must first remove the driver configuration, if it exists, as its properties will otherwise override name changes.
    #' @param driverId character. Driver ID.
    #' @param updateDriverRequest \link{UpdateDriverRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Driver properties updated successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' driverId <- 'driverId_example' # character | Driver ID.
    #' updateDriverRequest <- UpdateDriverRequest$new() # UpdateDriverRequest |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversPatch(driverId, updateDriverRequest=updateDriverRequest)
    #' }
    ExternalDataDriversPatch = function(driverId, updateDriverRequest = NULL, ...) {
      apiResponse <- private$ExternalDataDriversPatchWithHttpInfo(driverId, updateDriverRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve driver details.
    #' Produces: "application/json"
    #'
    #' @details Retrieve driver details by ID.
    #' @param driverId character. Driver ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Driver details retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' driverId <- 'driverId_example' # character | Driver ID.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataDriversRetrieve(driverId)
    #' }
    ExternalDataDriversRetrieve = function(driverId, ...) {
      apiResponse <- private$ExternalDataDriversRetrieveWithHttpInfo(driverId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get data source&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations who have access to this data source and their roles.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param username character. Optional, only return the access control information for a user with this username.
    #' @param userId character. Optional, only return the access control information for a user with this user ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharingListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The data source&#39;s access control list.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Either the data source does not exist or the user does not have permissions to view the data source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #' username <- 'username_example' # character | Optional, only return the access control information for a user with this username.
    #' userId <- 'userId_example' # character | Optional, only return the access control information for a user with this user ID.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesAccessControlList(offset, limit, dataSourceId, username=username, userId=userId)
    #' }
    ExternalDataSourcesAccessControlList = function(offset, limit, dataSourceId, username = NULL, userId = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesAccessControlListWithHttpInfo(offset, limit, dataSourceId, username, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update data source&#39;s access controls
    #' Produces: NA
    #'
    #' @details Set roles for users on this data source. Note that when granting access to a data source, access to the corresponding data store as a \&quot;CONSUMER\&quot; will also be granted.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param sharingUpdateOrRemoveWithGrant \link{SharingUpdateOrRemoveWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the data source without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #' sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesAccessControlPatchMany(dataSourceId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
    #' }
    ExternalDataSourcesAccessControlPatchMany = function(dataSourceId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesAccessControlPatchManyWithHttpInfo(dataSourceId, sharingUpdateOrRemoveWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a data source.
    #' Produces: "application/json"
    #'
    #' @details Create a fully configured source of data which could be used for datasets and projects creation.A &#x60;data source&#x60; specifies, via SQL query or selected table and schema data, which data to extract from the &#x60;data connection&#x60; (the location of data within a given endpoint) to use for modeling or predictions. A &#x60;data source&#x60; has one &#x60;data connection&#x60; and one &#x60;connector&#x60; but can have many &#x60;datasets&#x60;. To test the SQL query before creating the data source,use :http:post:&#x60;/api/v2/externalDataStores/(dataStoreId)/verifySQL/&#x60;.
    #' @param dataSourceCreate \link{DataSourceCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataSourceRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data source created successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceCreate <- DataSourceCreate$new() # DataSourceCreate |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesCreate(dataSourceCreate=dataSourceCreate)
    #' }
    ExternalDataSourcesCreate = function(dataSourceCreate = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesCreateWithHttpInfo(dataSourceCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete the data source.
    #' Produces: NA
    #'
    #' @details Delete the data source with given ID if it is not used by any dataset.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Data source deleted successfully.
    #' \itemize{
    #' }
    #' \item **`409`** Data source is in use by one or more datasets
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesDelete(dataSourceId)
    #' }
    ExternalDataSourcesDelete = function(dataSourceId, ...) {
      apiResponse <- private$ExternalDataSourcesDeleteWithHttpInfo(dataSourceId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List data sources.
    #' Produces: "application/json"
    #'
    #' @details Return detailed list of available data sources.
    #' @param type Enum < [dr-connector-v1, all, jdbc] > Data source type to filter by.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataSourceListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data sources retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' type <- "jdbc" # character | Data source type to filter by.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesList(type=type)
    #' }
    ExternalDataSourcesList = function(type = "jdbc", ...) {
      apiResponse <- private$ExternalDataSourcesListWithHttpInfo(type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the data source.
    #' Produces: NA
    #'
    #' @details Update the data source with given ID. To test the SQL query before updating the data source,use :http:post:&#x60;/api/v2/externalDataStores/(dataStoreId)/verifySQL/&#x60;.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param dataSourceUpdate \link{DataSourceUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Data source updated successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #' dataSourceUpdate <- DataSourceUpdate$new() # DataSourceUpdate |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesPatch(dataSourceId, dataSourceUpdate=dataSourceUpdate)
    #' }
    ExternalDataSourcesPatch = function(dataSourceId, dataSourceUpdate = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesPatchWithHttpInfo(dataSourceId, dataSourceUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Describe data source permissions.
    #' Produces: "application/json"
    #'
    #' @details Describe what permissions current user has for given data source.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataSourceDescribePermissionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The data source permissions.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesPermissionsList(dataSourceId)
    #' }
    ExternalDataSourcesPermissionsList = function(dataSourceId, ...) {
      apiResponse <- private$ExternalDataSourcesPermissionsListWithHttpInfo(dataSourceId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Data source details.
    #' Produces: "application/json"
    #'
    #' @details Return details of the existing data source with given ID, including SQL query or selected table and schema data, which fully describe which data to extract and from which location.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataSourceRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data source details retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesRetrieve(dataSourceId)
    #' }
    ExternalDataSourcesRetrieve = function(dataSourceId, ...) {
      apiResponse <- private$ExternalDataSourcesRetrieveWithHttpInfo(dataSourceId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get data source&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users, groups and organizations who have access to this data source and their roles.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param id character. Only return roles for a user, group or organization with this identifier.
    #' @param name character. Only return roles for a user, group or organization with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > List access controls for recipients with this type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharedRolesWithGrantListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A paginated list of user/group/organization roles.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 10 # integer | At most this many results are returned
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesSharedRolesList(offset, limit, dataSourceId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    ExternalDataSourcesSharedRolesList = function(offset, limit, dataSourceId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesSharedRolesListWithHttpInfo(offset, limit, dataSourceId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Modify data source shared roles.
    #' Produces: NA
    #'
    #' @details Grant access, remove access or update roles for organizations, groups or users on this data source. Up to 100 roles may be set per array in a single request.
    #' @param dataSourceId character. The ID of the Data Source.
    #' @param sharedRolesUpdateWithGrant \link{SharedRolesUpdateWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** Duplicate entry for the org/group/user in roles listor the request would leave the data source without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** Request is unprocessable. For example, &#x60;name&#x60; is stated for not user recipient.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataSourceId <- 'dataSourceId_example' # character | The ID of the Data Source.
    #' sharedRolesUpdateWithGrant <- SharedRolesUpdateWithGrant$new() # SharedRolesUpdateWithGrant |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataSourcesSharedRolesPatchMany(dataSourceId, sharedRolesUpdateWithGrant=sharedRolesUpdateWithGrant)
    #' }
    ExternalDataSourcesSharedRolesPatchMany = function(dataSourceId, sharedRolesUpdateWithGrant = NULL, ...) {
      apiResponse <- private$ExternalDataSourcesSharedRolesPatchManyWithHttpInfo(dataSourceId, sharedRolesUpdateWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update data store&#39;s controls
    #' Produces: NA
    #'
    #' @details Set roles for users on this data store.
    #' @param dataStoreId character. ID of the data store.
    #' @param sharingUpdateOrRemoveWithGrant \link{SharingUpdateOrRemoveWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the data store without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresAccessControlPatchMany(dataStoreId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
    #' }
    ExternalDataStoresAccessControlPatchMany = function(dataStoreId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      apiResponse <- private$ExternalDataStoresAccessControlPatchManyWithHttpInfo(dataStoreId, sharingUpdateOrRemoveWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieves a data store&#39;s data columns.
    #' Produces: "application/json"
    #'
    #' @details Retrieves a data store&#39;s data columns.
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreColumnsList \link{DataStoreColumnsList}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreColumnsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns response with array of Column objects.
    #' \itemize{
    #' }
    #' \item **`400`** Error thrown by DSS system when retrieving columns
    #' \itemize{
    #' }
    #' \item **`403`** Incorrect permissions to access catalog item through DSS
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreColumnsList <- DataStoreColumnsList$new() # DataStoreColumnsList |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresColumnsCreate(dataStoreId, dataStoreColumnsList=dataStoreColumnsList)
    #' }
    ExternalDataStoresColumnsCreate = function(dataStoreId, dataStoreColumnsList = NULL, ...) {
      apiResponse <- private$ExternalDataStoresColumnsCreateWithHttpInfo(dataStoreId, dataStoreColumnsList, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a data store.
    #' Produces: "application/json"
    #'
    #' @details Create a data store which includes a name and a driver ID or a connector ID. The driver would be configured by a JDBC URL or by jdbc fields; The connector would be configured by connection fields.
    #' @param dataStoreCreate \link{DataStoreCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data store created successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreCreate <- DataStoreCreate$new() # DataStoreCreate |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresCreate(dataStoreCreate=dataStoreCreate)
    #' }
    ExternalDataStoresCreate = function(dataStoreCreate = NULL, ...) {
      apiResponse <- private$ExternalDataStoresCreateWithHttpInfo(dataStoreCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List credentials associated with the specified data store.
    #' Produces: "application/json"
    #'
    #' @details Returns a list of credentials associated with the specified data store.
    #' @param dataStoreId character. ID of the data store.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param types \link{OneOfstringarray}. Includes only credentials of the specified type. Repeat the parameter for filtering on multiple statuses.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CredentialsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of credentials associated with the data store.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' types <- OneOfstringarray$new() # OneOfstringarray | Includes only credentials of the specified type. Repeat the parameter for filtering on multiple statuses.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresCredentialsList(dataStoreId, offset=offset, limit=limit, types=types)
    #' }
    ExternalDataStoresCredentialsList = function(dataStoreId, offset = 0, limit = 100, types = NULL, ...) {
      apiResponse <- private$ExternalDataStoresCredentialsListWithHttpInfo(dataStoreId, offset, limit, types, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete the data store.
    #' Produces: NA
    #'
    #' @details Delete the data store with given ID if it is not used by any data source.
    #' @param dataStoreId character. ID of the data store.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Data store deleted successfully.
    #' \itemize{
    #' }
    #' \item **`409`** Data store is in use by one or more data source
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresDelete(dataStoreId)
    #' }
    ExternalDataStoresDelete = function(dataStoreId, ...) {
      apiResponse <- private$ExternalDataStoresDeleteWithHttpInfo(dataStoreId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List data stores.
    #' Produces: "application/json"
    #'
    #' @details Return list with details of the existing data stores available for the user.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param type Enum < [dr-connector-v1, jdbc, all] > Includes only data stores of the specified type or any if set to &#x60;all&#x60;.
    #' @param showHidden Enum < [false, False, true, True] > Specifies whether non-visible OAuth fields are shown.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data stores retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' type <- "jdbc" # character | Includes only data stores of the specified type or any if set to `all`.
    #' showHidden <- "False" # character | Specifies whether non-visible OAuth fields are shown.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresList(offset=offset, limit=limit, type=type, showHidden=showHidden)
    #' }
    ExternalDataStoresList = function(offset = 0, limit = 100, type = "jdbc", showHidden = "False", ...) {
      apiResponse <- private$ExternalDataStoresListWithHttpInfo(offset, limit, type, showHidden, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Updates a data store configuration.
    #' Produces: "application/json"
    #'
    #' @details Updates a data store configuration.
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreUpdate \link{DataStoreUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns the updated data store entry.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreUpdate <- DataStoreUpdate$new() # DataStoreUpdate |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresPatch(dataStoreId, dataStoreUpdate=dataStoreUpdate)
    #' }
    ExternalDataStoresPatch = function(dataStoreId, dataStoreUpdate = NULL, ...) {
      apiResponse <- private$ExternalDataStoresPatchWithHttpInfo(dataStoreId, dataStoreUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Describe data store permissions.
    #' Produces: "application/json"
    #'
    #' @details Describe what permissions current user has for given data store.
    #' @param dataStoreId character. ID of the data store.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreDescribePermissionsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The data store permissions.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresPermissionsList(dataStoreId)
    #' }
    ExternalDataStoresPermissionsList = function(dataStoreId, ...) {
      apiResponse <- private$ExternalDataStoresPermissionsListWithHttpInfo(dataStoreId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Data store details.
    #' Produces: "application/json"
    #'
    #' @details A configured connection to a database - it has a name and a specified driver. The driver may be specified by a JDBC URL or connection parameters if the driver was created with the parameter configuration.
    #' @param dataStoreId character. ID of the data store.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data store details retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresRetrieve(dataStoreId)
    #' }
    ExternalDataStoresRetrieve = function(dataStoreId, ...) {
      apiResponse <- private$ExternalDataStoresRetrieveWithHttpInfo(dataStoreId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieves a data store&#39;s data schemas.
    #' Produces: "application/json"
    #'
    #' @details Retrieves a data store&#39;s data schemas.
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreCredentials \link{DataStoreCredentials}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreSchemasList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns response with schemas and catalog.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreCredentials <- DataStoreCredentials$new() # DataStoreCredentials |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresSchemasCreate(dataStoreId, dataStoreCredentials=dataStoreCredentials)
    #' }
    ExternalDataStoresSchemasCreate = function(dataStoreId, dataStoreCredentials = NULL, ...) {
      apiResponse <- private$ExternalDataStoresSchemasCreateWithHttpInfo(dataStoreId, dataStoreCredentials, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get data store&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users who have access to this data store and their roles on the data store.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param dataStoreId character. ID of the data store.
    #' @param id character. Only return roles for a user, group or organization with this identifier.
    #' @param name character. Only return roles for a user, group or organization with this name.
    #' @param shareRecipientType Enum < [user, group, organization] > List access controls for recipients with this type.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharedRolesWithGrantListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The data store&#39;s access control list.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Either the data store does not exist or the user does not have permissions to view the data store.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 10 # integer | At most this many results are returned
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' id <- 'id_example' # character | Only return roles for a user, group or organization with this identifier.
    #' name <- 'name_example' # character | Only return roles for a user, group or organization with this name.
    #' shareRecipientType <- 'shareRecipientType_example' # character | List access controls for recipients with this type.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresSharedRolesList(offset, limit, dataStoreId, id=id, name=name, shareRecipientType=shareRecipientType)
    #' }
    ExternalDataStoresSharedRolesList = function(offset, limit, dataStoreId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      apiResponse <- private$ExternalDataStoresSharedRolesListWithHttpInfo(offset, limit, dataStoreId, id, name, shareRecipientType, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Modify data store shared roles.
    #' Produces: NA
    #'
    #' @details Grant access, remove access or update roles for organizations, groups or users on this data store. Up to 100 roles may be set per array in a single request.
    #' @param dataStoreId character. ID of the data store.
    #' @param sharedRolesUpdateWithGrant \link{SharedRolesUpdateWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Successfully modified.
    #' \itemize{
    #' }
    #' \item **`409`** Duplicate entry for the org/group/user in roles listor the request would leave the data store without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** Request is unprocessable. For example, &#x60;name&#x60; is stated for not user recipient.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' sharedRolesUpdateWithGrant <- SharedRolesUpdateWithGrant$new() # SharedRolesUpdateWithGrant |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresSharedRolesPatchMany(dataStoreId, sharedRolesUpdateWithGrant=sharedRolesUpdateWithGrant)
    #' }
    ExternalDataStoresSharedRolesPatchMany = function(dataStoreId, sharedRolesUpdateWithGrant = NULL, ...) {
      apiResponse <- private$ExternalDataStoresSharedRolesPatchManyWithHttpInfo(dataStoreId, sharedRolesUpdateWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieves a data store&#39;s database tables (including views).
    #' Produces: "application/json"
    #'
    #' @details Retrieves a data store&#39;s database tables (including views).
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreTables \link{DataStoreTables}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreTablesList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of tables available in the retrieved data store.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreTables <- DataStoreTables$new() # DataStoreTables |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresTablesCreate(dataStoreId, dataStoreTables=dataStoreTables)
    #' }
    ExternalDataStoresTablesCreate = function(dataStoreId, dataStoreTables = NULL, ...) {
      apiResponse <- private$ExternalDataStoresTablesCreateWithHttpInfo(dataStoreId, dataStoreTables, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Tests data store connection.
    #' Produces: "application/json"
    #'
    #' @details Tests the ability to connect to a data store with specified authentication.
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreCredentialsWithCredentialsTypeSupport \link{DataStoreCredentialsWithCredentialsTypeSupport}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreTestResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Outcome of the connection test.
    #' \itemize{
    #' }
    #' \item **`400`** Details on why the connect call failed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreCredentialsWithCredentialsTypeSupport <- DataStoreCredentialsWithCredentialsTypeSupport$new() # DataStoreCredentialsWithCredentialsTypeSupport |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresTestCreate(dataStoreId, dataStoreCredentialsWithCredentialsTypeSupport=dataStoreCredentialsWithCredentialsTypeSupport)
    #' }
    ExternalDataStoresTestCreate = function(dataStoreId, dataStoreCredentialsWithCredentialsTypeSupport = NULL, ...) {
      apiResponse <- private$ExternalDataStoresTestCreateWithHttpInfo(dataStoreId, dataStoreCredentialsWithCredentialsTypeSupport, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Verifies a SQL query for a data store.
    #' Produces: "application/json"
    #'
    #' @details Executes the SQL query on the data store, returning a small number of rows (max 999). Use this for quick query execution validation and exploring results, not for capturing an entire result set.
    #' @param dataStoreId character. ID of the data store.
    #' @param dataStoreSqlVerify \link{DataStoreSQLVerify}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataStoreSQLVerifyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns the names of columns and a limited number of results from the SQL query.
    #' \itemize{
    #' }
    #' \item **`400`** Details explaining why the SQL query is invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' dataStoreId <- 'dataStoreId_example' # character | ID of the data store.
    #' dataStoreSqlVerify <- DataStoreSQLVerify$new() # DataStoreSQLVerify |
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDataStoresVerifySQLCreate(dataStoreId, dataStoreSqlVerify=dataStoreSqlVerify)
    #' }
    ExternalDataStoresVerifySQLCreate = function(dataStoreId, dataStoreSqlVerify = NULL, ...) {
      apiResponse <- private$ExternalDataStoresVerifySQLCreateWithHttpInfo(dataStoreId, dataStoreSqlVerify, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List available driver configurations.
    #' Produces: "application/json"
    #'
    #' @details Retrieve matching driver configurations based on query.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param type Enum < [dr-connector-v1, jdbc, all] > Type of driver configurations to return.
    #' @param showHidden Enum < [false, False, true, True] > If True, include hidden configurations in response.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverConfigurationListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Driver configurations retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' type <- "jdbc" # character | Type of driver configurations to return.
    #' showHidden <- "False" # character | If True, include hidden configurations in response.
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDriverConfigurationsList(offset=offset, limit=limit, type=type, showHidden=showHidden)
    #' }
    ExternalDriverConfigurationsList = function(offset = 0, limit = 100, type = "jdbc", showHidden = "False", ...) {
      apiResponse <- private$ExternalDriverConfigurationsListWithHttpInfo(offset, limit, type, showHidden, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Driver configuration details.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the driver configuration with the specified ID.
    #' @param configurationId character. Driver configuration ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DriverConfigurationRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Driver configuration retrieved successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' configurationId <- 'configurationId_example' # character | Driver configuration ID
    #'
    #' api.instance <- DataConnectivityApi$new()
    #' result <- api.instance$ExternalDriverConfigurationsRetrieve(configurationId)
    #' }
    ExternalDriverConfigurationsRetrieve = function(configurationId, ...) {
      apiResponse <- private$ExternalDriverConfigurationsRetrieveWithHttpInfo(configurationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `ExternalDataDriverFileCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriverFileCreateWithHttpInfo = function(driverUploadRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`driverUploadRequest`) && isa(driverUploadRequest, c("DriverUploadRequest", "R6"))) {
        body <- `driverUploadRequest`$toJSON()
      } else {
        stop("ExternalDataDriverFileCreateWithHttpInfo requires parameter driverUploadRequest to be of type DriverUploadRequest.")
      }

      urlPath <- "/externalDataDriverFile/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverUploadResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversConfigurationList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversConfigurationListWithHttpInfo = function(driverId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`driverId`)) {
        stop("Missing required parameter `driverId`.")
      }

      body <- NULL
      urlPath <- "/externalDataDrivers/{driverId}/configuration/"
      if (!missing(`driverId`)) {
        urlPath <- gsub(paste0("\\{", "driverId", "\\}"), URLencode(as.character(`driverId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverConfigurationRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversCreateWithHttpInfo = function(createDriverRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`createDriverRequest`) && isa(createDriverRequest, c("CreateDriverRequest", "R6"))) {
        body <- `createDriverRequest`$toJSON()
      } else {
        stop("ExternalDataDriversCreateWithHttpInfo requires parameter createDriverRequest to be of type CreateDriverRequest.")
      }

      urlPath <- "/externalDataDrivers/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversDeleteWithHttpInfo = function(driverId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`driverId`)) {
        stop("Missing required parameter `driverId`.")
      }

      body <- NULL
      urlPath <- "/externalDataDrivers/{driverId}/"
      if (!missing(`driverId`)) {
        urlPath <- gsub(paste0("\\{", "driverId", "\\}"), URLencode(as.character(`driverId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversListWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/externalDataDrivers/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversPatchWithHttpInfo = function(driverId, updateDriverRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`driverId`)) {
        stop("Missing required parameter `driverId`.")
      }

      if (!missing(`updateDriverRequest`) && isa(updateDriverRequest, c("UpdateDriverRequest", "R6"))) {
        body <- `updateDriverRequest`$toJSON()
      } else {
        stop("ExternalDataDriversPatchWithHttpInfo requires parameter updateDriverRequest to be of type UpdateDriverRequest.")
      }

      urlPath <- "/externalDataDrivers/{driverId}/"
      if (!missing(`driverId`)) {
        urlPath <- gsub(paste0("\\{", "driverId", "\\}"), URLencode(as.character(`driverId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataDriversRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataDriversRetrieveWithHttpInfo = function(driverId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`driverId`)) {
        stop("Missing required parameter `driverId`.")
      }

      body <- NULL
      urlPath <- "/externalDataDrivers/{driverId}/"
      if (!missing(`driverId`)) {
        urlPath <- gsub(paste0("\\{", "driverId", "\\}"), URLencode(as.character(`driverId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesAccessControlListWithHttpInfo = function(offset, limit, dataSourceId, username = NULL, userId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["username"] <- username

      queryParams["userId"] <- userId

      body <- NULL
      urlPath <- "/externalDataSources/{dataSourceId}/accessControl/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharingListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesAccessControlPatchManyWithHttpInfo = function(dataSourceId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      if (!missing(`sharingUpdateOrRemoveWithGrant`) && isa(sharingUpdateOrRemoveWithGrant, c("SharingUpdateOrRemoveWithGrant", "R6"))) {
        body <- `sharingUpdateOrRemoveWithGrant`$toJSON()
      } else {
        stop("ExternalDataSourcesAccessControlPatchManyWithHttpInfo requires parameter sharingUpdateOrRemoveWithGrant to be of type SharingUpdateOrRemoveWithGrant.")
      }

      urlPath <- "/externalDataSources/{dataSourceId}/accessControl/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesCreateWithHttpInfo = function(dataSourceCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`dataSourceCreate`) && isa(dataSourceCreate, c("DataSourceCreate", "R6"))) {
        body <- `dataSourceCreate`$toJSON()
      } else {
        stop("ExternalDataSourcesCreateWithHttpInfo requires parameter dataSourceCreate to be of type DataSourceCreate.")
      }

      urlPath <- "/externalDataSources/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataSourceRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesDeleteWithHttpInfo = function(dataSourceId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      body <- NULL
      urlPath <- "/externalDataSources/{dataSourceId}/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesListWithHttpInfo = function(type = "jdbc", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["type"] <- type

      body <- NULL
      urlPath <- "/externalDataSources/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataSourceListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesPatchWithHttpInfo = function(dataSourceId, dataSourceUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      if (!missing(`dataSourceUpdate`) && isa(dataSourceUpdate, c("DataSourceUpdate", "R6"))) {
        body <- `dataSourceUpdate`$toJSON()
      } else {
        stop("ExternalDataSourcesPatchWithHttpInfo requires parameter dataSourceUpdate to be of type DataSourceUpdate.")
      }

      urlPath <- "/externalDataSources/{dataSourceId}/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesPermissionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesPermissionsListWithHttpInfo = function(dataSourceId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      body <- NULL
      urlPath <- "/externalDataSources/{dataSourceId}/permissions/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataSourceDescribePermissionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesRetrieveWithHttpInfo = function(dataSourceId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      body <- NULL
      urlPath <- "/externalDataSources/{dataSourceId}/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataSourceRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesSharedRolesListWithHttpInfo = function(offset, limit, dataSourceId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      queryParams["id"] <- id

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      body <- NULL
      urlPath <- "/externalDataSources/{dataSourceId}/sharedRoles/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharedRolesWithGrantListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataSourcesSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataSourcesSharedRolesPatchManyWithHttpInfo = function(dataSourceId, sharedRolesUpdateWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataSourceId`)) {
        stop("Missing required parameter `dataSourceId`.")
      }

      if (!missing(`sharedRolesUpdateWithGrant`) && isa(sharedRolesUpdateWithGrant, c("SharedRolesUpdateWithGrant", "R6"))) {
        body <- `sharedRolesUpdateWithGrant`$toJSON()
      } else {
        stop("ExternalDataSourcesSharedRolesPatchManyWithHttpInfo requires parameter sharedRolesUpdateWithGrant to be of type SharedRolesUpdateWithGrant.")
      }

      urlPath <- "/externalDataSources/{dataSourceId}/sharedRoles/"
      if (!missing(`dataSourceId`)) {
        urlPath <- gsub(paste0("\\{", "dataSourceId", "\\}"), URLencode(as.character(`dataSourceId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresAccessControlPatchManyWithHttpInfo = function(dataStoreId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`sharingUpdateOrRemoveWithGrant`) && isa(sharingUpdateOrRemoveWithGrant, c("SharingUpdateOrRemoveWithGrant", "R6"))) {
        body <- `sharingUpdateOrRemoveWithGrant`$toJSON()
      } else {
        stop("ExternalDataStoresAccessControlPatchManyWithHttpInfo requires parameter sharingUpdateOrRemoveWithGrant to be of type SharingUpdateOrRemoveWithGrant.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/accessControl/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresColumnsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresColumnsCreateWithHttpInfo = function(dataStoreId, dataStoreColumnsList = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreColumnsList`) && isa(dataStoreColumnsList, c("DataStoreColumnsList", "R6"))) {
        body <- `dataStoreColumnsList`$toJSON()
      } else {
        stop("ExternalDataStoresColumnsCreateWithHttpInfo requires parameter dataStoreColumnsList to be of type DataStoreColumnsList.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/columns/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreColumnsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresCreateWithHttpInfo = function(dataStoreCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`dataStoreCreate`) && isa(dataStoreCreate, c("DataStoreCreate", "R6"))) {
        body <- `dataStoreCreate`$toJSON()
      } else {
        stop("ExternalDataStoresCreateWithHttpInfo requires parameter dataStoreCreate to be of type DataStoreCreate.")
      }

      urlPath <- "/externalDataStores/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresCredentialsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresCredentialsListWithHttpInfo = function(dataStoreId, offset = 0, limit = 100, types = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["types"] <- types

      body <- NULL
      urlPath <- "/externalDataStores/{dataStoreId}/credentials/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CredentialsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresDeleteWithHttpInfo = function(dataStoreId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      body <- NULL
      urlPath <- "/externalDataStores/{dataStoreId}/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresListWithHttpInfo = function(offset = 0, limit = 100, type = "jdbc", showHidden = "False", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["type"] <- type

      queryParams["showHidden"] <- showHidden

      body <- NULL
      urlPath <- "/externalDataStores/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresPatchWithHttpInfo = function(dataStoreId, dataStoreUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreUpdate`) && isa(dataStoreUpdate, c("DataStoreUpdate", "R6"))) {
        body <- `dataStoreUpdate`$toJSON()
      } else {
        stop("ExternalDataStoresPatchWithHttpInfo requires parameter dataStoreUpdate to be of type DataStoreUpdate.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresPermissionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresPermissionsListWithHttpInfo = function(dataStoreId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      body <- NULL
      urlPath <- "/externalDataStores/{dataStoreId}/permissions/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreDescribePermissionsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresRetrieveWithHttpInfo = function(dataStoreId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      body <- NULL
      urlPath <- "/externalDataStores/{dataStoreId}/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresSchemasCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresSchemasCreateWithHttpInfo = function(dataStoreId, dataStoreCredentials = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreCredentials`) && isa(dataStoreCredentials, c("DataStoreCredentials", "R6"))) {
        body <- `dataStoreCredentials`$toJSON()
      } else {
        stop("ExternalDataStoresSchemasCreateWithHttpInfo requires parameter dataStoreCredentials to be of type DataStoreCredentials.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/schemas/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreSchemasList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresSharedRolesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresSharedRolesListWithHttpInfo = function(offset, limit, dataStoreId, id = NULL, name = NULL, shareRecipientType = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      queryParams["id"] <- id

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["name"] <- name

      queryParams["shareRecipientType"] <- shareRecipientType

      body <- NULL
      urlPath <- "/externalDataStores/{dataStoreId}/sharedRoles/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharedRolesWithGrantListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresSharedRolesPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresSharedRolesPatchManyWithHttpInfo = function(dataStoreId, sharedRolesUpdateWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`sharedRolesUpdateWithGrant`) && isa(sharedRolesUpdateWithGrant, c("SharedRolesUpdateWithGrant", "R6"))) {
        body <- `sharedRolesUpdateWithGrant`$toJSON()
      } else {
        stop("ExternalDataStoresSharedRolesPatchManyWithHttpInfo requires parameter sharedRolesUpdateWithGrant to be of type SharedRolesUpdateWithGrant.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/sharedRoles/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresTablesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresTablesCreateWithHttpInfo = function(dataStoreId, dataStoreTables = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreTables`) && isa(dataStoreTables, c("DataStoreTables", "R6"))) {
        body <- `dataStoreTables`$toJSON()
      } else {
        stop("ExternalDataStoresTablesCreateWithHttpInfo requires parameter dataStoreTables to be of type DataStoreTables.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/tables/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreTablesList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresTestCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresTestCreateWithHttpInfo = function(dataStoreId, dataStoreCredentialsWithCredentialsTypeSupport = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreCredentialsWithCredentialsTypeSupport`) && isa(dataStoreCredentialsWithCredentialsTypeSupport, c("DataStoreCredentialsWithCredentialsTypeSupport", "R6"))) {
        body <- `dataStoreCredentialsWithCredentialsTypeSupport`$toJSON()
      } else {
        stop("ExternalDataStoresTestCreateWithHttpInfo requires parameter dataStoreCredentialsWithCredentialsTypeSupport to be of type DataStoreCredentialsWithCredentialsTypeSupport.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/test/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreTestResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDataStoresVerifySQLCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDataStoresVerifySQLCreateWithHttpInfo = function(dataStoreId, dataStoreSqlVerify = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`dataStoreId`)) {
        stop("Missing required parameter `dataStoreId`.")
      }

      if (!missing(`dataStoreSqlVerify`) && isa(dataStoreSqlVerify, c("DataStoreSQLVerify", "R6"))) {
        body <- `dataStoreSqlVerify`$toJSON()
      } else {
        stop("ExternalDataStoresVerifySQLCreateWithHttpInfo requires parameter dataStoreSqlVerify to be of type DataStoreSQLVerify.")
      }

      urlPath <- "/externalDataStores/{dataStoreId}/verifySQL/"
      if (!missing(`dataStoreId`)) {
        urlPath <- gsub(paste0("\\{", "dataStoreId", "\\}"), URLencode(as.character(`dataStoreId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataStoreSQLVerifyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDriverConfigurationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDriverConfigurationsListWithHttpInfo = function(offset = 0, limit = 100, type = "jdbc", showHidden = "False", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["type"] <- type

      queryParams["showHidden"] <- showHidden

      body <- NULL
      urlPath <- "/externalDriverConfigurations/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverConfigurationListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalDriverConfigurationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalDriverConfigurationsRetrieveWithHttpInfo = function(configurationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`configurationId`)) {
        stop("Missing required parameter `configurationId`.")
      }

      body <- NULL
      urlPath <- "/externalDriverConfigurations/{configurationId}/"
      if (!missing(`configurationId`)) {
        urlPath <- gsub(paste0("\\{", "configurationId", "\\}"), URLencode(as.character(`configurationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DriverConfigurationRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
