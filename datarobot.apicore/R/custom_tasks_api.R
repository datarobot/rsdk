# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title CustomTasks operations
#' @description datarobot.apicore.CustomTasks
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
CustomTasksApi <- R6::R6Class(
  "CustomTasksApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Update custom task version files.
    #' Produces: "application/json"
    #'
    #' @details Create a new custom task version with files added, replaced or deleted. Files from the previous version of a custom task will be used as a basis.
    #' @details This method invokes `PATCH /customTasks/{customTaskId}/versions/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param baseEnvironmentId character. The base environment to use with this custom task version.
    #' @param isMajorUpdate Enum < [false, False, true, True] > If set to true, new major version will created, otherwise minor version will be created.
    #' @param file character. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' @param filePath \link{OneOfstringarray}. The local path of the file being uploaded. See the &#x60;file&#x60; field explanation for more details.
    #' @param filesToDelete \link{OneOfstringarray}. The IDs of the files to be deleted.
    #' @param maximumMemory integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' @param requiredMetadata character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' @param requiredMetadataValues character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Item successfully created.
    #' \itemize{
    #' }
    #' \item **`413`** Item or collection of items was too large in size (bytes).
    #' \itemize{
    #' }
    #' \item **`422`** Cannot create the custom task version due to one or more errors. All error responses will have a \&quot;message\&quot; field and some may have optional fields. The optional fields include: [\&quot;errors\&quot;, \&quot;dependencies\&quot;, \&quot;invalidDependencies\&quot;]
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
    #' isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
    #' file <- '/path/to/file.csv' # character | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' filePath <- list(c('filePath_example')) # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
    #' filesToDelete <- list(c('filesToDelete_example')) # OneOfstringarray | The IDs of the files to be deleted.
    #' maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTaskVersionCreateFromLatest(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, filesToDelete=filesToDelete, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
    #' }
    CustomTaskVersionCreateFromLatest = function(customTaskId, baseEnvironmentId, isMajorUpdate, file = NULL, filePath = NULL, filesToDelete = NULL, maximumMemory = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, ...) {
      apiResponse <- private$CustomTaskVersionCreateFromLatestWithHttpInfo(customTaskId, baseEnvironmentId, isMajorUpdate, file, filePath, filesToDelete, maximumMemory, requiredMetadata, requiredMetadataValues, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users who have access to this custom task and their roles on it.
    #' Produces: "application/json"
    #'
    #' @details Get a list of users who have access to this custom task and their roles on it.
    #' @details This method invokes `GET /customTasks/{customTaskId}/accessControl/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customTaskId character. ID of the custom task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskAccessControlListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of users who have access to this custom task and their roles on it.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksAccessControlList(offset, limit, customTaskId)
    #' }
    CustomTasksAccessControlList = function(offset, limit, customTaskId, ...) {
      apiResponse <- private$CustomTasksAccessControlListWithHttpInfo(offset, limit, customTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Grant access or update roles for users on this custom task and appropriate learning data.
    #' Produces: NA
    #'
    #' @details Grant access or update roles for users on this custom task and appropriate learning data. Up to 100 user roles may be set in a single request.
    #' @details This method invokes `PATCH /customTasks/{customTaskId}/accessControl/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param sharingUpdateOrRemoveWithGrant \link{SharingUpdateOrRemoveWithGrant}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the custom task without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' sharingUpdateOrRemoveWithGrant <- SharingUpdateOrRemoveWithGrant$new() # SharingUpdateOrRemoveWithGrant |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksAccessControlPatchMany(customTaskId, sharingUpdateOrRemoveWithGrant=sharingUpdateOrRemoveWithGrant)
    #' }
    CustomTasksAccessControlPatchMany = function(customTaskId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      apiResponse <- private$CustomTasksAccessControlPatchManyWithHttpInfo(customTaskId, sharingUpdateOrRemoveWithGrant, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a custom task
    #' Produces: "application/json"
    #'
    #' @details Creates a new custom task and returns the newly created metadata record for it.  A custom task may either be an estimator or a transform. Estimators must support a single target type (e.g. binaryClassification, regression). Regression and anomaly detection models are expected to produce predictions that are arbitrary floating-point or integer numbers. A classification model is expected to return predictions with probability scores for each class. For example, a binary classification model might return:  &#x60;&#x60;&#x60; Python {     positiveClassLabel: probability,     negativeClassLabel: 1.0 - probability } &#x60;&#x60;&#x60;  Transforms are expected to return a dataframe or sparse matrix with the same number of rows as the input feature matrix. At this time, only numeric outputs are supported for custom transforms.
    #' @details This method invokes `POST /customTasks/` in the DataRobot Public API.
    #' @param customTaskCreate \link{CustomTaskCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Custom task successfully created.
    #' \itemize{
    #' }
    #' \item **`403`** Custom task creation is not enabled.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskCreate <- CustomTaskCreate$new() # CustomTaskCreate |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksCreate(customTaskCreate=customTaskCreate)
    #' }
    CustomTasksCreate = function(customTaskCreate = NULL, ...) {
      apiResponse <- private$CustomTasksCreateWithHttpInfo(customTaskCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete custom task.
    #' Produces: NA
    #'
    #' @details Delete a custom task. Only users who have permission to edit custom task can delete it. Only custom tasks which are not currently deployed can be deleted. Relevant CustomTaskImage will be deleted also.
    #' @details This method invokes `DELETE /customTasks/{customTaskId}/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Record deleted.
    #' \itemize{
    #' }
    #' \item **`409`** This custom task is currently deployed, trained, or part of a user blueprint, and cannot be deleted. The response body will contain link where these conflicts can be retrieved.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksDelete(customTaskId)
    #' }
    CustomTasksDelete = function(customTaskId, ...) {
      apiResponse <- private$CustomTasksDeleteWithHttpInfo(customTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download the latest custom task version content.
    #' Produces: NA
    #'
    #' @details Download the latest item bundle from a custom task as a zip compressed archive.
    #' @details This method invokes `GET /customTasks/{customTaskId}/download/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The download succeeded.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;model-&lt;model_id&gt;-version-&lt;version_id&gt;.zip\&quot;).
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksDownloadList(customTaskId)
    #' }
    CustomTasksDownloadList = function(customTaskId, ...) {
      apiResponse <- private$CustomTasksDownloadListWithHttpInfo(customTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Clone custom task.
    #' Produces: "application/json"
    #'
    #' @details Creates a copy of the provided custom task, including metadata, versions of that task, and uploaded files. Associates the new versions with files owned by the custom task.
    #' @details This method invokes `POST /customTasks/fromCustomTask/` in the DataRobot Public API.
    #' @param customTaskCopy \link{CustomTaskCopy}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Successfully created copy.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskCopy <- CustomTaskCopy$new() # CustomTaskCopy |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksFromCustomTaskCreate(customTaskCopy=customTaskCopy)
    #' }
    CustomTasksFromCustomTaskCreate = function(customTaskCopy = NULL, ...) {
      apiResponse <- private$CustomTasksFromCustomTaskCreateWithHttpInfo(customTaskCopy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom tasks.
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata for all custom tasks the user has access to.
    #' @details This method invokes `GET /customTasks/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param orderBy Enum < [created, -created, updated, -updated] > Sort order which will be applied to custom task list, valid options are \&quot;created\&quot;, \&quot;updated\&quot;. Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;\&quot;-created\&quot;. By default, the orderBy parameter is None which will result in custom tasks being returned in order of creation time descending.
    #' @param searchFor character. String to search for occurrence in custom task&#39;s description, language and name. Search is case insensitive. If not specified, all custom tasks will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' orderBy <- 'orderBy_example' # character | Sort order which will be applied to custom task list, valid options are \"created\", \"updated\". Prefix the attribute name with a dash to sort in descending order, e.g. orderBy=\"-created\". By default, the orderBy parameter is None which will result in custom tasks being returned in order of creation time descending.
    #' searchFor <- 'searchFor_example' # character | String to search for occurrence in custom task's description, language and name. Search is case insensitive. If not specified, all custom tasks will be returned.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksList(offset, limit, orderBy=orderBy, searchFor=searchFor)
    #' }
    CustomTasksList = function(offset, limit, orderBy = NULL, searchFor = NULL, ...) {
      apiResponse <- private$CustomTasksListWithHttpInfo(offset, limit, orderBy, searchFor, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update custom task.
    #' Produces: "application/json"
    #'
    #' @details Updates metadata for an existing custom task.  All custom tasks must support one target type (e.g. binaryClassification, regression, transform).  Setting positiveClassLabel and negativeClassLabel to null will set the labels to their default values (1 and 0 for positiveClassLabel and negativeClassLabel, respectively).  Setting positiveClassLabel, negativeClassLabel, targetName is disabled if task has active deployments.
    #' @details This method invokes `PATCH /customTasks/{customTaskId}/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskUpdate \link{CustomTaskUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Created.
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskUpdate <- CustomTaskUpdate$new() # CustomTaskUpdate |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksPatch(customTaskId, customTaskUpdate=customTaskUpdate)
    #' }
    CustomTasksPatch = function(customTaskId, customTaskUpdate = NULL, ...) {
      apiResponse <- private$CustomTasksPatchWithHttpInfo(customTaskId, customTaskUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom task.
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata for a custom task
    #' @details This method invokes `GET /customTasks/{customTaskId}/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksRetrieve(customTaskId)
    #' }
    CustomTasksRetrieve = function(customTaskId, ...) {
      apiResponse <- private$CustomTasksRetrieveWithHttpInfo(customTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom task version.
    #' Produces: "application/json"
    #'
    #' @details Create a new custom task version with attached files if supplied.
    #' @details This method invokes `POST /customTasks/{customTaskId}/versions/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param baseEnvironmentId character. The base environment to use with this custom task version.
    #' @param isMajorUpdate Enum < [false, False, true, True] > If set to true, new major version will created, otherwise minor version will be created.
    #' @param file character. A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' @param filePath \link{OneOfstringarray}. The local path of the file being uploaded. See the &#x60;file&#x60; field explanation for more details.
    #' @param maximumMemory integer. The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' @param requiredMetadata character. Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' @param requiredMetadataValues character. Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment&#39;s requiredMetadataKeys.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Item successfully created.
    #' \itemize{
    #' }
    #' \item **`413`** Item or collection of items was too large in size (bytes).
    #' \itemize{
    #' }
    #' \item **`422`** Cannot create the custom task version due to one or more errors. All error responses will have a \&quot;message\&quot; field and some may have optional fields. The optional fields include: [\&quot;errors\&quot;, \&quot;dependencies\&quot;, \&quot;invalidDependencies\&quot;]
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' baseEnvironmentId <- 'baseEnvironmentId_example' # character | The base environment to use with this custom task version.
    #' isMajorUpdate <- "true" # character | If set to true, new major version will created, otherwise minor version will be created.
    #' file <- '/path/to/file.csv' # character | A file with code for a custom task or a custom model. For each file supplied as form data, you must have a corresponding `filePath` supplied that shows the relative location of the file. For example, you have two files: `/home/username/custom-task/main.py` and `/home/username/custom-task/helpers/helper.py`. When uploading these files, you would _also_ need to include two `filePath` fields of, `\\\"main.py\\\"` and `\\\"helpers/helper.py\\\"`. If the supplied `file` already exists at the supplied `filePath`, the old file is replaced by the new file.
    #' filePath <- list(c('filePath_example')) # OneOfstringarray | The local path of the file being uploaded. See the `file` field explanation for more details.
    #' maximumMemory <- 56 # integer | The maximum memory that might be allocated by the custom-model. If exceeded, the custom-model will be killed
    #' requiredMetadata <- 'requiredMetadata_example' # character | Additional parameters required by the execution environment. The required keys are defined by the fieldNames in the base environment's requiredMetadataKeys. Once set, they cannot be changed. If you to change them, make a new version.
    #' requiredMetadataValues <- 'requiredMetadataValues_example' # character | Additional parameters required by the execution environment. The required fieldNames are defined by the fieldNames in the base environment's requiredMetadataKeys.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsCreate(customTaskId, baseEnvironmentId, isMajorUpdate, file=file, filePath=filePath, maximumMemory=maximumMemory, requiredMetadata=requiredMetadata, requiredMetadataValues=requiredMetadataValues)
    #' }
    CustomTasksVersionsCreate = function(customTaskId, baseEnvironmentId, isMajorUpdate, file = NULL, filePath = NULL, maximumMemory = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, ...) {
      apiResponse <- private$CustomTasksVersionsCreateWithHttpInfo(customTaskId, baseEnvironmentId, isMajorUpdate, file, filePath, maximumMemory, requiredMetadata, requiredMetadataValues, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start a custom task version&#39;s dependency build.
    #' Produces: "application/json"
    #'
    #' @details Start a custom task version&#39;s dependency build. This is required to test, deploy, or train custom tasks.
    #' @details This method invokes `POST /customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionDependencyBuildMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Custom task version&#39;s dependency build has started.
    #' \itemize{
    #' }
    #' \item **`422`** Custom task dependency build has failed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsDependencyBuildCreate(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsDependencyBuildCreate = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsDependencyBuildCreateWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel dependency build.
    #' Produces: NA
    #'
    #' @details Cancel the custom task version&#39;s dependency build.
    #' @details This method invokes `DELETE /customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Custom task version&#39;s dependency build was cancelled.
    #' \itemize{
    #' }
    #' \item **`409`** Custom task dependency build has reached a terminal state and cannot be cancelled.
    #' \itemize{
    #' }
    #' \item **`422`** No custom task dependency build started for specified version or dependency image is in use and cannot be deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsDependencyBuildDeleteMany(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsDependencyBuildDeleteMany = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsDependencyBuildDeleteManyWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the custom task version&#39;s dependency build status.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the custom task version&#39;s dependency build status.
    #' @details This method invokes `GET /customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionDependencyBuildMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The metadata from the custom task version&#39;s dependency build.
    #' \itemize{
    #' }
    #' \item **`422`** Custom task dependency build has not started.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsDependencyBuildList(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsDependencyBuildList = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsDependencyBuildListWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the custom task version&#39;s dependency build log.
    #' Produces: NA
    #'
    #' @details Retrieve the custom task version&#39;s dependency build log.
    #' @details This method invokes `GET /customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuildLog/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The log file generated during the custom task version&#39;s dependency build.
    #' \itemize{
    #' }
    #' \item **`404`** Dependency build is in progress or could not be found.
    #' \itemize{
    #' }
    #' \item **`422`** Custom task dependency build has not started.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsDependencyBuildLogList(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsDependencyBuildLogList = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsDependencyBuildLogListWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download custom task version content.
    #' Produces: NA
    #'
    #' @details Download a specific item bundle from a custom task as a zip compressed archive.
    #' @details This method invokes `GET /customTasks/{customTaskId}/versions/{customTaskVersionId}/download/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The download succeeded.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;model-&lt;model_id&gt;-version-&lt;version_id&gt;.zip\&quot;).
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsDownloadList(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsDownloadList = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsDownloadListWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom task version from remote repository.
    #' Produces: NA
    #'
    #' @details Create a new custom task version with only files added from the specified remote repository.
    #' @details This method invokes `POST /customTasks/{customTaskId}/versions/fromRepository/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionCreateFromRepository \link{CustomTaskVersionCreateFromRepository}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Accepted: request placed to a queue for processing.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsFromRepositoryCreate(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
    #' }
    CustomTasksVersionsFromRepositoryCreate = function(customTaskId, customTaskVersionCreateFromRepository = NULL, ...) {
      apiResponse <- private$CustomTasksVersionsFromRepositoryCreateWithHttpInfo(customTaskId, customTaskVersionCreateFromRepository, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create custom task version from remote repository with files from previous version.
    #' Produces: NA
    #'
    #' @details Create a new custom task version with files added from a remote repository. Files from the previous version of a custom task will be used as a basis.
    #' @details This method invokes `PATCH /customTasks/{customTaskId}/versions/fromRepository/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionCreateFromRepository \link{CustomTaskVersionCreateFromRepository}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Accepted: request placed to a queue for processing.
    #' \itemize{
    #' \item **`Location`** URL for tracking async job status.
    #' }
    #' \item **`422`** Input parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionCreateFromRepository <- CustomTaskVersionCreateFromRepository$new() # CustomTaskVersionCreateFromRepository |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsFromRepositoryPatchMany(customTaskId, customTaskVersionCreateFromRepository=customTaskVersionCreateFromRepository)
    #' }
    CustomTasksVersionsFromRepositoryPatchMany = function(customTaskId, customTaskVersionCreateFromRepository = NULL, ...) {
      apiResponse <- private$CustomTasksVersionsFromRepositoryPatchManyWithHttpInfo(customTaskId, customTaskVersionCreateFromRepository, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        if (httr::has_content(resp)) {
          httr::content(resp)
        }
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List custom task versions.
    #' Produces: "application/json"
    #'
    #' @details List custom task versions.
    #' @details This method invokes `GET /customTasks/{customTaskId}/versions/` in the DataRobot Public API.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param customTaskId character. ID of the custom task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' \item **`400`** Query parameters are invalid.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 1000 # integer | At most this many results are returned.
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsList(offset, limit, customTaskId)
    #' }
    CustomTasksVersionsList = function(offset, limit, customTaskId, ...) {
      apiResponse <- private$CustomTasksVersionsListWithHttpInfo(offset, limit, customTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update custom task version.
    #' Produces: "application/json"
    #'
    #' @details Edit metadata of a specific task version.
    #' @details This method invokes `PATCH /customTasks/{customTaskId}/versions/{customTaskVersionId}/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param customTaskVersionMetadataUpdate \link{CustomTaskVersionMetadataUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The edit was successful.
    #' \itemize{
    #' }
    #' \item **`404`** Custom task not found or user does not have edit permissions.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #' customTaskVersionMetadataUpdate <- CustomTaskVersionMetadataUpdate$new() # CustomTaskVersionMetadataUpdate |
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsPatch(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate=customTaskVersionMetadataUpdate)
    #' }
    CustomTasksVersionsPatch = function(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate = NULL, ...) {
      apiResponse <- private$CustomTasksVersionsPatchWithHttpInfo(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get custom task version.
    #' Produces: "application/json"
    #'
    #' @details Display a requested version of a custom task along with the files attached to it.
    #' @details This method invokes `GET /customTasks/{customTaskId}/versions/{customTaskVersionId}/` in the DataRobot Public API.
    #' @param customTaskId character. ID of the custom task.
    #' @param customTaskVersionId character. ID of the custom task version.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CustomTaskVersionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** OK.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' customTaskId <- 'customTaskId_example' # character | ID of the custom task.
    #' customTaskVersionId <- 'customTaskVersionId_example' # character | ID of the custom task version.
    #'
    #' api.instance <- CustomTasksApi$new()
    #' result <- api.instance$CustomTasksVersionsRetrieve(customTaskId, customTaskVersionId)
    #' }
    CustomTasksVersionsRetrieve = function(customTaskId, customTaskVersionId, ...) {
      apiResponse <- private$CustomTasksVersionsRetrieveWithHttpInfo(customTaskId, customTaskVersionId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `CustomTaskVersionCreateFromLatest`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTaskVersionCreateFromLatestWithHttpInfo = function(customTaskId, baseEnvironmentId, isMajorUpdate, file = NULL, filePath = NULL, filesToDelete = NULL, maximumMemory = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`baseEnvironmentId`)) {
        stop("Missing required parameter `baseEnvironmentId`.")
      }

      if (missing(`isMajorUpdate`)) {
        stop("Missing required parameter `isMajorUpdate`.")
      }

      body <- list(
        "baseEnvironmentId" = baseEnvironmentId,
        "file" = httr::upload_file(file),
        "filePath" = filePath,
        "filesToDelete" = filesToDelete,
        "isMajorUpdate" = isMajorUpdate,
        "maximumMemory" = maximumMemory,
        "requiredMetadata" = requiredMetadata,
        "requiredMetadataValues" = requiredMetadataValues
      )

      urlPath <- "/customTasks/{customTaskId}/versions/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksAccessControlListWithHttpInfo = function(offset, limit, customTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/accessControl/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskAccessControlListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksAccessControlPatchManyWithHttpInfo = function(customTaskId, sharingUpdateOrRemoveWithGrant = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (!missing(`sharingUpdateOrRemoveWithGrant`) && isa(sharingUpdateOrRemoveWithGrant, c("SharingUpdateOrRemoveWithGrant", "R6"))) {
        body <- `sharingUpdateOrRemoveWithGrant`$toJSON()
      } else {
        stop("CustomTasksAccessControlPatchManyWithHttpInfo requires parameter sharingUpdateOrRemoveWithGrant to be of type SharingUpdateOrRemoveWithGrant.")
      }

      urlPath <- "/customTasks/{customTaskId}/accessControl/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksCreateWithHttpInfo = function(customTaskCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customTaskCreate`) && isa(customTaskCreate, c("CustomTaskCreate", "R6"))) {
        body <- `customTaskCreate`$toJSON()
      } else {
        stop("CustomTasksCreateWithHttpInfo requires parameter customTaskCreate to be of type CustomTaskCreate.")
      }

      urlPath <- "/customTasks/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksDeleteWithHttpInfo = function(customTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksDownloadListWithHttpInfo = function(customTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/download/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksFromCustomTaskCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksFromCustomTaskCreateWithHttpInfo = function(customTaskCopy = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`customTaskCopy`) && isa(customTaskCopy, c("CustomTaskCopy", "R6"))) {
        body <- `customTaskCopy`$toJSON()
      } else {
        stop("CustomTasksFromCustomTaskCreateWithHttpInfo requires parameter customTaskCopy to be of type CustomTaskCopy.")
      }

      urlPath <- "/customTasks/fromCustomTask/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksListWithHttpInfo = function(offset, limit, orderBy = NULL, searchFor = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["searchFor"] <- searchFor

      body <- NULL
      urlPath <- "/customTasks/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksPatchWithHttpInfo = function(customTaskId, customTaskUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (!missing(`customTaskUpdate`) && isa(customTaskUpdate, c("CustomTaskUpdate", "R6"))) {
        body <- `customTaskUpdate`$toJSON()
      } else {
        stop("CustomTasksPatchWithHttpInfo requires parameter customTaskUpdate to be of type CustomTaskUpdate.")
      }

      urlPath <- "/customTasks/{customTaskId}/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksRetrieveWithHttpInfo = function(customTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsCreateWithHttpInfo = function(customTaskId, baseEnvironmentId, isMajorUpdate, file = NULL, filePath = NULL, maximumMemory = NULL, requiredMetadata = NULL, requiredMetadataValues = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`baseEnvironmentId`)) {
        stop("Missing required parameter `baseEnvironmentId`.")
      }

      if (missing(`isMajorUpdate`)) {
        stop("Missing required parameter `isMajorUpdate`.")
      }

      body <- list(
        "baseEnvironmentId" = baseEnvironmentId,
        "file" = httr::upload_file(file),
        "filePath" = filePath,
        "isMajorUpdate" = isMajorUpdate,
        "maximumMemory" = maximumMemory,
        "requiredMetadata" = requiredMetadata,
        "requiredMetadataValues" = requiredMetadataValues
      )

      urlPath <- "/customTasks/{customTaskId}/versions/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        encode = "multipart",
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsDependencyBuildCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsDependencyBuildCreateWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionDependencyBuildMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsDependencyBuildDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsDependencyBuildDeleteManyWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsDependencyBuildList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsDependencyBuildListWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuild/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionDependencyBuildMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsDependencyBuildLogList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsDependencyBuildLogListWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/dependencyBuildLog/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsDownloadListWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/download/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsFromRepositoryCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsFromRepositoryCreateWithHttpInfo = function(customTaskId, customTaskVersionCreateFromRepository = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (!missing(`customTaskVersionCreateFromRepository`) && isa(customTaskVersionCreateFromRepository, c("CustomTaskVersionCreateFromRepository", "R6"))) {
        body <- `customTaskVersionCreateFromRepository`$toJSON()
      } else {
        stop("CustomTasksVersionsFromRepositoryCreateWithHttpInfo requires parameter customTaskVersionCreateFromRepository to be of type CustomTaskVersionCreateFromRepository.")
      }

      urlPath <- "/customTasks/{customTaskId}/versions/fromRepository/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsFromRepositoryPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsFromRepositoryPatchManyWithHttpInfo = function(customTaskId, customTaskVersionCreateFromRepository = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (!missing(`customTaskVersionCreateFromRepository`) && isa(customTaskVersionCreateFromRepository, c("CustomTaskVersionCreateFromRepository", "R6"))) {
        body <- `customTaskVersionCreateFromRepository`$toJSON()
      } else {
        stop("CustomTasksVersionsFromRepositoryPatchManyWithHttpInfo requires parameter customTaskVersionCreateFromRepository to be of type CustomTaskVersionCreateFromRepository.")
      }

      urlPath <- "/customTasks/{customTaskId}/versions/fromRepository/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsListWithHttpInfo = function(offset, limit, customTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsPatchWithHttpInfo = function(customTaskId, customTaskVersionId, customTaskVersionMetadataUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      if (!missing(`customTaskVersionMetadataUpdate`) && isa(customTaskVersionMetadataUpdate, c("CustomTaskVersionMetadataUpdate", "R6"))) {
        body <- `customTaskVersionMetadataUpdate`$toJSON()
      } else {
        stop("CustomTasksVersionsPatchWithHttpInfo requires parameter customTaskVersionMetadataUpdate to be of type CustomTaskVersionMetadataUpdate.")
      }

      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CustomTasksVersionsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CustomTasksVersionsRetrieveWithHttpInfo = function(customTaskId, customTaskVersionId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`customTaskId`)) {
        stop("Missing required parameter `customTaskId`.")
      }

      if (missing(`customTaskVersionId`)) {
        stop("Missing required parameter `customTaskVersionId`.")
      }

      body <- NULL
      urlPath <- "/customTasks/{customTaskId}/versions/{customTaskVersionId}/"
      if (!missing(`customTaskId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskId", "\\}"), URLencode(as.character(`customTaskId`), reserved = TRUE), urlPath)
      }

      if (!missing(`customTaskVersionId`)) {
        urlPath <- gsub(paste0("\\{", "customTaskVersionId", "\\}"), URLencode(as.character(`customTaskVersionId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CustomTaskVersionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
