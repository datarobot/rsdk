# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Insights operations
#' @description datarobot.apicore.Insights
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
InsightsApi <- R6::R6Class(
  "InsightsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Retrieve multicategorical feature histogram.
    #' Produces: "application/json"
    #'
    #' @details Retrieve multicategorical feature histogram.
    #' @details This method invokes `GET /multilabelInsights/{multilabelInsightsKey}/histogram/` in the DataRobot Public API.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticategoricalHistogram}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Multicategorical feature histogram.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsHistogramList(multilabelInsightsKey)
    #' }
    MultilabelInsightsHistogramList = function(multilabelInsightsKey, ...) {
      apiResponse <- private$MultilabelInsightsHistogramListWithHttpInfo(multilabelInsightsKey, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Save a list of manually selected labels for Feature Statistics matrix.
    #' Produces: "application/json"
    #'
    #' @details Save a list of manually selected labels for Feature Statistics matrix.
    #' @details This method invokes `POST /multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/` in the DataRobot Public API.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param pairwiseManualSelectionCreatePayload \link{PairwiseManualSelectionCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PairwiseManualSelectionCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Whether manually selected labels were saved successfully.
    #' \itemize{
    #' }
    #' \item **`422`** The manual selection name is already taken or another exception occurred.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #' pairwiseManualSelectionCreatePayload <- PairwiseManualSelectionCreatePayload$new() # PairwiseManualSelectionCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsPairwiseManualSelectionsCreate(multilabelInsightsKey, pairwiseManualSelectionCreatePayload=pairwiseManualSelectionCreatePayload)
    #' }
    MultilabelInsightsPairwiseManualSelectionsCreate = function(multilabelInsightsKey, pairwiseManualSelectionCreatePayload = NULL, ...) {
      apiResponse <- private$MultilabelInsightsPairwiseManualSelectionsCreateWithHttpInfo(multilabelInsightsKey, pairwiseManualSelectionCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete label list.
    #' Produces: "application/json"
    #'
    #' @details Delete label list.
    #' @details This method invokes `DELETE /multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/{manualSelectionListId}/` in the DataRobot Public API.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param manualSelectionListId character. ID of the label set.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PairwiseManualSelectionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** ID of the deleted label list.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #' manualSelectionListId <- 'manualSelectionListId_example' # character | ID of the label set.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsPairwiseManualSelectionsDelete(multilabelInsightsKey, manualSelectionListId)
    #' }
    MultilabelInsightsPairwiseManualSelectionsDelete = function(multilabelInsightsKey, manualSelectionListId, ...) {
      apiResponse <- private$MultilabelInsightsPairwiseManualSelectionsDeleteWithHttpInfo(multilabelInsightsKey, manualSelectionListId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get all label lists.
    #' Produces: "application/json"
    #'
    #' @details Get all label lists.
    #' @details This method invokes `GET /multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/` in the DataRobot Public API.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PairwiseManualSelectionsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** All label lists
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsPairwiseManualSelectionsList(multilabelInsightsKey)
    #' }
    MultilabelInsightsPairwiseManualSelectionsList = function(multilabelInsightsKey, ...) {
      apiResponse <- private$MultilabelInsightsPairwiseManualSelectionsListWithHttpInfo(multilabelInsightsKey, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update label list&#39;s name.
    #' Produces: "application/json"
    #'
    #' @details Update label list&#39;s name.
    #' @details This method invokes `PATCH /multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/{manualSelectionListId}/` in the DataRobot Public API.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param manualSelectionListId character. ID of the label set.
    #' @param pairwiseManualSelectionUpdateRequest \link{PairwiseManualSelectionUpdateRequest}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PairwiseManualSelectionResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** ID of the updated label list.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #' manualSelectionListId <- 'manualSelectionListId_example' # character | ID of the label set.
    #' pairwiseManualSelectionUpdateRequest <- PairwiseManualSelectionUpdateRequest$new() # PairwiseManualSelectionUpdateRequest |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsPairwiseManualSelectionsPatch(multilabelInsightsKey, manualSelectionListId, pairwiseManualSelectionUpdateRequest=pairwiseManualSelectionUpdateRequest)
    #' }
    MultilabelInsightsPairwiseManualSelectionsPatch = function(multilabelInsightsKey, manualSelectionListId, pairwiseManualSelectionUpdateRequest = NULL, ...) {
      apiResponse <- private$MultilabelInsightsPairwiseManualSelectionsPatchWithHttpInfo(multilabelInsightsKey, manualSelectionListId, pairwiseManualSelectionUpdateRequest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve pairwise statistics for the given multilabel insights key.
    #' Produces: "application/json"
    #'
    #' @details Retrieve multilabel specific pairwise label statistics for the given multilabel insights key: correlation, joint probability and conditional probability.
    #' @details This method invokes `GET /multilabelInsights/{multilabelInsightsKey}/pairwiseStatistics/` in the DataRobot Public API.
    #' @param statisticType Enum < [jointProbability, correlation, conditionalProbability] > Type of pairwise statistic.
    #' @param multilabelInsightsKey character. Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; or :http:get:&#x60;/api/v2/projects/(projectId)/features/(featurename:featureName)/&#x60;
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PairwiseStatisticsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Pairwise label statistics.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statisticType <- 'statisticType_example' # character | Type of pairwise statistic.
    #' multilabelInsightsKey <- 'multilabelInsightsKey_example' # character | Key for multilabel insights, unique per project, feature, and EDA stage. The most recent key can be retrieved via :http:get:`/api/v2/projects/(projectId)/features/` or :http:get:`/api/v2/projects/(projectId)/features/(featurename:featureName)/`
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$MultilabelInsightsPairwiseStatisticsList(statisticType, multilabelInsightsKey)
    #' }
    MultilabelInsightsPairwiseStatisticsList = function(statisticType, multilabelInsightsKey, ...) {
      apiResponse <- private$MultilabelInsightsPairwiseStatisticsListWithHttpInfo(statisticType, multilabelInsightsKey, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete the anomaly assessment record.
    #' Produces: NA
    #'
    #' @details Delete the anomaly assessment record.
    #' @details This method invokes `DELETE /projects/{projectId}/anomalyAssessmentRecords/{recordId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param recordId character. The anomaly assessment record ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Anomaly assessment record deleted.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' recordId <- 'recordId_example' # character | The anomaly assessment record ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsAnomalyAssessmentRecordsDelete(projectId, recordId)
    #' }
    ProjectsAnomalyAssessmentRecordsDelete = function(projectId, recordId, ...) {
      apiResponse <- private$ProjectsAnomalyAssessmentRecordsDeleteWithHttpInfo(projectId, recordId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve anomaly assessment record.
    #' Produces: "application/json"
    #'
    #' @details Retrieve anomaly assessment record. Two out of three parameters: startDate, endDate or pointsCount must be specified.
    #' @details This method invokes `GET /projects/{projectId}/anomalyAssessmentRecords/{recordId}/explanations/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param recordId character. The anomaly assessment record ID
    #' @param startDate character. The start of the date range to return. Date should be in UTC format. For example: &#x60;&#x60;2019-08-01T00:00:00.000000Z&#x60;&#x60;.
    #' @param endDate character. The end of the date range to return, inclusive. Date should be in UTC format. For example: &#x60;&#x60;2020-01-01T00:00:00.000000Z&#x60;&#x60;.
    #' @param pointsCount integer. Count of points to return.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyAssessmentExplanationsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Anomaly assessment record.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' \item **`422`** Insight is not available.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' recordId <- 'recordId_example' # character | The anomaly assessment record ID
    #' startDate <- 'startDate_example' # character | The start of the date range to return. Date should be in UTC format. For example: ``2019-08-01T00:00:00.000000Z``.
    #' endDate <- 'endDate_example' # character | The end of the date range to return, inclusive. Date should be in UTC format. For example: ``2020-01-01T00:00:00.000000Z``.
    #' pointsCount <- 56 # integer | Count of points to return.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsAnomalyAssessmentRecordsExplanationsList(projectId, recordId, startDate=startDate, endDate=endDate, pointsCount=pointsCount)
    #' }
    ProjectsAnomalyAssessmentRecordsExplanationsList = function(projectId, recordId, startDate = NULL, endDate = NULL, pointsCount = NULL, ...) {
      apiResponse <- private$ProjectsAnomalyAssessmentRecordsExplanationsListWithHttpInfo(projectId, recordId, startDate, endDate, pointsCount, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve anomaly assessment records.
    #' Produces: "application/json"
    #'
    #' @details Retrieve anomaly assessment records.
    #' @details This method invokes `GET /projects/{projectId}/anomalyAssessmentRecords/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param modelId character. The model ID to filter records by.
    #' @param backtest \link{OneOfintegerstring}. The backtest to filter records by.
    #' @param source Enum < [training, validation] > The source of the data to filter records by.
    #' @param seriesId character. Can be specified for multiseries projects. The series id to filter records by.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyAssessmentRecordsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve anomaly assessment records.
    #' \itemize{
    #' }
    #' \item **`404`** No data found
    #' \itemize{
    #' }
    #' \item **`422`** Input parameters are invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' modelId <- 'modelId_example' # character | The model ID to filter records by.
    #' backtest <- 'backtest_example' # OneOfintegerstring | The backtest to filter records by.
    #' source <- 'source_example' # character | The source of the data to filter records by.
    #' seriesId <- 'seriesId_example' # character | Can be specified for multiseries projects. The series id to filter records by.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsAnomalyAssessmentRecordsList(projectId, offset=offset, limit=limit, modelId=modelId, backtest=backtest, source=source, seriesId=seriesId)
    #' }
    ProjectsAnomalyAssessmentRecordsList = function(projectId, offset = 0, limit = 100, modelId = NULL, backtest = NULL, source = NULL, seriesId = NULL, ...) {
      apiResponse <- private$ProjectsAnomalyAssessmentRecordsListWithHttpInfo(projectId, offset, limit, modelId, backtest, source, seriesId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve predictions preview for the anomaly assessment record.
    #' Produces: "application/json"
    #'
    #' @details Retrieve predictions preview for the anomaly assessment record.
    #' @details This method invokes `GET /projects/{projectId}/anomalyAssessmentRecords/{recordId}/predictionsPreview/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param recordId character. The anomaly assessment record ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyAssessmentPreviewResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Predictions preview for the anomaly assessment record.
    #' \itemize{
    #' }
    #' \item **`404`** Record not found.
    #' \itemize{
    #' }
    #' \item **`422`** Predictions preview is not available.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' recordId <- 'recordId_example' # character | The anomaly assessment record ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsAnomalyAssessmentRecordsPredictionsPreviewList(projectId, recordId)
    #' }
    ProjectsAnomalyAssessmentRecordsPredictionsPreviewList = function(projectId, recordId, ...) {
      apiResponse <- private$ProjectsAnomalyAssessmentRecordsPredictionsPreviewListWithHttpInfo(projectId, recordId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Bias vs Accuracy insights.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of Bias vs Accuracy insights for the model.
    #' @details This method invokes `GET /projects/{projectId}/biasVsAccuracyInsights/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param accuracyMetric Enum < [AUC, Weighted AUC, Area Under PR Curve, Weighted Area Under PR Curve, Kolmogorov-Smirnov, Weighted Kolmogorov-Smirnov, Ians Metric, FVE Binomial, Weighted FVE Binomial, Gini, Weighted Gini, Gini Norm, Weighted Gini Norm, LogLoss, Weighted LogLoss, LogLossSig, Weighted LogLossSig, Max MCC, Weighted Max MCC, Rate@Top5%, Weighted Rate@Top5%, Rate@Top10%, Weighted Rate@Top10%, Rate@TopTenth%, RMSE, Weighted RMSE] > The metric to return model accuracy scores. Defaults to the optimization metric configured in project options.
    #' @param protectedFeature \link{OneOfstringarray}. Name of the protected feature.
    #' @param fairnessMetric \link{OneOfstringarray}. The fairness metric used to calculate the fairness scores.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BiasVsAccuracyInsightRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns Bias vs Accuracy results.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' accuracyMetric <- 'accuracyMetric_example' # character | The metric to return model accuracy scores. Defaults to the optimization metric configured in project options.
    #' protectedFeature <- list(c('protectedFeature_example')) # OneOfstringarray | Name of the protected feature.
    #' fairnessMetric <- list(c('fairnessMetric_example')) # OneOfstringarray | The fairness metric used to calculate the fairness scores.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsBiasVsAccuracyInsightsList(projectId, accuracyMetric=accuracyMetric, protectedFeature=protectedFeature, fairnessMetric=fairnessMetric)
    #' }
    ProjectsBiasVsAccuracyInsightsList = function(projectId, accuracyMetric = NULL, protectedFeature = NULL, fairnessMetric = NULL, ...) {
      apiResponse <- private$ProjectsBiasVsAccuracyInsightsListWithHttpInfo(projectId, accuracyMetric, protectedFeature, fairnessMetric, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the data for the Accuracy over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the data for the Accuracy over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param forecastDistance integer. Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' @param resolution Enum < [milliseconds, seconds, minutes, hours, days, weeks, months, quarters, years] > Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins &lt;&#x3D; &#x60;maxBinSize&#x60;
    #' @param maxBinSize integer. Specifies the maximum number of bins for the retrieval.
    #' @param startDate character. The start of the date range to return. If not specified, start date for requested plots will be used.
    #' @param endDate character. The end of the date range to return. If not specified, end date for requested plots will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AccuracyOverTimePlotsDataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accuracy over Time plots data
    #' \itemize{
    #' }
    #' \item **`404`** Accuracy over Time plots data was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #' forecastDistance <- 56 # integer | Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' resolution <- 'resolution_example' # character | Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins <= `maxBinSize`
    #' maxBinSize <- 500 # integer | Specifies the maximum number of bins for the retrieval.
    #' startDate <- 'startDate_example' # character | The start of the date range to return. If not specified, start date for requested plots will be used.
    #' endDate <- 'endDate_example' # character | The end of the date range to return. If not specified, end date for requested plots will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAccuracyOverTimePlotsList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source, forecastDistance=forecastDistance, resolution=resolution, maxBinSize=maxBinSize, startDate=startDate, endDate=endDate)
    #' }
    ProjectsDatetimeModelsAccuracyOverTimePlotsList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", forecastDistance = NULL, resolution = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAccuracyOverTimePlotsListWithHttpInfo(projectId, modelId, seriesId, backtest, source, forecastDistance, resolution, maxBinSize, startDate, endDate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the metadata for the Accuracy over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the metadata for the Accuracy over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param forecastDistance integer. Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AccuracyOverTimePlotsMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accuracy over Time plots metadata
    #' \itemize{
    #' }
    #' \item **`404`** Accuracy over Time plots metadata was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' forecastDistance <- 56 # integer | Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAccuracyOverTimePlotsMetadataList(projectId, modelId, forecastDistance=forecastDistance, seriesId=seriesId)
    #' }
    ProjectsDatetimeModelsAccuracyOverTimePlotsMetadataList = function(projectId, modelId, forecastDistance = NULL, seriesId = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAccuracyOverTimePlotsMetadataListWithHttpInfo(projectId, modelId, forecastDistance, seriesId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the preview for the Accuracy over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the preview for the Accuracy over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/preview/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param forecastDistance integer. Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeTrendPlotsPreviewResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accuracy over Time plots preview
    #' \itemize{
    #' }
    #' \item **`404`** Accuracy over Time plots preview was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #' forecastDistance <- 56 # integer | Forecast distance to retrieve the data for. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAccuracyOverTimePlotsPreviewList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source, forecastDistance=forecastDistance)
    #' }
    ProjectsDatetimeModelsAccuracyOverTimePlotsPreviewList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", forecastDistance = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAccuracyOverTimePlotsPreviewListWithHttpInfo(projectId, modelId, seriesId, backtest, source, forecastDistance, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the data for the Anomaly over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the data for the Anomaly over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param resolution Enum < [milliseconds, seconds, minutes, hours, days, weeks, months, quarters, years] > Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins &lt;&#x3D; &#x60;maxBinSize&#x60;
    #' @param maxBinSize integer. Specifies the maximum number of bins for the retrieval.
    #' @param startDate character. The start of the date range to return. If not specified, start date for requested plots will be used.
    #' @param endDate character. The end of the date range to return. If not specified, end date for requested plots will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyOverTimePlotsDataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Anomaly over Time plots data
    #' \itemize{
    #' }
    #' \item **`404`** Anomaly over Time plots data was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #' resolution <- 'resolution_example' # character | Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins <= `maxBinSize`
    #' maxBinSize <- 500 # integer | Specifies the maximum number of bins for the retrieval.
    #' startDate <- 'startDate_example' # character | The start of the date range to return. If not specified, start date for requested plots will be used.
    #' endDate <- 'endDate_example' # character | The end of the date range to return. If not specified, end date for requested plots will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAnomalyOverTimePlotsList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source, resolution=resolution, maxBinSize=maxBinSize, startDate=startDate, endDate=endDate)
    #' }
    ProjectsDatetimeModelsAnomalyOverTimePlotsList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", resolution = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAnomalyOverTimePlotsListWithHttpInfo(projectId, modelId, seriesId, backtest, source, resolution, maxBinSize, startDate, endDate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the metadata for the Anomaly over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the metadata for the Anomaly over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyOverTimePlotsMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Anomaly over Time plots metadata
    #' \itemize{
    #' }
    #' \item **`404`** Anomaly over Time plots metadata was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAnomalyOverTimePlotsMetadataList(projectId, modelId, seriesId=seriesId)
    #' }
    ProjectsDatetimeModelsAnomalyOverTimePlotsMetadataList = function(projectId, modelId, seriesId = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAnomalyOverTimePlotsMetadataListWithHttpInfo(projectId, modelId, seriesId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the preview for the Anomaly over Time plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the preview for the Anomaly over Time plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/preview/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param predictionThreshold numeric. Only bins with predictions exceeding this threshold will be returned in the response.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyOverTimePlotsPreviewResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Anomaly over Time plots preview
    #' \itemize{
    #' }
    #' \item **`404`** Anomaly over Time plots preview was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #' predictionThreshold <- 0.5 # numeric | Only bins with predictions exceeding this threshold will be returned in the response.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsAnomalyOverTimePlotsPreviewList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source, predictionThreshold=predictionThreshold)
    #' }
    ProjectsDatetimeModelsAnomalyOverTimePlotsPreviewList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", predictionThreshold = 0.5, ...) {
      apiResponse <- private$ProjectsDatetimeModelsAnomalyOverTimePlotsPreviewListWithHttpInfo(projectId, modelId, seriesId, backtest, source, predictionThreshold, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a plot displaying the stability of the datetime model across different backtests.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a plot displaying the stability of the datetime model across different backtests.  All durations and datetimes should be specified in accordance with the &#x60;timestamp and duration formatting rules&lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/backtestStabilityPlot/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param metricName character. The name of the metric to retrieve the scores for. If omitted, the default project metric will be used
    #' @param forecastDistance integer. The forecast distance to retrieve the plot for. If not specified, the scores for each partition are aggregated across all forecast distances. This parameter is only available for time series models.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BacktestStabilityPlotResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Backtest stability plot data for datetime partitioned model.
    #' \itemize{
    #' }
    #' \item **`422`** Backtest stability plot data not available.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' metricName <- 'metricName_example' # character | The name of the metric to retrieve the scores for. If omitted, the default project metric will be used
    #' forecastDistance <- 56 # integer | The forecast distance to retrieve the plot for. If not specified, the scores for each partition are aggregated across all forecast distances. This parameter is only available for time series models.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsBacktestStabilityPlotList(projectId, modelId, metricName=metricName, forecastDistance=forecastDistance)
    #' }
    ProjectsDatetimeModelsBacktestStabilityPlotList = function(projectId, modelId, metricName = NULL, forecastDistance = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsBacktestStabilityPlotListWithHttpInfo(projectId, modelId, metricName, forecastDistance, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the metadata of the Accuracy Over Time (AOT) chart for an external dataset.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the metadata of the Accuracy Over Time (AOT) chart for an external dataset. Datetimes are specified in accordance with &#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project id which was used to compute the AOT chart.
    #' @param modelId character. The model id which was used to compute the AOT chart.
    #' @param datasetId character. The dataset id which was used to compute the AOT chart.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AOTChartMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Metadata of the Accuracy Over Time (AOT) chart for an external dataset.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project id which was used to compute the AOT chart.
    #' modelId <- 'modelId_example' # character | The model id which was used to compute the AOT chart.
    #' datasetId <- 'datasetId_example' # character | The dataset id which was used to compute the AOT chart.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsMetadataList(projectId, modelId, datasetId)
    #' }
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsMetadataList = function(projectId, modelId, datasetId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsMetadataListWithHttpInfo(projectId, modelId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a preview of the Accuracy Over Time (AOT) chart for an external dataset.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a preview of the Accuracy Over Time (AOT) chart for an external dataset. Datetimes are specified in accordance with &#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/preview/` in the DataRobot Public API.
    #' @param projectId character. The project id which was used to compute the AOT chart.
    #' @param modelId character. The model id which was used to compute the AOT chart.
    #' @param datasetId character. The dataset id which was used to compute the AOT chart.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AOTChartPreviewResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Preview of the Accuracy Over Time (AOT) chart for an external dataset.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project id which was used to compute the AOT chart.
    #' modelId <- 'modelId_example' # character | The model id which was used to compute the AOT chart.
    #' datasetId <- 'datasetId_example' # character | The dataset id which was used to compute the AOT chart.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsPreviewList(projectId, modelId, datasetId)
    #' }
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsPreviewList = function(projectId, modelId, datasetId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsPreviewListWithHttpInfo(projectId, modelId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the Accuracy Over Time (AOT) chart data for an external dataset for a project.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the Accuracy Over Time (AOT) chart data for an external dataset for a project. Datetimes are specified in accordance with &#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/` in the DataRobot Public API.
    #' @param projectId character. The project id which was used to compute the AOT chart.
    #' @param modelId character. The model id which was used to compute the AOT chart.
    #' @param datasetId character. The dataset id which was used to compute the AOT chart.
    #' @param maxBinSize integer. The limit of returned bins.
    #' @param startDate character. The start of the date range to return (UTC string), for example: &#39;2010-05-13T00:00:00.000000Z&#39;. If not specified, the start date for this model and source of the data will be used instead.
    #' @param endDate character. The end of the date range to return (UTC string), for example: &#39;2010-05-13T00:00:00.000000Z&#39;. If not specified, the end date for this model and source of the data will be used instead.
    #' @param resolution Enum < [microseconds, milliseconds, seconds, minutes, hours, days, weeks, months, quarters, years] > Specifies at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data such that bins &lt;&#x3D; &#x60;maxBinSize&#x60;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AOTChartRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Accuracy Over Time (AOT) chart data for an external dataset for a project.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project id which was used to compute the AOT chart.
    #' modelId <- 'modelId_example' # character | The model id which was used to compute the AOT chart.
    #' datasetId <- 'datasetId_example' # character | The dataset id which was used to compute the AOT chart.
    #' maxBinSize <- 500 # integer | The limit of returned bins.
    #' startDate <- 'startDate_example' # character | The start of the date range to return (UTC string), for example: '2010-05-13T00:00:00.000000Z'. If not specified, the start date for this model and source of the data will be used instead.
    #' endDate <- 'endDate_example' # character | The end of the date range to return (UTC string), for example: '2010-05-13T00:00:00.000000Z'. If not specified, the end date for this model and source of the data will be used instead.
    #' resolution <- 'resolution_example' # character | Specifies at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data such that bins <= `maxBinSize`.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsRetrieve(projectId, modelId, datasetId, maxBinSize=maxBinSize, startDate=startDate, endDate=endDate, resolution=resolution)
    #' }
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsRetrieve = function(projectId, modelId, datasetId, maxBinSize = 500, startDate = NULL, endDate = NULL, resolution = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsRetrieveWithHttpInfo(projectId, modelId, datasetId, maxBinSize, startDate, endDate, resolution, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Computes Datetime Trend plots for time series and OTV projects.
    #' Produces: "application/json"
    #'
    #' @details Computes Datetime Trend plots for time series and OTV projects: \\* For OTV projects, computes Accuracy over Time plots. \\* For time series supervised projects, computes both Accuracy over Time plots and Forecast vs Actual plots. .. minversion:: v2.25 \\* For unsupervised time series and OTV models, computes Anomaly Over Time plots. .. note:: For the multiseries time series projects only first 1000 series in alphabetical order and an average plot for them will be computed. .. note:: Maximum 100 forecast distances can be requested for calculation in time series supervised projects.
    #' @details This method invokes `POST /projects/{projectId}/datetimeModels/{modelId}/datetimeTrendPlots/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param datetimeTrendPlotsCreate \link{DatetimeTrendPlotsCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeTrendPlotsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Datetime Trend plots computation job submitted successfully.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** There were invalid parameters in the submitted request. See the &#x60;message&#x60; field for more details.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' datetimeTrendPlotsCreate <- DatetimeTrendPlotsCreate$new() # DatetimeTrendPlotsCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsDatetimeTrendPlotsCreate(projectId, modelId, datetimeTrendPlotsCreate=datetimeTrendPlotsCreate)
    #' }
    ProjectsDatetimeModelsDatetimeTrendPlotsCreate = function(projectId, modelId, datetimeTrendPlotsCreate = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsDatetimeTrendPlotsCreateWithHttpInfo(projectId, modelId, datetimeTrendPlotsCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add a request to the queue to calculate Feature Effects for a backtest.
    #' Produces: NA
    #'
    #' @details Add a request to the queue to calculate Feature Effects for a backtest. If the job has been previously submitted, the request fails, returning the jobId of the previously submitted job. Use this jobId to check status of the previously submitted job.
    #' @details This method invokes `POST /projects/{projectId}/datetimeModels/{modelId}/featureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param featureEffectsCreateDatetime \link{FeatureEffectsCreateDatetime}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Effects request for a backtest has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Provided project, model, or backtest index does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' featureEffectsCreateDatetime <- FeatureEffectsCreateDatetime$new() # FeatureEffectsCreateDatetime |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureEffectsCreate(projectId, modelId, featureEffectsCreateDatetime=featureEffectsCreateDatetime)
    #' }
    ProjectsDatetimeModelsFeatureEffectsCreate = function(projectId, modelId, featureEffectsCreateDatetime = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureEffectsCreateWithHttpInfo(projectId, modelId, featureEffectsCreateDatetime, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Effects for a model backtest.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Feature Effects for a model backtest. Feature Effects provides partial dependence and predicted vs actual values for the top 500 features, ordered by feature impact score. The partial dependence shows marginal effect of a feature on the target variable after accounting for the average effects of all other predictive features. It indicates how, holding all other variables except the feature of interest as they were, the value of this feature affects your prediction. If a Feature Effects job was previously submitted for a given backtest, this endpoint will return a response structured as {\&quot;message\&quot;: \\&lt;message\\&gt;, \&quot;jobId\&quot;: \\&lt;jobId\\&gt;} where jobId is the ID of the job. Retrieve the job with :&lt;http:get&gt;:/api/v2/projects/(projectId)/jobs/(jobId)/
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/featureEffects/` in the DataRobot Public API.
    #' @param backtestIndex character. The backtest index. For example: &#x60;0&#x60;, &#x60;1&#x60;, ..., &#x60;20&#x60;, &#x60;holdout&#x60;, &#x60;startstop&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureEffectsDatetimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source, backtest index, or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' backtestIndex <- 'backtestIndex_example' # character | The backtest index. For example: `0`, `1`, ..., `20`, `holdout`, `startstop`.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureEffectsList(backtestIndex, projectId, modelId, source=source, includeIcePlots=includeIcePlots)
    #' }
    ProjectsDatetimeModelsFeatureEffectsList = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureEffectsListWithHttpInfo(backtestIndex, projectId, modelId, source, includeIcePlots, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Effects metadata for each backtest. Response contains status and available sources for each backtest of the model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Feature Effects metadata for each backtest. Response contains status and available sources for each backtest of the model. One of the provided backtestIndex indexes used for submitting the compute request and retrieving Feature Effects. \\* Start/stop models contain a single backtestIndex response value of startstop. \\* Other models contain backtestIndex of 0, 1, ..., holdout. One of the provided source parameters used for retrieving Feature Effects. \\* Each backtest source can be, at a minimum, training or validation. If holdout is configured for the project, backtestIndex also includes holdout with sources training and holdout. \\* Source value of training is always available. (versions prior to v2.17 support validation only) \\* When a start/stop model is trained into validation or holdout without stacked predictions (i.e., no out-of-sample predictions in validation or holdout), validation and holdout sources are not available. \\* Source holdout is not available when there is no holdout configured for the project.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/featureEffectsMetadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelXrayMetadataDatetimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** The model is not datetime partitioned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureEffectsMetadataList(projectId, modelId)
    #' }
    ProjectsDatetimeModelsFeatureEffectsMetadataList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureEffectsMetadataListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add a request to the queue to calculate Feature Fit for a backtest.
    #' Produces: NA
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Add a request to the queue to calculate Feature Fit for a backtest. If the job has been previously submitted, the request fails, returning the jobId of the previously submitted job. Use this jobId to check status of the previously submitted job.
    #' @details This method invokes `POST /projects/{projectId}/datetimeModels/{modelId}/featureFit/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param modelXrayCreateDatetime \link{ModelXrayCreateDatetime}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Fit request for a backtest has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Provided project, model, or backtest index does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' modelXrayCreateDatetime <- ModelXrayCreateDatetime$new() # ModelXrayCreateDatetime |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureFitCreate(projectId, modelId, modelXrayCreateDatetime=modelXrayCreateDatetime)
    #' }
    ProjectsDatetimeModelsFeatureFitCreate = function(projectId, modelId, modelXrayCreateDatetime = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureFitCreateWithHttpInfo(projectId, modelId, modelXrayCreateDatetime, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Fit for a model backtest.
    #' Produces: "application/json"
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Retrieve Feature Fit for a model backtest. Feature Fit provides partial dependence and predicted vs actual values for the top 500 features, ordered by feature importance score. The partial dependence shows marginal effect of a feature on the target variable after accounting for the average effects of all other predictive features. It indicates how, holding all other variables except the feature of interest as they were, the value of this feature affects your prediction. If a Feature Fit job was previously submitted for a given backtest, this endpoint will return a response structured as {\&quot;message\&quot;: \\&lt;message\\&gt;, \&quot;jobId\&quot;: \\&lt;jobId\\&gt;} where jobId is the ID of the job. Retrieve the job with :&lt;http:get&gt;:/api/v2/projects/(projectId)/jobs/(jobId)/
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/featureFit/` in the DataRobot Public API.
    #' @param backtestIndex character. The backtest index. For example: &#x60;0&#x60;, &#x60;1&#x60;, ..., &#x60;20&#x60;, &#x60;holdout&#x60;, &#x60;startstop&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureFitDatetimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source, backtest index, or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' backtestIndex <- 'backtestIndex_example' # character | The backtest index. For example: `0`, `1`, ..., `20`, `holdout`, `startstop`.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureFitList(backtestIndex, projectId, modelId, source=source, includeIcePlots=includeIcePlots)
    #' }
    ProjectsDatetimeModelsFeatureFitList = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureFitListWithHttpInfo(backtestIndex, projectId, modelId, source, includeIcePlots, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Fit metadata for each backtest. Response contains status and available sources for each backtest of the model.
    #' Produces: "application/json"
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Retrieve Feature Fit metadata for each backtest. Response contains status and available sources for each backtest of the model. One of the provided backtestIndex indexes used for submitting the compute request and retrieving Feature Fit. \\* Start/stop models contain a single backtestIndex response value of startstop. \\* Other models contain backtestIndex of 0, 1, ..., holdout. One of the provided source parameters used for retrieving Feature Fit. \\* Each backtest source can be, at a minimum, training or validation. If holdout is configured for the project, backtestIndex also includes holdout with sources training and holdout. \\* Source value of training is always available. (versions prior to v2.17 support validation only) \\* When a start/stop model is trained into validation or holdout without stacked predictions (i.e., no out-of-sample predictions in validation or holdout), validation and holdout sources are not available. \\* Source holdout is not available when there is no holdout configured for the project.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/featureFitMetadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelXrayMetadataDatetimeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** The model is not datetime partitioned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsFeatureFitMetadataList(projectId, modelId)
    #' }
    ProjectsDatetimeModelsFeatureFitMetadataList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsDatetimeModelsFeatureFitMetadataListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a plot displaying the stability of the time series model across different forecast distances.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a plot displaying the stability of the time series model across different forecast distances. .. note:: All durations and datetimes are specified in accordance with the &#x60;timestamp and duration formatting rules &lt;time_format&gt;&#x60;.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/forecastDistanceStabilityPlot/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param metricName character. The name of the metric to retrieve the scores for. If omitted, the default project metric will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ForecastDistanceStabilityPlotResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Forecast distance stability plot for datetime partitioned model.
    #' \itemize{
    #' }
    #' \item **`422`** There was an error while retrieving the plot.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' metricName <- 'metricName_example' # character | The name of the metric to retrieve the scores for. If omitted, the default project metric will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsForecastDistanceStabilityPlotList(projectId, modelId, metricName=metricName)
    #' }
    ProjectsDatetimeModelsForecastDistanceStabilityPlotList = function(projectId, modelId, metricName = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsForecastDistanceStabilityPlotListWithHttpInfo(projectId, modelId, metricName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the data for the Forecast vs Actual plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the data for the Forecast vs Actual plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param resolution Enum < [milliseconds, seconds, minutes, hours, days, weeks, months, quarters, years] > Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins &lt;&#x3D; &#x60;maxBinSize&#x60;
    #' @param forecastDistanceStart integer. The start of forecast distance range (forecast window) to retrieve. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' @param forecastDistanceEnd integer. The end of forecast distance range (forecast window) to retrieve. If not specified, the last forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' @param maxBinSize integer. Specifies the maximum number of bins for the retrieval.
    #' @param startDate character. The start of the date range to return. If not specified, start date for requested plots will be used.
    #' @param endDate character. The end of the date range to return. If not specified, end date for requested plots will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ForecastVsActualPlotsDataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Forecast vs Actual plots data
    #' \itemize{
    #' }
    #' \item **`404`** Forecast vs Actual plots data was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #' resolution <- 'resolution_example' # character | Specifying at which resolution the data should be binned. If not specified, optimal resolution will be used to build chart data with number of bins <= `maxBinSize`
    #' forecastDistanceStart <- 56 # integer | The start of forecast distance range (forecast window) to retrieve. If not specified, the first forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' forecastDistanceEnd <- 56 # integer | The end of forecast distance range (forecast window) to retrieve. If not specified, the last forecast distance for this project will be used. Forecast distance specifies the number of time steps between the predicted point and the origin point. Only available for time series supervised projects.
    #' maxBinSize <- 500 # integer | Specifies the maximum number of bins for the retrieval.
    #' startDate <- 'startDate_example' # character | The start of the date range to return. If not specified, start date for requested plots will be used.
    #' endDate <- 'endDate_example' # character | The end of the date range to return. If not specified, end date for requested plots will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsForecastVsActualPlotsList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source, resolution=resolution, forecastDistanceStart=forecastDistanceStart, forecastDistanceEnd=forecastDistanceEnd, maxBinSize=maxBinSize, startDate=startDate, endDate=endDate)
    #' }
    ProjectsDatetimeModelsForecastVsActualPlotsList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", resolution = NULL, forecastDistanceStart = NULL, forecastDistanceEnd = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsForecastVsActualPlotsListWithHttpInfo(projectId, modelId, seriesId, backtest, source, resolution, forecastDistanceStart, forecastDistanceEnd, maxBinSize, startDate, endDate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the metadata for the Forecast vs Actual plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the metadata for the Forecast vs Actual plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ForecastVsActualPlotsMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Forecast vs Actual plots metadata
    #' \itemize{
    #' }
    #' \item **`404`** Forecast vs Actual plots metadata was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided a metadata of average plot for the first 1000 series will be retrieved.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsForecastVsActualPlotsMetadataList(projectId, modelId, seriesId=seriesId)
    #' }
    ProjectsDatetimeModelsForecastVsActualPlotsMetadataList = function(projectId, modelId, seriesId = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsForecastVsActualPlotsMetadataListWithHttpInfo(projectId, modelId, seriesId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the preview for the Forecast vs Actual plots.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the preview for the Forecast vs Actual plots.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/preview/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesId character. The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' @param backtest \link{OneOfintegerstring}. Retrieve plots for a specific backtest (use the backtest index starting from zero) or &#x60;holdout&#x60;. If not specified the first backtest (backtest index 0) will be used.
    #' @param source Enum < [training, validation] > The source of the data for the backtest/holdout.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DatetimeTrendPlotsPreviewResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Forecast vs Actual plots preview
    #' \itemize{
    #' }
    #' \item **`404`** Forecast vs Actual plots preview was not found
    #' \itemize{
    #' }
    #' \item **`422`** Invalid parameters were submitted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve. Only available for time series multiseries projects. If not provided an average plot for the first 1000 series will be retrieved.
    #' backtest <- 'backtest_example' # OneOfintegerstring | Retrieve plots for a specific backtest (use the backtest index starting from zero) or `holdout`. If not specified the first backtest (backtest index 0) will be used.
    #' source <- "validation" # character | The source of the data for the backtest/holdout.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsForecastVsActualPlotsPreviewList(projectId, modelId, seriesId=seriesId, backtest=backtest, source=source)
    #' }
    ProjectsDatetimeModelsForecastVsActualPlotsPreviewList = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", ...) {
      apiResponse <- private$ProjectsDatetimeModelsForecastVsActualPlotsPreviewListWithHttpInfo(projectId, modelId, seriesId, backtest, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute feature effects for a multiclass datetime model.
    #' Produces: NA
    #'
    #' @details Compute feature effects for a multiclass datetime model. If the job has been previously submitted, the request fails, returning the &#x60;jobId&#x60; of the previously submitted job. Use this &#x60;jobId&#x60; to check status of the previously submitted job. NOTE: feature effects are computed for top 100 classes.
    #' @details This method invokes `POST /projects/{projectId}/datetimeModels/{modelId}/multiclassFeatureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param multiclassFeatureEffectDatetimeCreate \link{MulticlassFeatureEffectDatetimeCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Effects request has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error. If the &#x60;&#x60;rowCount&#x60;&#x60; exceeds the maximum or minimum value for this dataset. Minimum is 10 rows. Maximum is 100000 rows or the training sample size of the model, whichever is less. If invalid class names are provided in &#x60;&#x60;classes&#x60;&#x60;.If neither &#x60;&#x60;features&#x60;&#x60; nor &#x60;&#x60;topNFeatures&#x60;&#x60; is provided. If invalid &#x60;&#x60;backtestIndex&#x60;&#x60; is provided.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' multiclassFeatureEffectDatetimeCreate <- MulticlassFeatureEffectDatetimeCreate$new() # MulticlassFeatureEffectDatetimeCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMulticlassFeatureEffectsCreate(projectId, modelId, multiclassFeatureEffectDatetimeCreate=multiclassFeatureEffectDatetimeCreate)
    #' }
    ProjectsDatetimeModelsMulticlassFeatureEffectsCreate = function(projectId, modelId, multiclassFeatureEffectDatetimeCreate = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMulticlassFeatureEffectsCreateWithHttpInfo(projectId, modelId, multiclassFeatureEffectDatetimeCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature effects for each class in a multiclass datetime model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature effects for each class in a multiclass datetime model.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/multiclassFeatureEffects/` in the DataRobot Public API.
    #' @param backtestIndex character. The backtest index. For example: &#x60;0&#x60;, &#x60;1&#x60;, ..., &#x60;20&#x60;, &#x60;holdout&#x60;, &#x60;startstop&#x60;.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param class character. Target class label.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticlassDatetimeFeatureEffectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' backtestIndex <- 'backtestIndex_example' # character | The backtest index. For example: `0`, `1`, ..., `20`, `holdout`, `startstop`.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' class <- 'class_example' # character | Target class label.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMulticlassFeatureEffectsList(backtestIndex, projectId, modelId, source=source, includeIcePlots=includeIcePlots, offset=offset, limit=limit, class=class)
    #' }
    ProjectsDatetimeModelsMulticlassFeatureEffectsList = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, offset = 0, limit = 100, class = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMulticlassFeatureEffectsListWithHttpInfo(backtestIndex, projectId, modelId, source, includeIcePlots, offset, limit, class, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the histograms for series insights.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the histograms for series insights.  Histogram is computed only for first 1000 series (ordered by name).
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/multiseriesHistograms/` in the DataRobot Public API.
    #' @param attribute Enum < [rowCount, duration, startDate, endDate, targetAverage, validationScore, backtestingScore, holdoutScore, rowPercent, clusterCount, clustering] > The series attribute to build a histogram for.
    #' @param bins Enum < [10, 20, 50] > The number of bins in a histogram. Can be 10, 20 or 50. The default is 10.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param metric character. The name of the metric to retrieve the histogram for attributes \&quot;validationScore\&quot;, \&quot;backtestingScore\&quot;, and\&quot;holdoutScore\&quot;. If omitted, the default project metric will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MultiseriesHistogramsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve the histograms for series insights in form of an array of histogram bins.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permissions to manage models.
    #' \itemize{
    #' }
    #' \item **`404`** Model with specified &#x60;modelId&#x60; doesn&#39;t exist, or user does not have access to the project.
    #' \itemize{
    #' }
    #' \item **`422`** Metric provided to query is not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' attribute <- "rowCount" # character | The series attribute to build a histogram for.
    #' bins <- "10" # character | The number of bins in a histogram. Can be 10, 20 or 50. The default is 10.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' metric <- 'metric_example' # character | The name of the metric to retrieve the histogram for attributes \"validationScore\", \"backtestingScore\", and\"holdoutScore\". If omitted, the default project metric will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMultiseriesHistogramsList(attribute, bins, projectId, modelId, metric=metric)
    #' }
    ProjectsDatetimeModelsMultiseriesHistogramsList = function(attribute, bins, projectId, modelId, metric = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMultiseriesHistogramsListWithHttpInfo(attribute, bins, projectId, modelId, metric, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Request the computation of per-series scores for a multiseries model.
    #' Produces: NA
    #'
    #' @details Request the computation of per-series scores for a multiseries model. .. note:: Computation uses available partitions only. This endpoint will not compute backtesting scores if no backtesting scores exist prior to this request.
    #' @details This method invokes `POST /projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param seriesAccuracyCompute \link{SeriesAccuracyCompute}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Multiseries score computation has been successfully requested.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' seriesAccuracyCompute <- SeriesAccuracyCompute$new() # SeriesAccuracyCompute |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMultiseriesScoresCreate(projectId, modelId, seriesAccuracyCompute=seriesAccuracyCompute)
    #' }
    ProjectsDatetimeModelsMultiseriesScoresCreate = function(projectId, modelId, seriesAccuracyCompute = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMultiseriesScoresCreateWithHttpInfo(projectId, modelId, seriesAccuracyCompute, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the CSV file for the series accuracy.
    #' Produces: NA
    #'
    #' @details Retrieve the CSV file for the series accuracy.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/file/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param multiseriesValue character. If specified, only the series containing the given value in one of the series ID columns will be returned.
    #' @param metric character. The name of the metric to retrieve the scores for. If omitted, the default project metric will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The response will contain a file containing the series accuracy data in csv format.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;Series accuracy (model:&lt;lid&gt;) (&lt;metric&gt;).csv\&quot;).
    #' \item **`ContentMinusType`** MIME type of the returned data
    #' }
    #' \item **`403`** User does not have permissions to manage models.
    #' \itemize{
    #' }
    #' \item **`404`** Model with specified &#x60;modelId&#x60; doesn&#39;t exist, or user does not have access to the project.
    #' \itemize{
    #' }
    #' \item **`422`** Metric provided to query is not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' multiseriesValue <- 'multiseriesValue_example' # character | If specified, only the series containing the given value in one of the series ID columns will be returned.
    #' metric <- 'metric_example' # character | The name of the metric to retrieve the scores for. If omitted, the default project metric will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMultiseriesScoresFileList(projectId, modelId, multiseriesValue=multiseriesValue, metric=metric)
    #' }
    ProjectsDatetimeModelsMultiseriesScoresFileList = function(projectId, modelId, multiseriesValue = NULL, metric = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMultiseriesScoresFileListWithHttpInfo(projectId, modelId, multiseriesValue, metric, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the scores per individual series for the specified multiseries model.
    #' Produces: "application/json"
    #'
    #' @details List the scores per individual series for the specified multiseries model.
    #' @details This method invokes `GET /projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/` in the DataRobot Public API.
    #' @param offset integer. The number of results to skip. Defaults to 0 if not specified.
    #' @param limit integer. The maximum number of results to return. Defaults to 100 if not specified.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param multiseriesValue character. Only the series containing the given value in one of the series ID columns will be returned if specified.
    #' @param metric character. The name of the metric to retrieve the scores for.If omitted, the default project metric will be used.
    #' @param orderBy Enum < [multiseriesValue, -multiseriesValue, rowCount, -rowCount, startDate, -startDate, endDate, -endDate, targetAverage, -targetAverage, validationScore, -validationScore, backtestingScore, -backtestingScore, holdoutScore, -holdoutScore, cluster, -cluster] > Used for sorting the series. Supported attributes for ordering include: \&quot;multiseriesValue\&quot;, \&quot;rowCount\&quot;, \&quot;validationScore\&quot;, \&quot;holdoutScore\&quot;  and \&quot;backtestingScore\&quot;, \&quot;startDate\&quot;, \&quot;endDate\&quot;, and \&quot;targetAverage\&quot;.Prefix the attribute name with a dash to sort in descending order,e.g. &#x60;orderBy&#x3D;-rowCount&#x60;. If multiple series with equal values of the ordering attributeexist, ties will be broken arbitrarily.
    #' @param filterBy Enum < [rowCount, startDate, endDate, targetAverage, validationScore, backtestingScore, holdoutScore, cluster] > Used to specify on which attribute values to filter the series.Supported attributes for filtering include: \&quot;rowCount\&quot;, \&quot;startDate\&quot;, \&quot;endDate\&quot;, \&quot;targetAverage\&quot;, \&quot;validationScore\&quot;, \&quot;holdoutScore\&quot;, and \&quot;backtestingScore\&quot;.&#x60;filterByBins&#x60; and &#x60;numberOfBins&#x60; are required if this parameter is used.
    #' @param numberOfBins Enum < [10, 20, 50] > Used to specify the number of bins in the histogram on which to filter the series.Can be 10, 20 or 50.&#x60;filterBy&#x60; and &#x60;filterByBins&#x60; are required if this parameter is used.
    #' @param filterByBins character. Used to specify the multiseries histogram bins on which to filter the series.&#x60;filterBy&#x60; and &#x60;numberOfBins&#x60; are required if this parameter is used.
    #' @param clusterNames character. Used to specify the specific cluster on which to filter the series.&#x60;filterBy&#x60; is required if this parameter is used.Only valid for unsupervised clustering projects.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SeriesAccuracyRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve the accuracy scores for each series for the specified multiseries model.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permissions to manage models.
    #' \itemize{
    #' }
    #' \item **`404`** Model with specified &#x60;modelId&#x60; doesn&#39;t exist, or user does not have access to the project.
    #' \itemize{
    #' }
    #' \item **`422`** Metric provided to query is not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | The number of results to skip. Defaults to 0 if not specified.
    #' limit <- 100 # integer | The maximum number of results to return. Defaults to 100 if not specified.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' multiseriesValue <- 'multiseriesValue_example' # character | Only the series containing the given value in one of the series ID columns will be returned if specified.
    #' metric <- 'metric_example' # character | The name of the metric to retrieve the scores for.If omitted, the default project metric will be used.
    #' orderBy <- 'orderBy_example' # character | Used for sorting the series. Supported attributes for ordering include: \"multiseriesValue\", \"rowCount\", \"validationScore\", \"holdoutScore\"  and \"backtestingScore\", \"startDate\", \"endDate\", and \"targetAverage\".Prefix the attribute name with a dash to sort in descending order,e.g. `orderBy=-rowCount`. If multiple series with equal values of the ordering attributeexist, ties will be broken arbitrarily.
    #' filterBy <- 'filterBy_example' # character | Used to specify on which attribute values to filter the series.Supported attributes for filtering include: \"rowCount\", \"startDate\", \"endDate\", \"targetAverage\", \"validationScore\", \"holdoutScore\", and \"backtestingScore\".`filterByBins` and `numberOfBins` are required if this parameter is used.
    #' numberOfBins <- 'numberOfBins_example' # character | Used to specify the number of bins in the histogram on which to filter the series.Can be 10, 20 or 50.`filterBy` and `filterByBins` are required if this parameter is used.
    #' filterByBins <- 'filterByBins_example' # character | Used to specify the multiseries histogram bins on which to filter the series.`filterBy` and `numberOfBins` are required if this parameter is used.
    #' clusterNames <- 'clusterNames_example' # character | Used to specify the specific cluster on which to filter the series.`filterBy` is required if this parameter is used.Only valid for unsupervised clustering projects.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsDatetimeModelsMultiseriesScoresList(offset, limit, projectId, modelId, multiseriesValue=multiseriesValue, metric=metric, orderBy=orderBy, filterBy=filterBy, numberOfBins=numberOfBins, filterByBins=filterByBins, clusterNames=clusterNames)
    #' }
    ProjectsDatetimeModelsMultiseriesScoresList = function(offset, limit, projectId, modelId, multiseriesValue = NULL, metric = NULL, orderBy = NULL, filterBy = NULL, numberOfBins = NULL, filterByBins = NULL, clusterNames = NULL, ...) {
      apiResponse <- private$ProjectsDatetimeModelsMultiseriesScoresListWithHttpInfo(offset, limit, projectId, modelId, multiseriesValue, metric, orderBy, filterBy, numberOfBins, filterByBins, clusterNames, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute model scores for external dataset.
    #' Produces: NA
    #'
    #' @details Compute model scores for external dataset, first upload your dataset to the project, and then using the corresponding datasetId, compute scores against that dataset. Computing external scores and insights depends on computed prediction, predictions will be computed if they are not available for this dataset. In order to compute scores and insights, uploaded dataset should contain actual value column. This api is not available in time series projects.
    #' @details This method invokes `POST /projects/{projectId}/externalScores/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param externalScoresCreate \link{ExternalScoresCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`**
    #' \itemize{
    #' }
    #' \item **`422`** The project type does not support or modeling is not finished yet.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' externalScoresCreate <- ExternalScoresCreate$new() # ExternalScoresCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsExternalScoresCreate(projectId, externalScoresCreate=externalScoresCreate)
    #' }
    ProjectsExternalScoresCreate = function(projectId, externalScoresCreate = NULL, ...) {
      apiResponse <- private$ProjectsExternalScoresCreateWithHttpInfo(projectId, externalScoresCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List of scores on prediction datasets for a project.
    #' Produces: "application/json"
    #'
    #' @details List of scores on prediction datasets for a project with filtering option by dataset or model or both of them. Prediction dataset may have scores if it contained a column with actual values and predictions were computed on this dataset.
    #' @details This method invokes `GET /projects/{projectId}/externalScores/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param datasetId character. If provided will return scores for dataset with matching datasetId.
    #' @param modelId character. If provided will return scores for model with matching modelId.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ExternalScoresListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of scores on prediction datasets.
    #' \itemize{
    #' }
    #' \item **`404`** Project not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' datasetId <- 'datasetId_example' # character | If provided will return scores for dataset with matching datasetId.
    #' modelId <- 'modelId_example' # character | If provided will return scores for model with matching modelId.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsExternalScoresList(projectId, offset=offset, limit=limit, datasetId=datasetId, modelId=modelId)
    #' }
    ProjectsExternalScoresList = function(projectId, offset = 0, limit = 100, datasetId = NULL, modelId = NULL, ...) {
      apiResponse <- private$ProjectsExternalScoresListWithHttpInfo(projectId, offset, limit, datasetId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all featurelists with feature association matrix availability flags for a project.
    #' Produces: "application/json"
    #'
    #' @details List all featurelists with feature association matrix availability flags for a project.
    #' @details This method invokes `GET /projects/{projectId}/featureAssociationFeaturelists/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureAssociationListControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List available Feature Association Matrix for a project.
    #' \itemize{
    #' }
    #' \item **`404`** Project not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsFeatureAssociationFeaturelistsList(projectId)
    #' }
    ProjectsFeatureAssociationFeaturelistsList = function(projectId, ...) {
      apiResponse <- private$ProjectsFeatureAssociationFeaturelistsListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute feature association matrix.
    #' Produces: NA
    #'
    #' @details Compute feature association matrix for given featurelist.
    #' @details This method invokes `POST /projects/{projectId}/featureAssociationMatrix/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param featureAssociationCreatePayload \link{FeatureAssociationCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`**
    #' \itemize{
    #' }
    #' \item **`404`** A project with &#x60;projectId&#x60; or a featurelist with &#x60;featurelistId&#x60; was not found.
    #' \itemize{
    #' }
    #' \item **`422`** The feature association matrix calculation is not supported for this project.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' featureAssociationCreatePayload <- FeatureAssociationCreatePayload$new() # FeatureAssociationCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsFeatureAssociationMatrixCreate(projectId, featureAssociationCreatePayload=featureAssociationCreatePayload)
    #' }
    ProjectsFeatureAssociationMatrixCreate = function(projectId, featureAssociationCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsFeatureAssociationMatrixCreateWithHttpInfo(projectId, featureAssociationCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieval for feature association plotting between a pair of features.
    #' Produces: "application/json"
    #'
    #' @details Retrieval for feature association plotting between a pair of features.   Projects created prior to v2.17 are not supported by this feature.
    #' @details This method invokes `GET /projects/{projectId}/featureAssociationMatrixDetails/` in the DataRobot Public API.
    #' @param feature1 character. The name of a feature.
    #' @param feature2 character. the name of another feature.
    #' @param projectId character. The project ID
    #' @param featurelistId character. the feature list to lookup FAM data for. By default, depending on the type of the project &#x60;Informative Features&#x60; or &#x60;Timeseries Informative Features&#x60; list will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureAssociationDetailsRetrieveControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieval for feature association plotting between a pair of features.
    #' \itemize{
    #' }
    #' \item **`404`** Wrong query parameters specified or no such &#x60;projectId&#x60; exists.
    #' \itemize{
    #' }
    #' \item **`422`** This project does not support feature associations, (e.g. multilabel, multiseries, time series unsupervised projects.).
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' feature1 <- 'feature1_example' # character | The name of a feature.
    #' feature2 <- 'feature2_example' # character | the name of another feature.
    #' projectId <- 'projectId_example' # character | The project ID
    #' featurelistId <- 'featurelistId_example' # character | the feature list to lookup FAM data for. By default, depending on the type of the project `Informative Features` or `Timeseries Informative Features` list will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsFeatureAssociationMatrixDetailsList(feature1, feature2, projectId, featurelistId=featurelistId)
    #' }
    ProjectsFeatureAssociationMatrixDetailsList = function(feature1, feature2, projectId, featurelistId = NULL, ...) {
      apiResponse <- private$ProjectsFeatureAssociationMatrixDetailsListWithHttpInfo(feature1, feature2, projectId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieval for pairwise feature association statistics.
    #' Produces: "application/json"
    #'
    #' @details &gt; Retrieval for pairwise feature association statistics.   &gt; Projects created prior to v2.17 are not supported by this feature.
    #' @details This method invokes `GET /projects/{projectId}/featureAssociationMatrix/` in the DataRobot Public API.
    #' @param type Enum < [association, correlation] > the type of dependence for the data. Must be either &#x60;association&#x60; or &#x60;correlation&#x60;. Since v2.19 this is optional and defaults to &#x60;association&#x60;.
    #' @param metric Enum < [mutualInfo, cramersV, spearman, pearson, tau] > the name of a metric to get pairwise data for. Must be one of &#x60;mutualInfo&#x60;, &#x60;cramersV&#x60;, &#x60;spearman&#x60;, &#x60;pearson&#x60;, or &#x60;tau&#x60;. Since v2.19 this is optional and defaults to &#x60;mutualInfo&#x60;.
    #' @param projectId character. The project ID
    #' @param featurelistId character. the feature list to lookup FAM data for. By default, depending on the type of the project &#x60;Informative Features&#x60; or &#x60;Timeseries Informative Features&#x60; list will be used.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureAssociationRetrieveControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve Feature Association Matrix for project.
    #' \itemize{
    #' }
    #' \item **`404`** Wrong query parameters specified or no such &#x60;projectId&#x60; exists.
    #' \itemize{
    #' }
    #' \item **`422`** The project does not support feature associations.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' type <- "association" # character | the type of dependence for the data. Must be either `association` or `correlation`. Since v2.19 this is optional and defaults to `association`.
    #' metric <- "mutualInfo" # character | the name of a metric to get pairwise data for. Must be one of `mutualInfo`, `cramersV`, `spearman`, `pearson`, or `tau`. Since v2.19 this is optional and defaults to `mutualInfo`.
    #' projectId <- 'projectId_example' # character | The project ID
    #' featurelistId <- 'featurelistId_example' # character | the feature list to lookup FAM data for. By default, depending on the type of the project `Informative Features` or `Timeseries Informative Features` list will be used.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsFeatureAssociationMatrixList(type, metric, projectId, featurelistId=featurelistId)
    #' }
    ProjectsFeatureAssociationMatrixList = function(type, metric, projectId, featurelistId = NULL, ...) {
      apiResponse <- private$ProjectsFeatureAssociationMatrixListWithHttpInfo(type, metric, projectId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the frequent values information for a particular feature.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the frequent values information for a particular feature.   Only valid for numeric features. This route returns information about the frequent values seen for a particular feature, based on the EDA sample of the dataset. Up to 60 values will be returned, and when more values are present, they will be bucketed into a level called \&quot;&#x3D;&#x3D;All Other&#x3D;&#x3D;\&quot; at the end of the response.
    #' @details This method invokes `GET /projects/{projectId}/features/{featureName}/frequentValues/` in the DataRobot Public API.
    #' @param projectId character. project id
    #' @param featureName character. name of the feature
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FrequentValuesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve the frequent values information for a particular feature.
    #' \itemize{
    #' }
    #' \item **`404`** If the feature doesn&#39;t exist, or no such projectId exists
    #' \itemize{
    #' }
    #' \item **`422`** If the feature isn&#39;t numeric
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | project id
    #' featureName <- 'featureName_example' # character | name of the feature
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsFeaturesFrequentValuesList(projectId, featureName)
    #' }
    ProjectsFeaturesFrequentValuesList = function(projectId, featureName, ...) {
      apiResponse <- private$ProjectsFeaturesFrequentValuesListWithHttpInfo(projectId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a map of one location feature
    #' Produces: NA
    #'
    #' @details Create a map of one location feature
    #' @details This method invokes `POST /projects/{projectId}/geometryFeaturePlots/` in the DataRobot Public API.
    #' @param projectId character. Project Id. It is the project to select the location feature from.
    #' @param geometryFeaturePLotCreatePayload \link{GeometryFeaturePLotCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Create a map of one location feature
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** Unprocessed Entity
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | Project Id. It is the project to select the location feature from.
    #' geometryFeaturePLotCreatePayload <- GeometryFeaturePLotCreatePayload$new() # GeometryFeaturePLotCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsGeometryFeaturePlotsCreate(projectId, geometryFeaturePLotCreatePayload=geometryFeaturePLotCreatePayload)
    #' }
    ProjectsGeometryFeaturePlotsCreate = function(projectId, geometryFeaturePLotCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsGeometryFeaturePlotsCreateWithHttpInfo(projectId, geometryFeaturePLotCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a map of one location feature
    #' Produces: "application/json"
    #'
    #' @details Retrieve a map of one location feature
    #' @details This method invokes `GET /projects/{projectId}/geometryFeaturePlots/{featureName}/` in the DataRobot Public API.
    #' @param projectId character. Project Id. It is the project to select the feature from.
    #' @param featureName character. Name of location feature to plot on map. Must be supplied in order to determine which plot to retrieve.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{GeometryFeaturePlotRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve the map of one location feature
    #' \itemize{
    #' }
    #' \item **`404`** Map of feature not found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | Project Id. It is the project to select the feature from.
    #' featureName <- 'featureName_example' # character | Name of location feature to plot on map. Must be supplied in order to determine which plot to retrieve.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsGeometryFeaturePlotsRetrieve(projectId, featureName)
    #' }
    ProjectsGeometryFeaturePlotsRetrieve = function(projectId, featureName, ...) {
      apiResponse <- private$ProjectsGeometryFeaturePlotsRetrieveWithHttpInfo(projectId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all Image Activation Maps for the project.
    #' Produces: "application/json"
    #'
    #' @details List all Image Activation Maps for the project.
    #' @details This method invokes `GET /projects/{projectId}/imageActivationMaps/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. The number of items to skip over.
    #' @param limit integer. The number of items to return.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ActivationMapsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Image Activation Maps
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | The number of items to skip over.
    #' limit <- 100 # integer | The number of items to return.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsImageActivationMapsList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsImageActivationMapsList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsImageActivationMapsListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all Image Embeddings for the project.
    #' Produces: "application/json"
    #'
    #' @details List all Image Embeddings for the project.
    #' @details This method invokes `GET /projects/{projectId}/imageEmbeddings/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. The number of items to skip over.
    #' @param limit integer. The number of items to return.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{EmbeddingsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Image Embeddings
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | The number of items to skip over.
    #' limit <- 100 # integer | The number of items to return.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsImageEmbeddingsList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsImageEmbeddingsList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsImageEmbeddingsListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Calculate the anomaly assessment insight.
    #' Produces: NA
    #'
    #' @details Initialize the anomaly assessment insight and calculate Shapley explanations for the most anomalous points in the subset. The insight is available for anomaly detection models in time series unsupervised projects which also support calculation of Shapley values.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/anomalyAssessmentInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param anomalyAssessmentInitialize \link{AnomalyAssessmentInitialize}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' anomalyAssessmentInitialize <- AnomalyAssessmentInitialize$new() # AnomalyAssessmentInitialize |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsAnomalyAssessmentInitializationCreate(projectId, modelId, anomalyAssessmentInitialize=anomalyAssessmentInitialize)
    #' }
    ProjectsModelsAnomalyAssessmentInitializationCreate = function(projectId, modelId, anomalyAssessmentInitialize = NULL, ...) {
      apiResponse <- private$ProjectsModelsAnomalyAssessmentInitializationCreateWithHttpInfo(projectId, modelId, anomalyAssessmentInitialize, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a CSV file of the raw data displayed with the anomaly score from the model.
    #' Produces: NA
    #'
    #' @details Retrieve a CSV file of the raw data displayed with the anomaly score from the specific model. The number of rows included will be set by the expected outlier fraction but up to a maximum of 1000 rows. Only models built from anomaly detection blueprints have those insights.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/anomalyInsightsFile/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param filename character. name of the file to generate and return
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a CSV file of the raw data displayed with the anomaly score from the model.
    #' \itemize{
    #' }
    #' \item **`404`** project Id / model Id does not exist or model doesn&#39;t have anomaly insights table.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' filename <- 'filename_example' # character | name of the file to generate and return
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsAnomalyInsightsFileList(projectId, modelId, filename=filename)
    #' }
    ProjectsModelsAnomalyInsightsFileList = function(projectId, modelId, filename = NULL, ...) {
      apiResponse <- private$ProjectsModelsAnomalyInsightsFileListWithHttpInfo(projectId, modelId, filename, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a table of the raw data displayed with the anomaly score from the specific model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a table of the raw data displayed with the anomaly score from the specific model. The number of rows displayed is limited to 100 rows by the ANOMALY_INSIGHT_SAMPLE_ROW_COUNT configuration setting. Additionally, feature column count and the size of data in text fields is also limited. Only models built from anomaly detection blueprints have those insights.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/anomalyInsightsTable/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param anomalyScoreRounding integer. number of decimals each element anomalyScore column will be rounded to.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AnomalyInsightTableRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a table of the raw data displayed with the anomaly score from the specific model.
    #' \itemize{
    #' }
    #' \item **`404`** The model doesn&#39;t have anomaly insights table.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' anomalyScoreRounding <- 56 # integer | number of decimals each element anomalyScore column will be rounded to.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsAnomalyInsightsTableList(projectId, modelId, anomalyScoreRounding=anomalyScoreRounding)
    #' }
    ProjectsModelsAnomalyInsightsTableList = function(projectId, modelId, anomalyScoreRounding = NULL, ...) {
      apiResponse <- private$ProjectsModelsAnomalyInsightsTableListWithHttpInfo(projectId, modelId, anomalyScoreRounding, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute Cluster Insights.
    #' Produces: "application/json"
    #'
    #' @details Compute Cluster Insights for a clustering project model.The number of features computed for cluster insights are capped at 100, starting with the features used to train the model sorted by feature impact (high to low), and then the remaining features in the dataset alphabetically.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/clusterInsights/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param body object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** A URI of the newly submitted job in the \&quot;Location\&quot; header.
    #' \itemize{
    #' }
    #' \item **`404`** The project or the model was not found or insights have not been computed yet.
    #' \itemize{
    #' }
    #' \item **`422`** Feature Impact is already in progress or Cluster Insighst is already in progress, but we were unable to find the previous job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' body <- NULL # object |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsClusterInsightsCreate(projectId, modelId, body=body)
    #' }
    ProjectsModelsClusterInsightsCreate = function(projectId, modelId, body = NULL, ...) {
      apiResponse <- private$ProjectsModelsClusterInsightsCreateWithHttpInfo(projectId, modelId, body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download Cluster Insights result.
    #' Produces: NA
    #'
    #' @details Download all computed Cluster Insights for a clustering project model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/clusterInsights/download/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param format Enum < [CSV] > A format to use.
    #' @param featurelistId character. The ID of the featurelist to download data for. If not specified all columns will be downloaded.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A file with insights for a clustering project model.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (\&quot;attachment;filename&#x3D;cluster_insights_&lt;project_id&gt;_&lt;model_id&gt;.csv\&quot;).
    #' }
    #' \item **`404`** The project or the model was not found or insights have not been computed yet.
    #' \itemize{
    #' }
    #' \item **`422`** Feature Impact is required. Please, compute it first.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' format <- "CSV" # character | A format to use.
    #' featurelistId <- 'featurelistId_example' # character | The ID of the featurelist to download data for. If not specified all columns will be downloaded.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsClusterInsightsDownloadList(projectId, modelId, format=format, featurelistId=featurelistId)
    #' }
    ProjectsModelsClusterInsightsDownloadList = function(projectId, modelId, format = "CSV", featurelistId = NULL, ...) {
      apiResponse <- private$ProjectsModelsClusterInsightsDownloadListWithHttpInfo(projectId, modelId, format, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Cluster Insights for all features.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all computed Cluster Insights for a clustering project model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/clusterInsights/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of results to skip.
    #' @param orderBy Enum < [featureImpact, -featureImpact, featureName, -featureName] > Order results by the specified field value.
    #' @param searchFor character. Search for a specific string in a feature name.This search is case insensitive. If not specified, all features will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ClusterInsightsPaginatedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Insights for a clustering project model.
    #' \itemize{
    #' }
    #' \item **`404`** The project or the model was not found or insights have not been computed yet.
    #' \itemize{
    #' }
    #' \item **`422`** Feature Impact is required. Please, compute it first.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 15 # integer | At most this many results are returned. The default may change without notice.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of results to skip.
    #' orderBy <- 'orderBy_example' # character | Order results by the specified field value.
    #' searchFor <- 'searchFor_example' # character | Search for a specific string in a feature name.This search is case insensitive. If not specified, all features will be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsClusterInsightsList(limit, projectId, modelId, offset=offset, orderBy=orderBy, searchFor=searchFor)
    #' }
    ProjectsModelsClusterInsightsList = function(limit, projectId, modelId, offset = 0, orderBy = NULL, searchFor = NULL, ...) {
      apiResponse <- private$ProjectsModelsClusterInsightsListWithHttpInfo(limit, projectId, modelId, offset, orderBy, searchFor, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Calculates and sends frequency of class in distributed among other classes for actual and predicted data.
    #' Produces: "application/json"
    #'
    #' @details &gt; Calculates and sends frequency of class in distributed among other &gt; classes for actual and predicted data. A confusion chart class details &gt; for given class gives stats of misclassification done by model for &gt; given class for actual and predicted data. .. note:: Available for &gt; multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/confusionCharts/{source}/classDetails/` in the DataRobot Public API.
    #' @param className character. Name of a class for which distribution frequency is requested.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [backtest_18, backtest_10, backtest_11, backtest_14, backtest_3, backtest_15, holdout, backtest_5, backtest_16, crossValidation, backtest_2, backtest_12, backtest_20, backtest_17, validation, backtest_6, backtest_4, backtest_13, backtest_9, backtest_19, backtest_8, backtest_7] > Source of the data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelConfusionChartClassDetailsRetrieveReponseController}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The details of the confusion matrix of a model for a specific class.
    #' \itemize{
    #' }
    #' \item **`404`** No confusion chart for source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' className <- 'className_example' # character | Name of a class for which distribution frequency is requested.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsConfusionChartsClassDetailsList(className, projectId, modelId, source)
    #' }
    ProjectsModelsConfusionChartsClassDetailsList = function(className, projectId, modelId, source, ...) {
      apiResponse <- private$ProjectsModelsConfusionChartsClassDetailsListWithHttpInfo(className, projectId, modelId, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all available confusion charts for model.
    #' Produces: "application/json"
    #'
    #' @details &gt; Retrieve all available confusion charts for model. The response will &gt; include a json array of all available confusion charts, in the same &gt; format as the response from &gt; :&lt;http:get&gt;:/api/v2/projects/(projectId)/models/(modelId)/confusionCharts/(source)/. &gt; .. note:: Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/confusionCharts/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelConfusionChartListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** All of the available confusion charts for a model.
    #' \itemize{
    #' }
    #' \item **`404`** No confusion chart available.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsConfusionChartsList(projectId, modelId)
    #' }
    ProjectsModelsConfusionChartsList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsConfusionChartsListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve metadata for the confusion chart of a model.
    #' Produces: "application/json"
    #'
    #' @details &gt; Retrieve metadata for the confusion chart of a model. .. note:: &gt; Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/confusionCharts/{source}/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [backtest_18, backtest_10, backtest_11, backtest_14, backtest_3, backtest_15, holdout, backtest_5, backtest_16, crossValidation, backtest_2, backtest_12, backtest_20, backtest_17, validation, backtest_6, backtest_4, backtest_13, backtest_9, backtest_19, backtest_8, backtest_7] > Source of the data
    #' @param orderBy Enum < [className, -className, actualCount, -actualCount, predictedCount, -predictedCount, f1, -f1] > Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;&#39;-predictedCount&#39;
    #' @param orientation Enum < [actual, -actual, predicted, -predicted] > Determines whether the values in the rows of the confusion matrix should correspond to the same actual class (&#39;actual&#39;) or predicted class (&#39;predicted&#39;).
    #' @param thumbnailCellSize integer. Number of classes in a single &#39;thumbnail&#39; cell.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelConfusionChartMetadataRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The metadata for the confusion chart of a model.
    #' \itemize{
    #' }
    #' \item **`404`** No confusion chart for source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data
    #' orderBy <- "className" # character | Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy='-predictedCount'
    #' orientation <- "actual" # character | Determines whether the values in the rows of the confusion matrix should correspond to the same actual class ('actual') or predicted class ('predicted').
    #' thumbnailCellSize <- 10 # integer | Number of classes in a single 'thumbnail' cell.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsConfusionChartsMetadataList(projectId, modelId, source, orderBy=orderBy, orientation=orientation, thumbnailCellSize=thumbnailCellSize)
    #' }
    ProjectsModelsConfusionChartsMetadataList = function(projectId, modelId, source, orderBy = "className", orientation = "actual", thumbnailCellSize = 10, ...) {
      apiResponse <- private$ProjectsModelsConfusionChartsMetadataListWithHttpInfo(projectId, modelId, source, orderBy, orientation, thumbnailCellSize, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the confusion chart data from a single source.
    #' Produces: "application/json"
    #'
    #' @details &gt; Retrieve the confusion chart data from a single source. A confusion &gt; chart consists of the confusion matrix for all classes, classes &gt; frequencies and oneVsAll metrics for all classes. The confusion matrix &gt; can be requested in a particular sort order and orientated by rows or &gt; columns. A subset of the confusion matrix can also be requested in &gt; part by specifying slicing indices. Throughout the following &gt; specification, C refers to the total number of classes in the dataset. &gt; The full confusion matrix refers to the confusion matrix with C &gt; classes. &gt; &gt; Note &gt; &gt; Available for multiclass projects only. &gt; &gt; An example on the meaning of wasActualPercentages and &gt; wasPredictedPercentages: Let&#39;s say we have the following data: .. &gt; code-block:: js &gt; &gt; &gt; classMetrics.classA.wasActualPercentages\\[0\\].percentage &#x3D; 0.56 &gt; &gt; classMetrics.classA.wasPredictedPercentages\\[0\\].percentage &#x3D; 0.62 &gt; &gt; classA.wasActualPercentages\\[0\\].otherClassName &#x3D; \&quot;classB\&quot; &gt; &gt; classA.wasPredictedPercentages\\[0\\].otherClassName &#x3D; \&quot;classB\&quot; &gt; &gt; That means: &gt; &gt; 1)  \&quot;Given that it was actually classA, it predicted classB 56% of the &gt;     time\&quot;. &gt; 2)  \&quot;Given that classA was predicted, it was actually classB 62% of &gt;     the time\&quot;.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/confusionCharts/{source}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [backtest_18, backtest_10, backtest_11, backtest_14, backtest_3, backtest_15, holdout, backtest_5, backtest_16, crossValidation, backtest_2, backtest_12, backtest_20, backtest_17, validation, backtest_6, backtest_4, backtest_13, backtest_9, backtest_19, backtest_8, backtest_7] > Source of the data
    #' @param orderBy Enum < [className, -className, actualCount, -actualCount, predictedCount, -predictedCount, f1, -f1] > Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;&#39;-predictedCount&#39;
    #' @param orientation Enum < [actual, -actual, predicted, -predicted] > Determines whether the values in the rows of the confusion matrix should correspond to the same actual class (&#39;actual&#39;) or predicted class (&#39;predicted&#39;).
    #' @param rowStart integer. start index of row for slicing the confusion matrix.
    #' @param rowEnd integer. end index of row for slicing the confusion matrix.
    #' @param colStart integer. start index of column for slicing the confusion matrix.
    #' @param colEnd integer. end index of column for slicing the confusion matrix.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelConfusionChartRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The confusion chart data from a single source.
    #' \itemize{
    #' }
    #' \item **`404`** No confusion chart for source.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid indices for confusion matrix.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data
    #' orderBy <- "className" # character | Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy='-predictedCount'
    #' orientation <- "actual" # character | Determines whether the values in the rows of the confusion matrix should correspond to the same actual class ('actual') or predicted class ('predicted').
    #' rowStart <- 56 # integer | start index of row for slicing the confusion matrix.
    #' rowEnd <- 56 # integer | end index of row for slicing the confusion matrix.
    #' colStart <- 56 # integer | start index of column for slicing the confusion matrix.
    #' colEnd <- 56 # integer | end index of column for slicing the confusion matrix.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsConfusionChartsRetrieve(projectId, modelId, source, orderBy=orderBy, orientation=orientation, rowStart=rowStart, rowEnd=rowEnd, colStart=colStart, colEnd=colEnd)
    #' }
    ProjectsModelsConfusionChartsRetrieve = function(projectId, modelId, source, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, ...) {
      apiResponse <- private$ProjectsModelsConfusionChartsRetrieveWithHttpInfo(projectId, modelId, source, orderBy, orientation, rowStart, rowEnd, colStart, colEnd, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start Cross Class Accuracy calculations.
    #' Produces: "application/json"
    #'
    #' @details Submits a job to start Cross Class Accuracy scores calculations for the model.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/crossClassAccuracyScores/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CrossClassAccuracyCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsCrossClassAccuracyScoresCreate(projectId, modelId)
    #' }
    ProjectsModelsCrossClassAccuracyScoresCreate = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsCrossClassAccuracyScoresCreateWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List Cross Class Accuracy scores.
    #' Produces: "application/json"
    #'
    #' @details Retrieves a list of Cross Class Accuracy scores for the model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/crossClassAccuracyScores/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of items to skip. Defaults to 0 if not provided.
    #' @param limit integer. Number of items to return, defaults to 100 if not provided.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CrossClassAccuracyList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns Cross Class Accuracy scores.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of items to skip. Defaults to 0 if not provided.
    #' limit <- 100 # integer | Number of items to return, defaults to 100 if not provided.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsCrossClassAccuracyScoresList(projectId, modelId, offset=offset, limit=limit)
    #' }
    ProjectsModelsCrossClassAccuracyScoresList = function(projectId, modelId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsModelsCrossClassAccuracyScoresListWithHttpInfo(projectId, modelId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start insight calculations.
    #' Produces: "application/json"
    #'
    #' @details Submits a job to start Cross Class Data Disparity insight calculations.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/dataDisparityInsights/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param dataDisparityCreatePayload \link{DataDisparityCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataDisparityCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' dataDisparityCreatePayload <- DataDisparityCreatePayload$new() # DataDisparityCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDataDisparityInsightsCreate(projectId, modelId, dataDisparityCreatePayload=dataDisparityCreatePayload)
    #' }
    ProjectsModelsDataDisparityInsightsCreate = function(projectId, modelId, dataDisparityCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsModelsDataDisparityInsightsCreateWithHttpInfo(projectId, modelId, dataDisparityCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get Cross Class Data Disparity results.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of Cross Class Data Disparity insights for the model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/dataDisparityInsights/` in the DataRobot Public API.
    #' @param feature character. Feature for which insight is computed.
    #' @param className1 character. One of the compared classes.
    #' @param className2 character. Another compared class.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of items to skip. Defaults to 0 if not provided.
    #' @param limit integer. Number of items to return, defaults to 100 if not provided.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DataDisparityRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns Cross Class Data Disparity results.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' feature <- 'feature_example' # character | Feature for which insight is computed.
    #' className1 <- 'className1_example' # character | One of the compared classes.
    #' className2 <- 'className2_example' # character | Another compared class.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of items to skip. Defaults to 0 if not provided.
    #' limit <- 100 # integer | Number of items to return, defaults to 100 if not provided.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDataDisparityInsightsList(feature, className1, className2, projectId, modelId, offset=offset, limit=limit)
    #' }
    ProjectsModelsDataDisparityInsightsList = function(feature, className1, className2, projectId, modelId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsModelsDataDisparityInsightsListWithHttpInfo(feature, className1, className2, projectId, modelId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Calculate and sends frequency of class in distributed among other classes for actual and predicted data.
    #' Produces: "application/json"
    #'
    #' @details Calculate and sends frequency of class in distributed among other classes for actual and predicted data. A confusion chart class details for given class gives stats of misclassification done by model for given class for actual and predicted data. Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/classDetails/` in the DataRobot Public API.
    #' @param className character. Name of a class for which distribution frequency is requested.
    #' @param projectId character. The project to retrieve a Confusion chart from.
    #' @param modelId character. The model to retrieve a Confusion chart from.
    #' @param datasetId character. The dataset to retrieve a Confusion chart from.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelConfusionChartClassDetailsForDatasetRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A confusion chart class details for given class.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' className <- 'className_example' # character | Name of a class for which distribution frequency is requested.
    #' projectId <- 'projectId_example' # character | The project to retrieve a Confusion chart from.
    #' modelId <- 'modelId_example' # character | The model to retrieve a Confusion chart from.
    #' datasetId <- 'datasetId_example' # character | The dataset to retrieve a Confusion chart from.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetConfusionChartsClassDetailsList(className, projectId, modelId, datasetId)
    #' }
    ProjectsModelsDatasetConfusionChartsClassDetailsList = function(className, projectId, modelId, datasetId, ...) {
      apiResponse <- private$ProjectsModelsDatasetConfusionChartsClassDetailsListWithHttpInfo(className, projectId, modelId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List of Confusion Charts objects on external datasets for a project with filtering option by dataset.
    #' Produces: "application/json"
    #'
    #' @details List of Confusion Charts objects on external datasets for a project with filtering option by dataset. Prediction dataset may have Confusion Chart for multiclass projects computed if it contained a target with actual values and insights were computed on this dataset. A confusion chart consists of the confusion matrix for all classes, classes frequencies and oneVsAll metrics for all classes. The confusion matrix can be requested in a particular sort order and orientated by rows or columns. Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetConfusionCharts/` in the DataRobot Public API.
    #' @param projectId character. The project to retrieve a Confusion chart from.
    #' @param modelId character. The model to retrieve a Confusion chart from.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param orderBy Enum < [className, -className, actualCount, -actualCount, predictedCount, -predictedCount, f1, -f1] > Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;&#39;-predictedCount&#39;
    #' @param orientation Enum < [actual, -actual, predicted, -predicted] > Determines whether the values in the rows of the confusion matrix should correspond to the same actual class (&#39;actual&#39;) or predicted class (&#39;predicted&#39;).
    #' @param rowStart integer. start index of row for slicing the confusion matrix.
    #' @param rowEnd integer. end index of row for slicing the confusion matrix.
    #' @param colStart integer. start index of column for slicing the confusion matrix.
    #' @param colEnd integer. end index of column for slicing the confusion matrix.
    #' @param datasetId character. The datasetId to retrieve a Confusion chart from.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ConfusionChartForDatasetsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of Confusion Charts objects for external datasets.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve a Confusion chart from.
    #' modelId <- 'modelId_example' # character | The model to retrieve a Confusion chart from.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' orderBy <- "className" # character | Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy='-predictedCount'
    #' orientation <- "actual" # character | Determines whether the values in the rows of the confusion matrix should correspond to the same actual class ('actual') or predicted class ('predicted').
    #' rowStart <- 56 # integer | start index of row for slicing the confusion matrix.
    #' rowEnd <- 56 # integer | end index of row for slicing the confusion matrix.
    #' colStart <- 56 # integer | start index of column for slicing the confusion matrix.
    #' colEnd <- 56 # integer | end index of column for slicing the confusion matrix.
    #' datasetId <- 'datasetId_example' # character | The datasetId to retrieve a Confusion chart from.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetConfusionChartsList(projectId, modelId, offset=offset, limit=limit, orderBy=orderBy, orientation=orientation, rowStart=rowStart, rowEnd=rowEnd, colStart=colStart, colEnd=colEnd, datasetId=datasetId)
    #' }
    ProjectsModelsDatasetConfusionChartsList = function(projectId, modelId, offset = 0, limit = 100, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, datasetId = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetConfusionChartsListWithHttpInfo(projectId, modelId, offset, limit, orderBy, orientation, rowStart, rowEnd, colStart, colEnd, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve metadata for the confusion chart of a model on external dataset for a project.
    #' Produces: "application/json"
    #'
    #' @details Retrieve metadata for the confusion chart of a model on external dataset for a project. Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/metadata/` in the DataRobot Public API.
    #' @param projectId character. The project to retrieve a Confusion chart from.
    #' @param modelId character. The model to retrieve a Confusion chart from.
    #' @param datasetId character. The dataset to retrieve a Confusion chart from.
    #' @param orderBy Enum < [className, -className, actualCount, -actualCount, predictedCount, -predictedCount, f1, -f1] > Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;&#39;-predictedCount&#39;
    #' @param orientation Enum < [actual, -actual, predicted, -predicted] > Determines whether the values in the rows of the confusion matrix should correspond to the same actual class (&#39;actual&#39;) or predicted class (&#39;predicted&#39;).
    #' @param thumbnailCellSize integer. Number of classes in a single &#39;thumbnail&#39; cell.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ConfusionChartRetrieveMetadataForDatasets}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve metadata for the Confusion Chart objects on external datasets.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve a Confusion chart from.
    #' modelId <- 'modelId_example' # character | The model to retrieve a Confusion chart from.
    #' datasetId <- 'datasetId_example' # character | The dataset to retrieve a Confusion chart from.
    #' orderBy <- "className" # character | Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy='-predictedCount'
    #' orientation <- "actual" # character | Determines whether the values in the rows of the confusion matrix should correspond to the same actual class ('actual') or predicted class ('predicted').
    #' thumbnailCellSize <- 10 # integer | Number of classes in a single 'thumbnail' cell.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetConfusionChartsMetadataList(projectId, modelId, datasetId, orderBy=orderBy, orientation=orientation, thumbnailCellSize=thumbnailCellSize)
    #' }
    ProjectsModelsDatasetConfusionChartsMetadataList = function(projectId, modelId, datasetId, orderBy = "className", orientation = "actual", thumbnailCellSize = 10, ...) {
      apiResponse <- private$ProjectsModelsDatasetConfusionChartsMetadataListWithHttpInfo(projectId, modelId, datasetId, orderBy, orientation, thumbnailCellSize, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Confusion Chart objects on external datasets for a project.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Confusion Chart objects on external datasets for a project. Prediction dataset may have Confusion Chart for multiclass projects computed if it contained a target with actual values and insights were computed on this dataset. A confusion chart consists of the confusion matrix for all classes, classes frequencies and oneVsAll metrics for all classes. The confusion matrix can be requested in a particular sort order and oriented by rows or columns (zero-indexed). Available for multiclass projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/` in the DataRobot Public API.
    #' @param projectId character. The project to retrieve a Confusion chart from.
    #' @param modelId character. The model to retrieve a Confusion chart from.
    #' @param datasetId character. The dataset to retrieve a Confusion chart from.
    #' @param orderBy Enum < [className, -className, actualCount, -actualCount, predictedCount, -predictedCount, f1, -f1] > Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy&#x3D;&#39;-predictedCount&#39;
    #' @param orientation Enum < [actual, -actual, predicted, -predicted] > Determines whether the values in the rows of the confusion matrix should correspond to the same actual class (&#39;actual&#39;) or predicted class (&#39;predicted&#39;).
    #' @param rowStart integer. start index of row for slicing the confusion matrix.
    #' @param rowEnd integer. end index of row for slicing the confusion matrix.
    #' @param colStart integer. start index of column for slicing the confusion matrix.
    #' @param colEnd integer. end index of column for slicing the confusion matrix.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ConfusionChartRetrieveForDatasets}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve Confusion Chart objects on external datasets.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve a Confusion chart from.
    #' modelId <- 'modelId_example' # character | The model to retrieve a Confusion chart from.
    #' datasetId <- 'datasetId_example' # character | The dataset to retrieve a Confusion chart from.
    #' orderBy <- "className" # character | Ordering the chart data by following attributes.Prefix the attribute name with a dash to sort in descending order, e.g. orderBy='-predictedCount'
    #' orientation <- "actual" # character | Determines whether the values in the rows of the confusion matrix should correspond to the same actual class ('actual') or predicted class ('predicted').
    #' rowStart <- 56 # integer | start index of row for slicing the confusion matrix.
    #' rowEnd <- 56 # integer | end index of row for slicing the confusion matrix.
    #' colStart <- 56 # integer | start index of column for slicing the confusion matrix.
    #' colEnd <- 56 # integer | end index of column for slicing the confusion matrix.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetConfusionChartsRetrieve(projectId, modelId, datasetId, orderBy=orderBy, orientation=orientation, rowStart=rowStart, rowEnd=rowEnd, colStart=colStart, colEnd=colEnd)
    #' }
    ProjectsModelsDatasetConfusionChartsRetrieve = function(projectId, modelId, datasetId, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetConfusionChartsRetrieveWithHttpInfo(projectId, modelId, datasetId, orderBy, orientation, rowStart, rowEnd, colStart, colEnd, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve List of Lift chart data on prediction datasets for a project.
    #' Produces: "application/json"
    #'
    #' @details List of Lift chart objects on prediction datasets for a project with filtering option by dataset. Prediction dataset may have Lift chart computed if it contained a column with actual values and predictions were computed on this dataset. This controller is not supported for multiclass classification projects. For multiclass, instead use /projects/\\&lt;projectId\\&gt;/models/\\&lt;modelId\\&gt;/datasetMulticlassLiftCharts/.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetLiftCharts/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param datasetId character. If provided will return Lift chart for dataset with matching datasetId.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{LiftChartForDatasetsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve List of Lift chart data on prediction datasets.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' datasetId <- 'datasetId_example' # character | If provided will return Lift chart for dataset with matching datasetId.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetLiftChartsList(projectId, modelId, offset=offset, limit=limit, datasetId=datasetId)
    #' }
    ProjectsModelsDatasetLiftChartsList = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetLiftChartsListWithHttpInfo(projectId, modelId, offset, limit, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve List of Multiclass Lift chart data on prediction datasets for a project.
    #' Produces: "application/json"
    #'
    #' @details List of Multiclass Lift chart objects on prediction datasets for a project with filtering option by dataset. Prediction dataset may have Multiclass Lift chart computed if it contained a column with actual values and predictions were computed on this dataset. Multiclass Lift charts are supported for multiclass classification projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetMulticlassLiftCharts/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param datasetId character. If provided will return Lift chart for dataset with matching datasetId.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticlassLiftChartForDatasetsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve List of Multiclass Lift chart data on prediction datasets.
    #' \itemize{
    #' }
    #' \item **`404`** No insights found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' datasetId <- 'datasetId_example' # character | If provided will return Lift chart for dataset with matching datasetId.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetMulticlassLiftChartsList(projectId, modelId, offset=offset, limit=limit, datasetId=datasetId)
    #' }
    ProjectsModelsDatasetMulticlassLiftChartsList = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetMulticlassLiftChartsListWithHttpInfo(projectId, modelId, offset, limit, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List of residuals charts objects on prediction datasets.
    #' Produces: "application/json"
    #'
    #' @details List of residuals charts objects on prediction datasets for a project with filtering option by dataset. Prediction dataset may have residuals chart computed if it contained a column with actual values and predictions were computed on this dataset. Residuals charts are supported for regression projects only.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetResidualsCharts/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param datasetId character. If provided will return ROC curve for dataset with matching &#x60;datasetId&#x60;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ResidualsChartForDatasetsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' datasetId <- 'datasetId_example' # character | If provided will return ROC curve for dataset with matching `datasetId`.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetResidualsChartsList(projectId, modelId, offset=offset, limit=limit, datasetId=datasetId)
    #' }
    ProjectsModelsDatasetResidualsChartsList = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetResidualsChartsListWithHttpInfo(projectId, modelId, offset, limit, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List of ROC curve objects on prediction datasets for a project with filtering option by dataset.
    #' Produces: "application/json"
    #'
    #' @details List of ROC curve objects on prediction datasets for a project with filtering option by dataset.  Prediction dataset may have ROC curve computed if it contained a column with actual values and predictions were computed on this dataset. Each ROC curve object includes an array of points showing the performance of the model at different thresholds for classification, and arrays of sample predictions for both the positive and negative classes.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/datasetRocCurves/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param datasetId character. If provided will return ROC curve for dataset with matching &#x60;datasetId&#x60;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RocCurveForDatasetsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Objects were returned successfully. No objects is a valid case.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' datasetId <- 'datasetId_example' # character | If provided will return ROC curve for dataset with matching `datasetId`.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsDatasetRocCurvesList(projectId, modelId, offset=offset, limit=limit, datasetId=datasetId)
    #' }
    ProjectsModelsDatasetRocCurvesList = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      apiResponse <- private$ProjectsModelsDatasetRocCurvesListWithHttpInfo(projectId, modelId, offset, limit, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start insight calculations.
    #' Produces: "application/json"
    #'
    #' @details Submits a job to start Per Class Bias insight calculations for the model.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/fairnessInsights/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param fairnessInsightsStartCalculationPayload \link{FairnessInsightsStartCalculationPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FairnessInsightsStartCalculationResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' fairnessInsightsStartCalculationPayload <- FairnessInsightsStartCalculationPayload$new() # FairnessInsightsStartCalculationPayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFairnessInsightsCreate(projectId, modelId, fairnessInsightsStartCalculationPayload=fairnessInsightsStartCalculationPayload)
    #' }
    ProjectsModelsFairnessInsightsCreate = function(projectId, modelId, fairnessInsightsStartCalculationPayload = NULL, ...) {
      apiResponse <- private$ProjectsModelsFairnessInsightsCreateWithHttpInfo(projectId, modelId, fairnessInsightsStartCalculationPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List calculated Per Class Bias insights.
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of Per Class Bias insights for the model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/fairnessInsights/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param offset integer. Number of items to skip. Defaults to 0 if not provided.
    #' @param limit integer. Number of items to return, defaults to 100 if not provided.
    #' @param fairnessMetricsSet Enum < [proportionalParity, equalParity, predictionBalance, trueFavorableAndUnfavorableRateParity, favorableAndUnfavorablePredictiveValueParity] > Metric to use for calculating fairness. Can be one of &#x60;&#x60;proportionalParity&#x60;&#x60;, &#x60;&#x60;equalParity&#x60;&#x60;, &#x60;&#x60;predictionBalance&#x60;&#x60;, &#x60;&#x60;trueFavorableAndUnfavorableRateParity&#x60;&#x60; or &#x60;&#x60;FavorableAndUnfavorablePredictiveValueParity&#x60;&#x60;. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FairnessInsightsListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Returns Per Class Bias results.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' offset <- 0 # integer | Number of items to skip. Defaults to 0 if not provided.
    #' limit <- 100 # integer | Number of items to return, defaults to 100 if not provided.
    #' fairnessMetricsSet <- 'fairnessMetricsSet_example' # character | Metric to use for calculating fairness. Can be one of ``proportionalParity``, ``equalParity``, ``predictionBalance``, ``trueFavorableAndUnfavorableRateParity`` or ``FavorableAndUnfavorablePredictiveValueParity``. Used and required only if *Bias & Fairness in AutoML* feature is enabled.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFairnessInsightsList(projectId, modelId, offset=offset, limit=limit, fairnessMetricsSet=fairnessMetricsSet)
    #' }
    ProjectsModelsFairnessInsightsList = function(projectId, modelId, offset = 0, limit = 100, fairnessMetricsSet = NULL, ...) {
      apiResponse <- private$ProjectsModelsFairnessInsightsListWithHttpInfo(projectId, modelId, offset, limit, fairnessMetricsSet, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add a request to the queue to calculate Feature Effects.
    #' Produces: NA
    #'
    #' @details Add a request to the queue to calculate Feature Effects. If the job has been previously submitted, the request fails, returning the jobId of the previously submitted job. Use this jobId to check status of the previously submitted job.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/featureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param featureEffectCreate \link{FeatureEffectCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Effects request has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Provided project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error.  .. minversion:: v2.21      If the rowCount exceeds the maximum or minimum value for this dataset. Minimum     is 10 rows. Maximum is 100000 rows or the training sample size of the model,     whichever is less.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' featureEffectCreate <- FeatureEffectCreate$new() # FeatureEffectCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureEffectsCreate(projectId, modelId, featureEffectCreate=featureEffectCreate)
    #' }
    ProjectsModelsFeatureEffectsCreate = function(projectId, modelId, featureEffectCreate = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureEffectsCreateWithHttpInfo(projectId, modelId, featureEffectCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Effects for the model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Feature Effects for the model. Feature Effects provides partial dependence and predicted vs actual values for the top 500 features, ordered by feature impact score. The partial dependence shows marginal effect of a feature on the target variable after accounting for the average effects of all other predictive features. It indicates how, holding all other variables except the feature of interest as they were, the value of this feature affects your prediction. If a Feature Effects job was previously submitted, this endpoint will return a response structured as {\&quot;message\&quot;: \\&lt;message\\&gt;, \&quot;jobId\&quot;: \\&lt;jobId\\&gt;} where jobId is the ID of the job. Retrieve the job with :&lt;http:get&gt;:/api/v2/projects/(projectId)/jobs/(jobId)/
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureEffectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureEffectsList(projectId, modelId, source=source, includeIcePlots=includeIcePlots)
    #' }
    ProjectsModelsFeatureEffectsList = function(projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureEffectsListWithHttpInfo(projectId, modelId, source, includeIcePlots, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Effects metadata. Response contains status and available sources.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Feature Effects metadata. Response contains status and available sources. One of the provided source parameters used for retrieving Feature Effects. \\* Source can be, at a minimum, training or validation. If holdout is configured for the project, source also includes holdout. \\* Source value of training is always available. (versions prior to v2.17 support validation only) \\* When a model is trained into validation or holdout without stacked predictions (i.e., no out-of-sample predictions in validation or holdout), validation and holdout sources are not available.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureEffectsMetadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelXrayMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** The model is datetime partitioned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureEffectsMetadataList(projectId, modelId)
    #' }
    ProjectsModelsFeatureEffectsMetadataList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsFeatureEffectsMetadataListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add a request to the queue to calculate Feature Fit.
    #' Produces: NA
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Add a request to the queue to calculate Feature Fit. If the job has been previously submitted, the request fails, returning the jobId of the previously submitted job. Use this jobId to check status of the previously submitted job.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/featureFit/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Effects request has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Provided project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureFitCreate(projectId, modelId)
    #' }
    ProjectsModelsFeatureFitCreate = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsFeatureFitCreateWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Fit for the model.
    #' Produces: "application/json"
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Retrieve Feature Fit for the model. Feature Fit provides partial dependence and predicted vs actual values for the top 500 features, ordered by feature importance score. The partial dependence shows marginal effect of a feature on the target variable after accounting for the average effects of all other predictive features. It indicates how, holding all other variables except the feature of interest as they were, the value of this feature affects your prediction. If a Feature Fit job was previously submitted, this endpoint will return a response structured as {\&quot;message\&quot;: \\&lt;message\\&gt;, \&quot;jobId\&quot;: \\&lt;jobId\\&gt;} where jobId is the ID of the job. Retrieve the job with :&lt;http:get&gt;:/api/v2/projects/(projectId)/jobs/(jobId)/
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureFit/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureFitResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureFitList(projectId, modelId, source=source, includeIcePlots=includeIcePlots)
    #' }
    ProjectsModelsFeatureFitList = function(projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureFitListWithHttpInfo(projectId, modelId, source, includeIcePlots, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Fit metadata. Response contains status and available sources.
    #' Produces: "application/json"
    #'
    #' @details NOTE: Starting from API v2.29 this endpoint will be deprecated. Retrieve Feature Fit metadata. Response contains status and available sources. One of the provided source parameters used for retrieving Feature Fit. \\* Source can be, at a minimum, training or validation. If holdout is configured for the project, source also includes holdout. \\* Source value of training is always available.(versions prior to v2.17 support validation only) \\* When a model is trained into validation or holdout without stacked predictions (i.e., no out-of-sample predictions in validation or holdout), validation and holdout sources are not available.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureFitMetadata/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelXrayMetadataResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project or model does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** The model is datetime partitioned.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureFitMetadataList(projectId, modelId)
    #' }
    ProjectsModelsFeatureFitMetadataList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsFeatureFitMetadataListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add a request to calculate feature impact to the queue.
    #' Produces: NA
    #'
    #' @details Add a request to calculate feature impact to the queue. If the job has been previously submitted, the request will fail and return the jobId of previously submitted job. This jobId can be used to check status of previously submitted job.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/featureImpact/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param permutationFeatureImpactCreatePayload \link{PermutationFeatureImpactCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`404`** If &#x60;modelId&#x60; does not exist in project leaderboard
    #' \itemize{
    #' }
    #' \item **`422`** If feature impact has already run will return error including &#x60;jobId&#x60; property which is the &#x60;jobId&#x60; of the previously started feature impact job.  .. minversion:: v2.21  If the &#x60;rowCount&#x60; exceeds the maximum or minimum value for this dataset. Minimum is 10 rows. Maximum is 100000 rows or the training sample size of the model, whichever is less.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' permutationFeatureImpactCreatePayload <- PermutationFeatureImpactCreatePayload$new() # PermutationFeatureImpactCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureImpactCreate(projectId, modelId, permutationFeatureImpactCreatePayload=permutationFeatureImpactCreatePayload)
    #' }
    ProjectsModelsFeatureImpactCreate = function(projectId, modelId, permutationFeatureImpactCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureImpactCreateWithHttpInfo(projectId, modelId, permutationFeatureImpactCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature impact scores for features in a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature impact scores for features in a model. Feature Impact is computed for each column by creating new data with that column randomly permuted (but the others left unchanged), and seeing how the error metric score for the predictions is affected. Elsewhere this technique is sometimes called &#39;Permutation Importance&#39;. The impactUnnormalized is how much worse the error metric score is when making predictions on this modified data. The impactNormalized is normalized so that the largest value is 1. In both cases, larger values indicate more important features. If a feature is a redundant feature, i.e. once other features are considered it doesn&#39;t contribute much in addition, the redundantWith value is the name of feature that has the highest correlation with this feature.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureImpact/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param backtest \link{OneOfintegerstring}. The backtest value used for Feature Impact computation. Applicable for datetime aware models.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PermutationFeatureImpactResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** No feature impact data found for the given model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' backtest <- 'backtest_example' # OneOfintegerstring | The backtest value used for Feature Impact computation. Applicable for datetime aware models.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureImpactList(projectId, modelId, backtest=backtest)
    #' }
    ProjectsModelsFeatureImpactList = function(projectId, modelId, backtest = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureImpactListWithHttpInfo(projectId, modelId, backtest, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Cluster Insights for a single featurelist
    #' Produces: "application/json"
    #'
    #' @details Retrieve computed Cluster Insights for a clustering project model on a single featurelist.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/featureLists/{datasetId}/clusterInsights/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param datasetId character. The dataset ID
    #' @param offset integer. Number of results to skip.
    #' @param orderBy Enum < [featureImpact, -featureImpact, featureName, -featureName] > Order results by the specified field value.
    #' @param searchFor character. Search for a specific string in a feature name.This search is case insensitive. If not specified, all features will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ClusterInsightsPaginatedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Insights for a clustering project model on a single featurelist.
    #' \itemize{
    #' }
    #' \item **`404`** The project or the model was not found or insights have not been computed yet.
    #' \itemize{
    #' }
    #' \item **`422`** Feature Impact is required. Please, compute it first.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 15 # integer | At most this many results are returned. The default may change without notice.
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' datasetId <- 'datasetId_example' # character | The dataset ID
    #' offset <- 0 # integer | Number of results to skip.
    #' orderBy <- 'orderBy_example' # character | Order results by the specified field value.
    #' searchFor <- 'searchFor_example' # character | Search for a specific string in a feature name.This search is case insensitive. If not specified, all features will be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsFeatureListsClusterInsightsList(limit, projectId, modelId, datasetId, offset=offset, orderBy=orderBy, searchFor=searchFor)
    #' }
    ProjectsModelsFeatureListsClusterInsightsList = function(limit, projectId, modelId, datasetId, offset = 0, orderBy = NULL, searchFor = NULL, ...) {
      apiResponse <- private$ProjectsModelsFeatureListsClusterInsightsListWithHttpInfo(limit, projectId, modelId, datasetId, offset, orderBy, searchFor, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Request the computation of image activation maps for the specified model.
    #' Produces: "application/json"
    #'
    #' @details Request the computation of image activation maps for the specified model.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/imageActivationMaps/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ActivationMapsComputeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Image activation map computation has been successfully requested
    #' \itemize{
    #' \item **`Location`** a url that can be polled to check the status of the job.
    #' }
    #' \item **`422`** Cannot compute image activation maps: if image activation maps were already computed for the model or there was another issue creating this job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsImageActivationMapsCreate(projectId, modelId)
    #' }
    ProjectsModelsImageActivationMapsCreate = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsImageActivationMapsCreateWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Image Activation Maps for a feature of a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Image Activation Maps for a feature of a model. Image Activation maps are a technique to get the discriminative image regions used by a CNN to identify a specific class in the image. In other words, an image activation map lets us see which regions in the image were relevant to this class. The higher the value in the activation map the greater the effect the region had on the prediction.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/imageActivationMaps/` in the DataRobot Public API.
    #' @param featureName character. Name of the feature to query
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ActivationMapsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Image Activation Maps
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' featureName <- 'featureName_example' # character | Name of the feature to query
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsImageActivationMapsList(featureName, projectId, modelId)
    #' }
    ProjectsModelsImageActivationMapsList = function(featureName, projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsImageActivationMapsListWithHttpInfo(featureName, projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Request the computation of image embeddings for the specified model.
    #' Produces: "application/json"
    #'
    #' @details Request the computation of image embeddings for the specified model.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/imageEmbeddings/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ImageEmbeddingsComputeResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Image embedding computation has been successfully requested
    #' \itemize{
    #' \item **`Location`** a url that can be polled to check the status of the job.
    #' }
    #' \item **`422`** Cannot compute image embeddings: if image embeddings were already computed for the model or there was another issue creating this job
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsImageEmbeddingsCreate(projectId, modelId)
    #' }
    ProjectsModelsImageEmbeddingsCreate = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsImageEmbeddingsCreateWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve ImageEmbeddings for a feature of a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve ImageEmbeddings for a feature of a model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/imageEmbeddings/` in the DataRobot Public API.
    #' @param featureName character. Name of the feature to query
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{EmbeddingsRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Image Embeddings
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' featureName <- 'featureName_example' # character | Name of the feature to query
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsImageEmbeddingsList(featureName, projectId, modelId)
    #' }
    ProjectsModelsImageEmbeddingsList = function(featureName, projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsImageEmbeddingsListWithHttpInfo(featureName, projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve labelwise ROC curves for model and given source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve labelwise ROC curves for model and given source.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/labelwiseRocCurves/{source}/` in the DataRobot Public API.
    #' @param projectId character. Project Id.
    #' @param modelId character. Model Id.
    #' @param source Enum < [validation, crossValidation, holdout] > Chart source.
    #' @param labels character. Labels for which data is requested.
    #' @param searchQuery character. Search query for label.
    #' @param sortBy Enum < [accuracy, f1Score, falsePositiveRate, label, matthewsCorrelationCoefficient, negativePredictiveValue, positivePredictiveValue, trueNegativeRate, truePositiveRate] > Property to sort labels in the response.
    #' @param sortOrder Enum < [ascending, descending] > Sort order.
    #' @param threshold numeric. Threshold at which the metric should be sorted.
    #' @param offset integer. Number of labels to skip.
    #' @param limit integer. Number of labels to return.
    #' @param includeModelAverage character. Whether model average metrics should be included in the response.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{LabelwiseROC}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Labelwise ROC curves for model and given source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | Project Id.
    #' modelId <- 'modelId_example' # character | Model Id.
    #' source <- 'source_example' # character | Chart source.
    #' labels <- 'labels_example' # character | Labels for which data is requested.
    #' searchQuery <- 'searchQuery_example' # character | Search query for label.
    #' sortBy <- "label" # character | Property to sort labels in the response.
    #' sortOrder <- "ascending" # character | Sort order.
    #' threshold <- 3.4 # numeric | Threshold at which the metric should be sorted.
    #' offset <- 0 # integer | Number of labels to skip.
    #' limit <- 100 # integer | Number of labels to return.
    #' includeModelAverage <- FALSE # character | Whether model average metrics should be included in the response.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsLabelwiseRocCurvesList(projectId, modelId, source, labels=labels, searchQuery=searchQuery, sortBy=sortBy, sortOrder=sortOrder, threshold=threshold, offset=offset, limit=limit, includeModelAverage=includeModelAverage)
    #' }
    ProjectsModelsLabelwiseRocCurvesList = function(projectId, modelId, source, labels = NULL, searchQuery = NULL, sortBy = "label", sortOrder = "ascending", threshold = NULL, offset = 0, limit = 100, includeModelAverage = FALSE, ...) {
      apiResponse <- private$ProjectsModelsLabelwiseRocCurvesListWithHttpInfo(projectId, modelId, source, labels, searchQuery, sortBy, sortOrder, threshold, offset, limit, includeModelAverage, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all available lift charts for model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all available lift charts for model. The response will include a json list of all available lift charts, in the same format as the response from :&lt;http:get&gt;:/api/v2/projects/(projectId)/models/(modelId)/liftChart/(source)/.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/liftChart/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelLiftChartListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of all of the available lift charts for a model.
    #' \itemize{
    #' }
    #' \item **`403`** Invalid Permissions
    #' \itemize{
    #' }
    #' \item **`404`** Please use multiclass lift route for per-class lift data.
    #' \itemize{
    #' }
    #' \item **`422`** Lift chart is not available for unsupervised mode projects.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsLiftChartList(projectId, modelId)
    #' }
    ProjectsModelsLiftChartList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsLiftChartListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the lift chart data from a single source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the lift chart data from a single source.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/liftChart/{source}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [backtest_18, backtest_10, backtest_11, backtest_14, backtest_3, backtest_15, holdout, backtest_5, backtest_16, crossValidation, backtest_2, backtest_12, backtest_20, backtest_17, validation, backtest_6, backtest_4, backtest_13, backtest_9, backtest_19, backtest_8, backtest_7] > Source of the data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelLiftChartResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Lift chart data from a single source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsLiftChartRetrieve(projectId, modelId, source)
    #' }
    ProjectsModelsLiftChartRetrieve = function(projectId, modelId, source, ...) {
      apiResponse <- private$ProjectsModelsLiftChartRetrieveWithHttpInfo(projectId, modelId, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Compute feature effects for a multiclass model.
    #' Produces: NA
    #'
    #' @details Compute feature effects for a multiclass model. If the job has been previously submitted, the request fails, returning the jobId of the previously submitted job. Use this jobId to check status of the previously submitted job. NOTE: feature effects are computed for top 100 classes.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/multiclassFeatureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param multiclassFeatureEffectCreate \link{MulticlassFeatureEffectCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The Feature Effects request has been successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have permission to view or submit jobs for the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Queue submission error. If the rowCount exceeds the maximum or minimum value for this dataset. Minimum is 10 rows. Maximum is 100000 rows or the training sample size of the model, whichever is less. If neither &#x60;&#x60;features&#x60;&#x60; nor &#x60;&#x60;topNFeatures&#x60;&#x60; is provided.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' multiclassFeatureEffectCreate <- MulticlassFeatureEffectCreate$new() # MulticlassFeatureEffectCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMulticlassFeatureEffectsCreate(projectId, modelId, multiclassFeatureEffectCreate=multiclassFeatureEffectCreate)
    #' }
    ProjectsModelsMulticlassFeatureEffectsCreate = function(projectId, modelId, multiclassFeatureEffectCreate = NULL, ...) {
      apiResponse <- private$ProjectsModelsMulticlassFeatureEffectsCreateWithHttpInfo(projectId, modelId, multiclassFeatureEffectCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature effects for each class in a multiclass model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature effects for each class in a multiclass model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/multiclassFeatureEffects/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [training, validation, holdout] > Models data source.
    #' @param includeIcePlots Enum < [false, False, true, True] > Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param class character. Target class label.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticlassFeatureEffectsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to view the project.
    #' \itemize{
    #' }
    #' \item **`404`** Project, model, source or computation results do not exist.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- "training" # character | Models data source.
    #' includeIcePlots <- 'includeIcePlots_example' # character | Indicates whether Individual Conditional Expectation (ICE) plots should be returned.
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #' class <- 'class_example' # character | Target class label.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMulticlassFeatureEffectsList(projectId, modelId, source=source, includeIcePlots=includeIcePlots, offset=offset, limit=limit, class=class)
    #' }
    ProjectsModelsMulticlassFeatureEffectsList = function(projectId, modelId, source = "training", includeIcePlots = NULL, offset = 0, limit = 100, class = NULL, ...) {
      apiResponse <- private$ProjectsModelsMulticlassFeatureEffectsListWithHttpInfo(projectId, modelId, source, includeIcePlots, offset, limit, class, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve feature impact scores for each class in a multiclass model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve feature impact scores for each class in a multiclass model. Feature Impact is computed for each column by creating new data with that column randomly permuted (but the others left unchanged), and seeing how the error metric score for the predictions is affected. Elsewhere this technique is sometimes called &#39;Permutation Importance&#39;. The impactUnnormalized is how much worse the error metric score is when making predictions on this modified data. The impactNormalized is normalized so that the largest value is 1. In both cases, larger values indicate more important features.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/multiclassFeatureImpact/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticlassFeatureImpactResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** If no feature impact data found for a given model.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMulticlassFeatureImpactList(projectId, modelId)
    #' }
    ProjectsModelsMulticlassFeatureImpactList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsMulticlassFeatureImpactListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all available lift charts for multiclass model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all available lift charts for multiclass model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/multiclassLiftChart/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AllMulticlassModelLiftChartsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Multiclass lift chart data.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMulticlassLiftChartList(projectId, modelId)
    #' }
    ProjectsModelsMulticlassLiftChartList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsMulticlassLiftChartListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the multiclass lift chart data from a single source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the multiclass lift chart data from a single source.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/multiclassLiftChart/{source}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [validation, crossValidation, holdout] > Source of the data.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticlassModelLiftChartResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Multiclass lift chart data from a single source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMulticlassLiftChartRetrieve(projectId, modelId, source)
    #' }
    ProjectsModelsMulticlassLiftChartRetrieve = function(projectId, modelId, source, ...) {
      apiResponse <- private$ProjectsModelsMulticlassLiftChartRetrieveWithHttpInfo(projectId, modelId, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve labelwise lift charts for model and given source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve labelwise lift charts for model and given source.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/multilabelLiftCharts/{source}/` in the DataRobot Public API.
    #' @param projectId character. Project Id.
    #' @param modelId character. Model Id.
    #' @param source Enum < [validation, crossValidation, holdout] > Chart source.
    #' @param labels character. Labels for which data is requested.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{LabelwiseLiftChart}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Labelwise lift charts for model and given source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | Project Id.
    #' modelId <- 'modelId_example' # character | Model Id.
    #' source <- 'source_example' # character | Chart source.
    #' labels <- 'labels_example' # character | Labels for which data is requested.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsMultilabelLiftChartsRetrieve(projectId, modelId, source, labels=labels)
    #' }
    ProjectsModelsMultilabelLiftChartsRetrieve = function(projectId, modelId, source, labels = NULL, ...) {
      apiResponse <- private$ProjectsModelsMultilabelLiftChartsRetrieveWithHttpInfo(projectId, modelId, source, labels, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new prediction explanations initialization.
    #' Produces: NA
    #'
    #' @details Create a new prediction explanations initialization. This is a necessary prerequisite for generating prediction explanations.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param predictionExplanationsInitializationCreate \link{PredictionExplanationsInitializationCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' predictionExplanationsInitializationCreate <- PredictionExplanationsInitializationCreate$new() # PredictionExplanationsInitializationCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationCreate(projectId, modelId, predictionExplanationsInitializationCreate=predictionExplanationsInitializationCreate)
    #' }
    ProjectsModelsPredictionExplanationsInitializationCreate = function(projectId, modelId, predictionExplanationsInitializationCreate = NULL, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo(projectId, modelId, predictionExplanationsInitializationCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete an existing PredictionExplanationsInitialization.
    #' Produces: NA
    #'
    #' @details Delete an existing PredictionExplanationsInitialization.
    #' @details This method invokes `DELETE /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The deletion was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationDeleteMany(projectId, modelId)
    #' }
    ProjectsModelsPredictionExplanationsInitializationDeleteMany = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationDeleteManyWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the current PredictionExplanationsInitialization.
    #' Produces: NA
    #'
    #' @details Retrieve the current PredictionExplanationsInitialization. A PredictionExplanationsInitialization is a pre-requisite for successfully computing prediction explanations using a particular model, and can be used to preview the prediction explanations that would be generated for a complete dataset.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param excludeAdjustedPredictions Enum < [false, False, true, True] > Whether to include adjusted prediction in the PredictionExplanationsSample response.
    #' @param predictionExplanationsInitializationRetrieve \link{PredictionExplanationsInitializationRetrieve}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' excludeAdjustedPredictions <- "true" # character | Whether to include adjusted prediction in the PredictionExplanationsSample response.
    #' predictionExplanationsInitializationRetrieve <- PredictionExplanationsInitializationRetrieve$new() # PredictionExplanationsInitializationRetrieve |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsPredictionExplanationsInitializationList(projectId, modelId, excludeAdjustedPredictions=excludeAdjustedPredictions, predictionExplanationsInitializationRetrieve=predictionExplanationsInitializationRetrieve)
    #' }
    ProjectsModelsPredictionExplanationsInitializationList = function(projectId, modelId, excludeAdjustedPredictions = "true", predictionExplanationsInitializationRetrieve = NULL, ...) {
      apiResponse <- private$ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo(projectId, modelId, excludeAdjustedPredictions, predictionExplanationsInitializationRetrieve, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all residuals charts for a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all residuals charts for a model.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/residuals/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelResidualsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsResidualsList(projectId, modelId)
    #' }
    ProjectsModelsResidualsList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsResidualsListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the residuals chart data from a single source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the residuals chart data from a single source.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/residuals/{source}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [validation, crossValidation, holdout] > Source of the data.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelResidualsList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsResidualsRetrieve(projectId, modelId, source)
    #' }
    ProjectsModelsResidualsRetrieve = function(projectId, modelId, source, ...) {
      apiResponse <- private$ProjectsModelsResidualsRetrieveWithHttpInfo(projectId, modelId, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve all available ROC curves for model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve all available ROC curves for model. The response will include a json list of all available ROC curves, in the same format as the response from :&lt;http:get&gt;:/api/v2/projects/(projectId)/models/(modelId)/rocCurve/(source)/.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/rocCurve/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelRocCurveListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of all of the available ROC curves for a model.
    #' \itemize{
    #' }
    #' \item **`403`** Invalid Permissions
    #' \itemize{
    #' }
    #' \item **`404`** This resource does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unsupervised mode projects do not have ROC curves
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsRocCurveList(projectId, modelId)
    #' }
    ProjectsModelsRocCurveList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsRocCurveListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the ROC curve data from a single source.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the ROC curve data from a single source. The response includes an array of pointsshowing the performance of the model at different thresholds for classification, and arrays of sample predictions for both the positive and negative classes.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/rocCurve/{source}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param source Enum < [backtest_18, backtest_10, backtest_11, backtest_14, backtest_3, backtest_15, holdout, backtest_5, backtest_16, crossValidation, backtest_2, backtest_12, backtest_20, backtest_17, validation, backtest_6, backtest_4, backtest_13, backtest_9, backtest_19, backtest_8, backtest_7] > Source of the data
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelRocCurveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** ROC curve data from a single source.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' source <- 'source_example' # character | Source of the data
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsRocCurveRetrieve(projectId, modelId, source)
    #' }
    ProjectsModelsRocCurveRetrieve = function(projectId, modelId, source, ...) {
      apiResponse <- private$ProjectsModelsRocCurveRetrieveWithHttpInfo(projectId, modelId, source, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a Shap based Feature Impact.
    #' Produces: NA
    #'
    #' @details Create a Shap based Feature Impact with a model.
    #' @details This method invokes `POST /projects/{projectId}/models/{modelId}/shapImpact/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param featureImpactCreatePayload \link{FeatureImpactCreatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' featureImpactCreatePayload <- FeatureImpactCreatePayload$new() # FeatureImpactCreatePayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsShapImpactCreate(projectId, modelId, featureImpactCreatePayload=featureImpactCreatePayload)
    #' }
    ProjectsModelsShapImpactCreate = function(projectId, modelId, featureImpactCreatePayload = NULL, ...) {
      apiResponse <- private$ProjectsModelsShapImpactCreateWithHttpInfo(projectId, modelId, featureImpactCreatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Impact for a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve Feature Impact for a model. Shap impact is computed by calculating the shap values on a sample of training data and then taking the mean absolute value for each column. The larger value of impact indicate more important feature.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/shapImpact/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ShapImpactRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve Feature Impact for a model.
    #' \itemize{
    #' }
    #' \item **`404`** Feature Impact was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsShapImpactList(projectId, modelId)
    #' }
    ProjectsModelsShapImpactList = function(projectId, modelId, ...) {
      apiResponse <- private$ProjectsModelsShapImpactListWithHttpInfo(projectId, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve word cloud data for a model.
    #' Produces: "application/json"
    #'
    #' @details Retrieve word cloud data for a model. Not all models will have word cloud data available, even when they use text features.
    #' @details This method invokes `GET /projects/{projectId}/models/{modelId}/wordCloud/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param modelId character. The model ID
    #' @param excludeStopWords Enum < [false, False, true, True] > Set to true if you want stopwords excluded from the response.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{WordCloudRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | The model ID
    #' excludeStopWords <- 'excludeStopWords_example' # character | Set to true if you want stopwords excluded from the response.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsModelsWordCloudList(projectId, modelId, excludeStopWords=excludeStopWords)
    #' }
    ProjectsModelsWordCloudList = function(projectId, modelId, excludeStopWords = NULL, ...) {
      apiResponse <- private$ProjectsModelsWordCloudListWithHttpInfo(projectId, modelId, excludeStopWords, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get file with format errors of potential multicategorical features.
    #' Produces: NA
    #'
    #' @details Get file with format errors of potential multicategorical features.
    #' @details This method invokes `GET /projects/{projectId}/multicategoricalInvalidFormat/file/` in the DataRobot Public API.
    #' @param projectId character. The ID of the project this request is associated with.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** File with format errors of potential multicategorical features.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project this request is associated with.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsMulticategoricalInvalidFormatFileList(projectId)
    #' }
    ProjectsMulticategoricalInvalidFormatFileList = function(projectId, ...) {
      apiResponse <- private$ProjectsMulticategoricalInvalidFormatFileListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve multicategorical data quality log.
    #' Produces: "application/json"
    #'
    #' @details Retrieve multicategorical data quality log.
    #' @details This method invokes `GET /projects/{projectId}/multicategoricalInvalidFormat/` in the DataRobot Public API.
    #' @param projectId character. The ID of the project this request is associated with.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MulticategoricalInvalidFormatResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data quality log for multicategorical features.
    #' \itemize{
    #' }
    #' \item **`422`** Not a data quality enabled project
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project this request is associated with.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsMulticategoricalInvalidFormatList(projectId)
    #' }
    ProjectsMulticategoricalInvalidFormatList = function(projectId, ...) {
      apiResponse <- private$ProjectsMulticategoricalInvalidFormatListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a payoff matrix.
    #' Produces: NA
    #'
    #' @details Create a payoff matrix associated with a project.
    #' @details This method invokes `POST /projects/{projectId}/payoffMatrices/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param payoffMatricesCreate \link{PayoffMatricesCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' payoffMatricesCreate <- PayoffMatricesCreate$new() # PayoffMatricesCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPayoffMatricesCreate(projectId, payoffMatricesCreate=payoffMatricesCreate)
    #' }
    ProjectsPayoffMatricesCreate = function(projectId, payoffMatricesCreate = NULL, ...) {
      apiResponse <- private$ProjectsPayoffMatricesCreateWithHttpInfo(projectId, payoffMatricesCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a payoff matrix in a project.
    #' Produces: NA
    #'
    #' @details Delete a payoff matrix in a project.
    #' @details This method invokes `DELETE /projects/{projectId}/payoffMatrices/{payoffMatrixId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param payoffMatrixId character. ObjectId of the payoff matrix.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Payoff matrix deleted successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' payoffMatrixId <- 'payoffMatrixId_example' # character | ObjectId of the payoff matrix.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPayoffMatricesDelete(projectId, payoffMatrixId)
    #' }
    ProjectsPayoffMatricesDelete = function(projectId, payoffMatrixId, ...) {
      apiResponse <- private$ProjectsPayoffMatricesDeleteWithHttpInfo(projectId, payoffMatrixId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List of all payoff matrices for a project.
    #' Produces: "application/json"
    #'
    #' @details List of all payoff matrices for a project.
    #' @details This method invokes `GET /projects/{projectId}/payoffMatrices/` in the DataRobot Public API.
    #' @param offset integer. Number of payoff matrices to skip.
    #' @param limit integer. Number of payoff matrices to return.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PayoffMatricesListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of payoff matrices.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Number of payoff matrices to skip.
    #' limit <- 100 # integer | Number of payoff matrices to return.
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPayoffMatricesList(offset, limit, projectId)
    #' }
    ProjectsPayoffMatricesList = function(offset, limit, projectId, ...) {
      apiResponse <- private$ProjectsPayoffMatricesListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a payoff matrix.
    #' Produces: "application/json"
    #'
    #' @details Update all fields in a payoff matrix, including values and label.
    #' @details This method invokes `PUT /projects/{projectId}/payoffMatrices/{payoffMatrixId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param payoffMatrixId character. ObjectId of the payoff matrix.
    #' @param payoffMatricesCreate \link{PayoffMatricesCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PayoffMatricesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Updated payoff matrix values and label.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' payoffMatrixId <- 'payoffMatrixId_example' # character | ObjectId of the payoff matrix.
    #' payoffMatricesCreate <- PayoffMatricesCreate$new() # PayoffMatricesCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPayoffMatricesPut(projectId, payoffMatrixId, payoffMatricesCreate=payoffMatricesCreate)
    #' }
    ProjectsPayoffMatricesPut = function(projectId, payoffMatrixId, payoffMatricesCreate = NULL, ...) {
      apiResponse <- private$ProjectsPayoffMatricesPutWithHttpInfo(projectId, payoffMatrixId, payoffMatricesCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new PredictionExplanations object (and its accompanying PredictionExplanationsRecord).
    #' Produces: NA
    #'
    #' @details Create a new PredictionExplanations object (and its accompanying PredictionExplanationsRecord). In order to successfully create PredictionExplanations for a particular model and dataset, you must first - Compute feature impact for the model via :&lt;http:post&gt;:/api/v2/projects/(projectId)/models/(modelId)/featureImpact/ - Compute a PredictionExplanationsInitialization for the model via :&lt;http:post&gt;:/api/v2/projects/(projectId)/models/(modelId)/predictionExplanationsInitialization/ - Compute predictions for the model and dataset via :&lt;http:post&gt;:/api/v2/projects/(projectId)/predictions/ thresholdHigh and thresholdLow are optional filters applied to speed up computation. When at least one is specified, only the selected outlier rows will have prediction explanations computed. Rows are considered to be outliers if their predicted value (in case of regression projects) or probability of being the positive class (in case of classification projects) isless than thresholdLow or greater than thresholdHigh. If neither is specified, prediction explanations will be computed for all rows.
    #' @details This method invokes `POST /projects/{projectId}/predictionExplanations/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsCreate \link{PredictionExplanationsCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The request was accepted and will be worked on.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsCreate <- PredictionExplanationsCreate$new() # PredictionExplanationsCreate |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsCreate(projectId, predictionExplanationsCreate=predictionExplanationsCreate)
    #' }
    ProjectsPredictionExplanationsCreate = function(projectId, predictionExplanationsCreate = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsCreateWithHttpInfo(projectId, predictionExplanationsCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve stored Prediction Explanations.
    #' Produces: NA
    #'
    #' @details Retrieve stored Prediction Explanations. Each PredictionExplanationsRow retrieved corresponds to a row of the prediction dataset, although some rows may not have had prediction explanations computed depending on the thresholds selected.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanations/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param limit integer. At most this many results are returned. The default may change and a new maximum limit may be imposed without notice.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param offset integer. This many results will be skipped.
    #' @param excludeAdjustedPredictions Enum < [false, False, true, True] > Whether to include adjusted prediction in PredictionExplanationsRow response.
    #' @param predictionExplanationsRetrieve \link{PredictionExplanationsRetrieve}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 3000 # integer | At most this many results are returned. The default may change and a new maximum limit may be imposed without notice.
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #' offset <- 0 # integer | This many results will be skipped.
    #' excludeAdjustedPredictions <- "true" # character | Whether to include adjusted prediction in PredictionExplanationsRow response.
    #' predictionExplanationsRetrieve <- PredictionExplanationsRetrieve$new() # PredictionExplanationsRetrieve |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsList(limit, projectId, predictionExplanationsId, offset=offset, excludeAdjustedPredictions=excludeAdjustedPredictions, predictionExplanationsRetrieve=predictionExplanationsRetrieve)
    #' }
    ProjectsPredictionExplanationsList = function(limit, projectId, predictionExplanationsId, offset = 0, excludeAdjustedPredictions = "true", predictionExplanationsRetrieve = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsListWithHttpInfo(limit, projectId, predictionExplanationsId, offset, excludeAdjustedPredictions, predictionExplanationsRetrieve, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete saved Prediction Explanations.
    #' Produces: NA
    #'
    #' @details Delete saved Prediction Explanations. Deletes both the actual prediction explanations and the corresponding PredictionExplanationsRecord.
    #' @details This method invokes `DELETE /projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The object was deleted successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsDelete(projectId, predictionExplanationsId)
    #' }
    ProjectsPredictionExplanationsRecordsDelete = function(projectId, predictionExplanationsId, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsDeleteWithHttpInfo(projectId, predictionExplanationsId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List PredictionExplanationsRecord objects for a project.
    #' Produces: "application/json"
    #'
    #' @details List PredictionExplanationsRecord objects for a project. These contain metadata about the computed prediction explanations and the location at which the PredictionExplanations can be retrieved.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanationsRecords/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param modelId character. If specified, only prediction explanations records computed for this model will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PredictionExplanationsRecordList}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The object was found and returned successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' modelId <- 'modelId_example' # character | If specified, only prediction explanations records computed for this model will be returned.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsList(projectId, offset=offset, limit=limit, modelId=modelId)
    #' }
    ProjectsPredictionExplanationsRecordsList = function(projectId, offset = 0, limit = 100, modelId = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsListWithHttpInfo(projectId, offset, limit, modelId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a PredictionExplanationsRecord object.
    #' Produces: NA
    #'
    #' @details Retrieve a PredictionExplanationsRecord object. A PredictionExplanationsRecord contains metadata about the computed prediction explanations and the location at which the PredictionExplanations can be retrieved.
    #' @details This method invokes `GET /projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param predictionExplanationsId character. The ID of the PredictionExplanationsRecord to retrieve.
    #' @param predictionExplanationsRecord \link{PredictionExplanationsRecord}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The object was found and returned successfully.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' predictionExplanationsId <- 'predictionExplanationsId_example' # character | The ID of the PredictionExplanationsRecord to retrieve.
    #' predictionExplanationsRecord <- PredictionExplanationsRecord$new() # PredictionExplanationsRecord |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsPredictionExplanationsRecordsRetrieve(projectId, predictionExplanationsId, predictionExplanationsRecord=predictionExplanationsRecord)
    #' }
    ProjectsPredictionExplanationsRecordsRetrieve = function(projectId, predictionExplanationsId, predictionExplanationsRecord = NULL, ...) {
      apiResponse <- private$ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo(projectId, predictionExplanationsId, predictionExplanationsRecord, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Calculate a matrix with SHAP based prediction explanations scores.
    #' Produces: NA
    #'
    #' @details Submit a request to calculate a matrix with SHAP based prediction explanations scores.
    #' @details This method invokes `POST /projects/{projectId}/shapMatrices/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param createShapMatrixPayload \link{CreateShapMatrixPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' createShapMatrixPayload <- CreateShapMatrixPayload$new() # CreateShapMatrixPayload |
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsShapMatricesCreate(projectId, createShapMatrixPayload=createShapMatrixPayload)
    #' }
    ProjectsShapMatricesCreate = function(projectId, createShapMatrixPayload = NULL, ...) {
      apiResponse <- private$ProjectsShapMatricesCreateWithHttpInfo(projectId, createShapMatrixPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List SHAP matrix records.
    #' Produces: "application/json"
    #'
    #' @details Get a list of available SHAP matrix records.
    #' @details This method invokes `GET /projects/{projectId}/shapMatrices/` in the DataRobot Public API.
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ShapMatrixListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsShapMatricesList(projectId, offset=offset, limit=limit)
    #' }
    ProjectsShapMatricesList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$ProjectsShapMatricesListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get matrix with SHAP prediction explanations scores.
    #' Produces: "application/json", "text/csv"
    #'
    #' @details Get matrix with SHAP prediction explanations scores.
    #' @details This method invokes `GET /projects/{projectId}/shapMatrices/{shapMatrixId}/` in the DataRobot Public API.
    #' @param projectId character. The project ID.
    #' @param shapMatrixId character. The SHAP matrix ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ShapMatrixRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' shapMatrixId <- 'shapMatrixId_example' # character | The SHAP matrix ID.
    #'
    #' api.instance <- InsightsApi$new()
    #' result <- api.instance$ProjectsShapMatricesRetrieve(projectId, shapMatrixId)
    #' }
    ProjectsShapMatricesRetrieve = function(projectId, shapMatrixId, ...) {
      apiResponse <- private$ProjectsShapMatricesRetrieveWithHttpInfo(projectId, shapMatrixId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `MultilabelInsightsHistogramList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsHistogramListWithHttpInfo = function(multilabelInsightsKey, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      body <- NULL
      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/histogram/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticategoricalHistogram", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultilabelInsightsPairwiseManualSelectionsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsPairwiseManualSelectionsCreateWithHttpInfo = function(multilabelInsightsKey, pairwiseManualSelectionCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      if (!missing(`pairwiseManualSelectionCreatePayload`) && isa(pairwiseManualSelectionCreatePayload, c("PairwiseManualSelectionCreatePayload", "R6"))) {
        body <- `pairwiseManualSelectionCreatePayload`$toJSON()
      } else {
        stop("MultilabelInsightsPairwiseManualSelectionsCreateWithHttpInfo requires parameter pairwiseManualSelectionCreatePayload to be of type PairwiseManualSelectionCreatePayload.")
      }

      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PairwiseManualSelectionCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultilabelInsightsPairwiseManualSelectionsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsPairwiseManualSelectionsDeleteWithHttpInfo = function(multilabelInsightsKey, manualSelectionListId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      if (missing(`manualSelectionListId`)) {
        stop("Missing required parameter `manualSelectionListId`.")
      }

      body <- NULL
      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/{manualSelectionListId}/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }

      if (!missing(`manualSelectionListId`)) {
        urlPath <- gsub(paste0("\\{", "manualSelectionListId", "\\}"), URLencode(as.character(`manualSelectionListId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PairwiseManualSelectionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultilabelInsightsPairwiseManualSelectionsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsPairwiseManualSelectionsListWithHttpInfo = function(multilabelInsightsKey, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      body <- NULL
      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PairwiseManualSelectionsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultilabelInsightsPairwiseManualSelectionsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsPairwiseManualSelectionsPatchWithHttpInfo = function(multilabelInsightsKey, manualSelectionListId, pairwiseManualSelectionUpdateRequest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      if (missing(`manualSelectionListId`)) {
        stop("Missing required parameter `manualSelectionListId`.")
      }

      if (!missing(`pairwiseManualSelectionUpdateRequest`) && isa(pairwiseManualSelectionUpdateRequest, c("PairwiseManualSelectionUpdateRequest", "R6"))) {
        body <- `pairwiseManualSelectionUpdateRequest`$toJSON()
      } else {
        stop("MultilabelInsightsPairwiseManualSelectionsPatchWithHttpInfo requires parameter pairwiseManualSelectionUpdateRequest to be of type PairwiseManualSelectionUpdateRequest.")
      }

      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/pairwiseManualSelections/{manualSelectionListId}/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }

      if (!missing(`manualSelectionListId`)) {
        urlPath <- gsub(paste0("\\{", "manualSelectionListId", "\\}"), URLencode(as.character(`manualSelectionListId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PairwiseManualSelectionResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultilabelInsightsPairwiseStatisticsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultilabelInsightsPairwiseStatisticsListWithHttpInfo = function(statisticType, multilabelInsightsKey, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statisticType`)) {
        stop("Missing required parameter `statisticType`.")
      }

      if (missing(`multilabelInsightsKey`)) {
        stop("Missing required parameter `multilabelInsightsKey`.")
      }

      queryParams["statisticType"] <- statisticType

      body <- NULL
      urlPath <- "/multilabelInsights/{multilabelInsightsKey}/pairwiseStatistics/"
      if (!missing(`multilabelInsightsKey`)) {
        urlPath <- gsub(paste0("\\{", "multilabelInsightsKey", "\\}"), URLencode(as.character(`multilabelInsightsKey`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PairwiseStatisticsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsAnomalyAssessmentRecordsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsAnomalyAssessmentRecordsDeleteWithHttpInfo = function(projectId, recordId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`recordId`)) {
        stop("Missing required parameter `recordId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/anomalyAssessmentRecords/{recordId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`recordId`)) {
        urlPath <- gsub(paste0("\\{", "recordId", "\\}"), URLencode(as.character(`recordId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsAnomalyAssessmentRecordsExplanationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsAnomalyAssessmentRecordsExplanationsListWithHttpInfo = function(projectId, recordId, startDate = NULL, endDate = NULL, pointsCount = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`recordId`)) {
        stop("Missing required parameter `recordId`.")
      }

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      queryParams["pointsCount"] <- pointsCount

      body <- NULL
      urlPath <- "/projects/{projectId}/anomalyAssessmentRecords/{recordId}/explanations/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`recordId`)) {
        urlPath <- gsub(paste0("\\{", "recordId", "\\}"), URLencode(as.character(`recordId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyAssessmentExplanationsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsAnomalyAssessmentRecordsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsAnomalyAssessmentRecordsListWithHttpInfo = function(projectId, offset = 0, limit = 100, modelId = NULL, backtest = NULL, source = NULL, seriesId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["modelId"] <- modelId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["seriesId"] <- seriesId

      body <- NULL
      urlPath <- "/projects/{projectId}/anomalyAssessmentRecords/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyAssessmentRecordsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsAnomalyAssessmentRecordsPredictionsPreviewList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsAnomalyAssessmentRecordsPredictionsPreviewListWithHttpInfo = function(projectId, recordId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`recordId`)) {
        stop("Missing required parameter `recordId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/anomalyAssessmentRecords/{recordId}/predictionsPreview/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`recordId`)) {
        urlPath <- gsub(paste0("\\{", "recordId", "\\}"), URLencode(as.character(`recordId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyAssessmentPreviewResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsBiasVsAccuracyInsightsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsBiasVsAccuracyInsightsListWithHttpInfo = function(projectId, accuracyMetric = NULL, protectedFeature = NULL, fairnessMetric = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["accuracyMetric"] <- accuracyMetric

      queryParams["protectedFeature"] <- protectedFeature

      queryParams["fairnessMetric"] <- fairnessMetric

      body <- NULL
      urlPath <- "/projects/{projectId}/biasVsAccuracyInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BiasVsAccuracyInsightRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAccuracyOverTimePlotsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAccuracyOverTimePlotsListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", forecastDistance = NULL, resolution = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["forecastDistance"] <- forecastDistance

      queryParams["resolution"] <- resolution

      queryParams["maxBinSize"] <- maxBinSize

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AccuracyOverTimePlotsDataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAccuracyOverTimePlotsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAccuracyOverTimePlotsMetadataListWithHttpInfo = function(projectId, modelId, forecastDistance = NULL, seriesId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["forecastDistance"] <- forecastDistance

      queryParams["seriesId"] <- seriesId

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AccuracyOverTimePlotsMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAccuracyOverTimePlotsPreviewList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAccuracyOverTimePlotsPreviewListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", forecastDistance = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["forecastDistance"] <- forecastDistance

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/accuracyOverTimePlots/preview/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeTrendPlotsPreviewResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAnomalyOverTimePlotsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAnomalyOverTimePlotsListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", resolution = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["resolution"] <- resolution

      queryParams["maxBinSize"] <- maxBinSize

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyOverTimePlotsDataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAnomalyOverTimePlotsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAnomalyOverTimePlotsMetadataListWithHttpInfo = function(projectId, modelId, seriesId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyOverTimePlotsMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsAnomalyOverTimePlotsPreviewList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsAnomalyOverTimePlotsPreviewListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", predictionThreshold = 0.5, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["predictionThreshold"] <- predictionThreshold

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/anomalyOverTimePlots/preview/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyOverTimePlotsPreviewResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsBacktestStabilityPlotList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsBacktestStabilityPlotListWithHttpInfo = function(projectId, modelId, metricName = NULL, forecastDistance = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["metricName"] <- metricName

      queryParams["forecastDistance"] <- forecastDistance

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/backtestStabilityPlot/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BacktestStabilityPlotResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsMetadataListWithHttpInfo = function(projectId, modelId, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AOTChartMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsPreviewList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsPreviewListWithHttpInfo = function(projectId, modelId, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/preview/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AOTChartPreviewResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsDatasetAccuracyOverTimePlotsRetrieveWithHttpInfo = function(projectId, modelId, datasetId, maxBinSize = 500, startDate = NULL, endDate = NULL, resolution = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["maxBinSize"] <- maxBinSize

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      queryParams["resolution"] <- resolution

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/datasetAccuracyOverTimePlots/{datasetId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AOTChartRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsDatetimeTrendPlotsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsDatetimeTrendPlotsCreateWithHttpInfo = function(projectId, modelId, datetimeTrendPlotsCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`datetimeTrendPlotsCreate`) && isa(datetimeTrendPlotsCreate, c("DatetimeTrendPlotsCreate", "R6"))) {
        body <- `datetimeTrendPlotsCreate`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsDatetimeTrendPlotsCreateWithHttpInfo requires parameter datetimeTrendPlotsCreate to be of type DatetimeTrendPlotsCreate.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/datetimeTrendPlots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeTrendPlotsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureEffectsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureEffectsCreateWithHttpInfo = function(projectId, modelId, featureEffectsCreateDatetime = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`featureEffectsCreateDatetime`) && isa(featureEffectsCreateDatetime, c("FeatureEffectsCreateDatetime", "R6"))) {
        body <- `featureEffectsCreateDatetime`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsFeatureEffectsCreateWithHttpInfo requires parameter featureEffectsCreateDatetime to be of type FeatureEffectsCreateDatetime.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureEffectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureEffectsListWithHttpInfo = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`backtestIndex`)) {
        stop("Missing required parameter `backtestIndex`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      queryParams["backtestIndex"] <- backtestIndex

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureEffectsDatetimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureEffectsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureEffectsMetadataListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureEffectsMetadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelXrayMetadataDatetimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureFitCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureFitCreateWithHttpInfo = function(projectId, modelId, modelXrayCreateDatetime = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`modelXrayCreateDatetime`) && isa(modelXrayCreateDatetime, c("ModelXrayCreateDatetime", "R6"))) {
        body <- `modelXrayCreateDatetime`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsFeatureFitCreateWithHttpInfo requires parameter modelXrayCreateDatetime to be of type ModelXrayCreateDatetime.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureFit/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureFitList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureFitListWithHttpInfo = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`backtestIndex`)) {
        stop("Missing required parameter `backtestIndex`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      queryParams["backtestIndex"] <- backtestIndex

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureFit/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureFitDatetimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsFeatureFitMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsFeatureFitMetadataListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/featureFitMetadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelXrayMetadataDatetimeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsForecastDistanceStabilityPlotList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsForecastDistanceStabilityPlotListWithHttpInfo = function(projectId, modelId, metricName = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["metricName"] <- metricName

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/forecastDistanceStabilityPlot/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ForecastDistanceStabilityPlotResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsForecastVsActualPlotsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsForecastVsActualPlotsListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", resolution = NULL, forecastDistanceStart = NULL, forecastDistanceEnd = NULL, maxBinSize = 500, startDate = NULL, endDate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      queryParams["resolution"] <- resolution

      queryParams["forecastDistanceStart"] <- forecastDistanceStart

      queryParams["forecastDistanceEnd"] <- forecastDistanceEnd

      queryParams["maxBinSize"] <- maxBinSize

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ForecastVsActualPlotsDataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsForecastVsActualPlotsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsForecastVsActualPlotsMetadataListWithHttpInfo = function(projectId, modelId, seriesId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ForecastVsActualPlotsMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsForecastVsActualPlotsPreviewList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsForecastVsActualPlotsPreviewListWithHttpInfo = function(projectId, modelId, seriesId = NULL, backtest = NULL, source = "validation", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["backtest"] <- backtest

      queryParams["source"] <- source

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/forecastVsActualPlots/preview/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DatetimeTrendPlotsPreviewResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMulticlassFeatureEffectsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMulticlassFeatureEffectsCreateWithHttpInfo = function(projectId, modelId, multiclassFeatureEffectDatetimeCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`multiclassFeatureEffectDatetimeCreate`) && isa(multiclassFeatureEffectDatetimeCreate, c("MulticlassFeatureEffectDatetimeCreate", "R6"))) {
        body <- `multiclassFeatureEffectDatetimeCreate`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsMulticlassFeatureEffectsCreateWithHttpInfo requires parameter multiclassFeatureEffectDatetimeCreate to be of type MulticlassFeatureEffectDatetimeCreate.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiclassFeatureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMulticlassFeatureEffectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMulticlassFeatureEffectsListWithHttpInfo = function(backtestIndex, projectId, modelId, source = "training", includeIcePlots = NULL, offset = 0, limit = 100, class = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`backtestIndex`)) {
        stop("Missing required parameter `backtestIndex`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      queryParams["backtestIndex"] <- backtestIndex

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["class"] <- class

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiclassFeatureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticlassDatetimeFeatureEffectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMultiseriesHistogramsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMultiseriesHistogramsListWithHttpInfo = function(attribute, bins, projectId, modelId, metric = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`attribute`)) {
        stop("Missing required parameter `attribute`.")
      }

      if (missing(`bins`)) {
        stop("Missing required parameter `bins`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["attribute"] <- attribute

      queryParams["metric"] <- metric

      queryParams["bins"] <- bins

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiseriesHistograms/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MultiseriesHistogramsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMultiseriesScoresCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMultiseriesScoresCreateWithHttpInfo = function(projectId, modelId, seriesAccuracyCompute = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`seriesAccuracyCompute`) && isa(seriesAccuracyCompute, c("SeriesAccuracyCompute", "R6"))) {
        body <- `seriesAccuracyCompute`$toJSON()
      } else {
        stop("ProjectsDatetimeModelsMultiseriesScoresCreateWithHttpInfo requires parameter seriesAccuracyCompute to be of type SeriesAccuracyCompute.")
      }

      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMultiseriesScoresFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMultiseriesScoresFileListWithHttpInfo = function(projectId, modelId, multiseriesValue = NULL, metric = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["multiseriesValue"] <- multiseriesValue

      queryParams["metric"] <- metric

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/file/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsDatetimeModelsMultiseriesScoresList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsDatetimeModelsMultiseriesScoresListWithHttpInfo = function(offset, limit, projectId, modelId, multiseriesValue = NULL, metric = NULL, orderBy = NULL, filterBy = NULL, numberOfBins = NULL, filterByBins = NULL, clusterNames = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["multiseriesValue"] <- multiseriesValue

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["metric"] <- metric

      queryParams["orderBy"] <- orderBy

      queryParams["filterBy"] <- filterBy

      queryParams["numberOfBins"] <- numberOfBins

      queryParams["filterByBins"] <- filterByBins

      queryParams["clusterNames"] <- clusterNames

      body <- NULL
      urlPath <- "/projects/{projectId}/datetimeModels/{modelId}/multiseriesScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SeriesAccuracyRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsExternalScoresCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsExternalScoresCreateWithHttpInfo = function(projectId, externalScoresCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`externalScoresCreate`) && isa(externalScoresCreate, c("ExternalScoresCreate", "R6"))) {
        body <- `externalScoresCreate`$toJSON()
      } else {
        stop("ProjectsExternalScoresCreateWithHttpInfo requires parameter externalScoresCreate to be of type ExternalScoresCreate.")
      }

      urlPath <- "/projects/{projectId}/externalScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsExternalScoresList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsExternalScoresListWithHttpInfo = function(projectId, offset = 0, limit = 100, datasetId = NULL, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/externalScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ExternalScoresListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFeatureAssociationFeaturelistsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFeatureAssociationFeaturelistsListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/featureAssociationFeaturelists/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureAssociationListControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFeatureAssociationMatrixCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFeatureAssociationMatrixCreateWithHttpInfo = function(projectId, featureAssociationCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`featureAssociationCreatePayload`) && isa(featureAssociationCreatePayload, c("FeatureAssociationCreatePayload", "R6"))) {
        body <- `featureAssociationCreatePayload`$toJSON()
      } else {
        stop("ProjectsFeatureAssociationMatrixCreateWithHttpInfo requires parameter featureAssociationCreatePayload to be of type FeatureAssociationCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/featureAssociationMatrix/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFeatureAssociationMatrixDetailsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFeatureAssociationMatrixDetailsListWithHttpInfo = function(feature1, feature2, projectId, featurelistId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`feature1`)) {
        stop("Missing required parameter `feature1`.")
      }

      if (missing(`feature2`)) {
        stop("Missing required parameter `feature2`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["feature1"] <- feature1

      queryParams["feature2"] <- feature2

      queryParams["featurelistId"] <- featurelistId

      body <- NULL
      urlPath <- "/projects/{projectId}/featureAssociationMatrixDetails/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureAssociationDetailsRetrieveControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFeatureAssociationMatrixList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFeatureAssociationMatrixListWithHttpInfo = function(type, metric, projectId, featurelistId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`type`)) {
        stop("Missing required parameter `type`.")
      }

      if (missing(`metric`)) {
        stop("Missing required parameter `metric`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["type"] <- type

      queryParams["metric"] <- metric

      queryParams["featurelistId"] <- featurelistId

      body <- NULL
      urlPath <- "/projects/{projectId}/featureAssociationMatrix/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureAssociationRetrieveControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsFeaturesFrequentValuesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsFeaturesFrequentValuesListWithHttpInfo = function(projectId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/features/{featureName}/frequentValues/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FrequentValuesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsGeometryFeaturePlotsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsGeometryFeaturePlotsCreateWithHttpInfo = function(projectId, geometryFeaturePLotCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`geometryFeaturePLotCreatePayload`) && isa(geometryFeaturePLotCreatePayload, c("GeometryFeaturePLotCreatePayload", "R6"))) {
        body <- `geometryFeaturePLotCreatePayload`$toJSON()
      } else {
        stop("ProjectsGeometryFeaturePlotsCreateWithHttpInfo requires parameter geometryFeaturePLotCreatePayload to be of type GeometryFeaturePLotCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/geometryFeaturePlots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsGeometryFeaturePlotsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsGeometryFeaturePlotsRetrieveWithHttpInfo = function(projectId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/geometryFeaturePlots/{featureName}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "GeometryFeaturePlotRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsImageActivationMapsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsImageActivationMapsListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/imageActivationMaps/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ActivationMapsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsImageEmbeddingsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsImageEmbeddingsListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/imageEmbeddings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "EmbeddingsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsAnomalyAssessmentInitializationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsAnomalyAssessmentInitializationCreateWithHttpInfo = function(projectId, modelId, anomalyAssessmentInitialize = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`anomalyAssessmentInitialize`) && isa(anomalyAssessmentInitialize, c("AnomalyAssessmentInitialize", "R6"))) {
        body <- `anomalyAssessmentInitialize`$toJSON()
      } else {
        stop("ProjectsModelsAnomalyAssessmentInitializationCreateWithHttpInfo requires parameter anomalyAssessmentInitialize to be of type AnomalyAssessmentInitialize.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/anomalyAssessmentInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsAnomalyInsightsFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsAnomalyInsightsFileListWithHttpInfo = function(projectId, modelId, filename = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["filename"] <- filename

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/anomalyInsightsFile/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsAnomalyInsightsTableList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsAnomalyInsightsTableListWithHttpInfo = function(projectId, modelId, anomalyScoreRounding = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["anomalyScoreRounding"] <- anomalyScoreRounding

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/anomalyInsightsTable/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AnomalyInsightTableRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsClusterInsightsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsClusterInsightsCreateWithHttpInfo = function(projectId, modelId, body = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`body`) && isa(body, c("object", "R6"))) {
        body <- `body`$toJSON()
      } else {
        stop("ProjectsModelsClusterInsightsCreateWithHttpInfo requires parameter body to be of type object.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/clusterInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsClusterInsightsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsClusterInsightsDownloadListWithHttpInfo = function(projectId, modelId, format = "CSV", featurelistId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["format"] <- format

      queryParams["featurelistId"] <- featurelistId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/clusterInsights/download/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsClusterInsightsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsClusterInsightsListWithHttpInfo = function(limit, projectId, modelId, offset = 0, orderBy = NULL, searchFor = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["searchFor"] <- searchFor

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/clusterInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ClusterInsightsPaginatedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsConfusionChartsClassDetailsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsConfusionChartsClassDetailsListWithHttpInfo = function(className, projectId, modelId, source, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`className`)) {
        stop("Missing required parameter `className`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      queryParams["className"] <- className

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/confusionCharts/{source}/classDetails/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelConfusionChartClassDetailsRetrieveReponseController", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsConfusionChartsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsConfusionChartsListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/confusionCharts/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelConfusionChartListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsConfusionChartsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsConfusionChartsMetadataListWithHttpInfo = function(projectId, modelId, source, orderBy = "className", orientation = "actual", thumbnailCellSize = 10, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      queryParams["orderBy"] <- orderBy

      queryParams["orientation"] <- orientation

      queryParams["thumbnailCellSize"] <- thumbnailCellSize

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/confusionCharts/{source}/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelConfusionChartMetadataRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsConfusionChartsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsConfusionChartsRetrieveWithHttpInfo = function(projectId, modelId, source, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      queryParams["orderBy"] <- orderBy

      queryParams["orientation"] <- orientation

      queryParams["rowStart"] <- rowStart

      queryParams["rowEnd"] <- rowEnd

      queryParams["colStart"] <- colStart

      queryParams["colEnd"] <- colEnd

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/confusionCharts/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelConfusionChartRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsCrossClassAccuracyScoresCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsCrossClassAccuracyScoresCreateWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/crossClassAccuracyScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CrossClassAccuracyCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsCrossClassAccuracyScoresList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsCrossClassAccuracyScoresListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/crossClassAccuracyScores/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CrossClassAccuracyList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDataDisparityInsightsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDataDisparityInsightsCreateWithHttpInfo = function(projectId, modelId, dataDisparityCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`dataDisparityCreatePayload`) && isa(dataDisparityCreatePayload, c("DataDisparityCreatePayload", "R6"))) {
        body <- `dataDisparityCreatePayload`$toJSON()
      } else {
        stop("ProjectsModelsDataDisparityInsightsCreateWithHttpInfo requires parameter dataDisparityCreatePayload to be of type DataDisparityCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/dataDisparityInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataDisparityCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDataDisparityInsightsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDataDisparityInsightsListWithHttpInfo = function(feature, className1, className2, projectId, modelId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`feature`)) {
        stop("Missing required parameter `feature`.")
      }

      if (missing(`className1`)) {
        stop("Missing required parameter `className1`.")
      }

      if (missing(`className2`)) {
        stop("Missing required parameter `className2`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["feature"] <- feature

      queryParams["className1"] <- className1

      queryParams["className2"] <- className2

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/dataDisparityInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DataDisparityRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetConfusionChartsClassDetailsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetConfusionChartsClassDetailsListWithHttpInfo = function(className, projectId, modelId, datasetId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`className`)) {
        stop("Missing required parameter `className`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["className"] <- className

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/classDetails/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelConfusionChartClassDetailsForDatasetRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetConfusionChartsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetConfusionChartsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["orientation"] <- orientation

      queryParams["rowStart"] <- rowStart

      queryParams["rowEnd"] <- rowEnd

      queryParams["colStart"] <- colStart

      queryParams["colEnd"] <- colEnd

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetConfusionCharts/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ConfusionChartForDatasetsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetConfusionChartsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetConfusionChartsMetadataListWithHttpInfo = function(projectId, modelId, datasetId, orderBy = "className", orientation = "actual", thumbnailCellSize = 10, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["orderBy"] <- orderBy

      queryParams["orientation"] <- orientation

      queryParams["thumbnailCellSize"] <- thumbnailCellSize

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/metadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ConfusionChartRetrieveMetadataForDatasets", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetConfusionChartsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetConfusionChartsRetrieveWithHttpInfo = function(projectId, modelId, datasetId, orderBy = "className", orientation = "actual", rowStart = NULL, rowEnd = NULL, colStart = NULL, colEnd = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["orderBy"] <- orderBy

      queryParams["orientation"] <- orientation

      queryParams["rowStart"] <- rowStart

      queryParams["rowEnd"] <- rowEnd

      queryParams["colStart"] <- colStart

      queryParams["colEnd"] <- colEnd

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetConfusionCharts/{datasetId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ConfusionChartRetrieveForDatasets", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetLiftChartsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetLiftChartsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetLiftCharts/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "LiftChartForDatasetsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetMulticlassLiftChartsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetMulticlassLiftChartsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetMulticlassLiftCharts/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticlassLiftChartForDatasetsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetResidualsChartsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetResidualsChartsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetResidualsCharts/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ResidualsChartForDatasetsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsDatasetRocCurvesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsDatasetRocCurvesListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/datasetRocCurves/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RocCurveForDatasetsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFairnessInsightsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFairnessInsightsCreateWithHttpInfo = function(projectId, modelId, fairnessInsightsStartCalculationPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`fairnessInsightsStartCalculationPayload`) && isa(fairnessInsightsStartCalculationPayload, c("FairnessInsightsStartCalculationPayload", "R6"))) {
        body <- `fairnessInsightsStartCalculationPayload`$toJSON()
      } else {
        stop("ProjectsModelsFairnessInsightsCreateWithHttpInfo requires parameter fairnessInsightsStartCalculationPayload to be of type FairnessInsightsStartCalculationPayload.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/fairnessInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FairnessInsightsStartCalculationResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFairnessInsightsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFairnessInsightsListWithHttpInfo = function(projectId, modelId, offset = 0, limit = 100, fairnessMetricsSet = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["fairnessMetricsSet"] <- fairnessMetricsSet

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/fairnessInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FairnessInsightsListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureEffectsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureEffectsCreateWithHttpInfo = function(projectId, modelId, featureEffectCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`featureEffectCreate`) && isa(featureEffectCreate, c("FeatureEffectCreate", "R6"))) {
        body <- `featureEffectCreate`$toJSON()
      } else {
        stop("ProjectsModelsFeatureEffectsCreateWithHttpInfo requires parameter featureEffectCreate to be of type FeatureEffectCreate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/featureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureEffectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureEffectsListWithHttpInfo = function(projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureEffectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureEffectsMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureEffectsMetadataListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureEffectsMetadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelXrayMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureFitCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureFitCreateWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureFit/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureFitList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureFitListWithHttpInfo = function(projectId, modelId, source = "training", includeIcePlots = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureFit/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureFitResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureFitMetadataList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureFitMetadataListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureFitMetadata/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelXrayMetadataResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureImpactCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureImpactCreateWithHttpInfo = function(projectId, modelId, permutationFeatureImpactCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`permutationFeatureImpactCreatePayload`) && isa(permutationFeatureImpactCreatePayload, c("PermutationFeatureImpactCreatePayload", "R6"))) {
        body <- `permutationFeatureImpactCreatePayload`$toJSON()
      } else {
        stop("ProjectsModelsFeatureImpactCreateWithHttpInfo requires parameter permutationFeatureImpactCreatePayload to be of type PermutationFeatureImpactCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/featureImpact/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureImpactList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureImpactListWithHttpInfo = function(projectId, modelId, backtest = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["backtest"] <- backtest

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureImpact/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PermutationFeatureImpactResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsFeatureListsClusterInsightsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsFeatureListsClusterInsightsListWithHttpInfo = function(limit, projectId, modelId, datasetId, offset = 0, orderBy = NULL, searchFor = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`datasetId`)) {
        stop("Missing required parameter `datasetId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["orderBy"] <- orderBy

      queryParams["searchFor"] <- searchFor

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/featureLists/{datasetId}/clusterInsights/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`datasetId`)) {
        urlPath <- gsub(paste0("\\{", "datasetId", "\\}"), URLencode(as.character(`datasetId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ClusterInsightsPaginatedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsImageActivationMapsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsImageActivationMapsCreateWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/imageActivationMaps/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ActivationMapsComputeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsImageActivationMapsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsImageActivationMapsListWithHttpInfo = function(featureName, projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["featureName"] <- featureName

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/imageActivationMaps/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ActivationMapsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsImageEmbeddingsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsImageEmbeddingsCreateWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/imageEmbeddings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ImageEmbeddingsComputeResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsImageEmbeddingsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsImageEmbeddingsListWithHttpInfo = function(featureName, projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["featureName"] <- featureName

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/imageEmbeddings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "EmbeddingsRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsLabelwiseRocCurvesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsLabelwiseRocCurvesListWithHttpInfo = function(projectId, modelId, source, labels = NULL, searchQuery = NULL, sortBy = "label", sortOrder = "ascending", threshold = NULL, offset = 0, limit = 100, includeModelAverage = FALSE, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      queryParams["labels"] <- labels

      queryParams["searchQuery"] <- searchQuery

      queryParams["sortBy"] <- sortBy

      queryParams["sortOrder"] <- sortOrder

      queryParams["threshold"] <- threshold

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["includeModelAverage"] <- includeModelAverage

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/labelwiseRocCurves/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "LabelwiseROC", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsLiftChartList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsLiftChartListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/liftChart/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelLiftChartListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsLiftChartRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsLiftChartRetrieveWithHttpInfo = function(projectId, modelId, source, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/liftChart/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelLiftChartResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMulticlassFeatureEffectsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMulticlassFeatureEffectsCreateWithHttpInfo = function(projectId, modelId, multiclassFeatureEffectCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`multiclassFeatureEffectCreate`) && isa(multiclassFeatureEffectCreate, c("MulticlassFeatureEffectCreate", "R6"))) {
        body <- `multiclassFeatureEffectCreate`$toJSON()
      } else {
        stop("ProjectsModelsMulticlassFeatureEffectsCreateWithHttpInfo requires parameter multiclassFeatureEffectCreate to be of type MulticlassFeatureEffectCreate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/multiclassFeatureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMulticlassFeatureEffectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMulticlassFeatureEffectsListWithHttpInfo = function(projectId, modelId, source = "training", includeIcePlots = NULL, offset = 0, limit = 100, class = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["source"] <- source

      queryParams["includeIcePlots"] <- includeIcePlots

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["class"] <- class

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/multiclassFeatureEffects/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticlassFeatureEffectsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMulticlassFeatureImpactList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMulticlassFeatureImpactListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/multiclassFeatureImpact/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticlassFeatureImpactResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMulticlassLiftChartList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMulticlassLiftChartListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/multiclassLiftChart/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AllMulticlassModelLiftChartsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMulticlassLiftChartRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMulticlassLiftChartRetrieveWithHttpInfo = function(projectId, modelId, source, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/multiclassLiftChart/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticlassModelLiftChartResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsMultilabelLiftChartsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsMultilabelLiftChartsRetrieveWithHttpInfo = function(projectId, modelId, source, labels = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      queryParams["labels"] <- labels

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/multilabelLiftCharts/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "LabelwiseLiftChart", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo = function(projectId, modelId, predictionExplanationsInitializationCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`predictionExplanationsInitializationCreate`) && isa(predictionExplanationsInitializationCreate, c("PredictionExplanationsInitializationCreate", "R6"))) {
        body <- `predictionExplanationsInitializationCreate`$toJSON()
      } else {
        stop("ProjectsModelsPredictionExplanationsInitializationCreateWithHttpInfo requires parameter predictionExplanationsInitializationCreate to be of type PredictionExplanationsInitializationCreate.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationDeleteManyWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsPredictionExplanationsInitializationList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo = function(projectId, modelId, excludeAdjustedPredictions = "true", predictionExplanationsInitializationRetrieve = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["excludeAdjustedPredictions"] <- excludeAdjustedPredictions

      if (!missing(`predictionExplanationsInitializationRetrieve`) && isa(predictionExplanationsInitializationRetrieve, c("PredictionExplanationsInitializationRetrieve", "R6"))) {
        body <- `predictionExplanationsInitializationRetrieve`$toJSON()
      } else {
        stop("ProjectsModelsPredictionExplanationsInitializationListWithHttpInfo requires parameter predictionExplanationsInitializationRetrieve to be of type PredictionExplanationsInitializationRetrieve.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/predictionExplanationsInitialization/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsResidualsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsResidualsListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/residuals/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelResidualsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsResidualsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsResidualsRetrieveWithHttpInfo = function(projectId, modelId, source, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/residuals/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelResidualsList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsRocCurveList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsRocCurveListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/rocCurve/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelRocCurveListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsRocCurveRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsRocCurveRetrieveWithHttpInfo = function(projectId, modelId, source, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (missing(`source`)) {
        stop("Missing required parameter `source`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/rocCurve/{source}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }

      if (!missing(`source`)) {
        urlPath <- gsub(paste0("\\{", "source", "\\}"), URLencode(as.character(`source`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelRocCurveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsShapImpactCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsShapImpactCreateWithHttpInfo = function(projectId, modelId, featureImpactCreatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      if (!missing(`featureImpactCreatePayload`) && isa(featureImpactCreatePayload, c("FeatureImpactCreatePayload", "R6"))) {
        body <- `featureImpactCreatePayload`$toJSON()
      } else {
        stop("ProjectsModelsShapImpactCreateWithHttpInfo requires parameter featureImpactCreatePayload to be of type FeatureImpactCreatePayload.")
      }

      urlPath <- "/projects/{projectId}/models/{modelId}/shapImpact/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsShapImpactList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsShapImpactListWithHttpInfo = function(projectId, modelId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/shapImpact/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ShapImpactRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsModelsWordCloudList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsModelsWordCloudListWithHttpInfo = function(projectId, modelId, excludeStopWords = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`modelId`)) {
        stop("Missing required parameter `modelId`.")
      }

      queryParams["excludeStopWords"] <- excludeStopWords

      body <- NULL
      urlPath <- "/projects/{projectId}/models/{modelId}/wordCloud/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`modelId`)) {
        urlPath <- gsub(paste0("\\{", "modelId", "\\}"), URLencode(as.character(`modelId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "WordCloudRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsMulticategoricalInvalidFormatFileList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsMulticategoricalInvalidFormatFileListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/multicategoricalInvalidFormat/file/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsMulticategoricalInvalidFormatList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsMulticategoricalInvalidFormatListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/multicategoricalInvalidFormat/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MulticategoricalInvalidFormatResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPayoffMatricesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPayoffMatricesCreateWithHttpInfo = function(projectId, payoffMatricesCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`payoffMatricesCreate`) && isa(payoffMatricesCreate, c("PayoffMatricesCreate", "R6"))) {
        body <- `payoffMatricesCreate`$toJSON()
      } else {
        stop("ProjectsPayoffMatricesCreateWithHttpInfo requires parameter payoffMatricesCreate to be of type PayoffMatricesCreate.")
      }

      urlPath <- "/projects/{projectId}/payoffMatrices/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPayoffMatricesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPayoffMatricesDeleteWithHttpInfo = function(projectId, payoffMatrixId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`payoffMatrixId`)) {
        stop("Missing required parameter `payoffMatrixId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/payoffMatrices/{payoffMatrixId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`payoffMatrixId`)) {
        urlPath <- gsub(paste0("\\{", "payoffMatrixId", "\\}"), URLencode(as.character(`payoffMatrixId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPayoffMatricesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPayoffMatricesListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/payoffMatrices/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PayoffMatricesListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPayoffMatricesPut`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPayoffMatricesPutWithHttpInfo = function(projectId, payoffMatrixId, payoffMatricesCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`payoffMatrixId`)) {
        stop("Missing required parameter `payoffMatrixId`.")
      }

      if (!missing(`payoffMatricesCreate`) && isa(payoffMatricesCreate, c("PayoffMatricesCreate", "R6"))) {
        body <- `payoffMatricesCreate`$toJSON()
      } else {
        stop("ProjectsPayoffMatricesPutWithHttpInfo requires parameter payoffMatricesCreate to be of type PayoffMatricesCreate.")
      }

      urlPath <- "/projects/{projectId}/payoffMatrices/{payoffMatrixId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`payoffMatrixId`)) {
        urlPath <- gsub(paste0("\\{", "payoffMatrixId", "\\}"), URLencode(as.character(`payoffMatrixId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PayoffMatricesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsCreateWithHttpInfo = function(projectId, predictionExplanationsCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`predictionExplanationsCreate`) && isa(predictionExplanationsCreate, c("PredictionExplanationsCreate", "R6"))) {
        body <- `predictionExplanationsCreate`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsCreateWithHttpInfo requires parameter predictionExplanationsCreate to be of type PredictionExplanationsCreate.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanations/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsListWithHttpInfo = function(limit, projectId, predictionExplanationsId, offset = 0, excludeAdjustedPredictions = "true", predictionExplanationsRetrieve = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["excludeAdjustedPredictions"] <- excludeAdjustedPredictions

      if (!missing(`predictionExplanationsRetrieve`) && isa(predictionExplanationsRetrieve, c("PredictionExplanationsRetrieve", "R6"))) {
        body <- `predictionExplanationsRetrieve`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsListWithHttpInfo requires parameter predictionExplanationsRetrieve to be of type PredictionExplanationsRetrieve.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanations/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsDeleteWithHttpInfo = function(projectId, predictionExplanationsId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsListWithHttpInfo = function(projectId, offset = 0, limit = 100, modelId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["modelId"] <- modelId

      body <- NULL
      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PredictionExplanationsRecordList", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsPredictionExplanationsRecordsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo = function(projectId, predictionExplanationsId, predictionExplanationsRecord = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`predictionExplanationsId`)) {
        stop("Missing required parameter `predictionExplanationsId`.")
      }

      if (!missing(`predictionExplanationsRecord`) && isa(predictionExplanationsRecord, c("PredictionExplanationsRecord", "R6"))) {
        body <- `predictionExplanationsRecord`$toJSON()
      } else {
        stop("ProjectsPredictionExplanationsRecordsRetrieveWithHttpInfo requires parameter predictionExplanationsRecord to be of type PredictionExplanationsRecord.")
      }

      urlPath <- "/projects/{projectId}/predictionExplanationsRecords/{predictionExplanationsId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`predictionExplanationsId`)) {
        urlPath <- gsub(paste0("\\{", "predictionExplanationsId", "\\}"), URLencode(as.character(`predictionExplanationsId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsShapMatricesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsShapMatricesCreateWithHttpInfo = function(projectId, createShapMatrixPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`createShapMatrixPayload`) && isa(createShapMatrixPayload, c("CreateShapMatrixPayload", "R6"))) {
        body <- `createShapMatrixPayload`$toJSON()
      } else {
        stop("ProjectsShapMatricesCreateWithHttpInfo requires parameter createShapMatrixPayload to be of type CreateShapMatrixPayload.")
      }

      urlPath <- "/projects/{projectId}/shapMatrices/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsShapMatricesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsShapMatricesListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/shapMatrices/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ShapMatrixListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ProjectsShapMatricesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ProjectsShapMatricesRetrieveWithHttpInfo = function(projectId, shapMatrixId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`shapMatrixId`)) {
        stop("Missing required parameter `shapMatrixId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/shapMatrices/{shapMatrixId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`shapMatrixId`)) {
        urlPath <- gsub(paste0("\\{", "shapMatrixId", "\\}"), URLencode(as.character(`shapMatrixId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ShapMatrixRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
