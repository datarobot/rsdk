# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title DatasetFeatureResponse
#'
#' @description DatasetFeatureResponse Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field datasetId  character The ID of the dataset the feature belongs to
#'
#' @field datasetVersionId  character The ID of the dataset version the feature belongs to.
#'
#' @field dateFormat  character The date format string for how this feature was interpreted (or null if not a date feature). If not null, it will be compatible with https://docs.python.org/2/library/time.html#time.strftime .
#'
#' @field featureType  character Feature type.
#'
#' @field id  integer The number of the column in the dataset.
#'
#' @field isZeroInflated  character [optional] whether feature has an excessive number of zeros
#'
#' @field keySummary  \link{OneOfFeatureKeySummaryResponseValidatorSummarizedCategoricalarray} [optional] Per key summaries for Summarized Categorical or Multicategorical columns
#'
#' @field lowInformation  character [optional] Whether feature has too few values to be informative.
#'
#' @field max  numeric [optional] Maximum value of the EDA sample of the feature.
#'
#' @field mean  numeric [optional] Arithmetic mean of the EDA sample of the feature.
#'
#' @field median  numeric [optional] Median of the EDA sample of the feature.
#'
#' @field min  numeric [optional] Minimum value of the EDA sample of the feature.
#'
#' @field naCount  integer [optional] Number of missing values.
#'
#' @field name  character Feature name
#'
#' @field stdDev  numeric [optional] Standard deviation of EDA sample of the feature.
#'
#' @field timeSeriesEligibilityReason  character [optional] why the feature is ineligible for time series projects, or &#39;suitable&#39; if it is eligible.
#'
#' @field timeSeriesEligibilityReasonAggregation  character [optional] why the feature is ineligible for aggregation, or &#39;suitable&#39; if it is eligible.
#'
#' @field timeSeriesEligible  character [optional] whether this feature can be used as a datetime partitioning feature for time series projects.  Only sufficiently regular date features can be selected as the datetime feature for time series projects.  Always false for non-date features. Date features that cannot be used in datetime partitioning for a time series project may be eligible for an OTV project, which has less stringent requirements.
#'
#' @field timeSeriesEligibleAggregation  character [optional] whether this feature can be used as a datetime feature for aggregationfor time series data prep.  Always false for non-date features.
#'
#' @field timeStep  integer [optional] The minimum time step that can be used to specify time series windows.  The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  When specifying windows for time series projects, all windows must have durations that are integer multiples of this number. Only present for date features that are eligible for time series projects and null otherwise.
#'
#' @field timeStepAggregation  integer [optional] The minimum time step that can be used to aggregate using this feature for time series data prep. The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  Only present for date features that are eligible for aggregation in time series data prep and null otherwise.
#'
#' @field timeUnit  character [optional] The unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  When specifying windows for time series projects, the windows are expressed in terms of this unit.  Only present for date features eligible for time series projects, and null otherwise.
#'
#' @field timeUnitAggregation  character [optional] The unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  Only present for date features eligible for aggregation, and null otherwise.
#'
#' @field uniqueCount  integer [optional] Number of unique values.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
DatasetFeatureResponse <- R6::R6Class(
  "DatasetFeatureResponse",
  lock_objects = FALSE,
  private = list(
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(datasetId = NULL, datasetVersionId = NULL, dateFormat = NULL, featureType = NULL, id = NULL, isZeroInflated = NULL, keySummary = NULL, lowInformation = NULL, max = NULL, mean = NULL, median = NULL, min = NULL, naCount = NULL, name = NULL, stdDev = NULL, timeSeriesEligibilityReason = NULL, timeSeriesEligibilityReasonAggregation = NULL, timeSeriesEligible = NULL, timeSeriesEligibleAggregation = NULL, timeStep = NULL, timeStepAggregation = NULL, timeUnit = NULL, timeUnitAggregation = NULL, uniqueCount = NULL) {
      if (!is.null(`datasetId`)) {
        stopifnot(is.character(`datasetId`), length(`datasetId`) == 1)
      }
      if (!is.null(`datasetVersionId`)) {
        stopifnot(is.character(`datasetVersionId`), length(`datasetVersionId`) == 1)
      }
      if (!is.null(`dateFormat`)) {
        stopifnot(is.character(`dateFormat`), length(`dateFormat`) == 1)
      }
      if (!is.null(`featureType`)) {
        stopifnot(is.character(`featureType`), length(`featureType`) == 1)
      }
      if (!is.null(`id`)) {
        stopifnot(is.numeric(`id`), length(`id`) == 1)
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
      }
      if (!is.null(`isZeroInflated`)) {
        stopifnot(is.logical(`isZeroInflated`), length(`isZeroInflated`) == 1)
      }
      if (!is.null(`keySummary`)) {
        .setMixedProperty(typeList = list(FeatureKeySummaryResponseValidatorSummarizedCategorical, array), propertyData = keySummary)
      }
      if (!is.null(`lowInformation`)) {
        stopifnot(is.logical(`lowInformation`), length(`lowInformation`) == 1)
      }
      if (!is.null(`max`)) {
        stopifnot(is.numeric(`max`), length(`max`) == 1)
      }
      if (!is.null(`mean`)) {
        stopifnot(is.numeric(`mean`), length(`mean`) == 1)
      }
      if (!is.null(`median`)) {
        stopifnot(is.numeric(`median`), length(`median`) == 1)
      }
      if (!is.null(`min`)) {
        stopifnot(is.numeric(`min`), length(`min`) == 1)
      }
      if (!is.null(`naCount`)) {
        stopifnot(is.numeric(`naCount`), length(`naCount`) == 1)
      }
      if (!is.null(`stdDev`)) {
        stopifnot(is.numeric(`stdDev`), length(`stdDev`) == 1)
      }
      if (!is.null(`timeSeriesEligibilityReason`)) {
        stopifnot(is.character(`timeSeriesEligibilityReason`), length(`timeSeriesEligibilityReason`) == 1)
      }
      if (!is.null(`timeSeriesEligibilityReasonAggregation`)) {
        stopifnot(is.character(`timeSeriesEligibilityReasonAggregation`), length(`timeSeriesEligibilityReasonAggregation`) == 1)
      }
      if (!is.null(`timeSeriesEligible`)) {
        stopifnot(is.logical(`timeSeriesEligible`), length(`timeSeriesEligible`) == 1)
      }
      if (!is.null(`timeSeriesEligibleAggregation`)) {
        stopifnot(is.logical(`timeSeriesEligibleAggregation`), length(`timeSeriesEligibleAggregation`) == 1)
      }
      if (!is.null(`timeStep`)) {
        stopifnot(is.numeric(`timeStep`), length(`timeStep`) == 1)
      }
      if (!is.null(`timeStepAggregation`)) {
        stopifnot(is.numeric(`timeStepAggregation`), length(`timeStepAggregation`) == 1)
      }
      if (!is.null(`timeUnit`)) {
        stopifnot(is.character(`timeUnit`), length(`timeUnit`) == 1)
      }
      if (!is.null(`timeUnitAggregation`)) {
        stopifnot(is.character(`timeUnitAggregation`), length(`timeUnitAggregation`) == 1)
      }
      if (!is.null(`uniqueCount`)) {
        stopifnot(is.numeric(`uniqueCount`), length(`uniqueCount`) == 1)
      }
    }
  ),
  public = list(
    `datasetId` = NULL,
    `datasetVersionId` = NULL,
    `dateFormat` = NULL,
    `featureType` = NULL,
    `id` = NULL,
    `isZeroInflated` = NULL,
    `keySummary` = NULL,
    `lowInformation` = NULL,
    `max` = NULL,
    `mean` = NULL,
    `median` = NULL,
    `min` = NULL,
    `naCount` = NULL,
    `name` = NULL,
    `stdDev` = NULL,
    `timeSeriesEligibilityReason` = NULL,
    `timeSeriesEligibilityReasonAggregation` = NULL,
    `timeSeriesEligible` = NULL,
    `timeSeriesEligibleAggregation` = NULL,
    `timeStep` = NULL,
    `timeStepAggregation` = NULL,
    `timeUnit` = NULL,
    `timeUnitAggregation` = NULL,
    `uniqueCount` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param datasetId The ID of the dataset the feature belongs to
    #' @param datasetVersionId The ID of the dataset version the feature belongs to.
    #' @param dateFormat The date format string for how this feature was interpreted (or null if not a date feature). If not null, it will be compatible with https://docs.python.org/2/library/time.html#time.strftime .
    #' @param featureType Feature type.
    #' @param id The number of the column in the dataset.
    #' @param isZeroInflated whether feature has an excessive number of zeros
    #' @param keySummary Per key summaries for Summarized Categorical or Multicategorical columns
    #' @param lowInformation Whether feature has too few values to be informative.
    #' @param max Maximum value of the EDA sample of the feature.
    #' @param mean Arithmetic mean of the EDA sample of the feature.
    #' @param median Median of the EDA sample of the feature.
    #' @param min Minimum value of the EDA sample of the feature.
    #' @param naCount Number of missing values.
    #' @param name Feature name
    #' @param stdDev Standard deviation of EDA sample of the feature.
    #' @param timeSeriesEligibilityReason why the feature is ineligible for time series projects, or &#39;suitable&#39; if it is eligible.
    #' @param timeSeriesEligibilityReasonAggregation why the feature is ineligible for aggregation, or &#39;suitable&#39; if it is eligible.
    #' @param timeSeriesEligible whether this feature can be used as a datetime partitioning feature for time series projects.  Only sufficiently regular date features can be selected as the datetime feature for time series projects.  Always false for non-date features. Date features that cannot be used in datetime partitioning for a time series project may be eligible for an OTV project, which has less stringent requirements.
    #' @param timeSeriesEligibleAggregation whether this feature can be used as a datetime feature for aggregationfor time series data prep.  Always false for non-date features.
    #' @param timeStep The minimum time step that can be used to specify time series windows.  The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  When specifying windows for time series projects, all windows must have durations that are integer multiples of this number. Only present for date features that are eligible for time series projects and null otherwise.
    #' @param timeStepAggregation The minimum time step that can be used to aggregate using this feature for time series data prep. The units for this value are the &#x60;&#x60;timeUnit&#x60;&#x60;.  Only present for date features that are eligible for aggregation in time series data prep and null otherwise.
    #' @param timeUnit The unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  When specifying windows for time series projects, the windows are expressed in terms of this unit.  Only present for date features eligible for time series projects, and null otherwise.
    #' @param timeUnitAggregation The unit for the interval between values of this feature, e.g. DAY, MONTH, HOUR.  Only present for date features eligible for aggregation, and null otherwise.
    #' @param uniqueCount Number of unique values.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`datasetId` = NULL, `datasetVersionId` = NULL, `dateFormat` = NULL, `featureType` = NULL, `id` = NULL, `name` = NULL, `isZeroInflated` = NULL, `keySummary` = NULL, `lowInformation` = NULL, `max` = NULL, `mean` = NULL, `median` = NULL, `min` = NULL, `naCount` = NULL, `stdDev` = NULL, `timeSeriesEligibilityReason` = NULL, `timeSeriesEligibilityReasonAggregation` = NULL, `timeSeriesEligible` = NULL, `timeSeriesEligibleAggregation` = NULL, `timeStep` = NULL, `timeStepAggregation` = NULL, `timeUnit` = NULL, `timeUnitAggregation` = NULL, `uniqueCount` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      requiredProps <- list(`datasetId`, `datasetVersionId`, `dateFormat`, `featureType`, `id`, `name`)
      if (validateParams) {
        lapply(requiredProps, missing)
        private$validateProps(datasetId, datasetVersionId, dateFormat, featureType, id, isZeroInflated, keySummary, lowInformation, max, mean, median, min, naCount, name, stdDev, timeSeriesEligibilityReason, timeSeriesEligibilityReasonAggregation, timeSeriesEligible, timeSeriesEligibleAggregation, timeStep, timeStepAggregation, timeUnit, timeUnitAggregation, uniqueCount)
      }
      self$`datasetId` <- `datasetId`
      self$`datasetVersionId` <- `datasetVersionId`
      self$`dateFormat` <- `dateFormat`
      self$`featureType` <- `featureType`
      self$`id` <- `id`
      self$`isZeroInflated` <- `isZeroInflated`
      self$`keySummary` <- `keySummary`
      self$`lowInformation` <- `lowInformation`
      self$`max` <- `max`
      self$`mean` <- `mean`
      self$`median` <- `median`
      self$`min` <- `min`
      self$`naCount` <- `naCount`
      self$`name` <- `name`
      self$`stdDev` <- `stdDev`
      self$`timeSeriesEligibilityReason` <- `timeSeriesEligibilityReason`
      self$`timeSeriesEligibilityReasonAggregation` <- `timeSeriesEligibilityReasonAggregation`
      self$`timeSeriesEligible` <- `timeSeriesEligible`
      self$`timeSeriesEligibleAggregation` <- `timeSeriesEligibleAggregation`
      self$`timeStep` <- `timeStep`
      self$`timeStepAggregation` <- `timeStepAggregation`
      self$`timeUnit` <- `timeUnit`
      self$`timeUnitAggregation` <- `timeUnitAggregation`
      self$`uniqueCount` <- `uniqueCount`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    validate = function() {
      props <- list(datasetId = self$`datasetId`, datasetVersionId = self$`datasetVersionId`, dateFormat = self$`dateFormat`, featureType = self$`featureType`, id = self$`id`, isZeroInflated = self$`isZeroInflated`, keySummary = self$`keySummary`, lowInformation = self$`lowInformation`, max = self$`max`, mean = self$`mean`, median = self$`median`, min = self$`min`, naCount = self$`naCount`, name = self$`name`, stdDev = self$`stdDev`, timeSeriesEligibilityReason = self$`timeSeriesEligibilityReason`, timeSeriesEligibilityReasonAggregation = self$`timeSeriesEligibilityReasonAggregation`, timeSeriesEligible = self$`timeSeriesEligible`, timeSeriesEligibleAggregation = self$`timeSeriesEligibleAggregation`, timeStep = self$`timeStep`, timeStepAggregation = self$`timeStepAggregation`, timeUnit = self$`timeUnit`, timeUnitAggregation = self$`timeUnitAggregation`, uniqueCount = self$`uniqueCount`)
      do.call(private$validateProps, props)
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`datasetId`)) {
          sprintf(
            '"datasetId":
            "%s"
                  ',
            self$`datasetId`
          )
        },
        if (!is.null(self$`datasetVersionId`)) {
          sprintf(
            '"datasetVersionId":
            "%s"
                  ',
            self$`datasetVersionId`
          )
        },
        if (!is.null(self$`dateFormat`)) {
          sprintf(
            '"dateFormat":
            "%s"
                  ',
            self$`dateFormat`
          )
        },
        if (!is.null(self$`featureType`)) {
          sprintf(
            '"featureType":
            "%s"
                  ',
            self$`featureType`
          )
        },
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                  ',
            self$`id`
          )
        },
        if (!is.null(self$`isZeroInflated`)) {
          sprintf(
            '"isZeroInflated":
            %s
                  ',
            tolower(self$`isZeroInflated`)
          )
        },
        if (!is.null(self$`keySummary`)) {
          sprintf(
            '"keySummary":
          %s
        ',
          )
        },
        if (!is.null(self$`lowInformation`)) {
          sprintf(
            '"lowInformation":
            %s
                  ',
            tolower(self$`lowInformation`)
          )
        },
        if (!is.null(self$`max`)) {
          sprintf(
            '"max":
            %d
                  ',
            self$`max`
          )
        },
        if (!is.null(self$`mean`)) {
          sprintf(
            '"mean":
            %d
                  ',
            self$`mean`
          )
        },
        if (!is.null(self$`median`)) {
          sprintf(
            '"median":
            %d
                  ',
            self$`median`
          )
        },
        if (!is.null(self$`min`)) {
          sprintf(
            '"min":
            %d
                  ',
            self$`min`
          )
        },
        if (!is.null(self$`naCount`)) {
          sprintf(
            '"naCount":
            %d
                  ',
            self$`naCount`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                  ',
            self$`name`
          )
        },
        if (!is.null(self$`stdDev`)) {
          sprintf(
            '"stdDev":
            %d
                  ',
            self$`stdDev`
          )
        },
        if (!is.null(self$`timeSeriesEligibilityReason`)) {
          sprintf(
            '"timeSeriesEligibilityReason":
            "%s"
                  ',
            self$`timeSeriesEligibilityReason`
          )
        },
        if (!is.null(self$`timeSeriesEligibilityReasonAggregation`)) {
          sprintf(
            '"timeSeriesEligibilityReasonAggregation":
            "%s"
                  ',
            self$`timeSeriesEligibilityReasonAggregation`
          )
        },
        if (!is.null(self$`timeSeriesEligible`)) {
          sprintf(
            '"timeSeriesEligible":
            %s
                  ',
            tolower(self$`timeSeriesEligible`)
          )
        },
        if (!is.null(self$`timeSeriesEligibleAggregation`)) {
          sprintf(
            '"timeSeriesEligibleAggregation":
            %s
                  ',
            tolower(self$`timeSeriesEligibleAggregation`)
          )
        },
        if (!is.null(self$`timeStep`)) {
          sprintf(
            '"timeStep":
            %d
                  ',
            self$`timeStep`
          )
        },
        if (!is.null(self$`timeStepAggregation`)) {
          sprintf(
            '"timeStepAggregation":
            %d
                  ',
            self$`timeStepAggregation`
          )
        },
        if (!is.null(self$`timeUnit`)) {
          sprintf(
            '"timeUnit":
            "%s"
                  ',
            self$`timeUnit`
          )
        },
        if (!is.null(self$`timeUnitAggregation`)) {
          sprintf(
            '"timeUnitAggregation":
            "%s"
                  ',
            self$`timeUnitAggregation`
          )
        },
        if (!is.null(self$`uniqueCount`)) {
          sprintf(
            '"uniqueCount":
            %d
                  ',
            self$`uniqueCount`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param DatasetFeatureResponseJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(DatasetFeatureResponseJson, validateParams = FALSE) {
      DatasetFeatureResponseObject <- jsonlite::fromJSON(DatasetFeatureResponseJson)
      self$`datasetId` <- DatasetFeatureResponseObject$`datasetId`
      self$`datasetVersionId` <- DatasetFeatureResponseObject$`datasetVersionId`
      self$`dateFormat` <- DatasetFeatureResponseObject$`dateFormat`
      self$`featureType` <- DatasetFeatureResponseObject$`featureType`
      self$`id` <- DatasetFeatureResponseObject$`id`
      self$`isZeroInflated` <- DatasetFeatureResponseObject$`isZeroInflated`
      self$`lowInformation` <- DatasetFeatureResponseObject$`lowInformation`
      self$`max` <- DatasetFeatureResponseObject$`max`
      self$`mean` <- DatasetFeatureResponseObject$`mean`
      self$`median` <- DatasetFeatureResponseObject$`median`
      self$`min` <- DatasetFeatureResponseObject$`min`
      self$`naCount` <- DatasetFeatureResponseObject$`naCount`
      self$`name` <- DatasetFeatureResponseObject$`name`
      self$`stdDev` <- DatasetFeatureResponseObject$`stdDev`
      self$`timeSeriesEligibilityReason` <- DatasetFeatureResponseObject$`timeSeriesEligibilityReason`
      self$`timeSeriesEligibilityReasonAggregation` <- DatasetFeatureResponseObject$`timeSeriesEligibilityReasonAggregation`
      self$`timeSeriesEligible` <- DatasetFeatureResponseObject$`timeSeriesEligible`
      self$`timeSeriesEligibleAggregation` <- DatasetFeatureResponseObject$`timeSeriesEligibleAggregation`
      self$`timeStep` <- DatasetFeatureResponseObject$`timeStep`
      self$`timeStepAggregation` <- DatasetFeatureResponseObject$`timeStepAggregation`
      self$`timeUnit` <- DatasetFeatureResponseObject$`timeUnit`
      self$`timeUnitAggregation` <- DatasetFeatureResponseObject$`timeUnitAggregation`
      self$`uniqueCount` <- DatasetFeatureResponseObject$`uniqueCount`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
