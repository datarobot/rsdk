# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Aim
#'
#' @description Aim Class
#'
#' @format An \code{R6Class} generator object
#'
#' @field accuracyOptimizedMb  character [optional] Include additional, longer-running models that will be run by the autopilot and available to run manually.
#'
#' @field aggregationType  character [optional] For multiseries projects only. The aggregation type to apply when creating cross-series features.
#'
#' @field allowPartialHistoryTimeSeriesPredictions  character [optional] Specifies whether the time series predictions can use partial historical data.
#'
#' @field allowedPairwiseInteractionGroups  list( \link{array[character]} ) [optional] For GAM models - specify groups of columns for which pairwise interactions will be allowed. E.g. if set to [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], [&#39;C&#39;, &#39;D&#39;] ] then GAM models will allow interactions between columns AxB, BxC, AxC, CxD. All others (AxD, BxD) will not be considered. If not specified - all possible interactions will be considered by model.
#'
#' @field autopilotClusterList  list( integer ) [optional] A list of integers where each value will be used as the number of clusters in Autopilot model(s) for unsupervised clustering projects. Cannot be specified unless &#x60;unsupervisedMode&#x60; is true and &#x60;unsupervisedType&#x60; is set to &#x60;clustering&#x60;.
#'
#' @field autopilotDataSamplingMethod  character [optional] Defines how autopilot will select subsample from training dataset in OTV/TS projects. Defaults to &#39;latest&#39; for &#39;rowCount&#39; dataSelectionMethod and to &#39;random&#39; for &#39;duration&#39;.
#'
#' @field autopilotDataSelectionMethod  character The Data Selection method to be used by autopilot when creating models for datetime-partitioned datasets.
#'
#' @field autopilotWithFeatureDiscovery  character [optional] If true, autopilot will run on a feature list that includes features found via search for interactions.
#'
#' @field backtests  list( \link{Backtest} ) [optional] An array specifying the format of the backtests.
#'
#' @field biasMitigationFeatureName  character [optional] The name of the protected feature used to mitigate bias on models.
#'
#' @field biasMitigationTechnique  character [optional] Method applied to perform bias mitigation.
#'
#' @field blendBestModels  character [optional] Blend best models during Autopilot run. This option is not supported in SHAP-only mode or for multilabel projects.
#'
#' @field blueprintThreshold  integer [optional] The runtime (in hours) which if exceeded will exclude a model from autopilot runs.
#'
#' @field calendarId  character [optional] The ID of the calendar to be used in this project.
#'
#' @field classMappingAggregationSettings  \link{ClassMappingAggregationSettings} [optional]
#'
#' @field considerBlendersInRecommendation  character [optional] Include blenders when selecting a model to prepare for deployment in an Autopilot Run. This option is not supported in SHAP-only mode or for multilabel projects.
#'
#' @field credentials  list( \link{OneOfPasswordCredentialsCredentialId} ) [optional] List of credentials for the secondary datasets used in feature discovery project.
#'
#' @field crossSeriesGroupByColumns  list( character ) [optional] For multiseries projects with cross-series features enabled only. List of columns (currently of length 1). Setting that indicates how to further split series into related groups. For example, if every series is sales of an individual product, the series group-by could be the product category with values like \&quot;men&#39;s clothing\&quot;, \&quot;sports equipment\&quot;, etc.
#'
#' @field cvHoldoutLevel  \link{AnyOfstringintegernumber} [optional] The value of the partition column indicating a row is part of the holdout set. This level is optional - if not specified or if provided as &#x60;&#x60;null&#x60;&#x60;, then no holdout will be used in the project. The rest of the levels indicate which cross validation fold each row should fall into.
#'
#' @field cvMethod  character [optional] The partitioning method to be applied to the training data.
#'
#' @field dateRemoval  character [optional] If true, enable creating additional feature lists without dates (does not apply to time-aware projects).
#'
#' @field datetimePartitionColumn  character [optional] The date column that will be used as a datetime partition column.
#'
#' @field defaultToAPriori  character [optional] Renamed to &#x60;defaultToKnownInAdvance&#x60;.
#'
#' @field defaultToDoNotDerive  character [optional] For time series projects only. Sets whether all features default to being treated as do-not-derive features, excluding them from feature derivation. Individual features can be set to a value different than the default by using the &#x60;featureSettings&#x60; parameter.
#'
#' @field defaultToKnownInAdvance  character [optional] For time series projects only. Sets whether all features default to being treated as known in advance features, which are features that are known into the future. Features marked as known in advance must be specified into the future when making predictions. The default is false, all features are not known in advance. Individual features can be set to a value different than the default using the &#x60;featureSettings&#x60; parameter. See the :ref:&#x60;Time Series Overview &lt;time_series_overview&gt;&#x60; for more context.
#'
#' @field differencingMethod  character [optional] For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems &#x60;simple&#x60; and &#x60;seasonal&#x60; are not allowed. Parameter &#x60;periodicities&#x60; must be specified if &#x60;seasonal&#x60; is chosen. Defaults to &#x60;auto&#x60;.
#'
#' @field disableHoldout  character [optional] Whether to suppress allocating a holdout fold. If &#x60;disableHoldout&#x60; is set to true, &#x60;holdoutStartDate&#x60; and &#x60;holdoutDuration&#x60; must not be set.
#'
#' @field eventsCount  character [optional] The name of a column specifying events count. The data in this column must be pure numeric and non negative without missing values
#'
#' @field exponentiallyWeightedMovingAlpha  numeric [optional] Discount factor (alpha) used for exponentially weighted moving features
#'
#' @field exposure  character [optional] The name of a column specifying row exposure.The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
#'
#' @field externalPredictions  list( character ) [optional] List of external prediction columns from the dataset.
#'
#' @field externalTimeSeriesBaselineDatasetId  character [optional] Catalog version id for external prediction data that can be used as a baseline to calculate new metrics.
#'
#' @field externalTimeSeriesBaselineDatasetName  character [optional] The name of the time series baseline dataset for the project.
#'
#' @field fairnessMetricsSet  character [optional] Metric to use for calculating fairness. Can be one of &#x60;&#x60;proportionalParity&#x60;&#x60;, &#x60;&#x60;equalParity&#x60;&#x60;, &#x60;&#x60;predictionBalance&#x60;&#x60;, &#x60;&#x60;trueFavorableAndUnfavorableRateParity&#x60;&#x60; or &#x60;&#x60;FavorableAndUnfavorablePredictiveValueParity&#x60;&#x60;. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
#'
#' @field fairnessThreshold  numeric [optional] Threshold value of the fairness metric. Can be in a range of &#x60;&#x60;[0:1]&#x60;&#x60;. If the actual metric value is below the threshold, the user will be notified
#'
#' @field featureDerivationWindowEnd  integer [optional] For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should end.
#'
#' @field featureDerivationWindowStart  integer [optional] For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should begin.
#'
#' @field featureDiscoverySupervisedFeatureReduction  character [optional] Run supervised feature reduction for feature discovery projects.
#'
#' @field featureEngineeringPredictionPoint  character [optional] The date column to be used as prediction point for time-based feature engineering.
#'
#' @field featureSettings  list( \link{FeatureSetting} ) [optional] An array specifying per feature settings. Features can be left unspecified.
#'
#' @field featurelistId  character [optional] The ID of a featurelist to use for autopilot.
#'
#' @field forecastWindowEnd  integer [optional] For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should end.
#'
#' @field forecastWindowStart  integer [optional] For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should start.
#'
#' @field gapDuration  character [optional] The duration of the gap between holdout training and holdout scoring data. For time series projects, defaults to the duration of the gap between the end of the feature derivation window and the beginning of the forecast window. For OTV projects, defaults to a zero duration (P0Y0M0D).
#'
#' @field holdoutDuration  character [optional] The duration of holdout scoring data. When specifying &#x60;holdoutDuration&#x60;, &#x60;holdoutStartDate&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
#'
#' @field holdoutEndDate  character [optional] The end date of holdout scoring data. When specifying &#x60;holdoutEndDate&#x60;, &#x60;holdoutStartDate&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
#'
#' @field holdoutLevel  \link{AnyOfstringintegernumber} [optional] The value of the partition column indicating a row is part of the holdout set. This level is optional - if not specified or if provided as &#x60;&#x60;null&#x60;&#x60;, then no holdout will be used in the project. However, the column must have exactly 2 values in order for this option to be valid
#'
#' @field holdoutPct  numeric [optional] The percentage of the dataset to assign to the holdout set
#'
#' @field holdoutStartDate  character [optional] The start date of holdout scoring data. When specifying &#x60;holdoutStartDate&#x60;, one of &#x60;holdoutEndDate&#x60; or &#x60;holdoutDuration&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
#'
#' @field includeBiasMitigationFeatureAsPredictorVariable  character [optional] Specifies whether the mitigation feature will be used as a predictor variable (i.e., treated like other categorical features in the input to train the modeler), in addition to being used for bias mitigation. If false, the mitigation feature will be used only for bias mitigation, and not for training the modeler task.
#'
#' @field isHoldoutModified  character [optional] A boolean value indicating whether holdout settings (start/end dates) have been modified by user.
#'
#' @field majorityDownsamplingRate  numeric [optional] The percentage between 0 and 100 of the majority rows that should be kept. Must be specified only if using smart downsampling. If not specified, a default will be selected based on the dataset distribution. The chosen rate may not cause the majority class to become smaller than the minority class.
#'
#' @field metric  character [optional] The metric to use to select the best models. See &#x60;/api/v2/projects/(projectId)/features/metrics/&#x60; for the metrics that may be valid for a potential target.  Note that weighted metrics must be used with a weights column.
#'
#' @field minSecondaryValidationModelCount  integer [optional] Compute &#39;All backtest&#39; scores (datetime models) or cross validation scores for the specified number of highest ranking models on the Leaderboard, if over the Autopilot default.
#'
#' @field mode  character [optional] The autopilot mode to use.  Either &#39;quick&#39;, &#39;auto&#39;, &#39;manual&#39; or &#39;comprehensive&#39;
#'
#' @field modelSplits  integer [optional] Sets the cap on the number of jobs per model used when building models to control number of jobs in the queue. Higher number of modelSplits will allow for less downsampling leading to the use of more post-processed data.
#'
#' @field monotonicDecreasingFeaturelistId  character [optional] The ID of the featurelist that defines the set of features with a monotonically decreasing relationship to the target.  If null, no such constraints are enforced. When specified, this will set a default for the project that can be overriden at model submission time if desired.
#'
#' @field monotonicIncreasingFeaturelistId  character [optional] The ID of the featurelist that defines the set of features with a monotonically increasing relationship to the target. If null, no such constraints are enforced. When specified, this will set a default for the project that can be overriden at model submission time if desired.
#'
#' @field multiseriesIdColumns  list( character ) [optional] May be used only with time series projects. An array of the column names identifying  the series to which each row of the dataset belongs. Currently only one multiseries ID column is supported. See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; section of the time series documentation for more context.
#'
#' @field numberOfBacktests  integer [optional] The number of backtests to use. If omitted, defaults to a positive value selected by the server based on the validation and gap durations.
#'
#' @field offset  list( character ) [optional] An array of strings with names of a columns specifying row offsets.The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
#'
#' @field onlyIncludeMonotonicBlueprints  character When true, only blueprints that support enforcing montonic constraints will be available in the project or selected for autopilot.
#'
#' @field partitionKeyCols  list( character ) [optional] An array containing a single string - the name of the group partition column
#'
#' @field periodicities  list( \link{Periodicity} ) [optional] A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter &#39;differencing_method&#39; will default to &#39;seasonal&#39; if not provided or &#39;auto&#39;.
#'
#' @field positiveClass  \link{AnyOfstringintegernumber} [optional] A value from the target column to use for the positive class. May only be specified for projects doing binary classification.If not specified, a positive class is selected automatically.
#'
#' @field preferableTargetValue  \link{AnyOfstringintegernumber} [optional] A target value that should be treated as a positive outcome for the prediction. For example if we want to check gender discrimination for giving a loan and our target named &#x60;&#x60;is_bad&#x60;&#x60;, then the positive outcome for the prediction would be &#x60;&#x60;No&#x60;&#x60;, which means that the loan is good and that&#39;s what we treat as a preferable result for the loaner. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
#'
#' @field prepareModelForDeployment  character [optional] Prepare model for deployment during Autopilot run. The preparation includes creating reduced feature list models, retraining best model on higher sample size, computing insights and assigning &#39;RECOMMENDED FOR DEPLOYMENT&#39; label.
#'
#' @field primaryLocationColumn  character [optional] Primary geospatial location column.
#'
#' @field protectedFeatures  list( character ) [optional] A list of project feature to mark as protected for Bias metric calculation and Fairness correction. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
#'
#' @field quantileLevel  numeric [optional] The quantile level between 0.01 and 0.99 for specifying the Quantile metric.
#'
#' @field quickrun  character [optional] (Deprecated): &#39;quick&#39; should be used in the &#x60;mode&#x60; parameter instead of using this parameter. If set to &#x60;true&#x60;, will use a limited autopilot setting whose goal is to complete more quickly by trying a smaller number of models. Note: quickrun cannot be set to &#x60;true&#x60; when &#x60;mode&#x60; is set to &#39;comprehensive&#39;.
#'
#' @field rateTopPctThreshold  numeric [optional] The percentage threshold between 0.1 and 50 for specifying the Rate@Top% metric.
#'
#' @field relationshipsConfigurationId  character [optional] Relationships configuration id to be used for Feature Discovery projects.
#'
#' @field reps  integer [optional] The number of cross validation folds to use.
#'
#' @field responseCap  numeric [optional] Used to cap the maximum response of a model
#'
#' @field runLeakageRemovedFeatureList  character [optional] Run Autopilot on Leakage Removed feature list (if exists).
#'
#' @field sampleStepPct  numeric [optional] A float between 0 and 100 indicating the desired percentage of data to sample when training models in comprehensive Autopilot. Note: this only supported for comprehensive Autopilot and the specified value may be lowered in order to be compatible with the project&#39;s dataset and partition settings.
#'
#' @field scoringCodeOnly  character [optional] Keep only models that can be converted to scorable java code during Autopilot run.
#'
#' @field seed  integer [optional] A seed to use for randomization.
#'
#' @field segmentationTaskId  character [optional] Specifies the SegmentationTask that will be used for dividing the project up into multiple segmented projects.
#'
#' @field shapOnlyMode  character [optional] Keep only models that support SHAP values during Autopilot run. Use SHAP-based insights wherever possible.
#'
#' @field smartDownsampled  character [optional] Whether to use smart downsampling to throw away excess rows of the majority class. Only applicable to classification and zero-boosted regression projects.
#'
#' @field stopWords  list( character ) [optional] A list of stop words to be used for text blueprints. Note: &#x60;&#x60;stop_words&#x3D;True&#x60;&#x60; must be set in the blueprint preprocessing parameters for this list of stop words to actually be used during preprocessing.
#'
#' @field target  character [optional] The name of the target feature.
#'
#' @field targetType  character [optional] Used to specify the targetType to use for a project when it is ambiguous, i.e. a numeric target with a few unique values that could be used for either regression or multiclass.
#'
#' @field trainingLevel  \link{AnyOfstringintegernumber} [optional] The value of the partition column indicating a row is part of the training set.
#'
#' @field treatAsExponential  character [optional] For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems &#x60;always&#x60; is not allowed.
#'
#' @field unsupervisedMode  character [optional] If True, unsupervised project (without target) will be created. &#x60;&#x60;target&#x60;&#x60; cannot be specified if &#x60;&#x60;unsupervisedMode&#x60;&#x60; is True.
#'
#' @field unsupervisedType  character [optional] The type of unsupervised project. Only valid when &#x60;unsupervisedMode&#x60; is true. If &#x60;unsupervisedMode&#x60;, defaults to &#x60;anomaly&#x60;.
#'
#' @field useCrossSeriesFeatures  character [optional] Indicating if user wants to use cross-series features.
#'
#' @field useProjectSettings  character [optional] Specifies whether datetime-partitioned project should use project settings (i.e. backtests configuration has been modified by the user).
#'
#' @field useSupervisedFeatureReduction  character [optional] When true, during feature generation DataRobot runs a supervised algorithm feature lists using only qualifying features. Setting false can severely impact autopilot duration, especially for datasets with many features.
#'
#' @field useTimeSeries  character [optional] A boolean value indicating whether a time series project should be created instead of a regular project which uses datetime partitioning.
#'
#' @field userPartitionCol  character [optional] The name of the column containing the partition assignments.
#'
#' @field validationDuration  character [optional] The default validation duration for all backtests. If the primary date/time feature in a time series project is irregular, you cannot set a default validation length. Instead, set each duration individually. For an OTV project setting the validation duration will always use regular partitioning. Omitting it will use irregular partitioning if the date/time feature is irregular.
#'
#' @field validationLevel  \link{AnyOfstringintegernumber} [optional] The value of the partition column indicating a row is part of the validation set.
#'
#' @field validationPct  numeric [optional] The percentage of the dataset to assign to the validation set
#'
#' @field validationType  character [optional] The validation method to be used.  CV for cross validation or TVH for train-validation-holdout split.
#'
#' @field weights  character [optional] The name of a column specifying row weights. The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
#'
#' @field windowsBasisUnit  character [optional] For time series projects only. Indicates which unit is basis for feature derivation window and forecast window. Valid options are detected time unit or &#x60;ROW&#x60;. If omitted, the default value is detected time unit.
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
Aim <- R6::R6Class(
  "Aim",
  lock_objects = FALSE,
  private = list(
    # @description A helper function to handle assist with type validation. This function will validate class parameters with definite
    # types assigned to them, as well as handling validation of parameters with anyOf and oneOf types listed. These types
    # can themselves be other R6 objects.
    validateProps = function(accuracyOptimizedMb = NULL, aggregationType = NULL, allowPartialHistoryTimeSeriesPredictions = NULL, allowedPairwiseInteractionGroups = NULL, autopilotClusterList = NULL, autopilotDataSamplingMethod = NULL, autopilotDataSelectionMethod = NULL, autopilotWithFeatureDiscovery = NULL, backtests = NULL, biasMitigationFeatureName = NULL, biasMitigationTechnique = NULL, blendBestModels = NULL, blueprintThreshold = NULL, calendarId = NULL, classMappingAggregationSettings = NULL, considerBlendersInRecommendation = NULL, credentials = NULL, crossSeriesGroupByColumns = NULL, cvHoldoutLevel = NULL, cvMethod = NULL, dateRemoval = NULL, datetimePartitionColumn = NULL, defaultToAPriori = NULL, defaultToDoNotDerive = NULL, defaultToKnownInAdvance = NULL, differencingMethod = NULL, disableHoldout = NULL, eventsCount = NULL, exponentiallyWeightedMovingAlpha = NULL, exposure = NULL, externalPredictions = NULL, externalTimeSeriesBaselineDatasetId = NULL, externalTimeSeriesBaselineDatasetName = NULL, fairnessMetricsSet = NULL, fairnessThreshold = NULL, featureDerivationWindowEnd = NULL, featureDerivationWindowStart = NULL, featureDiscoverySupervisedFeatureReduction = NULL, featureEngineeringPredictionPoint = NULL, featureSettings = NULL, featurelistId = NULL, forecastWindowEnd = NULL, forecastWindowStart = NULL, gapDuration = NULL, holdoutDuration = NULL, holdoutEndDate = NULL, holdoutLevel = NULL, holdoutPct = NULL, holdoutStartDate = NULL, includeBiasMitigationFeatureAsPredictorVariable = NULL, isHoldoutModified = NULL, majorityDownsamplingRate = NULL, metric = NULL, minSecondaryValidationModelCount = NULL, mode = NULL, modelSplits = NULL, monotonicDecreasingFeaturelistId = NULL, monotonicIncreasingFeaturelistId = NULL, multiseriesIdColumns = NULL, numberOfBacktests = NULL, offset = NULL, onlyIncludeMonotonicBlueprints = NULL, partitionKeyCols = NULL, periodicities = NULL, positiveClass = NULL, preferableTargetValue = NULL, prepareModelForDeployment = NULL, primaryLocationColumn = NULL, protectedFeatures = NULL, quantileLevel = NULL, quickrun = NULL, rateTopPctThreshold = NULL, relationshipsConfigurationId = NULL, reps = NULL, responseCap = NULL, runLeakageRemovedFeatureList = NULL, sampleStepPct = NULL, scoringCodeOnly = NULL, seed = NULL, segmentationTaskId = NULL, shapOnlyMode = NULL, smartDownsampled = NULL, stopWords = NULL, target = NULL, targetType = NULL, trainingLevel = NULL, treatAsExponential = NULL, unsupervisedMode = NULL, unsupervisedType = NULL, useCrossSeriesFeatures = NULL, useProjectSettings = NULL, useSupervisedFeatureReduction = NULL, useTimeSeries = NULL, userPartitionCol = NULL, validationDuration = NULL, validationLevel = NULL, validationPct = NULL, validationType = NULL, weights = NULL, windowsBasisUnit = NULL) {
      if (!is.null(`autopilotDataSelectionMethod`)) {
        stopifnot(is.character(`autopilotDataSelectionMethod`), length(`autopilotDataSelectionMethod`) == 1)
      }
      if (!is.null(`onlyIncludeMonotonicBlueprints`)) {
        stopifnot(is.logical(`onlyIncludeMonotonicBlueprints`), length(`onlyIncludeMonotonicBlueprints`) == 1)
      }
      if (!is.null(`accuracyOptimizedMb`)) {
        stopifnot(is.logical(`accuracyOptimizedMb`), length(`accuracyOptimizedMb`) == 1)
      }
      if (!is.null(`aggregationType`)) {
        stopifnot(is.character(`aggregationType`), length(`aggregationType`) == 1)
      }
      if (!is.null(`allowPartialHistoryTimeSeriesPredictions`)) {
        stopifnot(is.logical(`allowPartialHistoryTimeSeriesPredictions`), length(`allowPartialHistoryTimeSeriesPredictions`) == 1)
      }
      if (!is.null(`allowedPairwiseInteractionGroups`)) {
        stopifnot(is.vector(`allowedPairwiseInteractionGroups`))
      }
      if (!is.null(`autopilotClusterList`)) {
        stopifnot(is.vector(`autopilotClusterList`))
      }
      if (!is.null(`autopilotDataSamplingMethod`)) {
        stopifnot(is.character(`autopilotDataSamplingMethod`), length(`autopilotDataSamplingMethod`) == 1)
      }
      if (!is.null(`autopilotWithFeatureDiscovery`)) {
        stopifnot(is.logical(`autopilotWithFeatureDiscovery`), length(`autopilotWithFeatureDiscovery`) == 1)
      }
      if (!is.null(`backtests`)) {
        stopifnot(is.vector(`backtests`))
      }
      if (!is.null(`biasMitigationFeatureName`)) {
        stopifnot(is.character(`biasMitigationFeatureName`), length(`biasMitigationFeatureName`) == 1)
      }
      if (!is.null(`biasMitigationTechnique`)) {
        stopifnot(is.character(`biasMitigationTechnique`), length(`biasMitigationTechnique`) == 1)
      }
      if (!is.null(`blendBestModels`)) {
        stopifnot(is.logical(`blendBestModels`), length(`blendBestModels`) == 1)
      }
      if (!is.null(`blueprintThreshold`)) {
        stopifnot(is.numeric(`blueprintThreshold`), length(`blueprintThreshold`) == 1)
      }
      if (!is.null(`calendarId`)) {
        stopifnot(is.character(`calendarId`), length(`calendarId`) == 1)
      }
      if (!is.null(`classMappingAggregationSettings`)) {
        stopifnot(R6::is.R6(`classMappingAggregationSettings`))
      }
      if (!is.null(`considerBlendersInRecommendation`)) {
        stopifnot(is.logical(`considerBlendersInRecommendation`), length(`considerBlendersInRecommendation`) == 1)
      }
      if (!is.null(`credentials`)) {
        .setComplexProperty(typeList = list(PasswordCredentials, CredentialId), propertyData = credentials)
      }
      if (!is.null(`crossSeriesGroupByColumns`)) {
        stopifnot(is.vector(`crossSeriesGroupByColumns`))
      }
      if (!is.null(`cvHoldoutLevel`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = cvHoldoutLevel)
      }
      if (!is.null(`cvMethod`)) {
        stopifnot(is.character(`cvMethod`), length(`cvMethod`) == 1)
      }
      if (!is.null(`dateRemoval`)) {
        stopifnot(is.logical(`dateRemoval`), length(`dateRemoval`) == 1)
      }
      if (!is.null(`datetimePartitionColumn`)) {
        stopifnot(is.character(`datetimePartitionColumn`), length(`datetimePartitionColumn`) == 1)
      }
      if (!is.null(`defaultToAPriori`)) {
        stopifnot(is.logical(`defaultToAPriori`), length(`defaultToAPriori`) == 1)
      }
      if (!is.null(`defaultToDoNotDerive`)) {
        stopifnot(is.logical(`defaultToDoNotDerive`), length(`defaultToDoNotDerive`) == 1)
      }
      if (!is.null(`defaultToKnownInAdvance`)) {
        stopifnot(is.logical(`defaultToKnownInAdvance`), length(`defaultToKnownInAdvance`) == 1)
      }
      if (!is.null(`differencingMethod`)) {
        stopifnot(is.character(`differencingMethod`), length(`differencingMethod`) == 1)
      }
      if (!is.null(`disableHoldout`)) {
        stopifnot(is.logical(`disableHoldout`), length(`disableHoldout`) == 1)
      }
      if (!is.null(`eventsCount`)) {
        stopifnot(is.character(`eventsCount`), length(`eventsCount`) == 1)
      }
      if (!is.null(`exponentiallyWeightedMovingAlpha`)) {
        stopifnot(is.numeric(`exponentiallyWeightedMovingAlpha`), length(`exponentiallyWeightedMovingAlpha`) == 1)
      }
      if (!is.null(`exposure`)) {
        stopifnot(is.character(`exposure`), length(`exposure`) == 1)
      }
      if (!is.null(`externalPredictions`)) {
        stopifnot(is.vector(`externalPredictions`))
      }
      if (!is.null(`externalTimeSeriesBaselineDatasetId`)) {
        stopifnot(is.character(`externalTimeSeriesBaselineDatasetId`), length(`externalTimeSeriesBaselineDatasetId`) == 1)
      }
      if (!is.null(`externalTimeSeriesBaselineDatasetName`)) {
        stopifnot(is.character(`externalTimeSeriesBaselineDatasetName`), length(`externalTimeSeriesBaselineDatasetName`) == 1)
      }
      if (!is.null(`fairnessMetricsSet`)) {
        stopifnot(is.character(`fairnessMetricsSet`), length(`fairnessMetricsSet`) == 1)
      }
      if (!is.null(`fairnessThreshold`)) {
        stopifnot(is.numeric(`fairnessThreshold`), length(`fairnessThreshold`) == 1)
      }
      if (!is.null(`featureDerivationWindowEnd`)) {
        stopifnot(is.numeric(`featureDerivationWindowEnd`), length(`featureDerivationWindowEnd`) == 1)
      }
      if (!is.null(`featureDerivationWindowStart`)) {
        stopifnot(is.numeric(`featureDerivationWindowStart`), length(`featureDerivationWindowStart`) == 1)
      }
      if (!is.null(`featureDiscoverySupervisedFeatureReduction`)) {
        stopifnot(is.logical(`featureDiscoverySupervisedFeatureReduction`), length(`featureDiscoverySupervisedFeatureReduction`) == 1)
      }
      if (!is.null(`featureEngineeringPredictionPoint`)) {
        stopifnot(is.character(`featureEngineeringPredictionPoint`), length(`featureEngineeringPredictionPoint`) == 1)
      }
      if (!is.null(`featureSettings`)) {
        stopifnot(is.vector(`featureSettings`))
      }
      if (!is.null(`featurelistId`)) {
        stopifnot(is.character(`featurelistId`), length(`featurelistId`) == 1)
      }
      if (!is.null(`forecastWindowEnd`)) {
        stopifnot(is.numeric(`forecastWindowEnd`), length(`forecastWindowEnd`) == 1)
      }
      if (!is.null(`forecastWindowStart`)) {
        stopifnot(is.numeric(`forecastWindowStart`), length(`forecastWindowStart`) == 1)
      }
      if (!is.null(`gapDuration`)) {
        stopifnot(is.character(`gapDuration`), length(`gapDuration`) == 1)
      }
      if (!is.null(`holdoutDuration`)) {
        stopifnot(is.character(`holdoutDuration`), length(`holdoutDuration`) == 1)
      }
      if (!is.null(`holdoutEndDate`)) {
        stopifnot(inherits(`holdoutEndDate`, "POSIXt"))
      }
      if (!is.null(`holdoutLevel`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = holdoutLevel)
      }
      if (!is.null(`holdoutPct`)) {
        stopifnot(is.numeric(`holdoutPct`), length(`holdoutPct`) == 1)
      }
      if (!is.null(`holdoutStartDate`)) {
        stopifnot(inherits(`holdoutStartDate`, "POSIXt"))
      }
      if (!is.null(`includeBiasMitigationFeatureAsPredictorVariable`)) {
        stopifnot(is.logical(`includeBiasMitigationFeatureAsPredictorVariable`), length(`includeBiasMitigationFeatureAsPredictorVariable`) == 1)
      }
      if (!is.null(`isHoldoutModified`)) {
        stopifnot(is.logical(`isHoldoutModified`), length(`isHoldoutModified`) == 1)
      }
      if (!is.null(`majorityDownsamplingRate`)) {
        stopifnot(is.numeric(`majorityDownsamplingRate`), length(`majorityDownsamplingRate`) == 1)
      }
      if (!is.null(`metric`)) {
        stopifnot(is.character(`metric`), length(`metric`) == 1)
      }
      if (!is.null(`minSecondaryValidationModelCount`)) {
        stopifnot(is.numeric(`minSecondaryValidationModelCount`), length(`minSecondaryValidationModelCount`) == 1)
      }
      if (!is.null(`mode`)) {
        stopifnot(is.character(`mode`), length(`mode`) == 1)
      }
      if (!is.null(`modelSplits`)) {
        stopifnot(is.numeric(`modelSplits`), length(`modelSplits`) == 1)
      }
      if (!is.null(`monotonicDecreasingFeaturelistId`)) {
        stopifnot(is.character(`monotonicDecreasingFeaturelistId`), length(`monotonicDecreasingFeaturelistId`) == 1)
      }
      if (!is.null(`monotonicIncreasingFeaturelistId`)) {
        stopifnot(is.character(`monotonicIncreasingFeaturelistId`), length(`monotonicIncreasingFeaturelistId`) == 1)
      }
      if (!is.null(`multiseriesIdColumns`)) {
        stopifnot(is.vector(`multiseriesIdColumns`))
      }
      if (!is.null(`numberOfBacktests`)) {
        stopifnot(is.numeric(`numberOfBacktests`), length(`numberOfBacktests`) == 1)
      }
      if (!is.null(`offset`)) {
        stopifnot(is.vector(`offset`))
      }
      if (!is.null(`partitionKeyCols`)) {
        stopifnot(is.vector(`partitionKeyCols`))
      }
      if (!is.null(`periodicities`)) {
        stopifnot(is.vector(`periodicities`))
      }
      if (!is.null(`positiveClass`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = positiveClass)
      }
      if (!is.null(`preferableTargetValue`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = preferableTargetValue)
      }
      if (!is.null(`prepareModelForDeployment`)) {
        stopifnot(is.logical(`prepareModelForDeployment`), length(`prepareModelForDeployment`) == 1)
      }
      if (!is.null(`primaryLocationColumn`)) {
        stopifnot(is.character(`primaryLocationColumn`), length(`primaryLocationColumn`) == 1)
      }
      if (!is.null(`protectedFeatures`)) {
        stopifnot(is.vector(`protectedFeatures`))
      }
      if (!is.null(`quantileLevel`)) {
        stopifnot(is.numeric(`quantileLevel`), length(`quantileLevel`) == 1)
      }
      if (!is.null(`quickrun`)) {
        stopifnot(is.logical(`quickrun`), length(`quickrun`) == 1)
      }
      if (!is.null(`rateTopPctThreshold`)) {
        stopifnot(is.numeric(`rateTopPctThreshold`), length(`rateTopPctThreshold`) == 1)
      }
      if (!is.null(`relationshipsConfigurationId`)) {
        stopifnot(is.character(`relationshipsConfigurationId`), length(`relationshipsConfigurationId`) == 1)
      }
      if (!is.null(`reps`)) {
        stopifnot(is.numeric(`reps`), length(`reps`) == 1)
      }
      if (!is.null(`responseCap`)) {
        stopifnot(is.numeric(`responseCap`), length(`responseCap`) == 1)
      }
      if (!is.null(`runLeakageRemovedFeatureList`)) {
        stopifnot(is.logical(`runLeakageRemovedFeatureList`), length(`runLeakageRemovedFeatureList`) == 1)
      }
      if (!is.null(`sampleStepPct`)) {
        stopifnot(is.numeric(`sampleStepPct`), length(`sampleStepPct`) == 1)
      }
      if (!is.null(`scoringCodeOnly`)) {
        stopifnot(is.logical(`scoringCodeOnly`), length(`scoringCodeOnly`) == 1)
      }
      if (!is.null(`seed`)) {
        stopifnot(is.numeric(`seed`), length(`seed`) == 1)
      }
      if (!is.null(`segmentationTaskId`)) {
        stopifnot(is.character(`segmentationTaskId`), length(`segmentationTaskId`) == 1)
      }
      if (!is.null(`shapOnlyMode`)) {
        stopifnot(is.logical(`shapOnlyMode`), length(`shapOnlyMode`) == 1)
      }
      if (!is.null(`smartDownsampled`)) {
        stopifnot(is.logical(`smartDownsampled`), length(`smartDownsampled`) == 1)
      }
      if (!is.null(`stopWords`)) {
        stopifnot(is.vector(`stopWords`))
      }
      if (!is.null(`target`)) {
        stopifnot(is.character(`target`), length(`target`) == 1)
      }
      if (!is.null(`targetType`)) {
        stopifnot(is.character(`targetType`), length(`targetType`) == 1)
      }
      if (!is.null(`trainingLevel`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = trainingLevel)
      }
      if (!is.null(`treatAsExponential`)) {
        stopifnot(is.character(`treatAsExponential`), length(`treatAsExponential`) == 1)
      }
      if (!is.null(`unsupervisedMode`)) {
        stopifnot(is.logical(`unsupervisedMode`), length(`unsupervisedMode`) == 1)
      }
      if (!is.null(`unsupervisedType`)) {
        stopifnot(is.character(`unsupervisedType`), length(`unsupervisedType`) == 1)
      }
      if (!is.null(`useCrossSeriesFeatures`)) {
        stopifnot(is.logical(`useCrossSeriesFeatures`), length(`useCrossSeriesFeatures`) == 1)
      }
      if (!is.null(`useProjectSettings`)) {
        stopifnot(is.logical(`useProjectSettings`), length(`useProjectSettings`) == 1)
      }
      if (!is.null(`useSupervisedFeatureReduction`)) {
        stopifnot(is.logical(`useSupervisedFeatureReduction`), length(`useSupervisedFeatureReduction`) == 1)
      }
      if (!is.null(`useTimeSeries`)) {
        stopifnot(is.logical(`useTimeSeries`), length(`useTimeSeries`) == 1)
      }
      if (!is.null(`userPartitionCol`)) {
        stopifnot(is.character(`userPartitionCol`), length(`userPartitionCol`) == 1)
      }
      if (!is.null(`validationDuration`)) {
        stopifnot(is.character(`validationDuration`), length(`validationDuration`) == 1)
      }
      if (!is.null(`validationLevel`)) {
        .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = validationLevel)
      }
      if (!is.null(`validationPct`)) {
        stopifnot(is.numeric(`validationPct`), length(`validationPct`) == 1)
      }
      if (!is.null(`validationType`)) {
        stopifnot(is.character(`validationType`), length(`validationType`) == 1)
      }
      if (!is.null(`weights`)) {
        stopifnot(is.character(`weights`), length(`weights`) == 1)
      }
      if (!is.null(`windowsBasisUnit`)) {
        stopifnot(is.character(`windowsBasisUnit`), length(`windowsBasisUnit`) == 1)
      }
    }
  ),
  public = list(
    `accuracyOptimizedMb` = NULL,
    `aggregationType` = NULL,
    `allowPartialHistoryTimeSeriesPredictions` = NULL,
    `allowedPairwiseInteractionGroups` = NULL,
    `autopilotClusterList` = NULL,
    `autopilotDataSamplingMethod` = NULL,
    `autopilotDataSelectionMethod` = NULL,
    `autopilotWithFeatureDiscovery` = NULL,
    `backtests` = NULL,
    `biasMitigationFeatureName` = NULL,
    `biasMitigationTechnique` = NULL,
    `blendBestModels` = NULL,
    `blueprintThreshold` = NULL,
    `calendarId` = NULL,
    `classMappingAggregationSettings` = NULL,
    `considerBlendersInRecommendation` = NULL,
    `credentials` = NULL,
    `crossSeriesGroupByColumns` = NULL,
    `cvHoldoutLevel` = NULL,
    `cvMethod` = NULL,
    `dateRemoval` = NULL,
    `datetimePartitionColumn` = NULL,
    `defaultToAPriori` = NULL,
    `defaultToDoNotDerive` = NULL,
    `defaultToKnownInAdvance` = NULL,
    `differencingMethod` = NULL,
    `disableHoldout` = NULL,
    `eventsCount` = NULL,
    `exponentiallyWeightedMovingAlpha` = NULL,
    `exposure` = NULL,
    `externalPredictions` = NULL,
    `externalTimeSeriesBaselineDatasetId` = NULL,
    `externalTimeSeriesBaselineDatasetName` = NULL,
    `fairnessMetricsSet` = NULL,
    `fairnessThreshold` = NULL,
    `featureDerivationWindowEnd` = NULL,
    `featureDerivationWindowStart` = NULL,
    `featureDiscoverySupervisedFeatureReduction` = NULL,
    `featureEngineeringPredictionPoint` = NULL,
    `featureSettings` = NULL,
    `featurelistId` = NULL,
    `forecastWindowEnd` = NULL,
    `forecastWindowStart` = NULL,
    `gapDuration` = NULL,
    `holdoutDuration` = NULL,
    `holdoutEndDate` = NULL,
    `holdoutLevel` = NULL,
    `holdoutPct` = NULL,
    `holdoutStartDate` = NULL,
    `includeBiasMitigationFeatureAsPredictorVariable` = NULL,
    `isHoldoutModified` = NULL,
    `majorityDownsamplingRate` = NULL,
    `metric` = NULL,
    `minSecondaryValidationModelCount` = NULL,
    `mode` = NULL,
    `modelSplits` = NULL,
    `monotonicDecreasingFeaturelistId` = NULL,
    `monotonicIncreasingFeaturelistId` = NULL,
    `multiseriesIdColumns` = NULL,
    `numberOfBacktests` = NULL,
    `offset` = NULL,
    `onlyIncludeMonotonicBlueprints` = NULL,
    `partitionKeyCols` = NULL,
    `periodicities` = NULL,
    `positiveClass` = NULL,
    `preferableTargetValue` = NULL,
    `prepareModelForDeployment` = NULL,
    `primaryLocationColumn` = NULL,
    `protectedFeatures` = NULL,
    `quantileLevel` = NULL,
    `quickrun` = NULL,
    `rateTopPctThreshold` = NULL,
    `relationshipsConfigurationId` = NULL,
    `reps` = NULL,
    `responseCap` = NULL,
    `runLeakageRemovedFeatureList` = NULL,
    `sampleStepPct` = NULL,
    `scoringCodeOnly` = NULL,
    `seed` = NULL,
    `segmentationTaskId` = NULL,
    `shapOnlyMode` = NULL,
    `smartDownsampled` = NULL,
    `stopWords` = NULL,
    `target` = NULL,
    `targetType` = NULL,
    `trainingLevel` = NULL,
    `treatAsExponential` = NULL,
    `unsupervisedMode` = NULL,
    `unsupervisedType` = NULL,
    `useCrossSeriesFeatures` = NULL,
    `useProjectSettings` = NULL,
    `useSupervisedFeatureReduction` = NULL,
    `useTimeSeries` = NULL,
    `userPartitionCol` = NULL,
    `validationDuration` = NULL,
    `validationLevel` = NULL,
    `validationPct` = NULL,
    `validationType` = NULL,
    `weights` = NULL,
    `windowsBasisUnit` = NULL,
    #' @description A function used to initialize an instance of this class.
    #' @param accuracyOptimizedMb Include additional, longer-running models that will be run by the autopilot and available to run manually.
    #' @param aggregationType For multiseries projects only. The aggregation type to apply when creating cross-series features.
    #' @param allowPartialHistoryTimeSeriesPredictions Specifies whether the time series predictions can use partial historical data.
    #' @param allowedPairwiseInteractionGroups For GAM models - specify groups of columns for which pairwise interactions will be allowed. E.g. if set to [[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], [&#39;C&#39;, &#39;D&#39;] ] then GAM models will allow interactions between columns AxB, BxC, AxC, CxD. All others (AxD, BxD) will not be considered. If not specified - all possible interactions will be considered by model.
    #' @param autopilotClusterList A list of integers where each value will be used as the number of clusters in Autopilot model(s) for unsupervised clustering projects. Cannot be specified unless &#x60;unsupervisedMode&#x60; is true and &#x60;unsupervisedType&#x60; is set to &#x60;clustering&#x60;.
    #' @param autopilotDataSamplingMethod Defines how autopilot will select subsample from training dataset in OTV/TS projects. Defaults to &#39;latest&#39; for &#39;rowCount&#39; dataSelectionMethod and to &#39;random&#39; for &#39;duration&#39;.
    #' @param autopilotDataSelectionMethod The Data Selection method to be used by autopilot when creating models for datetime-partitioned datasets.
    #' @param autopilotWithFeatureDiscovery If true, autopilot will run on a feature list that includes features found via search for interactions.
    #' @param backtests An array specifying the format of the backtests.
    #' @param biasMitigationFeatureName The name of the protected feature used to mitigate bias on models.
    #' @param biasMitigationTechnique Method applied to perform bias mitigation.
    #' @param blendBestModels Blend best models during Autopilot run. This option is not supported in SHAP-only mode or for multilabel projects.
    #' @param blueprintThreshold The runtime (in hours) which if exceeded will exclude a model from autopilot runs.
    #' @param calendarId The ID of the calendar to be used in this project.
    #' @param classMappingAggregationSettings
    #' @param considerBlendersInRecommendation Include blenders when selecting a model to prepare for deployment in an Autopilot Run. This option is not supported in SHAP-only mode or for multilabel projects.
    #' @param credentials List of credentials for the secondary datasets used in feature discovery project.
    #' @param crossSeriesGroupByColumns For multiseries projects with cross-series features enabled only. List of columns (currently of length 1). Setting that indicates how to further split series into related groups. For example, if every series is sales of an individual product, the series group-by could be the product category with values like \&quot;men&#39;s clothing\&quot;, \&quot;sports equipment\&quot;, etc.
    #' @param cvHoldoutLevel The value of the partition column indicating a row is part of the holdout set. This level is optional - if not specified or if provided as &#x60;&#x60;null&#x60;&#x60;, then no holdout will be used in the project. The rest of the levels indicate which cross validation fold each row should fall into.
    #' @param cvMethod The partitioning method to be applied to the training data.
    #' @param dateRemoval If true, enable creating additional feature lists without dates (does not apply to time-aware projects).
    #' @param datetimePartitionColumn The date column that will be used as a datetime partition column.
    #' @param defaultToAPriori Renamed to &#x60;defaultToKnownInAdvance&#x60;.
    #' @param defaultToDoNotDerive For time series projects only. Sets whether all features default to being treated as do-not-derive features, excluding them from feature derivation. Individual features can be set to a value different than the default by using the &#x60;featureSettings&#x60; parameter.
    #' @param defaultToKnownInAdvance For time series projects only. Sets whether all features default to being treated as known in advance features, which are features that are known into the future. Features marked as known in advance must be specified into the future when making predictions. The default is false, all features are not known in advance. Individual features can be set to a value different than the default using the &#x60;featureSettings&#x60; parameter. See the :ref:&#x60;Time Series Overview &lt;time_series_overview&gt;&#x60; for more context.
    #' @param differencingMethod For time series projects only. Used to specify which differencing method to apply if the data is stationary. For classification problems &#x60;simple&#x60; and &#x60;seasonal&#x60; are not allowed. Parameter &#x60;periodicities&#x60; must be specified if &#x60;seasonal&#x60; is chosen. Defaults to &#x60;auto&#x60;.
    #' @param disableHoldout Whether to suppress allocating a holdout fold. If &#x60;disableHoldout&#x60; is set to true, &#x60;holdoutStartDate&#x60; and &#x60;holdoutDuration&#x60; must not be set.
    #' @param eventsCount The name of a column specifying events count. The data in this column must be pure numeric and non negative without missing values
    #' @param exponentiallyWeightedMovingAlpha Discount factor (alpha) used for exponentially weighted moving features
    #' @param exposure The name of a column specifying row exposure.The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
    #' @param externalPredictions List of external prediction columns from the dataset.
    #' @param externalTimeSeriesBaselineDatasetId Catalog version id for external prediction data that can be used as a baseline to calculate new metrics.
    #' @param externalTimeSeriesBaselineDatasetName The name of the time series baseline dataset for the project.
    #' @param fairnessMetricsSet Metric to use for calculating fairness. Can be one of &#x60;&#x60;proportionalParity&#x60;&#x60;, &#x60;&#x60;equalParity&#x60;&#x60;, &#x60;&#x60;predictionBalance&#x60;&#x60;, &#x60;&#x60;trueFavorableAndUnfavorableRateParity&#x60;&#x60; or &#x60;&#x60;FavorableAndUnfavorablePredictiveValueParity&#x60;&#x60;. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
    #' @param fairnessThreshold Threshold value of the fairness metric. Can be in a range of &#x60;&#x60;[0:1]&#x60;&#x60;. If the actual metric value is below the threshold, the user will be notified
    #' @param featureDerivationWindowEnd For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should end.
    #' @param featureDerivationWindowStart For time series projects only. How many timeUnits of the datetimePartitionColumn into the past relative to the forecast point the feature derivation window should begin.
    #' @param featureDiscoverySupervisedFeatureReduction Run supervised feature reduction for feature discovery projects.
    #' @param featureEngineeringPredictionPoint The date column to be used as prediction point for time-based feature engineering.
    #' @param featureSettings An array specifying per feature settings. Features can be left unspecified.
    #' @param featurelistId The ID of a featurelist to use for autopilot.
    #' @param forecastWindowEnd For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should end.
    #' @param forecastWindowStart For time series projects only. How many timeUnits of the datetimePartitionColumn into the future relative to the forecast point the forecast window should start.
    #' @param gapDuration The duration of the gap between holdout training and holdout scoring data. For time series projects, defaults to the duration of the gap between the end of the feature derivation window and the beginning of the forecast window. For OTV projects, defaults to a zero duration (P0Y0M0D).
    #' @param holdoutDuration The duration of holdout scoring data. When specifying &#x60;holdoutDuration&#x60;, &#x60;holdoutStartDate&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
    #' @param holdoutEndDate The end date of holdout scoring data. When specifying &#x60;holdoutEndDate&#x60;, &#x60;holdoutStartDate&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
    #' @param holdoutLevel The value of the partition column indicating a row is part of the holdout set. This level is optional - if not specified or if provided as &#x60;&#x60;null&#x60;&#x60;, then no holdout will be used in the project. However, the column must have exactly 2 values in order for this option to be valid
    #' @param holdoutPct The percentage of the dataset to assign to the holdout set
    #' @param holdoutStartDate The start date of holdout scoring data. When specifying &#x60;holdoutStartDate&#x60;, one of &#x60;holdoutEndDate&#x60; or &#x60;holdoutDuration&#x60; must also be specified. This attribute cannot be specified when &#x60;disableHoldout&#x60; is true.
    #' @param includeBiasMitigationFeatureAsPredictorVariable Specifies whether the mitigation feature will be used as a predictor variable (i.e., treated like other categorical features in the input to train the modeler), in addition to being used for bias mitigation. If false, the mitigation feature will be used only for bias mitigation, and not for training the modeler task.
    #' @param isHoldoutModified A boolean value indicating whether holdout settings (start/end dates) have been modified by user.
    #' @param majorityDownsamplingRate The percentage between 0 and 100 of the majority rows that should be kept. Must be specified only if using smart downsampling. If not specified, a default will be selected based on the dataset distribution. The chosen rate may not cause the majority class to become smaller than the minority class.
    #' @param metric The metric to use to select the best models. See &#x60;/api/v2/projects/(projectId)/features/metrics/&#x60; for the metrics that may be valid for a potential target.  Note that weighted metrics must be used with a weights column.
    #' @param minSecondaryValidationModelCount Compute &#39;All backtest&#39; scores (datetime models) or cross validation scores for the specified number of highest ranking models on the Leaderboard, if over the Autopilot default.
    #' @param mode The autopilot mode to use.  Either &#39;quick&#39;, &#39;auto&#39;, &#39;manual&#39; or &#39;comprehensive&#39;
    #' @param modelSplits Sets the cap on the number of jobs per model used when building models to control number of jobs in the queue. Higher number of modelSplits will allow for less downsampling leading to the use of more post-processed data.
    #' @param monotonicDecreasingFeaturelistId The ID of the featurelist that defines the set of features with a monotonically decreasing relationship to the target.  If null, no such constraints are enforced. When specified, this will set a default for the project that can be overriden at model submission time if desired.
    #' @param monotonicIncreasingFeaturelistId The ID of the featurelist that defines the set of features with a monotonically increasing relationship to the target. If null, no such constraints are enforced. When specified, this will set a default for the project that can be overriden at model submission time if desired.
    #' @param multiseriesIdColumns May be used only with time series projects. An array of the column names identifying  the series to which each row of the dataset belongs. Currently only one multiseries ID column is supported. See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; section of the time series documentation for more context.
    #' @param numberOfBacktests The number of backtests to use. If omitted, defaults to a positive value selected by the server based on the validation and gap durations.
    #' @param offset An array of strings with names of a columns specifying row offsets.The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
    #' @param onlyIncludeMonotonicBlueprints When true, only blueprints that support enforcing montonic constraints will be available in the project or selected for autopilot.
    #' @param partitionKeyCols An array containing a single string - the name of the group partition column
    #' @param periodicities A list of periodicities for time series projects only. For classification problems periodicities are not allowed. If this is provided, parameter &#39;differencing_method&#39; will default to &#39;seasonal&#39; if not provided or &#39;auto&#39;.
    #' @param positiveClass A value from the target column to use for the positive class. May only be specified for projects doing binary classification.If not specified, a positive class is selected automatically.
    #' @param preferableTargetValue A target value that should be treated as a positive outcome for the prediction. For example if we want to check gender discrimination for giving a loan and our target named &#x60;&#x60;is_bad&#x60;&#x60;, then the positive outcome for the prediction would be &#x60;&#x60;No&#x60;&#x60;, which means that the loan is good and that&#39;s what we treat as a preferable result for the loaner. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
    #' @param prepareModelForDeployment Prepare model for deployment during Autopilot run. The preparation includes creating reduced feature list models, retraining best model on higher sample size, computing insights and assigning &#39;RECOMMENDED FOR DEPLOYMENT&#39; label.
    #' @param primaryLocationColumn Primary geospatial location column.
    #' @param protectedFeatures A list of project feature to mark as protected for Bias metric calculation and Fairness correction. Used and required only if *Bias &amp; Fairness in AutoML* feature is enabled.
    #' @param quantileLevel The quantile level between 0.01 and 0.99 for specifying the Quantile metric.
    #' @param quickrun (Deprecated): &#39;quick&#39; should be used in the &#x60;mode&#x60; parameter instead of using this parameter. If set to &#x60;true&#x60;, will use a limited autopilot setting whose goal is to complete more quickly by trying a smaller number of models. Note: quickrun cannot be set to &#x60;true&#x60; when &#x60;mode&#x60; is set to &#39;comprehensive&#39;.
    #' @param rateTopPctThreshold The percentage threshold between 0.1 and 50 for specifying the Rate@Top% metric.
    #' @param relationshipsConfigurationId Relationships configuration id to be used for Feature Discovery projects.
    #' @param reps The number of cross validation folds to use.
    #' @param responseCap Used to cap the maximum response of a model
    #' @param runLeakageRemovedFeatureList Run Autopilot on Leakage Removed feature list (if exists).
    #' @param sampleStepPct A float between 0 and 100 indicating the desired percentage of data to sample when training models in comprehensive Autopilot. Note: this only supported for comprehensive Autopilot and the specified value may be lowered in order to be compatible with the project&#39;s dataset and partition settings.
    #' @param scoringCodeOnly Keep only models that can be converted to scorable java code during Autopilot run.
    #' @param seed A seed to use for randomization.
    #' @param segmentationTaskId Specifies the SegmentationTask that will be used for dividing the project up into multiple segmented projects.
    #' @param shapOnlyMode Keep only models that support SHAP values during Autopilot run. Use SHAP-based insights wherever possible.
    #' @param smartDownsampled Whether to use smart downsampling to throw away excess rows of the majority class. Only applicable to classification and zero-boosted regression projects.
    #' @param stopWords A list of stop words to be used for text blueprints. Note: &#x60;&#x60;stop_words&#x3D;True&#x60;&#x60; must be set in the blueprint preprocessing parameters for this list of stop words to actually be used during preprocessing.
    #' @param target The name of the target feature.
    #' @param targetType Used to specify the targetType to use for a project when it is ambiguous, i.e. a numeric target with a few unique values that could be used for either regression or multiclass.
    #' @param trainingLevel The value of the partition column indicating a row is part of the training set.
    #' @param treatAsExponential For time series projects only. Used to specify whether to treat data as exponential trend and apply transformations like log-transform. For classification problems &#x60;always&#x60; is not allowed.
    #' @param unsupervisedMode If True, unsupervised project (without target) will be created. &#x60;&#x60;target&#x60;&#x60; cannot be specified if &#x60;&#x60;unsupervisedMode&#x60;&#x60; is True.
    #' @param unsupervisedType The type of unsupervised project. Only valid when &#x60;unsupervisedMode&#x60; is true. If &#x60;unsupervisedMode&#x60;, defaults to &#x60;anomaly&#x60;.
    #' @param useCrossSeriesFeatures Indicating if user wants to use cross-series features.
    #' @param useProjectSettings Specifies whether datetime-partitioned project should use project settings (i.e. backtests configuration has been modified by the user).
    #' @param useSupervisedFeatureReduction When true, during feature generation DataRobot runs a supervised algorithm feature lists using only qualifying features. Setting false can severely impact autopilot duration, especially for datasets with many features.
    #' @param useTimeSeries A boolean value indicating whether a time series project should be created instead of a regular project which uses datetime partitioning.
    #' @param userPartitionCol The name of the column containing the partition assignments.
    #' @param validationDuration The default validation duration for all backtests. If the primary date/time feature in a time series project is irregular, you cannot set a default validation length. Instead, set each duration individually. For an OTV project setting the validation duration will always use regular partitioning. Omitting it will use irregular partitioning if the date/time feature is irregular.
    #' @param validationLevel The value of the partition column indicating a row is part of the validation set.
    #' @param validationPct The percentage of the dataset to assign to the validation set
    #' @param validationType The validation method to be used.  CV for cross validation or TVH for train-validation-holdout split.
    #' @param weights The name of a column specifying row weights. The data in this column must be pure numeric (e.g. not currency, date, length, etc.) and without missing values
    #' @param windowsBasisUnit For time series projects only. Indicates which unit is basis for feature derivation window and forecast window. Valid options are detected time unit or &#x60;ROW&#x60;. If omitted, the default value is detected time unit.
    #' @param validateParams An optional param for auto validating this object's parameters before initialization. Default FALSE.
    #' @param ... Any additional keyword arguments to be passed into this object for initialization.
    initialize = function(`autopilotDataSelectionMethod` = NULL, `onlyIncludeMonotonicBlueprints` = NULL, `accuracyOptimizedMb` = NULL, `aggregationType` = NULL, `allowPartialHistoryTimeSeriesPredictions` = NULL, `allowedPairwiseInteractionGroups` = NULL, `autopilotClusterList` = NULL, `autopilotDataSamplingMethod` = NULL, `autopilotWithFeatureDiscovery` = NULL, `backtests` = NULL, `biasMitigationFeatureName` = NULL, `biasMitigationTechnique` = NULL, `blendBestModels` = NULL, `blueprintThreshold` = NULL, `calendarId` = NULL, `classMappingAggregationSettings` = NULL, `considerBlendersInRecommendation` = NULL, `credentials` = NULL, `crossSeriesGroupByColumns` = NULL, `cvHoldoutLevel` = NULL, `cvMethod` = NULL, `dateRemoval` = NULL, `datetimePartitionColumn` = NULL, `defaultToAPriori` = NULL, `defaultToDoNotDerive` = NULL, `defaultToKnownInAdvance` = NULL, `differencingMethod` = NULL, `disableHoldout` = FALSE, `eventsCount` = NULL, `exponentiallyWeightedMovingAlpha` = NULL, `exposure` = NULL, `externalPredictions` = NULL, `externalTimeSeriesBaselineDatasetId` = NULL, `externalTimeSeriesBaselineDatasetName` = NULL, `fairnessMetricsSet` = NULL, `fairnessThreshold` = NULL, `featureDerivationWindowEnd` = NULL, `featureDerivationWindowStart` = NULL, `featureDiscoverySupervisedFeatureReduction` = NULL, `featureEngineeringPredictionPoint` = NULL, `featureSettings` = NULL, `featurelistId` = NULL, `forecastWindowEnd` = NULL, `forecastWindowStart` = NULL, `gapDuration` = NULL, `holdoutDuration` = NULL, `holdoutEndDate` = NULL, `holdoutLevel` = NULL, `holdoutPct` = NULL, `holdoutStartDate` = NULL, `includeBiasMitigationFeatureAsPredictorVariable` = NULL, `isHoldoutModified` = NULL, `majorityDownsamplingRate` = NULL, `metric` = NULL, `minSecondaryValidationModelCount` = NULL, `mode` = NULL, `modelSplits` = 5, `monotonicDecreasingFeaturelistId` = NULL, `monotonicIncreasingFeaturelistId` = NULL, `multiseriesIdColumns` = NULL, `numberOfBacktests` = NULL, `offset` = NULL, `partitionKeyCols` = NULL, `periodicities` = NULL, `positiveClass` = NULL, `preferableTargetValue` = NULL, `prepareModelForDeployment` = NULL, `primaryLocationColumn` = NULL, `protectedFeatures` = NULL, `quantileLevel` = NULL, `quickrun` = NULL, `rateTopPctThreshold` = NULL, `relationshipsConfigurationId` = NULL, `reps` = NULL, `responseCap` = NULL, `runLeakageRemovedFeatureList` = NULL, `sampleStepPct` = NULL, `scoringCodeOnly` = NULL, `seed` = NULL, `segmentationTaskId` = NULL, `shapOnlyMode` = NULL, `smartDownsampled` = NULL, `stopWords` = NULL, `target` = NULL, `targetType` = NULL, `trainingLevel` = NULL, `treatAsExponential` = "auto", `unsupervisedMode` = FALSE, `unsupervisedType` = NULL, `useCrossSeriesFeatures` = NULL, `useProjectSettings` = NULL, `useSupervisedFeatureReduction` = TRUE, `useTimeSeries` = FALSE, `userPartitionCol` = NULL, `validationDuration` = NULL, `validationLevel` = NULL, `validationPct` = NULL, `validationType` = NULL, `weights` = NULL, `windowsBasisUnit` = NULL, validateParams = FALSE, ...) {
      local.optional.var <- list(...)
      requiredProps <- list(`autopilotDataSelectionMethod`, `onlyIncludeMonotonicBlueprints`)
      if (validateParams) {
        lapply(requiredProps, missing)
        private$validateProps(accuracyOptimizedMb, aggregationType, allowPartialHistoryTimeSeriesPredictions, allowedPairwiseInteractionGroups, autopilotClusterList, autopilotDataSamplingMethod, autopilotDataSelectionMethod, autopilotWithFeatureDiscovery, backtests, biasMitigationFeatureName, biasMitigationTechnique, blendBestModels, blueprintThreshold, calendarId, classMappingAggregationSettings, considerBlendersInRecommendation, credentials, crossSeriesGroupByColumns, cvHoldoutLevel, cvMethod, dateRemoval, datetimePartitionColumn, defaultToAPriori, defaultToDoNotDerive, defaultToKnownInAdvance, differencingMethod, disableHoldout, eventsCount, exponentiallyWeightedMovingAlpha, exposure, externalPredictions, externalTimeSeriesBaselineDatasetId, externalTimeSeriesBaselineDatasetName, fairnessMetricsSet, fairnessThreshold, featureDerivationWindowEnd, featureDerivationWindowStart, featureDiscoverySupervisedFeatureReduction, featureEngineeringPredictionPoint, featureSettings, featurelistId, forecastWindowEnd, forecastWindowStart, gapDuration, holdoutDuration, holdoutEndDate, holdoutLevel, holdoutPct, holdoutStartDate, includeBiasMitigationFeatureAsPredictorVariable, isHoldoutModified, majorityDownsamplingRate, metric, minSecondaryValidationModelCount, mode, modelSplits, monotonicDecreasingFeaturelistId, monotonicIncreasingFeaturelistId, multiseriesIdColumns, numberOfBacktests, offset, onlyIncludeMonotonicBlueprints, partitionKeyCols, periodicities, positiveClass, preferableTargetValue, prepareModelForDeployment, primaryLocationColumn, protectedFeatures, quantileLevel, quickrun, rateTopPctThreshold, relationshipsConfigurationId, reps, responseCap, runLeakageRemovedFeatureList, sampleStepPct, scoringCodeOnly, seed, segmentationTaskId, shapOnlyMode, smartDownsampled, stopWords, target, targetType, trainingLevel, treatAsExponential, unsupervisedMode, unsupervisedType, useCrossSeriesFeatures, useProjectSettings, useSupervisedFeatureReduction, useTimeSeries, userPartitionCol, validationDuration, validationLevel, validationPct, validationType, weights, windowsBasisUnit)
      }
      self$`accuracyOptimizedMb` <- `accuracyOptimizedMb`
      self$`aggregationType` <- `aggregationType`
      self$`allowPartialHistoryTimeSeriesPredictions` <- `allowPartialHistoryTimeSeriesPredictions`
      sapply(`allowedPairwiseInteractionGroups`, function(x) stopifnot(R6::is.R6(x)))
      sapply(`autopilotClusterList`, function(x) stopifnot(is.character(x)))
      self$`autopilotDataSamplingMethod` <- `autopilotDataSamplingMethod`
      self$`autopilotDataSelectionMethod` <- `autopilotDataSelectionMethod`
      self$`autopilotWithFeatureDiscovery` <- `autopilotWithFeatureDiscovery`
      sapply(`backtests`, function(x) stopifnot(R6::is.R6(x)))
      self$`biasMitigationFeatureName` <- `biasMitigationFeatureName`
      self$`biasMitigationTechnique` <- `biasMitigationTechnique`
      self$`blendBestModels` <- `blendBestModels`
      self$`blueprintThreshold` <- `blueprintThreshold`
      self$`calendarId` <- `calendarId`
      self$`classMappingAggregationSettings` <- `classMappingAggregationSettings`
      self$`considerBlendersInRecommendation` <- `considerBlendersInRecommendation`
      self$`credentials` <- .setComplexProperty(typeList = list(PasswordCredentials, CredentialId), propertyData = credentials)
      sapply(`crossSeriesGroupByColumns`, function(x) stopifnot(is.character(x)))
      self$`cvHoldoutLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = cvHoldoutLevel)
      self$`cvMethod` <- `cvMethod`
      self$`dateRemoval` <- `dateRemoval`
      self$`datetimePartitionColumn` <- `datetimePartitionColumn`
      self$`defaultToAPriori` <- `defaultToAPriori`
      self$`defaultToDoNotDerive` <- `defaultToDoNotDerive`
      self$`defaultToKnownInAdvance` <- `defaultToKnownInAdvance`
      self$`differencingMethod` <- `differencingMethod`
      self$`disableHoldout` <- `disableHoldout`
      self$`eventsCount` <- `eventsCount`
      self$`exponentiallyWeightedMovingAlpha` <- `exponentiallyWeightedMovingAlpha`
      self$`exposure` <- `exposure`
      sapply(`externalPredictions`, function(x) stopifnot(is.character(x)))
      self$`externalTimeSeriesBaselineDatasetId` <- `externalTimeSeriesBaselineDatasetId`
      self$`externalTimeSeriesBaselineDatasetName` <- `externalTimeSeriesBaselineDatasetName`
      self$`fairnessMetricsSet` <- `fairnessMetricsSet`
      self$`fairnessThreshold` <- `fairnessThreshold`
      self$`featureDerivationWindowEnd` <- `featureDerivationWindowEnd`
      self$`featureDerivationWindowStart` <- `featureDerivationWindowStart`
      self$`featureDiscoverySupervisedFeatureReduction` <- `featureDiscoverySupervisedFeatureReduction`
      self$`featureEngineeringPredictionPoint` <- `featureEngineeringPredictionPoint`
      sapply(`featureSettings`, function(x) stopifnot(R6::is.R6(x)))
      self$`featurelistId` <- `featurelistId`
      self$`forecastWindowEnd` <- `forecastWindowEnd`
      self$`forecastWindowStart` <- `forecastWindowStart`
      self$`gapDuration` <- `gapDuration`
      self$`holdoutDuration` <- `holdoutDuration`
      self$`holdoutEndDate` <- `holdoutEndDate`
      self$`holdoutLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = holdoutLevel)
      self$`holdoutPct` <- `holdoutPct`
      self$`holdoutStartDate` <- `holdoutStartDate`
      self$`includeBiasMitigationFeatureAsPredictorVariable` <- `includeBiasMitigationFeatureAsPredictorVariable`
      self$`isHoldoutModified` <- `isHoldoutModified`
      self$`majorityDownsamplingRate` <- `majorityDownsamplingRate`
      self$`metric` <- `metric`
      self$`minSecondaryValidationModelCount` <- `minSecondaryValidationModelCount`
      self$`mode` <- `mode`
      self$`modelSplits` <- `modelSplits`
      self$`monotonicDecreasingFeaturelistId` <- `monotonicDecreasingFeaturelistId`
      self$`monotonicIncreasingFeaturelistId` <- `monotonicIncreasingFeaturelistId`
      sapply(`multiseriesIdColumns`, function(x) stopifnot(is.character(x)))
      self$`numberOfBacktests` <- `numberOfBacktests`
      sapply(`offset`, function(x) stopifnot(is.character(x)))
      self$`onlyIncludeMonotonicBlueprints` <- `onlyIncludeMonotonicBlueprints`
      sapply(`partitionKeyCols`, function(x) stopifnot(is.character(x)))
      sapply(`periodicities`, function(x) stopifnot(R6::is.R6(x)))
      self$`positiveClass` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = positiveClass)
      self$`preferableTargetValue` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = preferableTargetValue)
      self$`prepareModelForDeployment` <- `prepareModelForDeployment`
      self$`primaryLocationColumn` <- `primaryLocationColumn`
      sapply(`protectedFeatures`, function(x) stopifnot(is.character(x)))
      self$`quantileLevel` <- `quantileLevel`
      self$`quickrun` <- `quickrun`
      self$`rateTopPctThreshold` <- `rateTopPctThreshold`
      self$`relationshipsConfigurationId` <- `relationshipsConfigurationId`
      self$`reps` <- `reps`
      self$`responseCap` <- `responseCap`
      self$`runLeakageRemovedFeatureList` <- `runLeakageRemovedFeatureList`
      self$`sampleStepPct` <- `sampleStepPct`
      self$`scoringCodeOnly` <- `scoringCodeOnly`
      self$`seed` <- `seed`
      self$`segmentationTaskId` <- `segmentationTaskId`
      self$`shapOnlyMode` <- `shapOnlyMode`
      self$`smartDownsampled` <- `smartDownsampled`
      sapply(`stopWords`, function(x) stopifnot(is.character(x)))
      self$`target` <- `target`
      self$`targetType` <- `targetType`
      self$`trainingLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = trainingLevel)
      self$`treatAsExponential` <- `treatAsExponential`
      self$`unsupervisedMode` <- `unsupervisedMode`
      self$`unsupervisedType` <- `unsupervisedType`
      self$`useCrossSeriesFeatures` <- `useCrossSeriesFeatures`
      self$`useProjectSettings` <- `useProjectSettings`
      self$`useSupervisedFeatureReduction` <- `useSupervisedFeatureReduction`
      self$`useTimeSeries` <- `useTimeSeries`
      self$`userPartitionCol` <- `userPartitionCol`
      self$`validationDuration` <- `validationDuration`
      self$`validationLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = validationLevel)
      self$`validationPct` <- `validationPct`
      self$`validationType` <- `validationType`
      self$`weights` <- `weights`
      self$`windowsBasisUnit` <- `windowsBasisUnit`
    },
    #' @description A helper function that provides public access to the private validateProps function. This allows users the ability
    #' to programmatically validate objects before sending them to DataRobot.
    validate = function() {
      props <- list(accuracyOptimizedMb = self$`accuracyOptimizedMb`, aggregationType = self$`aggregationType`, allowPartialHistoryTimeSeriesPredictions = self$`allowPartialHistoryTimeSeriesPredictions`, allowedPairwiseInteractionGroups = self$`allowedPairwiseInteractionGroups`, autopilotClusterList = self$`autopilotClusterList`, autopilotDataSamplingMethod = self$`autopilotDataSamplingMethod`, autopilotDataSelectionMethod = self$`autopilotDataSelectionMethod`, autopilotWithFeatureDiscovery = self$`autopilotWithFeatureDiscovery`, backtests = self$`backtests`, biasMitigationFeatureName = self$`biasMitigationFeatureName`, biasMitigationTechnique = self$`biasMitigationTechnique`, blendBestModels = self$`blendBestModels`, blueprintThreshold = self$`blueprintThreshold`, calendarId = self$`calendarId`, classMappingAggregationSettings = self$`classMappingAggregationSettings`, considerBlendersInRecommendation = self$`considerBlendersInRecommendation`, credentials = self$`credentials`, crossSeriesGroupByColumns = self$`crossSeriesGroupByColumns`, cvHoldoutLevel = self$`cvHoldoutLevel`, cvMethod = self$`cvMethod`, dateRemoval = self$`dateRemoval`, datetimePartitionColumn = self$`datetimePartitionColumn`, defaultToAPriori = self$`defaultToAPriori`, defaultToDoNotDerive = self$`defaultToDoNotDerive`, defaultToKnownInAdvance = self$`defaultToKnownInAdvance`, differencingMethod = self$`differencingMethod`, disableHoldout = self$`disableHoldout`, eventsCount = self$`eventsCount`, exponentiallyWeightedMovingAlpha = self$`exponentiallyWeightedMovingAlpha`, exposure = self$`exposure`, externalPredictions = self$`externalPredictions`, externalTimeSeriesBaselineDatasetId = self$`externalTimeSeriesBaselineDatasetId`, externalTimeSeriesBaselineDatasetName = self$`externalTimeSeriesBaselineDatasetName`, fairnessMetricsSet = self$`fairnessMetricsSet`, fairnessThreshold = self$`fairnessThreshold`, featureDerivationWindowEnd = self$`featureDerivationWindowEnd`, featureDerivationWindowStart = self$`featureDerivationWindowStart`, featureDiscoverySupervisedFeatureReduction = self$`featureDiscoverySupervisedFeatureReduction`, featureEngineeringPredictionPoint = self$`featureEngineeringPredictionPoint`, featureSettings = self$`featureSettings`, featurelistId = self$`featurelistId`, forecastWindowEnd = self$`forecastWindowEnd`, forecastWindowStart = self$`forecastWindowStart`, gapDuration = self$`gapDuration`, holdoutDuration = self$`holdoutDuration`, holdoutEndDate = self$`holdoutEndDate`, holdoutLevel = self$`holdoutLevel`, holdoutPct = self$`holdoutPct`, holdoutStartDate = self$`holdoutStartDate`, includeBiasMitigationFeatureAsPredictorVariable = self$`includeBiasMitigationFeatureAsPredictorVariable`, isHoldoutModified = self$`isHoldoutModified`, majorityDownsamplingRate = self$`majorityDownsamplingRate`, metric = self$`metric`, minSecondaryValidationModelCount = self$`minSecondaryValidationModelCount`, mode = self$`mode`, modelSplits = self$`modelSplits`, monotonicDecreasingFeaturelistId = self$`monotonicDecreasingFeaturelistId`, monotonicIncreasingFeaturelistId = self$`monotonicIncreasingFeaturelistId`, multiseriesIdColumns = self$`multiseriesIdColumns`, numberOfBacktests = self$`numberOfBacktests`, offset = self$`offset`, onlyIncludeMonotonicBlueprints = self$`onlyIncludeMonotonicBlueprints`, partitionKeyCols = self$`partitionKeyCols`, periodicities = self$`periodicities`, positiveClass = self$`positiveClass`, preferableTargetValue = self$`preferableTargetValue`, prepareModelForDeployment = self$`prepareModelForDeployment`, primaryLocationColumn = self$`primaryLocationColumn`, protectedFeatures = self$`protectedFeatures`, quantileLevel = self$`quantileLevel`, quickrun = self$`quickrun`, rateTopPctThreshold = self$`rateTopPctThreshold`, relationshipsConfigurationId = self$`relationshipsConfigurationId`, reps = self$`reps`, responseCap = self$`responseCap`, runLeakageRemovedFeatureList = self$`runLeakageRemovedFeatureList`, sampleStepPct = self$`sampleStepPct`, scoringCodeOnly = self$`scoringCodeOnly`, seed = self$`seed`, segmentationTaskId = self$`segmentationTaskId`, shapOnlyMode = self$`shapOnlyMode`, smartDownsampled = self$`smartDownsampled`, stopWords = self$`stopWords`, target = self$`target`, targetType = self$`targetType`, trainingLevel = self$`trainingLevel`, treatAsExponential = self$`treatAsExponential`, unsupervisedMode = self$`unsupervisedMode`, unsupervisedType = self$`unsupervisedType`, useCrossSeriesFeatures = self$`useCrossSeriesFeatures`, useProjectSettings = self$`useProjectSettings`, useSupervisedFeatureReduction = self$`useSupervisedFeatureReduction`, useTimeSeries = self$`useTimeSeries`, userPartitionCol = self$`userPartitionCol`, validationDuration = self$`validationDuration`, validationLevel = self$`validationLevel`, validationPct = self$`validationPct`, validationType = self$`validationType`, weights = self$`weights`, windowsBasisUnit = self$`windowsBasisUnit`)
      do.call(private$validateProps, props)
    },
    #' @description A helper function that serializes this object into a JSON encoded string.
    toJSON = function() {
      jsoncontent <- c(
        if (!is.null(self$`accuracyOptimizedMb`)) {
          sprintf(
            '"accuracyOptimizedMb":
            %s
                  ',
            tolower(self$`accuracyOptimizedMb`)
          )
        },
        if (!is.null(self$`aggregationType`)) {
          sprintf(
            '"aggregationType":
            "%s"
                  ',
            self$`aggregationType`
          )
        },
        if (!is.null(self$`allowPartialHistoryTimeSeriesPredictions`)) {
          sprintf(
            '"allowPartialHistoryTimeSeriesPredictions":
            %s
                  ',
            tolower(self$`allowPartialHistoryTimeSeriesPredictions`)
          )
        },
        if (!is.null(self$`allowedPairwiseInteractionGroups`)) {
          sprintf(
            '"allowedPairwiseInteractionGroups":
            [%s]
',
            paste(sapply(self$`allowedPairwiseInteractionGroups`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`autopilotClusterList`)) {
          sprintf(
            '"autopilotClusterList":
              [%s]
            ',
            paste(unlist(lapply(self$`autopilotClusterList`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`autopilotDataSamplingMethod`)) {
          sprintf(
            '"autopilotDataSamplingMethod":
            "%s"
                  ',
            self$`autopilotDataSamplingMethod`
          )
        },
        if (!is.null(self$`autopilotDataSelectionMethod`)) {
          sprintf(
            '"autopilotDataSelectionMethod":
            "%s"
                  ',
            self$`autopilotDataSelectionMethod`
          )
        },
        if (!is.null(self$`autopilotWithFeatureDiscovery`)) {
          sprintf(
            '"autopilotWithFeatureDiscovery":
            %s
                  ',
            tolower(self$`autopilotWithFeatureDiscovery`)
          )
        },
        if (!is.null(self$`backtests`)) {
          sprintf(
            '"backtests":
            [%s]
',
            paste(sapply(self$`backtests`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`biasMitigationFeatureName`)) {
          sprintf(
            '"biasMitigationFeatureName":
            "%s"
                  ',
            self$`biasMitigationFeatureName`
          )
        },
        if (!is.null(self$`biasMitigationTechnique`)) {
          sprintf(
            '"biasMitigationTechnique":
            "%s"
                  ',
            self$`biasMitigationTechnique`
          )
        },
        if (!is.null(self$`blendBestModels`)) {
          sprintf(
            '"blendBestModels":
            %s
                  ',
            tolower(self$`blendBestModels`)
          )
        },
        if (!is.null(self$`blueprintThreshold`)) {
          sprintf(
            '"blueprintThreshold":
            %d
                  ',
            self$`blueprintThreshold`
          )
        },
        if (!is.null(self$`calendarId`)) {
          sprintf(
            '"calendarId":
            "%s"
                  ',
            self$`calendarId`
          )
        },
        if (!is.null(self$`classMappingAggregationSettings`)) {
          sprintf(
            '"classMappingAggregationSettings":
          %s
        ',
            jsonlite::toJSON(self$`classMappingAggregationSettings`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`considerBlendersInRecommendation`)) {
          sprintf(
            '"considerBlendersInRecommendation":
            %s
                  ',
            tolower(self$`considerBlendersInRecommendation`)
          )
        },
        if (!is.null(self$`credentials`)) {
          sprintf(
            '"credentials":
            [%s]
',
            paste(sapply(self$`credentials`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`crossSeriesGroupByColumns`)) {
          sprintf(
            '"crossSeriesGroupByColumns":
              [%s]
            ',
            paste(unlist(lapply(self$`crossSeriesGroupByColumns`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`cvHoldoutLevel`)) {
          sprintf(
            '"cvHoldoutLevel":
          %s
        ',
            self$`cvHoldoutLevel`
          )
        },
        if (!is.null(self$`cvMethod`)) {
          sprintf(
            '"cvMethod":
            "%s"
                  ',
            self$`cvMethod`
          )
        },
        if (!is.null(self$`dateRemoval`)) {
          sprintf(
            '"dateRemoval":
            %s
                  ',
            tolower(self$`dateRemoval`)
          )
        },
        if (!is.null(self$`datetimePartitionColumn`)) {
          sprintf(
            '"datetimePartitionColumn":
            "%s"
                  ',
            self$`datetimePartitionColumn`
          )
        },
        if (!is.null(self$`defaultToAPriori`)) {
          sprintf(
            '"defaultToAPriori":
            %s
                  ',
            tolower(self$`defaultToAPriori`)
          )
        },
        if (!is.null(self$`defaultToDoNotDerive`)) {
          sprintf(
            '"defaultToDoNotDerive":
            %s
                  ',
            tolower(self$`defaultToDoNotDerive`)
          )
        },
        if (!is.null(self$`defaultToKnownInAdvance`)) {
          sprintf(
            '"defaultToKnownInAdvance":
            %s
                  ',
            tolower(self$`defaultToKnownInAdvance`)
          )
        },
        if (!is.null(self$`differencingMethod`)) {
          sprintf(
            '"differencingMethod":
            "%s"
                  ',
            self$`differencingMethod`
          )
        },
        if (!is.null(self$`disableHoldout`)) {
          sprintf(
            '"disableHoldout":
            %s
                  ',
            tolower(self$`disableHoldout`)
          )
        },
        if (!is.null(self$`eventsCount`)) {
          sprintf(
            '"eventsCount":
            "%s"
                  ',
            self$`eventsCount`
          )
        },
        if (!is.null(self$`exponentiallyWeightedMovingAlpha`)) {
          sprintf(
            '"exponentiallyWeightedMovingAlpha":
            %d
                  ',
            self$`exponentiallyWeightedMovingAlpha`
          )
        },
        if (!is.null(self$`exposure`)) {
          sprintf(
            '"exposure":
            "%s"
                  ',
            self$`exposure`
          )
        },
        if (!is.null(self$`externalPredictions`)) {
          sprintf(
            '"externalPredictions":
              [%s]
            ',
            paste(unlist(lapply(self$`externalPredictions`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`externalTimeSeriesBaselineDatasetId`)) {
          sprintf(
            '"externalTimeSeriesBaselineDatasetId":
            "%s"
                  ',
            self$`externalTimeSeriesBaselineDatasetId`
          )
        },
        if (!is.null(self$`externalTimeSeriesBaselineDatasetName`)) {
          sprintf(
            '"externalTimeSeriesBaselineDatasetName":
            "%s"
                  ',
            self$`externalTimeSeriesBaselineDatasetName`
          )
        },
        if (!is.null(self$`fairnessMetricsSet`)) {
          sprintf(
            '"fairnessMetricsSet":
            "%s"
                  ',
            self$`fairnessMetricsSet`
          )
        },
        if (!is.null(self$`fairnessThreshold`)) {
          sprintf(
            '"fairnessThreshold":
            %d
                  ',
            self$`fairnessThreshold`
          )
        },
        if (!is.null(self$`featureDerivationWindowEnd`)) {
          sprintf(
            '"featureDerivationWindowEnd":
            %d
                  ',
            self$`featureDerivationWindowEnd`
          )
        },
        if (!is.null(self$`featureDerivationWindowStart`)) {
          sprintf(
            '"featureDerivationWindowStart":
            %d
                  ',
            self$`featureDerivationWindowStart`
          )
        },
        if (!is.null(self$`featureDiscoverySupervisedFeatureReduction`)) {
          sprintf(
            '"featureDiscoverySupervisedFeatureReduction":
            %s
                  ',
            tolower(self$`featureDiscoverySupervisedFeatureReduction`)
          )
        },
        if (!is.null(self$`featureEngineeringPredictionPoint`)) {
          sprintf(
            '"featureEngineeringPredictionPoint":
            "%s"
                  ',
            self$`featureEngineeringPredictionPoint`
          )
        },
        if (!is.null(self$`featureSettings`)) {
          sprintf(
            '"featureSettings":
            [%s]
',
            paste(sapply(self$`featureSettings`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`featurelistId`)) {
          sprintf(
            '"featurelistId":
            "%s"
                  ',
            self$`featurelistId`
          )
        },
        if (!is.null(self$`forecastWindowEnd`)) {
          sprintf(
            '"forecastWindowEnd":
            %d
                  ',
            self$`forecastWindowEnd`
          )
        },
        if (!is.null(self$`forecastWindowStart`)) {
          sprintf(
            '"forecastWindowStart":
            %d
                  ',
            self$`forecastWindowStart`
          )
        },
        if (!is.null(self$`gapDuration`)) {
          sprintf(
            '"gapDuration":
            "%s"
                  ',
            self$`gapDuration`
          )
        },
        if (!is.null(self$`holdoutDuration`)) {
          sprintf(
            '"holdoutDuration":
            "%s"
                  ',
            self$`holdoutDuration`
          )
        },
        if (!is.null(self$`holdoutEndDate`)) {
          sprintf(
            '"holdoutEndDate":
            "%s"
                  ',
            format(self$`holdoutEndDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`holdoutLevel`)) {
          sprintf(
            '"holdoutLevel":
          %s
        ',
            self$`holdoutLevel`
          )
        },
        if (!is.null(self$`holdoutPct`)) {
          sprintf(
            '"holdoutPct":
            %d
                  ',
            self$`holdoutPct`
          )
        },
        if (!is.null(self$`holdoutStartDate`)) {
          sprintf(
            '"holdoutStartDate":
            "%s"
                  ',
            format(self$`holdoutStartDate`, format = "%Y-%m-%dT%H:%M:%OSZ", tz = "UTC")
          )
        },
        if (!is.null(self$`includeBiasMitigationFeatureAsPredictorVariable`)) {
          sprintf(
            '"includeBiasMitigationFeatureAsPredictorVariable":
            %s
                  ',
            tolower(self$`includeBiasMitigationFeatureAsPredictorVariable`)
          )
        },
        if (!is.null(self$`isHoldoutModified`)) {
          sprintf(
            '"isHoldoutModified":
            %s
                  ',
            tolower(self$`isHoldoutModified`)
          )
        },
        if (!is.null(self$`majorityDownsamplingRate`)) {
          sprintf(
            '"majorityDownsamplingRate":
            %d
                  ',
            self$`majorityDownsamplingRate`
          )
        },
        if (!is.null(self$`metric`)) {
          sprintf(
            '"metric":
            "%s"
                  ',
            self$`metric`
          )
        },
        if (!is.null(self$`minSecondaryValidationModelCount`)) {
          sprintf(
            '"minSecondaryValidationModelCount":
            %d
                  ',
            self$`minSecondaryValidationModelCount`
          )
        },
        if (!is.null(self$`mode`)) {
          sprintf(
            '"mode":
            "%s"
                  ',
            self$`mode`
          )
        },
        if (!is.null(self$`modelSplits`)) {
          sprintf(
            '"modelSplits":
            %d
                  ',
            self$`modelSplits`
          )
        },
        if (!is.null(self$`monotonicDecreasingFeaturelistId`)) {
          sprintf(
            '"monotonicDecreasingFeaturelistId":
            "%s"
                  ',
            self$`monotonicDecreasingFeaturelistId`
          )
        },
        if (!is.null(self$`monotonicIncreasingFeaturelistId`)) {
          sprintf(
            '"monotonicIncreasingFeaturelistId":
            "%s"
                  ',
            self$`monotonicIncreasingFeaturelistId`
          )
        },
        if (!is.null(self$`multiseriesIdColumns`)) {
          sprintf(
            '"multiseriesIdColumns":
              [%s]
            ',
            paste(unlist(lapply(self$`multiseriesIdColumns`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`numberOfBacktests`)) {
          sprintf(
            '"numberOfBacktests":
            %d
                  ',
            self$`numberOfBacktests`
          )
        },
        if (!is.null(self$`offset`)) {
          sprintf(
            '"offset":
              [%s]
            ',
            paste(unlist(lapply(self$`offset`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`onlyIncludeMonotonicBlueprints`)) {
          sprintf(
            '"onlyIncludeMonotonicBlueprints":
            %s
                  ',
            tolower(self$`onlyIncludeMonotonicBlueprints`)
          )
        },
        if (!is.null(self$`partitionKeyCols`)) {
          sprintf(
            '"partitionKeyCols":
              [%s]
            ',
            paste(unlist(lapply(self$`partitionKeyCols`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`periodicities`)) {
          sprintf(
            '"periodicities":
            [%s]
',
            paste(sapply(self$`periodicities`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`positiveClass`)) {
          sprintf(
            '"positiveClass":
          %s
        ',
            self$`positiveClass`
          )
        },
        if (!is.null(self$`preferableTargetValue`)) {
          sprintf(
            '"preferableTargetValue":
          %s
        ',
            self$`preferableTargetValue`
          )
        },
        if (!is.null(self$`prepareModelForDeployment`)) {
          sprintf(
            '"prepareModelForDeployment":
            %s
                  ',
            tolower(self$`prepareModelForDeployment`)
          )
        },
        if (!is.null(self$`primaryLocationColumn`)) {
          sprintf(
            '"primaryLocationColumn":
            "%s"
                  ',
            self$`primaryLocationColumn`
          )
        },
        if (!is.null(self$`protectedFeatures`)) {
          sprintf(
            '"protectedFeatures":
              [%s]
            ',
            paste(unlist(lapply(self$`protectedFeatures`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`quantileLevel`)) {
          sprintf(
            '"quantileLevel":
            %d
                  ',
            self$`quantileLevel`
          )
        },
        if (!is.null(self$`quickrun`)) {
          sprintf(
            '"quickrun":
            %s
                  ',
            tolower(self$`quickrun`)
          )
        },
        if (!is.null(self$`rateTopPctThreshold`)) {
          sprintf(
            '"rateTopPctThreshold":
            %d
                  ',
            self$`rateTopPctThreshold`
          )
        },
        if (!is.null(self$`relationshipsConfigurationId`)) {
          sprintf(
            '"relationshipsConfigurationId":
            "%s"
                  ',
            self$`relationshipsConfigurationId`
          )
        },
        if (!is.null(self$`reps`)) {
          sprintf(
            '"reps":
            %d
                  ',
            self$`reps`
          )
        },
        if (!is.null(self$`responseCap`)) {
          sprintf(
            '"responseCap":
            %d
                  ',
            self$`responseCap`
          )
        },
        if (!is.null(self$`runLeakageRemovedFeatureList`)) {
          sprintf(
            '"runLeakageRemovedFeatureList":
            %s
                  ',
            tolower(self$`runLeakageRemovedFeatureList`)
          )
        },
        if (!is.null(self$`sampleStepPct`)) {
          sprintf(
            '"sampleStepPct":
            %d
                  ',
            self$`sampleStepPct`
          )
        },
        if (!is.null(self$`scoringCodeOnly`)) {
          sprintf(
            '"scoringCodeOnly":
            %s
                  ',
            tolower(self$`scoringCodeOnly`)
          )
        },
        if (!is.null(self$`seed`)) {
          sprintf(
            '"seed":
            %d
                  ',
            self$`seed`
          )
        },
        if (!is.null(self$`segmentationTaskId`)) {
          sprintf(
            '"segmentationTaskId":
            "%s"
                  ',
            self$`segmentationTaskId`
          )
        },
        if (!is.null(self$`shapOnlyMode`)) {
          sprintf(
            '"shapOnlyMode":
            %s
                  ',
            tolower(self$`shapOnlyMode`)
          )
        },
        if (!is.null(self$`smartDownsampled`)) {
          sprintf(
            '"smartDownsampled":
            %s
                  ',
            tolower(self$`smartDownsampled`)
          )
        },
        if (!is.null(self$`stopWords`)) {
          sprintf(
            '"stopWords":
              [%s]
            ',
            paste(unlist(lapply(self$`stopWords`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`target`)) {
          sprintf(
            '"target":
            "%s"
                  ',
            self$`target`
          )
        },
        if (!is.null(self$`targetType`)) {
          sprintf(
            '"targetType":
            "%s"
                  ',
            self$`targetType`
          )
        },
        if (!is.null(self$`trainingLevel`)) {
          sprintf(
            '"trainingLevel":
          %s
        ',
            self$`trainingLevel`
          )
        },
        if (!is.null(self$`treatAsExponential`)) {
          sprintf(
            '"treatAsExponential":
            "%s"
                  ',
            self$`treatAsExponential`
          )
        },
        if (!is.null(self$`unsupervisedMode`)) {
          sprintf(
            '"unsupervisedMode":
            %s
                  ',
            tolower(self$`unsupervisedMode`)
          )
        },
        if (!is.null(self$`unsupervisedType`)) {
          sprintf(
            '"unsupervisedType":
            "%s"
                  ',
            self$`unsupervisedType`
          )
        },
        if (!is.null(self$`useCrossSeriesFeatures`)) {
          sprintf(
            '"useCrossSeriesFeatures":
            %s
                  ',
            tolower(self$`useCrossSeriesFeatures`)
          )
        },
        if (!is.null(self$`useProjectSettings`)) {
          sprintf(
            '"useProjectSettings":
            %s
                  ',
            tolower(self$`useProjectSettings`)
          )
        },
        if (!is.null(self$`useSupervisedFeatureReduction`)) {
          sprintf(
            '"useSupervisedFeatureReduction":
            %s
                  ',
            tolower(self$`useSupervisedFeatureReduction`)
          )
        },
        if (!is.null(self$`useTimeSeries`)) {
          sprintf(
            '"useTimeSeries":
            %s
                  ',
            tolower(self$`useTimeSeries`)
          )
        },
        if (!is.null(self$`userPartitionCol`)) {
          sprintf(
            '"userPartitionCol":
            "%s"
                  ',
            self$`userPartitionCol`
          )
        },
        if (!is.null(self$`validationDuration`)) {
          sprintf(
            '"validationDuration":
            "%s"
                  ',
            self$`validationDuration`
          )
        },
        if (!is.null(self$`validationLevel`)) {
          sprintf(
            '"validationLevel":
          %s
        ',
            self$`validationLevel`
          )
        },
        if (!is.null(self$`validationPct`)) {
          sprintf(
            '"validationPct":
            %d
                  ',
            self$`validationPct`
          )
        },
        if (!is.null(self$`validationType`)) {
          sprintf(
            '"validationType":
            "%s"
                  ',
            self$`validationType`
          )
        },
        if (!is.null(self$`weights`)) {
          sprintf(
            '"weights":
            "%s"
                  ',
            self$`weights`
          )
        },
        if (!is.null(self$`windowsBasisUnit`)) {
          sprintf(
            '"windowsBasisUnit":
            "%s"
                  ',
            self$`windowsBasisUnit`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste("{", jsoncontent, "}", sep = "")
    },
    #' @description A helper function that deserializes a JSON string into an instance of this class.
    #' @param AimJson A JSON encoded string representation of a class instance.
    #' @param validateParams An optional param for auto validating this object's parameters after deserialization. Default FALSE.
    fromJSON = function(AimJson, validateParams = FALSE) {
      AimObject <- jsonlite::fromJSON(AimJson)
      self$`accuracyOptimizedMb` <- AimObject$`accuracyOptimizedMb`
      self$`aggregationType` <- AimObject$`aggregationType`
      self$`allowPartialHistoryTimeSeriesPredictions` <- AimObject$`allowPartialHistoryTimeSeriesPredictions`
      self$`allowedPairwiseInteractionGroups` <- ApiClient$new()$deserializeObj(AimObject$`allowedPairwiseInteractionGroups`, "array[array[character]]", loadNamespace("datarobot.apicore"))
      self$`autopilotClusterList` <- ApiClient$new()$deserializeObj(AimObject$`autopilotClusterList`, "array[integer]", loadNamespace("datarobot.apicore"))
      self$`autopilotDataSamplingMethod` <- AimObject$`autopilotDataSamplingMethod`
      self$`autopilotDataSelectionMethod` <- AimObject$`autopilotDataSelectionMethod`
      self$`autopilotWithFeatureDiscovery` <- AimObject$`autopilotWithFeatureDiscovery`
      self$`backtests` <- ApiClient$new()$deserializeObj(AimObject$`backtests`, "array[Backtest]", loadNamespace("datarobot.apicore"))
      self$`biasMitigationFeatureName` <- AimObject$`biasMitigationFeatureName`
      self$`biasMitigationTechnique` <- AimObject$`biasMitigationTechnique`
      self$`blendBestModels` <- AimObject$`blendBestModels`
      self$`blueprintThreshold` <- AimObject$`blueprintThreshold`
      self$`calendarId` <- AimObject$`calendarId`
      self$`classMappingAggregationSettings` <- ClassMappingAggregationSettings$new()$fromJSON(jsonlite::toJSON(AimObject$classMappingAggregationSettings, auto_unbox = TRUE, digits = NA, null = "null"))
      self$`considerBlendersInRecommendation` <- AimObject$`considerBlendersInRecommendation`
      self$`credentials` <- ApiClient$new()$deserializeObj(AimObject$`credentials`, "array[OneOfPasswordCredentialsCredentialId]", loadNamespace("datarobot.apicore"))
      self$`crossSeriesGroupByColumns` <- ApiClient$new()$deserializeObj(AimObject$`crossSeriesGroupByColumns`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`cvHoldoutLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$cvHoldoutLevel)
      self$`cvMethod` <- AimObject$`cvMethod`
      self$`dateRemoval` <- AimObject$`dateRemoval`
      self$`datetimePartitionColumn` <- AimObject$`datetimePartitionColumn`
      self$`defaultToAPriori` <- AimObject$`defaultToAPriori`
      self$`defaultToDoNotDerive` <- AimObject$`defaultToDoNotDerive`
      self$`defaultToKnownInAdvance` <- AimObject$`defaultToKnownInAdvance`
      self$`differencingMethod` <- AimObject$`differencingMethod`
      self$`disableHoldout` <- AimObject$`disableHoldout`
      self$`eventsCount` <- AimObject$`eventsCount`
      self$`exponentiallyWeightedMovingAlpha` <- AimObject$`exponentiallyWeightedMovingAlpha`
      self$`exposure` <- AimObject$`exposure`
      self$`externalPredictions` <- ApiClient$new()$deserializeObj(AimObject$`externalPredictions`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`externalTimeSeriesBaselineDatasetId` <- AimObject$`externalTimeSeriesBaselineDatasetId`
      self$`externalTimeSeriesBaselineDatasetName` <- AimObject$`externalTimeSeriesBaselineDatasetName`
      self$`fairnessMetricsSet` <- AimObject$`fairnessMetricsSet`
      self$`fairnessThreshold` <- AimObject$`fairnessThreshold`
      self$`featureDerivationWindowEnd` <- AimObject$`featureDerivationWindowEnd`
      self$`featureDerivationWindowStart` <- AimObject$`featureDerivationWindowStart`
      self$`featureDiscoverySupervisedFeatureReduction` <- AimObject$`featureDiscoverySupervisedFeatureReduction`
      self$`featureEngineeringPredictionPoint` <- AimObject$`featureEngineeringPredictionPoint`
      self$`featureSettings` <- ApiClient$new()$deserializeObj(AimObject$`featureSettings`, "array[FeatureSetting]", loadNamespace("datarobot.apicore"))
      self$`featurelistId` <- AimObject$`featurelistId`
      self$`forecastWindowEnd` <- AimObject$`forecastWindowEnd`
      self$`forecastWindowStart` <- AimObject$`forecastWindowStart`
      self$`gapDuration` <- AimObject$`gapDuration`
      self$`holdoutDuration` <- AimObject$`holdoutDuration`
      self$`holdoutEndDate` <- ParseRFC3339Timestamp(AimObject$`holdoutEndDate`)
      self$`holdoutLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$holdoutLevel)
      self$`holdoutPct` <- AimObject$`holdoutPct`
      self$`holdoutStartDate` <- ParseRFC3339Timestamp(AimObject$`holdoutStartDate`)
      self$`includeBiasMitigationFeatureAsPredictorVariable` <- AimObject$`includeBiasMitigationFeatureAsPredictorVariable`
      self$`isHoldoutModified` <- AimObject$`isHoldoutModified`
      self$`majorityDownsamplingRate` <- AimObject$`majorityDownsamplingRate`
      self$`metric` <- AimObject$`metric`
      self$`minSecondaryValidationModelCount` <- AimObject$`minSecondaryValidationModelCount`
      self$`mode` <- AimObject$`mode`
      self$`modelSplits` <- AimObject$`modelSplits`
      self$`monotonicDecreasingFeaturelistId` <- AimObject$`monotonicDecreasingFeaturelistId`
      self$`monotonicIncreasingFeaturelistId` <- AimObject$`monotonicIncreasingFeaturelistId`
      self$`multiseriesIdColumns` <- ApiClient$new()$deserializeObj(AimObject$`multiseriesIdColumns`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`numberOfBacktests` <- AimObject$`numberOfBacktests`
      self$`offset` <- ApiClient$new()$deserializeObj(AimObject$`offset`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`onlyIncludeMonotonicBlueprints` <- AimObject$`onlyIncludeMonotonicBlueprints`
      self$`partitionKeyCols` <- ApiClient$new()$deserializeObj(AimObject$`partitionKeyCols`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`periodicities` <- ApiClient$new()$deserializeObj(AimObject$`periodicities`, "array[Periodicity]", loadNamespace("datarobot.apicore"))
      self$`positiveClass` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$positiveClass)
      self$`preferableTargetValue` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$preferableTargetValue)
      self$`prepareModelForDeployment` <- AimObject$`prepareModelForDeployment`
      self$`primaryLocationColumn` <- AimObject$`primaryLocationColumn`
      self$`protectedFeatures` <- ApiClient$new()$deserializeObj(AimObject$`protectedFeatures`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`quantileLevel` <- AimObject$`quantileLevel`
      self$`quickrun` <- AimObject$`quickrun`
      self$`rateTopPctThreshold` <- AimObject$`rateTopPctThreshold`
      self$`relationshipsConfigurationId` <- AimObject$`relationshipsConfigurationId`
      self$`reps` <- AimObject$`reps`
      self$`responseCap` <- AimObject$`responseCap`
      self$`runLeakageRemovedFeatureList` <- AimObject$`runLeakageRemovedFeatureList`
      self$`sampleStepPct` <- AimObject$`sampleStepPct`
      self$`scoringCodeOnly` <- AimObject$`scoringCodeOnly`
      self$`seed` <- AimObject$`seed`
      self$`segmentationTaskId` <- AimObject$`segmentationTaskId`
      self$`shapOnlyMode` <- AimObject$`shapOnlyMode`
      self$`smartDownsampled` <- AimObject$`smartDownsampled`
      self$`stopWords` <- ApiClient$new()$deserializeObj(AimObject$`stopWords`, "array[character]", loadNamespace("datarobot.apicore"))
      self$`target` <- AimObject$`target`
      self$`targetType` <- AimObject$`targetType`
      self$`trainingLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$trainingLevel)
      self$`treatAsExponential` <- AimObject$`treatAsExponential`
      self$`unsupervisedMode` <- AimObject$`unsupervisedMode`
      self$`unsupervisedType` <- AimObject$`unsupervisedType`
      self$`useCrossSeriesFeatures` <- AimObject$`useCrossSeriesFeatures`
      self$`useProjectSettings` <- AimObject$`useProjectSettings`
      self$`useSupervisedFeatureReduction` <- AimObject$`useSupervisedFeatureReduction`
      self$`useTimeSeries` <- AimObject$`useTimeSeries`
      self$`userPartitionCol` <- AimObject$`userPartitionCol`
      self$`validationDuration` <- AimObject$`validationDuration`
      self$`validationLevel` <- .setPrimitiveProperty(typeList = list("character", "numeric"), propertyData = AimObject$validationLevel)
      self$`validationPct` <- AimObject$`validationPct`
      self$`validationType` <- AimObject$`validationType`
      self$`weights` <- AimObject$`weights`
      self$`windowsBasisUnit` <- AimObject$`windowsBasisUnit`

      if (validateParams) {
        self$validate()
      }

      return(self)
    }
  )
)
