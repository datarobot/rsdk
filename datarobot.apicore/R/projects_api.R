# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Projects operations
#' @description datarobot.apicore.Projects
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
ProjectsApi <- R6::R6Class(
  "ProjectsApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Get project&#39;s access control list
    #' Produces: "application/json"
    #'
    #' @details Get a list of users who have access to this project and their roles on the project.
    #' @param offset integer. This many results will be skipped
    #' @param limit integer. At most this many results are returned
    #' @param projectId character. The project ID
    #' @param username character. Optional, only return the access control information for a user with this username.
    #' @param userId character. Optional, only return the access control information for a user with this user ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SharingListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project&#39;s access control list.
    #' \itemize{
    #' }
    #' \item **`400`** Both username and userId were specified
    #' \itemize{
    #' }
    #' \item **`404`** Either the project does not exist or the user does not have permissions to view the project.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped
    #' limit <- 0 # integer | At most this many results are returned
    #' projectId <- 'projectId_example' # character | The project ID
    #' username <- 'username_example' # character | Optional, only return the access control information for a user with this username.
    #' userId <- 'userId_example' # character | Optional, only return the access control information for a user with this user ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$AccessControlList(offset, limit, projectId, username=username, userId=userId)
    #' }
    AccessControlList = function(offset, limit, projectId, username = NULL, userId = NULL, ...) {
      apiResponse <- private$AccessControlListWithHttpInfo(offset, limit, projectId, username, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update project&#39;s access controls
    #' Produces: NA
    #'
    #' @details Set roles for users on this project.
    #' @param projectId character. The project ID
    #' @param sharingUpdateOrRemove \link{SharingUpdateOrRemove}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Roles updated successfully.
    #' \itemize{
    #' }
    #' \item **`409`** The request would leave the project without an owner.
    #' \itemize{
    #' }
    #' \item **`422`** One of the users in the request does not exist, or the request is otherwise invalid
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' sharingUpdateOrRemove <- SharingUpdateOrRemove$new() # SharingUpdateOrRemove |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$AccessControlPatchMany(projectId, sharingUpdateOrRemove=sharingUpdateOrRemove)
    #' }
    AccessControlPatchMany = function(projectId, sharingUpdateOrRemove = NULL, ...) {
      apiResponse <- private$AccessControlPatchManyWithHttpInfo(projectId, sharingUpdateOrRemove, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start modeling
    #' Produces: NA
    #'
    #' @details Start the data modeling process.
    #' @param projectId character. The project ID.
    #' @param aim \link{Aim}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Autopilot has successfully started.  See the Location header.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' aim <- Aim$new() # Aim |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$AimPatchMany(projectId, aim=aim)
    #' }
    AimPatchMany = function(projectId, aim = NULL, ...) {
      apiResponse <- private$AimPatchManyWithHttpInfo(projectId, aim, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Pause or unpause Autopilot
    #' Produces: NA
    #'
    #' @details Pause or unpause the autopilot for a project.
    #' @param projectId character. The project ID.
    #' @param autopilot \link{Autopilot}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Request received
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' autopilot <- Autopilot$new() # Autopilot |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$AutopilotCreate(projectId, autopilot=autopilot)
    #' }
    AutopilotCreate = function(projectId, autopilot = NULL, ...) {
      apiResponse <- private$AutopilotCreateWithHttpInfo(projectId, autopilot, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Start autopilot
    #' Produces: NA
    #'
    #' @details Start autopilot on provided featurelist.
    #' @param projectId character. The project ID.
    #' @param autopilotStart \link{AutopilotStart}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`** Successfully started
    #' \itemize{
    #' }
    #' \item **`422`** Autopilot on this featurelist has already completed or is already in progress. This status code is also returned if target was not selected for specified project.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' autopilotStart <- AutopilotStart$new() # AutopilotStart |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$AutopilotsCreate(projectId, autopilotStart=autopilotStart)
    #' }
    AutopilotsCreate = function(projectId, autopilotStart = NULL, ...) {
      apiResponse <- private$AutopilotsCreateWithHttpInfo(projectId, autopilotStart, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create multiple new features by changing the type of existing features.
    #' Produces: NA
    #'
    #' @details Create multiple new features by changing the type of existing features.
    #' @param projectId character. The project to create the feature in.
    #' @param batchFeatureTransform \link{BatchFeatureTransform}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to create the feature in.
    #' batchFeatureTransform <- BatchFeatureTransform$new() # BatchFeatureTransform |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$BatchTypeTransformFeaturesCreate(projectId, batchFeatureTransform=batchFeatureTransform)
    #' }
    BatchTypeTransformFeaturesCreate = function(projectId, batchFeatureTransform = NULL, ...) {
      apiResponse <- private$BatchTypeTransformFeaturesCreateWithHttpInfo(projectId, batchFeatureTransform, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the result of a batch variable type transformation.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the result of a batch variable type transformation.
    #' @param projectId character. The project containing transformed features.
    #' @param jobId integer. ID of the batch variable type transformation job.
    #' @param batchFeatureTransform \link{BatchFeatureTransform}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{BatchFeatureTransformRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Names of successfully created features.
    #' \itemize{
    #' }
    #' \item **`404`** Could not find specified transformation report
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project containing transformed features.
    #' jobId <- 56 # integer | ID of the batch variable type transformation job.
    #' batchFeatureTransform <- BatchFeatureTransform$new() # BatchFeatureTransform |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$BatchTypeTransformFeaturesResultRetrieve(projectId, jobId, batchFeatureTransform=batchFeatureTransform)
    #' }
    BatchTypeTransformFeaturesResultRetrieve = function(projectId, jobId, batchFeatureTransform = NULL, ...) {
      apiResponse <- private$BatchTypeTransformFeaturesResultRetrieveWithHttpInfo(projectId, jobId, batchFeatureTransform, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the list of allowed country codes to request preloaded calendars generation for.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the list of allowed country codes to request preloaded calendars generation for.
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{PreloadedCalendarListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request for the list of allowed country codes that have the generated preloaded calendars.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarCountryCodesList(offset=offset, limit=limit)
    #' }
    CalendarCountryCodesList = function(offset = 0, limit = 100, ...) {
      apiResponse <- private$CalendarCountryCodesListWithHttpInfo(offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List available calendar events for the project.
    #' Produces: "application/json"
    #'
    #' @details List available calendar events for the project.
    #' @param projectId character. The project ID
    #' @param seriesId character. The name of the series to retrieve specific series for. If specified, retrieves only series specific to the event and common events.
    #' @param startDate character. The start of the date range to return, inclusive. If not specified, start date for the first calendar event will be used.
    #' @param endDate character. The end of the date range to return, exclusive. If not specified, end date capturing the last calendar event will be used.
    #' @param offset integer. Optional (default: &#x60;0&#x60;), this many results will be skipped.
    #' @param limit integer. Optional (default: &#x60;1000&#x60;), at most this many results will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CalendarEventsResponseQuery}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of calendar events.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' seriesId <- 'seriesId_example' # character | The name of the series to retrieve specific series for. If specified, retrieves only series specific to the event and common events.
    #' startDate <- 'startDate_example' # character | The start of the date range to return, inclusive. If not specified, start date for the first calendar event will be used.
    #' endDate <- 'endDate_example' # character | The end of the date range to return, exclusive. If not specified, end date capturing the last calendar event will be used.
    #' offset <- 0 # integer | Optional (default: `0`), this many results will be skipped.
    #' limit <- 1000 # integer | Optional (default: `1000`), at most this many results will be returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarEventsList(projectId, seriesId=seriesId, startDate=startDate, endDate=endDate, offset=offset, limit=limit)
    #' }
    CalendarEventsList = function(projectId, seriesId = NULL, startDate = NULL, endDate = NULL, offset = 0, limit = 1000, ...) {
      apiResponse <- private$CalendarEventsListWithHttpInfo(projectId, seriesId, startDate, endDate, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a list of users who have access to this calendar and their roles on the calendar.
    #' Produces: "application/json"
    #'
    #' @details Get a list of users who have access to this calendar and their roles on the calendar.
    #' @param calendarId character. The ID of this calendar.
    #' @param username character. Optional, only return the access control information for a user with this username. Should not be specified if &#x60;userId&#x60; is specified.
    #' @param userId character. Optional, only return the access control information for a user with this user ID. Should not be specified if &#x60;username&#x60; is specified.
    #' @param offset integer. Optional (default: &#x60;0&#x60;), this many results will be skipped.
    #' @param limit integer. Optional (default: &#x60;0&#x60;), at most this many results will be returned. If &#x60;0&#x60;, all results will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CalendarAccessControlListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request for the list of users who have access to this calendar and their roles on the calendar was successful.
    #' \itemize{
    #' }
    #' \item **`400`** Both &#x60;username&#x60; and &#x60;userId&#x60; were specified.
    #' \itemize{
    #' }
    #' \item **`404`** Entity not found. Either the calendar does not exist or the user does not have permissions to view the calendar.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarId <- 'calendarId_example' # character | The ID of this calendar.
    #' username <- 'username_example' # character | Optional, only return the access control information for a user with this username. Should not be specified if `userId` is specified.
    #' userId <- 'userId_example' # character | Optional, only return the access control information for a user with this user ID. Should not be specified if `username` is specified.
    #' offset <- 0 # integer | Optional (default: `0`), this many results will be skipped.
    #' limit <- 0 # integer | Optional (default: `0`), at most this many results will be returned. If `0`, all results will be returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsAccessControlList(calendarId, username=username, userId=userId, offset=offset, limit=limit)
    #' }
    CalendarsAccessControlList = function(calendarId, username = NULL, userId = NULL, offset = 0, limit = 0, ...) {
      apiResponse <- private$CalendarsAccessControlListWithHttpInfo(calendarId, username, userId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the access control for this calendar.
    #' Produces: NA
    #'
    #' @details Update the access control for this calendar. See the &#x60;entity sharing documentation &lt;sharing&gt;&#x60; for more information.
    #' @param calendarId character. The ID of this calendar.
    #' @param calendarAccessControlUpdate \link{CalendarAccessControlUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request to update the accesss control for this calendar was sussessful.
    #' \itemize{
    #' }
    #' \item **`404`** Invalid &#x60;calendarId&#x60; provided, or user has no access whatsoever on the specified calendar.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid &#x60;username&#x60; provided to modify access for the specified calendar.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarId <- 'calendarId_example' # character | The ID of this calendar.
    #' calendarAccessControlUpdate <- CalendarAccessControlUpdate$new() # CalendarAccessControlUpdate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsAccessControlPatchMany(calendarId, calendarAccessControlUpdate=calendarAccessControlUpdate)
    #' }
    CalendarsAccessControlPatchMany = function(calendarId, calendarAccessControlUpdate = NULL, ...) {
      apiResponse <- private$CalendarsAccessControlPatchManyWithHttpInfo(calendarId, calendarAccessControlUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a calendar.
    #' Produces: "application/json"
    #'
    #' @details Delete a calendar. This can only be done if all projects and deployments using the calendar have been deleted.
    #' @param calendarId character. The ID of this calendar.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Calendar successfully deleted.
    #' \itemize{
    #' }
    #' \item **`404`** Invalid &#x60;calendarId&#x60; provided, or user does not have permissions to delete calendar.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarId <- 'calendarId_example' # character | The ID of this calendar.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsDelete(calendarId)
    #' }
    CalendarsDelete = function(calendarId, ...) {
      apiResponse <- private$CalendarsDeleteWithHttpInfo(calendarId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a calendar from a file.
    #' Produces: "application/json"
    #'
    #' @details Create a calendar from a file in a csv or xlsx format. The calendar file specifies the dates or events in a dataset such that DataRobot automatically derives and creates special features based on the calendar events (e.g., time until the next event, labeling the most recent event).
    #' @param calendarFileUpload \link{CalendarFileUpload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Request for calendar generation was submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarFileUpload <- CalendarFileUpload$new() # CalendarFileUpload |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsFileUploadCreate(calendarFileUpload=calendarFileUpload)
    #' }
    CalendarsFileUploadCreate = function(calendarFileUpload = NULL, ...) {
      apiResponse <- private$CalendarsFileUploadCreateWithHttpInfo(calendarFileUpload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Initialize generation of preloaded calendars.
    #' Produces: "application/json"
    #'
    #' @details Initialize generation of preloaded calendars. Preloaded calendars are available only for time series projects. Preloaded calendars do not support multiseries calendars.
    #' @param preloadedCalendar \link{PreloadedCalendar}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Request for calendar generation was submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' preloadedCalendar <- PreloadedCalendar$new() # PreloadedCalendar |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsFromCountryCodeCreate(preloadedCalendar=preloadedCalendar)
    #' }
    CalendarsFromCountryCodeCreate = function(preloadedCalendar = NULL, ...) {
      apiResponse <- private$CalendarsFromCountryCodeCreateWithHttpInfo(preloadedCalendar, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a calendar from the dataset
    #' Produces: "application/json"
    #'
    #' @details Create a calendar from the dataset.
    #' @param calendarFromDataset \link{CalendarFromDataset}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CreatedCalendarDatasetResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Successfully created a calendar from the dataset.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarFromDataset <- CalendarFromDataset$new() # CalendarFromDataset |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsFromDatasetCreate(calendarFromDataset=calendarFromDataset)
    #' }
    CalendarsFromDatasetCreate = function(calendarFromDataset = NULL, ...) {
      apiResponse <- private$CalendarsFromDatasetCreateWithHttpInfo(calendarFromDataset, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all available calendars for a user.
    #' Produces: "application/json"
    #'
    #' @details List all the calendars which the user has access to.
    #' @param offset integer. Optional (default: &#x60;0&#x60;), this many results will be skipped.
    #' @param limit integer. Optional (default: &#x60;0&#x60;), at most this many results will be returned. If &#x60;0&#x60;, all results will be returned.
    #' @param projectId character. Optional, if provided will filter returned calendars to those being used in the specified project.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CalendarListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** A list of Calendar objects.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | Optional (default: `0`), this many results will be skipped.
    #' limit <- 0 # integer | Optional (default: `0`), at most this many results will be returned. If `0`, all results will be returned.
    #' projectId <- 'projectId_example' # character | Optional, if provided will filter returned calendars to those being used in the specified project.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsList(offset, limit, projectId=projectId)
    #' }
    CalendarsList = function(offset, limit, projectId = NULL, ...) {
      apiResponse <- private$CalendarsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update a calendar&#39;s name
    #' Produces: "application/json"
    #'
    #' @details Update a calendar&#39;s name
    #' @param calendarId character. The ID of this calendar.
    #' @param calendarNameUpdate \link{CalendarNameUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Calendar name successfully updated.
    #' \itemize{
    #' }
    #' \item **`404`** Invalid &#x60;calendarId&#x60; provided, or user does not have permissions to update calendar.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarId <- 'calendarId_example' # character | The ID of this calendar.
    #' calendarNameUpdate <- CalendarNameUpdate$new() # CalendarNameUpdate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsPatch(calendarId, calendarNameUpdate=calendarNameUpdate)
    #' }
    CalendarsPatch = function(calendarId, calendarNameUpdate = NULL, ...) {
      apiResponse <- private$CalendarsPatchWithHttpInfo(calendarId, calendarNameUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve information about a calendar.
    #' Produces: "application/json"
    #'
    #' @details List all the information about a calendar such as the total number of event dates, the earliest calendar event date, the IDs of projects currently using this calendar and the others.
    #' @param calendarId character. The ID of this calendar.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CalendarRecord}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request for a Calendar object was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' calendarId <- 'calendarId_example' # character | The ID of this calendar.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CalendarsRetrieve(calendarId)
    #' }
    CalendarsRetrieve = function(calendarId, ...) {
      apiResponse <- private$CalendarsRetrieveWithHttpInfo(calendarId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Schedule Project Permadelete Job
    #' Produces: NA
    #'
    #' @details Add list of projects to permadelete and returns async status
    #' @param projectNuke \link{ProjectNuke}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Location URL to check permadelete status per project
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectNuke <- ProjectNuke$new() # ProjectNuke |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsCreate(projectNuke=projectNuke)
    #' }
    CleanupJobsCreate = function(projectNuke = NULL, ...) {
      apiResponse <- private$CleanupJobsCreateWithHttpInfo(projectNuke, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel Scheduled Project Permadelete Job
    #' Produces: NA
    #'
    #' @details Stop permadelete job, if possible
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsDelete(statusId)
    #' }
    CleanupJobsDelete = function(statusId, ...) {
      apiResponse <- private$CleanupJobsDeleteWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download a projects permadeletion report.
    #' Produces: "application/json"
    #'
    #' @details Get a file containing a per-project report of permanent deletion.
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectNukeJobStatus}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** JSON-formatted project permadeletion report.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** Contains an auto generated filename for this download (&#39;attachment;filename&#x3D;\&quot;project_permadeletion_&lt;statusId&gt;.json\&quot;&#39;).
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsDownloadList(statusId)
    #' }
    CleanupJobsDownloadList = function(statusId, ...) {
      apiResponse <- private$CleanupJobsDownloadListWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Project Permadelete job status
    #' Produces: "application/json"
    #'
    #' @details Get async status of the project permadelete job
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectNukeJobListStatus}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Permadelete Job Status with details per project
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsList()
    #' }
    CleanupJobsList = function(...) {
      apiResponse <- private$CleanupJobsListWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Project Permadelete job status
    #' Produces: "application/json"
    #'
    #' @details Get async status of the project permadelete job
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectNukeJobStatus}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Permadelete Job Status with details per project
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsRetrieve(statusId)
    #' }
    CleanupJobsRetrieve = function(statusId, ...) {
      apiResponse <- private$CleanupJobsRetrieveWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get a projects cleanup jobs summary.
    #' Produces: "application/json"
    #'
    #' @details Get number of projects whose deletion finished in particular state
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectNukeJobStatusSummary}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Project permanent deletion job status to occurrence count
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CleanupJobsSummaryList(statusId)
    #' }
    CleanupJobsSummaryList = function(statusId, ...) {
      apiResponse <- private$CleanupJobsSummaryListWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Clone a project
    #' Produces: "application/json"
    #'
    #' @details      Create a clone of an existing project.      The resultant project will begin the initial exploratory     data analysis and will be ready to set the target of the new project shortly.
    #' @param projectClone \link{ProjectClone}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Project cloning has successfully started.  See the Location header.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectClone <- ProjectClone$new() # ProjectClone |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ClonesCreate(projectClone=projectClone)
    #' }
    ClonesCreate = function(projectClone = NULL, ...) {
      apiResponse <- private$ClonesCreateWithHttpInfo(projectClone, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create project.
    #' Produces: "application/json"
    #'
    #' @details Create a new project.
    #' @param projectCreate \link{ProjectCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started.  See the Location header.
    #' \itemize{
    #' }
    #' \item **`403`** User does not have permission to use specified dataset item for project.
    #' \itemize{
    #' }
    #' \item **`404`** The dataset item with the given ID or version ID is not found.
    #' \itemize{
    #' }
    #' \item **`422`** Ingest not yet completed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectCreate <- ProjectCreate$new() # ProjectCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$Create(projectCreate=projectCreate)
    #' }
    Create = function(projectCreate = NULL, ...) {
      apiResponse <- private$CreateWithHttpInfo(projectCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Validate columns for potential use as the group-by column for cross-series functionality.
    #' Produces: "application/json"
    #'
    #' @details Validate columns for potential use as the group-by column for cross-series functionality.  The group-by column is an optional setting that indicates how to further splitseries into related groups. For example, if each series represents sales of an individual product, the group-by column could be the product category, e.g., \&quot;clothing\&quot; or \&quot;sports equipment\&quot;.
    #' @param projectId character. The project ID
    #' @param crossSeriesGroupByColumnValidatePayload \link{CrossSeriesGroupByColumnValidatePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CrossSeriesGroupByColumnValidateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Cross-series group-by column validation job was successfully submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' crossSeriesGroupByColumnValidatePayload <- CrossSeriesGroupByColumnValidatePayload$new() # CrossSeriesGroupByColumnValidatePayload |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$CrossSeriesPropertiesCreate(projectId, crossSeriesGroupByColumnValidatePayload=crossSeriesGroupByColumnValidatePayload)
    #' }
    CrossSeriesPropertiesCreate = function(projectId, crossSeriesGroupByColumnValidatePayload = NULL, ...) {
      apiResponse <- private$CrossSeriesPropertiesCreateWithHttpInfo(projectId, crossSeriesGroupByColumnValidatePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a project
    #' Produces: NA
    #'
    #' @details Delete a project
    #' @param projectId character. The project ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The project has been successfully deleted.
    #' \itemize{
    #' }
    #' \item **`409`** The project is in use and cannot be deleted.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$Delete(projectId)
    #' }
    Delete = function(projectId, ...) {
      apiResponse <- private$DeleteWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Count soft-deleted projects.
    #' Produces: "application/json"
    #'
    #' @details Get current number of deleted projects matching search criteria. Value is limited by DELETED_PROJECTS_BATCH_LIMIT system setting. That means that the actual amount of deleted projects can be greater than the limit, but counting will stop when reaching it.
    #' @param searchFor character. Project or dataset name to filter by
    #' @param creator character. Creator ID to filter projects by
    #' @param organization character. ID of organization that projects should belong to. Given project belongs to the organization the user who created the project is part of that organization.If there are no users in organization, then no projects will match the query.
    #' @param deletedBefore character. ISO-8601 formatted date projects were deleted before
    #' @param deletedAfter character. ISO-8601 formatted date projects were deleted after
    #' @param projectId character. Project ID to search
    #' @param limit integer. Count deleted projects until specified value reached.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeletedProjectCountResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Soft-deleted projects amount, current counting limit value and boolean flag to notify if an actual amount of soft-deleted projects in the system exceeds the limit value.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' searchFor <- 'searchFor_example' # character | Project or dataset name to filter by
    #' creator <- 'creator_example' # character | Creator ID to filter projects by
    #' organization <- 'organization_example' # character | ID of organization that projects should belong to. Given project belongs to the organization the user who created the project is part of that organization.If there are no users in organization, then no projects will match the query.
    #' deletedBefore <- 'deletedBefore_example' # character | ISO-8601 formatted date projects were deleted before
    #' deletedAfter <- 'deletedAfter_example' # character | ISO-8601 formatted date projects were deleted after
    #' projectId <- 'projectId_example' # character | Project ID to search
    #' limit <- 56 # integer | Count deleted projects until specified value reached.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$DeletedProjectsCountList(searchFor=searchFor, creator=creator, organization=organization, deletedBefore=deletedBefore, deletedAfter=deletedAfter, projectId=projectId, limit=limit)
    #' }
    DeletedProjectsCountList = function(searchFor = NULL, creator = NULL, organization = NULL, deletedBefore = NULL, deletedAfter = NULL, projectId = NULL, limit = NULL, ...) {
      apiResponse <- private$DeletedProjectsCountListWithHttpInfo(searchFor, creator, organization, deletedBefore, deletedAfter, projectId, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a list of soft-deleted projects
    #' Produces: "application/json"
    #'
    #' @details Retrieve a list of soft-deleted projects matching search criteria
    #' @param searchFor character. Project or dataset name to filter by
    #' @param creator character. Creator ID to filter projects by
    #' @param organization character. ID of organization that projects should belong to. Given project belongs to the organization the user who created the project is part of that organization.If there are no users in organization, then no projects will match the query.
    #' @param deletedBefore character. ISO-8601 formatted date projects were deleted before
    #' @param deletedAfter character. ISO-8601 formatted date projects were deleted after
    #' @param projectId character. Project ID to search
    #' @param limit integer. At most this many results are returned.
    #' @param offset integer. This many results will be skipped.
    #' @param orderBy Enum < [projectId, projectName, datasetName, deletedOn, deletedBy, creator, -projectId, -projectName, -datasetName, -deletedOn, -deletedBy, -creator] > Order deleted projects by
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DeletedProjectListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of soft-deleted projects
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' searchFor <- 'searchFor_example' # character | Project or dataset name to filter by
    #' creator <- 'creator_example' # character | Creator ID to filter projects by
    #' organization <- 'organization_example' # character | ID of organization that projects should belong to. Given project belongs to the organization the user who created the project is part of that organization.If there are no users in organization, then no projects will match the query.
    #' deletedBefore <- 'deletedBefore_example' # character | ISO-8601 formatted date projects were deleted before
    #' deletedAfter <- 'deletedAfter_example' # character | ISO-8601 formatted date projects were deleted after
    #' projectId <- 'projectId_example' # character | Project ID to search
    #' limit <- 20 # integer | At most this many results are returned.
    #' offset <- 0 # integer | This many results will be skipped.
    #' orderBy <- "deletedOn" # character | Order deleted projects by
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$DeletedProjectsList(searchFor=searchFor, creator=creator, organization=organization, deletedBefore=deletedBefore, deletedAfter=deletedAfter, projectId=projectId, limit=limit, offset=offset, orderBy=orderBy)
    #' }
    DeletedProjectsList = function(searchFor = NULL, creator = NULL, organization = NULL, deletedBefore = NULL, deletedAfter = NULL, projectId = NULL, limit = 20, offset = 0, orderBy = "deletedOn", ...) {
      apiResponse <- private$DeletedProjectsListWithHttpInfo(searchFor, creator, organization, deletedBefore, deletedAfter, projectId, limit, offset, orderBy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Recover soft-deleted project
    #' Produces: "application/json"
    #'
    #' @details Recover (undelete) soft-deleted project
    #' @param projectId character. The project ID.
    #' @param projectRecover \link{ProjectRecover}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectRecoverResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Recovery operation result description
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' projectRecover <- ProjectRecover$new() # ProjectRecover |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$DeletedProjectsPatch(projectId, projectRecover=projectRecover)
    #' }
    DeletedProjectsPatch = function(projectId, projectRecover = NULL, ...) {
      apiResponse <- private$DeletedProjectsPatchWithHttpInfo(projectId, projectRecover, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get discarded features.
    #' Produces: "application/json"
    #'
    #' @details Get features which were discarded during feature reduction process.
    #' @param projectId character. The project ID
    #' @param search character. Case insensitive search against discarded feature names.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{DiscardedFeaturesResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Discarded features.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' search <- 'search_example' # character | Case insensitive search against discarded feature names.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$DiscardedFeaturesList(projectId, search=search)
    #' }
    DiscardedFeaturesList = function(projectId, search = NULL, ...) {
      apiResponse <- private$DiscardedFeaturesListWithHttpInfo(projectId, search, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Validate baseline data
    #' Produces: NA
    #'
    #' @details This route validates if a provided catalog version id can be used as baseline for calculating metrics. This functionality is available only for time series projects.For a baseline dataset to be valid, the number of unique date amd multiseries_id columnrows must match the unique number of date and multiseries_id column rows in the uploadedtraining dataset. This functionality is limited to one forecast distance. Additionally, the catalog must be a snapshot.
    #' @param projectId character. The project ID
    #' @param externalTsBaselinePayload \link{ExternalTSBaselinePayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Validate baseline data that is provided in the form of a catalog version id. We willconfirm that the dataset contains the proper date, target column, and multiseries ID column. If the provided dataset meets the criteria, the job will be successful.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process external time sereis baseline validation job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' externalTsBaselinePayload <- ExternalTSBaselinePayload$new() # ExternalTSBaselinePayload |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ExternalTimeSeriesBaselineDataValidationJobsCreate(projectId, externalTsBaselinePayload=externalTsBaselinePayload)
    #' }
    ExternalTimeSeriesBaselineDataValidationJobsCreate = function(projectId, externalTsBaselinePayload = NULL, ...) {
      apiResponse <- private$ExternalTimeSeriesBaselineDataValidationJobsCreateWithHttpInfo(projectId, externalTsBaselinePayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Baseline Validation Job
    #' Produces: "application/json"
    #'
    #' @details Retrieve information to confirm if the validation job triggered via /api/v2/projects/(projectId)/externalTimeSeriesBaselineDataValidationJobs/ is valid.
    #' @param projectId character. The project to retrieve the validation job information from.
    #' @param baselineValidationJobId character. The id for the validation job
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ExternalTSBaselineResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`403`** User does not have access to this functionality.
    #' \itemize{
    #' }
    #' \item **`404`** External time series validation job not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve the validation job information from.
    #' baselineValidationJobId <- 'baselineValidationJobId_example' # character | The id for the validation job
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ExternalTimeSeriesBaselineDataValidationJobsRetrieve(projectId, baselineValidationJobId)
    #' }
    ExternalTimeSeriesBaselineDataValidationJobsRetrieve = function(projectId, baselineValidationJobId, ...) {
      apiResponse <- private$ExternalTimeSeriesBaselineDataValidationJobsRetrieveWithHttpInfo(projectId, baselineValidationJobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download the project dataset with features added by feature discovery
    #' Produces: NA
    #'
    #' @details Download the project dataset with features added by feature discovery
    #' @param projectId character. The project ID
    #' @param datasetId character. The ID of the dataset to use for the prediction.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Project dataset file.
    #' \itemize{
    #' }
    #' \item **`404`** Data is not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' datasetId <- 'datasetId_example' # character | The ID of the dataset to use for the prediction.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureDiscoveryDatasetDownloadList(projectId, datasetId=datasetId)
    #' }
    FeatureDiscoveryDatasetDownloadList = function(projectId, datasetId = NULL, ...) {
      apiResponse <- private$FeatureDiscoveryDatasetDownloadListWithHttpInfo(projectId, datasetId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a text file containing the feature discovery log
    #' Produces: NA
    #'
    #' @details Retrieve a text file containing the feature discovery log. This route is only supported for feature discovery projects that have finished partitioning.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Feature discovery log file.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureDiscoveryLogsDownloadList(projectId)
    #' }
    FeatureDiscoveryLogsDownloadList = function(projectId, ...) {
      apiResponse <- private$FeatureDiscoveryLogsDownloadListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve the feature discovery log content and log length
    #' Produces: "application/json"
    #'
    #' @details Retrieve the feature discovery log content and log length for a feature discovery project. This route is only supported for feature discovery projects that have finished partitioning
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureDiscoveryLogListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Feature discovery log data.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureDiscoveryLogsList(projectId, offset=offset, limit=limit)
    #' }
    FeatureDiscoveryLogsList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$FeatureDiscoveryLogsListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Download feature discovery SQL recipe
    #' Produces: NA
    #'
    #' @details Download feature discovery SQL recipe for a project
    #' @param projectId character. The project ID
    #' @param modelId character. Model ID to export recipe for
    #' @param statusOnly Enum < [false, False, true, True] > Return status only for availability check
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Project feature discovery SQL recipe file.
    #' \itemize{
    #' }
    #' \item **`400`** Unable to process the request
    #' \itemize{
    #' }
    #' \item **`404`** Data not found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelId <- 'modelId_example' # character | Model ID to export recipe for
    #' statusOnly <- "false" # character | Return status only for availability check
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureDiscoveryRecipeSQLsDownloadList(projectId, modelId=modelId, statusOnly=statusOnly)
    #' }
    FeatureDiscoveryRecipeSQLsDownloadList = function(projectId, modelId = NULL, statusOnly = "false", ...) {
      apiResponse <- private$FeatureDiscoveryRecipeSQLsDownloadListWithHttpInfo(projectId, modelId, statusOnly, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Generate feature discovery SQL recipe
    #' Produces: NA
    #'
    #' @details Generate feature discovery SQL recipe for a project
    #' @param projectId character. The project ID
    #' @param featureDiscoveryRecipeSqlsExport \link{FeatureDiscoveryRecipeSQLsExport}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`404`** Data not found
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' featureDiscoveryRecipeSqlsExport <- FeatureDiscoveryRecipeSQLsExport$new() # FeatureDiscoveryRecipeSQLsExport |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureDiscoveryRecipeSqlExportsCreate(projectId, featureDiscoveryRecipeSqlsExport=featureDiscoveryRecipeSqlsExport)
    #' }
    FeatureDiscoveryRecipeSqlExportsCreate = function(projectId, featureDiscoveryRecipeSqlsExport = NULL, ...) {
      apiResponse <- private$FeatureDiscoveryRecipeSqlExportsCreateWithHttpInfo(projectId, featureDiscoveryRecipeSqlsExport, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get feature histogram
    #' Produces: "application/json"
    #'
    #' @details Get histogram chart data for a specific feature. Information that can be used to build histogram charts. Plot data returned is based on raw data that is calculated during initial project creation and updated after the project&#39;s target variable has been selected. The number of bins in the histogram is no greater than the requested limit.
    #' @param binLimit integer. maximum number of bins in the returned plot
    #' @param projectId character. The ID of the project
    #' @param featureName character. the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #' @param key character. name of the top 50 key for which plot to be retrieved. (Only required for the Summarized categorical feature)
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureHistogramResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature histogram chart data
    #' \itemize{
    #' }
    #' \item **`404`** A Histogram is unavailable for this feature because the data contains unsupportedfeature types (e.g., image, audio, location).
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' binLimit <- 60 # integer | maximum number of bins in the returned plot
    #' projectId <- 'projectId_example' # character | The ID of the project
    #' featureName <- 'featureName_example' # character | the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:`/api/v2/projects/(projectId)/features/` to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #' key <- 'key_example' # character | name of the top 50 key for which plot to be retrieved. (Only required for the Summarized categorical feature)
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureHistogramsRetrieve(binLimit, projectId, featureName, key=key)
    #' }
    FeatureHistogramsRetrieve = function(binLimit, projectId, featureName, key = NULL, ...) {
      apiResponse <- private$FeatureHistogramsRetrieveWithHttpInfo(binLimit, projectId, featureName, key, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve Feature Discovery Lineage
    #' Produces: "application/json"
    #'
    #' @details Retrieve single Feature Discovery feature lineage.
    #' @param projectId character. The project to retrieve a lineage from.
    #' @param featureLineageId character. id of a feature lineage object to return. You can access the id with  *ModelingFeatureRetrieveController*.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureLineageResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve a lineage from.
    #' featureLineageId <- 'featureLineageId_example' # character | id of a feature lineage object to return. You can access the id with  *ModelingFeatureRetrieveController*.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeatureLineagesRetrieve(projectId, featureLineageId)
    #' }
    FeatureLineagesRetrieve = function(projectId, featureLineageId, ...) {
      apiResponse <- private$FeatureLineagesRetrieveWithHttpInfo(projectId, featureLineageId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new featurelist.
    #' Produces: "application/json"
    #'
    #' @details Create a new featurelist from list of feature names.
    #' @param projectId character. The project ID
    #' @param createFeaturelist \link{CreateFeaturelist}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The newly created featurelist in the same format as :http:get:&#x60;/api/v2/projects/(projectId)/featurelists/(featurelistId)/&#x60;.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' createFeaturelist <- CreateFeaturelist$new() # CreateFeaturelist |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturelistsCreate(projectId, createFeaturelist=createFeaturelist)
    #' }
    FeaturelistsCreate = function(projectId, createFeaturelist = NULL, ...) {
      apiResponse <- private$FeaturelistsCreateWithHttpInfo(projectId, createFeaturelist, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a specified featurelist.
    #' Produces: "application/json"
    #'
    #' @details Delete a specified featurelist. All models using a featurelist, whether as the training featurelist or as a monotonic constraint featurelist, will also be deleted when the deletion is executed and any queued or running jobs using it will be cancelled. Similarly, predictions made on these models will also be deleted. All the entities that are to be deleted with a featurelist are described as \&quot;dependencies\&quot; of it. When deleting a featurelist with dependencies, users must pass an additional query parameter &#x60;deleteDependencies&#x60; to confirm they want to delete the featurelist and all its dependencies. Without that option, only featurelists with no dependencies may be successfully deleted. Featurelists configured into the project as a default featurelist or as a default monotonic constraint featurelist cannot be deleted. Featurelists used in a model deployment cannot be deleted until the model deployment is deleted.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param dryRun Enum < [false, False, true, True] > Preview the deletion results without actually deleting the featurelist.
    #' @param deleteDependencies Enum < [false, False, true, True] > Automatically delete all dependencies of a featurelist. If false (default), will only delete the featurelist if it has no dependencies. The value of deleteDependencies will not be used if dryRun is true.If a featurelist has dependencies, deleteDependencies must be true for the request to succeed.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistDestroyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #' dryRun <- "false" # character | Preview the deletion results without actually deleting the featurelist.
    #' deleteDependencies <- "false" # character | Automatically delete all dependencies of a featurelist. If false (default), will only delete the featurelist if it has no dependencies. The value of deleteDependencies will not be used if dryRun is true.If a featurelist has dependencies, deleteDependencies must be true for the request to succeed.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturelistsDelete(projectId, featurelistId, dryRun=dryRun, deleteDependencies=deleteDependencies)
    #' }
    FeaturelistsDelete = function(projectId, featurelistId, dryRun = "false", deleteDependencies = "false", ...) {
      apiResponse <- private$FeaturelistsDeleteWithHttpInfo(projectId, featurelistId, dryRun, deleteDependencies, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List featurelists
    #' Produces: "application/json"
    #'
    #' @details List all featurelists for a project.
    #' @param projectId character. The project ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The list of featurelists
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturelistsList(projectId)
    #' }
    FeaturelistsList = function(projectId, ...) {
      apiResponse <- private$FeaturelistsListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update an existing featurelist
    #' Produces: NA
    #'
    #' @details Update an existing featurelist by ID.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param updateFeaturelist \link{UpdateFeaturelist}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The featurelist was successfully updated.
    #' \itemize{
    #' }
    #' \item **`422`** Update failed due to an invalid payload. This may be because the name is identical to an existing featurelist name.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #' updateFeaturelist <- UpdateFeaturelist$new() # UpdateFeaturelist |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturelistsPatch(projectId, featurelistId, updateFeaturelist=updateFeaturelist)
    #' }
    FeaturelistsPatch = function(projectId, featurelistId, updateFeaturelist = NULL, ...) {
      apiResponse <- private$FeaturelistsPatchWithHttpInfo(projectId, featurelistId, updateFeaturelist, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a feature list
    #' Produces: "application/json"
    #'
    #' @details Retrieve a single known feature list.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Retrieve a single known feature list.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturelistsRetrieve(projectId, featurelistId)
    #' }
    FeaturelistsRetrieve = function(projectId, featurelistId, ...) {
      apiResponse <- private$FeaturelistsRetrieveWithHttpInfo(projectId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List project features
    #' Produces: "application/json"
    #'
    #' @details List the features from a project with descriptive information.
    #' @param projectId character. The project ID.
    #' @param forSegmentedAnalysis Enum < [false, False, true, True] > When True, features returned will be filtered to those usable for segmented analysis.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{ProjectFeatureResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The list of features
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' forSegmentedAnalysis <- "false" # character | When True, features returned will be filtered to those usable for segmented analysis.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturesList(projectId, forSegmentedAnalysis=forSegmentedAnalysis)
    #' }
    FeaturesList = function(projectId, forSegmentedAnalysis = "false", ...) {
      apiResponse <- private$FeaturesListWithHttpInfo(projectId, forSegmentedAnalysis, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List feature metrics
    #' Produces: "application/json"
    #'
    #' @details List the appropriate metrics if a feature were chosen as the target. The metrics listed will include both weighted and unweighted metrics - which are appropriate will depend on whether a weights column is used.
    #' @param featureName character. The name of the feature to check
    #' @param projectId character. The project ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeatureMetricsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature&#39;s metrics
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' featureName <- 'featureName_example' # character | The name of the feature to check
    #' projectId <- 'projectId_example' # character | The project ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturesMetricsList(featureName, projectId)
    #' }
    FeaturesMetricsList = function(featureName, projectId, ...) {
      apiResponse <- private$FeaturesMetricsListWithHttpInfo(featureName, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve potential multiseries ID columns to use with a particular datetime partition column.
    #' Produces: "application/json"
    #'
    #' @details Time series projects require that each timestamp have at most one row corresponding to it. However, multiple series of data can be handled within a single project by designating a multiseries ID column that assigns each row to a particular series. See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; docs on time series projects for more information.  Note that detection will have to be triggered via :http:post:&#x60;/api/v2/projects/(projectId)/multiseriesProperties/&#x60; in order for multiseries id columns to appear here. The route will return successfully with an empty array of detected columns if detection hasn&#39;t run yet, or hasn&#39;t found any valid columns.
    #' @param projectId character. The project ID to retrieve multiseries properties from.
    #' @param featureName character. The feature to be used to the datetime partition column.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MultiseriesRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request to retrieve the potential multiseries ID columns was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID to retrieve multiseries properties from.
    #' featureName <- 'featureName_example' # character | The feature to be used to the datetime partition column.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturesMultiseriesPropertiesList(projectId, featureName)
    #' }
    FeaturesMultiseriesPropertiesList = function(projectId, featureName, ...) {
      apiResponse <- private$FeaturesMultiseriesPropertiesListWithHttpInfo(projectId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get project feature
    #' Produces: NA
    #'
    #' @details Retrieve the specified feature with descriptive information. Descriptive information for features also includes summary statistics as of v2.8. These are returned via the fields max, min, mean, median, and stdDev. These fields are formatted according to the original feature type of the feature. For example, the format will be numeric if your feature is numeric, in feet and inches if your feature is length type, in currency if your feature is currency type, in time format if your feature is time type, or in ISO date format if your feature is a date type. Numbers will be rounded so that they have at most two non-zero decimal digits. For projects created prior to v2.8, these descriptive statistics will not be available. Also, some features, like categorical and text features, may not have summary statistics.
    #' @param projectId character. The ID of the project
    #' @param featureName character. the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The feature information
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project
    #' featureName <- 'featureName_example' # character | the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:`/api/v2/projects/(projectId)/features/` to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$FeaturesRetrieve(projectId, featureName)
    #' }
    FeaturesRetrieve = function(projectId, featureName, ...) {
      apiResponse <- private$FeaturesRetrieveWithHttpInfo(projectId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a project from an HDFS file source.
    #' Produces: "application/json"
    #'
    #' @details Create a project from an HDFS file via WebHDFS API. Represent the file using URL, optionally, port, and optionally, user/password credentials. For example, &#x60;{\&quot;url\&quot;: \&quot;hdfs://&lt;ip&gt;/path/to/file.csv\&quot;, \&quot;port\&quot;: \&quot;50070\&quot;}&#x60;.
    #' @param hdfsProjectCreate \link{HdfsProjectCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' hdfsProjectCreate <- HdfsProjectCreate$new() # HdfsProjectCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$HdfsProjectsCreate(hdfsProjectCreate=hdfsProjectCreate)
    #' }
    HdfsProjectsCreate = function(hdfsProjectCreate = NULL, ...) {
      apiResponse <- private$HdfsProjectsCreateWithHttpInfo(hdfsProjectCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel Job
    #' Produces: NA
    #'
    #' @details Cancel a pending job.
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The job has been canceled.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$JobsDelete(projectId, jobId)
    #' }
    JobsDelete = function(projectId, jobId, ...) {
      apiResponse <- private$JobsDeleteWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List project jobs
    #' Produces: "application/json"
    #'
    #' @details List the project&#39;s jobs.
    #' @param projectId character. The project ID.
    #' @param status Enum < [queue, inprogress, error] > If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{JobListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project&#39;s jobs
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' status <- 'status_example' # character | If provided, only jobs with the same status will be included in the results; otherwise, queued and inprogress jobs (but not errored jobs) will be returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$JobsList(projectId, status=status)
    #' }
    JobsList = function(projectId, status = NULL, ...) {
      apiResponse <- private$JobsListWithHttpInfo(projectId, status, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get job
    #' Produces: "application/json"
    #'
    #' @details Retrieve details for a job that has been started but has not yet completed.
    #' @param projectId character. The project ID.
    #' @param jobId character. The job ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{JobDetailsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The job details
    #' \itemize{
    #' }
    #' \item **`303`** The requested job has already finished. See the Location header for the job details.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' jobId <- 'jobId_example' # character | The job ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$JobsRetrieve(projectId, jobId)
    #' }
    JobsRetrieve = function(projectId, jobId, ...) {
      apiResponse <- private$JobsRetrieveWithHttpInfo(projectId, jobId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List projects
    #' Produces: "application/json"
    #'
    #' @details List all available projects.
    #' @param projectName character. if provided will filter returned projects for projects with matching names
    #' @param projectId \link{OneOfstringarray}. if provided will filter returned projects with matching project IDs
    #' @param orderBy Enum < [projectName, -projectName] > if provided will order the results by this field
    #' @param featureDiscovery Enum < [false, False, true, True] > Return only feature discovery projects
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return list( \link{ProjectDetailsResponse} )
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The list of projects
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectName <- 'projectName_example' # character | if provided will filter returned projects for projects with matching names
    #' projectId <- OneOfstringarray$new() # OneOfstringarray | if provided will filter returned projects with matching project IDs
    #' orderBy <- 'orderBy_example' # character | if provided will order the results by this field
    #' featureDiscovery <- 'featureDiscovery_example' # character | Return only feature discovery projects
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$List(projectName=projectName, projectId=projectId, orderBy=orderBy, featureDiscovery=featureDiscovery)
    #' }
    List = function(projectName = NULL, projectId = NULL, orderBy = NULL, featureDiscovery = NULL, ...) {
      apiResponse <- private$ListWithHttpInfo(projectName, projectId, orderBy, featureDiscovery, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new modeling featurelist.
    #' Produces: "application/json"
    #'
    #' @details Create new modeling featurelist from list of feature names. Only time series projects differentiate between modeling and input featurelists. On other projects, this route will behave the same as :http:post:&#x60;/api/v2/projects/(projectId)/featurelists/&#x60;. On time series projects, this can be used after the target has been set in order to create a new featurelist on the modeling features, although the previously mentioned route for creating featurelists will be disabled. On time series projects, only modeling features may be passed to this route to create a featurelist.
    #' @param projectId character. The project ID
    #' @param createFeaturelist \link{CreateFeaturelist}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The newly created featurelist in the same format as :http:get:&#x60;/api/v2/projects/(projectId)/modelingFeaturelists/(featurelistId)/&#x60;.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' createFeaturelist <- CreateFeaturelist$new() # CreateFeaturelist |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturelistsCreate(projectId, createFeaturelist=createFeaturelist)
    #' }
    ModelingFeaturelistsCreate = function(projectId, createFeaturelist = NULL, ...) {
      apiResponse <- private$ModelingFeaturelistsCreateWithHttpInfo(projectId, createFeaturelist, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a specified modeling featurelist.
    #' Produces: "application/json"
    #'
    #' @details Delete a specified modeling featurelist. All models using a featurelist, whether as the training featurelist or as a monotonic constraint featurelist, will also be deleted when the deletion is executed and any queued or running jobs using it will be cancelled. Similarly, predictions made on these models will also be deleted. All the entities that are to be deleted with a featurelist are described as \&quot;dependencies\&quot; of it. When deleting a featurelist with dependencies, users must pass an additional query parameter &#x60;deleteDependencies&#x60; to confirm they want to delete the featurelist and all its dependencies. Without that option, only featurelists with no dependencies may be successfully deleted. Featurelists configured into the project as a default featurelist or as a default monotonic constraint featurelist cannot be deleted. Featurelists used in a model deployment cannot be deleted until the model deployment is deleted. Modeling featurelists are featurelists of modeling features, and are the appropriate featurelists to use when creating models or restarting the autopilot. In a time series project, these will be distinct from those returned from :http:get:&#x60;/api/v2/projects/(projectId)/featurelists/&#x60; while in other projects these will be identical.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param dryRun Enum < [false, False, true, True] > Preview the deletion results without actually deleting the featurelist.
    #' @param deleteDependencies Enum < [false, False, true, True] > Automatically delete all dependencies of a featurelist. If false (default), will only delete the featurelist if it has no dependencies. The value of deleteDependencies will not be used if dryRun is true.If a featurelist has dependencies, deleteDependencies must be true for the request to succeed.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistDestroyResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #' dryRun <- "false" # character | Preview the deletion results without actually deleting the featurelist.
    #' deleteDependencies <- "false" # character | Automatically delete all dependencies of a featurelist. If false (default), will only delete the featurelist if it has no dependencies. The value of deleteDependencies will not be used if dryRun is true.If a featurelist has dependencies, deleteDependencies must be true for the request to succeed.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturelistsDelete(projectId, featurelistId, dryRun=dryRun, deleteDependencies=deleteDependencies)
    #' }
    ModelingFeaturelistsDelete = function(projectId, featurelistId, dryRun = "false", deleteDependencies = "false", ...) {
      apiResponse <- private$ModelingFeaturelistsDeleteWithHttpInfo(projectId, featurelistId, dryRun, deleteDependencies, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all modeling featurelists from a project
    #' Produces: "application/json"
    #'
    #' @details List all modeling featurelists from the project requested by ID. This route will only become available after the target and partitioning options have been set for a project. Modeling featurelists are featurelists of modeling features, and are the correct featurelists to use when creating models or restarting the autopilot. In a time series project, these will differ from those returned from :http:get:&#x60;/api/v2/projects/(projectId)/featurelists/&#x60; while in other projects these will be identical. See the :ref:&#x60;documentation &lt;input_vs_modeling&gt;&#x60; for more information on the distinction between input and modeling data in time series projects.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of requested project modeling featurelists.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturelistsList(offset, limit, projectId)
    #' }
    ModelingFeaturelistsList = function(offset, limit, projectId, ...) {
      apiResponse <- private$ModelingFeaturelistsListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update an existing modeling featurelist
    #' Produces: NA
    #'
    #' @details Update an existing modeling featurelist by ID. In non-time series projects, \&quot;modeling featurelists\&quot; and \&quot;featurelists\&quot; routes behave the same, except \&quot;modeling featurelists\&quot; are only accessible after the project is ready for modeling.  In time series projects, \&quot;featurelists\&quot; contain the input features before feature derivation that are used to derive the time series features, while  \&quot;modeling featurelists\&quot; contain the derived time series features used for modeling.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param updateFeaturelist \link{UpdateFeaturelist}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** The modeling featurelist was successfully updated.
    #' \itemize{
    #' }
    #' \item **`422`** Update failed due to an invalid payload. This may be because the name is identical to an existing featurelist name.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #' updateFeaturelist <- UpdateFeaturelist$new() # UpdateFeaturelist |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturelistsPatch(projectId, featurelistId, updateFeaturelist=updateFeaturelist)
    #' }
    ModelingFeaturelistsPatch = function(projectId, featurelistId, updateFeaturelist = NULL, ...) {
      apiResponse <- private$ModelingFeaturelistsPatchWithHttpInfo(projectId, featurelistId, updateFeaturelist, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a single modeling featurelist by ID
    #' Produces: "application/json"
    #'
    #' @details Retrieve a single modeling featurelist by ID. When reporting the number of models that \&quot;use\&quot; a featurelist, a model is considered to use a featurelist if it is used as to train the model or as a monotonic constraint featurelist, or if the model is a blender with component models that use the featurelist. This route will only become available after the target and partitioning options have been set for a project. Modeling featurelists are featurelists of modeling features, and are the appropriate featurelists to use when creating models or restarting the autopilot. In a time series project, these will be distinct from those returned from :http:get:&#x60;/api/v2/projects/(projectId)/featurelists/&#x60; while in other projects these will be identical.
    #' @param projectId character. The project ID.
    #' @param featurelistId character. The featurelist ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{FeaturelistResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Modeling featurelist with specified ID.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' featurelistId <- 'featurelistId_example' # character | The featurelist ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturelistsRetrieve(projectId, featurelistId)
    #' }
    ModelingFeaturelistsRetrieve = function(projectId, featurelistId, ...) {
      apiResponse <- private$ModelingFeaturelistsRetrieveWithHttpInfo(projectId, featurelistId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Restore discarded time series features.
    #' Produces: "application/json"
    #'
    #' @details Restore discarded time series features.
    #' @param projectId character. The project ID
    #' @param modelingFeaturesCreateFromDiscarded \link{ModelingFeaturesCreateFromDiscarded}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelingFeaturesCreateFromDiscardedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`404`** No discarded time series features information available.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' modelingFeaturesCreateFromDiscarded <- ModelingFeaturesCreateFromDiscarded$new() # ModelingFeaturesCreateFromDiscarded |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturesFromDiscardedFeaturesCreate(projectId, modelingFeaturesCreateFromDiscarded=modelingFeaturesCreateFromDiscarded)
    #' }
    ModelingFeaturesFromDiscardedFeaturesCreate = function(projectId, modelingFeaturesCreateFromDiscarded = NULL, ...) {
      apiResponse <- private$ModelingFeaturesFromDiscardedFeaturesCreateWithHttpInfo(projectId, modelingFeaturesCreateFromDiscarded, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List project modeling features.
    #' Produces: "application/json"
    #'
    #' @details List the features from a project that are used for modeling with descriptive information.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param projectId character. The project ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelingFeatureListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Descriptive information for features.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' projectId <- 'projectId_example' # character | The project ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturesList(offset, limit, projectId)
    #' }
    ModelingFeaturesList = function(offset, limit, projectId, ...) {
      apiResponse <- private$ModelingFeaturesListWithHttpInfo(offset, limit, projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve project modeling feature.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the specified modeling feature with descriptive information.
    #' @param projectId character. The ID of the project
    #' @param featureName character. the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:&#x60;/api/v2/projects/(projectId)/features/&#x60; to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ModelingFeatureResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Descriptive information for feature.
    #' \itemize{
    #' }
    #' \item **`404`** Feature does not exist.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The ID of the project
    #' featureName <- 'featureName_example' # character | the name of the feature Note: DataRobot renames some features, so the feature name may not be the one from your original data. You can use :http:get:`/api/v2/projects/(projectId)/features/` to list the features and check the name. Note to users with non-ascii features names: The feature name should be utf-8-encoded (before URL-quoting)
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$ModelingFeaturesRetrieve(projectId, featureName)
    #' }
    ModelingFeaturesRetrieve = function(projectId, featureName, ...) {
      apiResponse <- private$ModelingFeaturesRetrieveWithHttpInfo(projectId, featureName, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve eligible cross-series group-by columns.
    #' Produces: "application/json"
    #'
    #' @details Retrieve eligible cross-series group-by columns.  Note that validation will have to have been triggered via :http:post:&#x60;/api/v2/projects/(projectId)/crossSeriesProperties/&#x60; in order for results to appear here.
    #' @param projectId character. The project to retrieve cross-series group-by columns for.
    #' @param multiseriesId character. The name of the column to be used as the multiseries ID column.
    #' @param crossSeriesGroupByColumns \link{OneOfstringarray}. The names of the columns to retrieve the validation status for. If not specified, all eligible columns will be returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{CrossSeriesGroupByColumnRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Request was successful.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to retrieve cross-series group-by columns for.
    #' multiseriesId <- 'multiseriesId_example' # character | The name of the column to be used as the multiseries ID column.
    #' crossSeriesGroupByColumns <- OneOfstringarray$new() # OneOfstringarray | The names of the columns to retrieve the validation status for. If not specified, all eligible columns will be returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$MultiseriesIdsCrossSeriesPropertiesList(projectId, multiseriesId, crossSeriesGroupByColumns=crossSeriesGroupByColumns)
    #' }
    MultiseriesIdsCrossSeriesPropertiesList = function(projectId, multiseriesId, crossSeriesGroupByColumns = NULL, ...) {
      apiResponse <- private$MultiseriesIdsCrossSeriesPropertiesListWithHttpInfo(projectId, multiseriesId, crossSeriesGroupByColumns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List the names of a multiseries project.
    #' Produces: "application/json"
    #'
    #' @details List the individual series names of a multiseries project
    #' @param projectId character. The project ID
    #' @param offset integer. Number of results to skip.
    #' @param limit integer. At most this many results are returned. The default may change without notice.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{MultiseriesNamesControllerResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | Number of results to skip.
    #' limit <- 100 # integer | At most this many results are returned. The default may change without notice.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$MultiseriesNamesList(projectId, offset=offset, limit=limit)
    #' }
    MultiseriesNamesList = function(projectId, offset = 0, limit = 100, ...) {
      apiResponse <- private$MultiseriesNamesListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Detect multiseries properties
    #' Produces: NA
    #'
    #' @details Analyze relationships between potential partition and multiseries ID columns. Time series projects require that each timestamp have at most one row corresponding to it. However, multiple series of data can be handled within a single project by designating a multiseries ID column that assigns each row to a particular series.  See the :ref:&#x60;multiseries &lt;multiseries&gt;&#x60; docs on time series projects for more information. A detection job analyzing the relationship between the multiseries ID column and the datetime partition column must be ran before it can be used.  If the desired multiseries ID column(s) are known, it can be specified to limit the analysis to only those columns.
    #' @param projectId character. The project ID
    #' @param multiseriesPayload \link{MultiseriesPayload}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Request to analyze relationships between potential partition and multiseries ID columns was submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' multiseriesPayload <- MultiseriesPayload$new() # MultiseriesPayload |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$MultiseriesPropertiesCreate(projectId, multiseriesPayload=multiseriesPayload)
    #' }
    MultiseriesPropertiesCreate = function(projectId, multiseriesPayload = NULL, ...) {
      apiResponse <- private$MultiseriesPropertiesCreateWithHttpInfo(projectId, multiseriesPayload, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update project
    #' Produces: NA
    #'
    #' @details Change project name, worker count, or unlock the holdout.     If any of the optional json arguments are not provided,     that aspect of the project will not be altered.
    #' @param projectId character. The project ID.
    #' @param projectUpdate \link{ProjectUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project was successfully updated
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' projectUpdate <- ProjectUpdate$new() # ProjectUpdate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$Patch(projectId, projectUpdate=projectUpdate)
    #' }
    Patch = function(projectId, projectUpdate = NULL, ...) {
      apiResponse <- private$PatchWithHttpInfo(projectId, projectUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve relationships configuration for a project
    #' Produces: "application/json"
    #'
    #' @details Retrieve relationships configuration for a project
    #' @param projectId character. The project ID
    #' @param configId character. Id of Secondary Dataset Configuration
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RelationshipsConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Project relationships configuration.
    #' \itemize{
    #' }
    #' \item **`404`** Data was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' configId <- 'configId_example' # character | Id of Secondary Dataset Configuration
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$RelationshipsConfigurationList(projectId, configId=configId)
    #' }
    RelationshipsConfigurationList = function(projectId, configId = NULL, ...) {
      apiResponse <- private$RelationshipsConfigurationListWithHttpInfo(projectId, configId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a relationships configuration
    #' Produces: "application/json"
    #'
    #' @details Create a relationships configuration
    #' @param relationshipsConfigCreate \link{RelationshipsConfigCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RelationshipsConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`**
    #' \itemize{
    #' }
    #' \item **`422`** User input fails validation
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' relationshipsConfigCreate <- RelationshipsConfigCreate$new() # RelationshipsConfigCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$RelationshipsConfigurationsCreate(relationshipsConfigCreate=relationshipsConfigCreate)
    #' }
    RelationshipsConfigurationsCreate = function(relationshipsConfigCreate = NULL, ...) {
      apiResponse <- private$RelationshipsConfigurationsCreateWithHttpInfo(relationshipsConfigCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete a relationships configuration
    #' Produces: NA
    #'
    #' @details Delete a relationships configuration
    #' @param relationshipsConfigurationId character. Id of the relationships configuration to delete
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`404`** Relationships configuration not found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' relationshipsConfigurationId <- 'relationshipsConfigurationId_example' # character | Id of the relationships configuration to delete
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$RelationshipsConfigurationsDelete(relationshipsConfigurationId)
    #' }
    RelationshipsConfigurationsDelete = function(relationshipsConfigurationId, ...) {
      apiResponse <- private$RelationshipsConfigurationsDeleteWithHttpInfo(relationshipsConfigurationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Replace a relationships configuration
    #' Produces: "application/json"
    #'
    #' @details Replace a relationships configuration
    #' @param relationshipsConfigurationId character. Id of the relationships configuration to delete
    #' @param relationshipsConfigCreate \link{RelationshipsConfigCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RelationshipsConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** User input fails validation
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' relationshipsConfigurationId <- 'relationshipsConfigurationId_example' # character | Id of the relationships configuration to delete
    #' relationshipsConfigCreate <- RelationshipsConfigCreate$new() # RelationshipsConfigCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$RelationshipsConfigurationsPut(relationshipsConfigurationId, relationshipsConfigCreate=relationshipsConfigCreate)
    #' }
    RelationshipsConfigurationsPut = function(relationshipsConfigurationId, relationshipsConfigCreate = NULL, ...) {
      apiResponse <- private$RelationshipsConfigurationsPutWithHttpInfo(relationshipsConfigurationId, relationshipsConfigCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve a relationships configuration
    #' Produces: "application/json"
    #'
    #' @details Retrieve a relationships configuration
    #' @param relationshipsConfigurationId character. Id of the relationships configuration to delete
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{RelationshipsConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`404`** Relationships configuration cannot be found
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' relationshipsConfigurationId <- 'relationshipsConfigurationId_example' # character | Id of the relationships configuration to delete
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$RelationshipsConfigurationsRetrieve(relationshipsConfigurationId)
    #' }
    RelationshipsConfigurationsRetrieve = function(relationshipsConfigurationId, ...) {
      apiResponse <- private$RelationshipsConfigurationsRetrieveWithHttpInfo(relationshipsConfigurationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get project.
    #' Produces: "application/json"
    #'
    #' @details Look up a particular project
    #' @param projectId character. The project ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectRetrieveResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$Retrieve(projectId)
    #' }
    Retrieve = function(projectId, ...) {
      apiResponse <- private$RetrieveWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create secondary dataset configurations for a project.
    #' Produces: NA
    #'
    #' @details Create secondary dataset configurations for a project.
    #' @param projectId character. The project ID
    #' @param secondaryDatasetCreate \link{SecondaryDatasetCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Secondary dataset configuration created with allowable type mismatches
    #' \itemize{
    #' }
    #' \item **`201`** Secondary dataset configuration created with no errors.
    #' \itemize{
    #' }
    #' \item **`204`** Validation of secondary dataset configuration is successful
    #' \itemize{
    #' }
    #' \item **`422`** Validation of secondary dataset configuration failed.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' secondaryDatasetCreate <- SecondaryDatasetCreate$new() # SecondaryDatasetCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SecondaryDatasetsConfigurationsCreate(projectId, secondaryDatasetCreate=secondaryDatasetCreate)
    #' }
    SecondaryDatasetsConfigurationsCreate = function(projectId, secondaryDatasetCreate = NULL, ...) {
      apiResponse <- private$SecondaryDatasetsConfigurationsCreateWithHttpInfo(projectId, secondaryDatasetCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Soft deletes a secondary dataset configuration.
    #' Produces: NA
    #'
    #' @details Soft deletes a secondary dataset configuration.
    #' @param projectId character. The project ID.
    #' @param secondaryDatasetConfigId character. Secondary dataset configuration ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`** Secondary dataset configuration successfully soft deleted.
    #' \itemize{
    #' }
    #' \item **`404`** Data is not found.
    #' \itemize{
    #' }
    #' \item **`409`** Dataset has already been deleted
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' secondaryDatasetConfigId <- 'secondaryDatasetConfigId_example' # character | Secondary dataset configuration ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SecondaryDatasetsConfigurationsDelete(projectId, secondaryDatasetConfigId)
    #' }
    SecondaryDatasetsConfigurationsDelete = function(projectId, secondaryDatasetConfigId, ...) {
      apiResponse <- private$SecondaryDatasetsConfigurationsDeleteWithHttpInfo(projectId, secondaryDatasetConfigId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List all secondary dataset configurations for a project
    #' Produces: "application/json"
    #'
    #' @details List all secondary dataset configurations for a project, optionally filtered by feature list id.
    #' @param projectId character. The project ID
    #' @param featurelistId character. feature list ID of the model
    #' @param modelId character. ID of the model
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param includeDeleted Enum < [false, False, true, True] > Include deleted records.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SecondaryDatasetConfigListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** List of secondary dataset configurations.
    #' \itemize{
    #' }
    #' \item **`404`** Data is not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' featurelistId <- 'featurelistId_example' # character | feature list ID of the model
    #' modelId <- 'modelId_example' # character | ID of the model
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 100 # integer | At most this many results are returned.
    #' includeDeleted <- "true" # character | Include deleted records.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SecondaryDatasetsConfigurationsList(projectId, featurelistId=featurelistId, modelId=modelId, offset=offset, limit=limit, includeDeleted=includeDeleted)
    #' }
    SecondaryDatasetsConfigurationsList = function(projectId, featurelistId = NULL, modelId = NULL, offset = 0, limit = 100, includeDeleted = "true", ...) {
      apiResponse <- private$SecondaryDatasetsConfigurationsListWithHttpInfo(projectId, featurelistId, modelId, offset, limit, includeDeleted, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve secondary dataset configuration by ID.
    #' Produces: "application/json"
    #'
    #' @details Retrieve secondary dataset configuration by ID.
    #' @param projectId character. The project ID.
    #' @param secondaryDatasetConfigId character. Secondary dataset configuration ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectSecondaryDatasetConfigResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Secondary dataset configuration.
    #' \itemize{
    #' }
    #' \item **`404`** Data is not found.
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #' secondaryDatasetConfigId <- 'secondaryDatasetConfigId_example' # character | Secondary dataset configuration ID
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SecondaryDatasetsConfigurationsRetrieve(projectId, secondaryDatasetConfigId)
    #' }
    SecondaryDatasetsConfigurationsRetrieve = function(projectId, secondaryDatasetConfigId, ...) {
      apiResponse <- private$SecondaryDatasetsConfigurationsRetrieveWithHttpInfo(projectId, secondaryDatasetConfigId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve segmentation task statuses.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the statuses of segmentation task jobs associated with the ID.
    #' @param projectId character. The project ID
    #' @param segmentationTaskId character. The ID of the segmentation task to check the status of.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SegmentationResultsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentationTaskId <- 'segmentationTaskId_example' # character | The ID of the segmentation task to check the status of.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentationTaskJobResultsRetrieve(projectId, segmentationTaskId)
    #' }
    SegmentationTaskJobResultsRetrieve = function(projectId, segmentationTaskId, ...) {
      apiResponse <- private$SegmentationTaskJobResultsRetrieveWithHttpInfo(projectId, segmentationTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create segmentation tasks.
    #' Produces: NA
    #'
    #' @details Create segmentation tasks for the dataset used in the project.
    #' @param projectId character. The project ID
    #' @param segmentationTaskCreate \link{SegmentationTaskCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Job submitted. See Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentationTaskCreate <- SegmentationTaskCreate$new() # SegmentationTaskCreate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentationTasksCreate(projectId, segmentationTaskCreate=segmentationTaskCreate)
    #' }
    SegmentationTasksCreate = function(projectId, segmentationTaskCreate = NULL, ...) {
      apiResponse <- private$SegmentationTasksCreateWithHttpInfo(projectId, segmentationTaskCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List segmentation tasks.
    #' Produces: "application/json"
    #'
    #' @details List all segmentation tasks created for the project.
    #' @param projectId character. The project ID
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SegmentationTaskListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 10 # integer | At most this many results are returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentationTasksList(projectId, offset=offset, limit=limit)
    #' }
    SegmentationTasksList = function(projectId, offset = 0, limit = 10, ...) {
      apiResponse <- private$SegmentationTasksListWithHttpInfo(projectId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve seriesId to segmentId mappings.
    #' Produces: "application/json"
    #'
    #' @details Retrieve the seriesId to segmentId mappings for a Segmentation Task.
    #' @param projectId character. The project ID
    #' @param segmentationTaskId character. The ID of the segmentation task.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SegmentationTaskSegmentMappingsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentationTaskId <- 'segmentationTaskId_example' # character | The ID of the segmentation task.
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 10 # integer | At most this many results are returned.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentationTasksMappingsList(projectId, segmentationTaskId, offset=offset, limit=limit)
    #' }
    SegmentationTasksMappingsList = function(projectId, segmentationTaskId, offset = 0, limit = 10, ...) {
      apiResponse <- private$SegmentationTasksMappingsListWithHttpInfo(projectId, segmentationTaskId, offset, limit, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve segmentation task.
    #' Produces: "application/json"
    #'
    #' @details Retrieve information about a segmentation task.
    #' @param projectId character. The project ID
    #' @param segmentationTaskId character. The ID of the segmentation task.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{SegmentationTaskResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentationTaskId <- 'segmentationTaskId_example' # character | The ID of the segmentation task.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentationTasksRetrieve(projectId, segmentationTaskId)
    #' }
    SegmentationTasksRetrieve = function(projectId, segmentationTaskId, ...) {
      apiResponse <- private$SegmentationTasksRetrieveWithHttpInfo(projectId, segmentationTaskId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update child segment project.
    #' Produces: "application/json"
    #'
    #' @details The only supported operation right now is segment restart, which removes existing child segment project and starts another child project instead for the given segment. Should be only used for child segments which are stuck during project startup or upload.
    #' @param projectId character. The project ID
    #' @param segmentId character. The name of the segment
    #' @param projectSegmentUpdate \link{ProjectSegmentUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectSegmentUpdateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The segment is updated.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID
    #' segmentId <- 'segmentId_example' # character | The name of the segment
    #' projectSegmentUpdate <- ProjectSegmentUpdate$new() # ProjectSegmentUpdate |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$SegmentsPatch(projectId, segmentId, projectSegmentUpdate=projectSegmentUpdate)
    #' }
    SegmentsPatch = function(projectId, segmentId, projectSegmentUpdate = NULL, ...) {
      apiResponse <- private$SegmentsPatchWithHttpInfo(projectId, segmentId, projectSegmentUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Check project status
    #' Produces: "application/json"
    #'
    #' @details Check the status of a project
    #' @param projectId character. The project ID.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ProjectStatusResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The project status
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project ID.
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$StatusList(projectId)
    #' }
    StatusList = function(projectId, ...) {
      apiResponse <- private$StatusListWithHttpInfo(projectId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a new feature by changing the type of an existing one.
    #' Produces: NA
    #'
    #' @details Create a new feature by changing the type of an existing one.
    #' @param projectId character. The project to create the feature in.
    #' @param featureTransform \link{FeatureTransform}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Creation has successfully started. See the Location header.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`422`** Unable to process the request
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' projectId <- 'projectId_example' # character | The project to create the feature in.
    #' featureTransform <- FeatureTransform$new() # FeatureTransform |
    #'
    #' api.instance <- ProjectsApi$new()
    #' result <- api.instance$TypeTransformFeaturesCreate(projectId, featureTransform=featureTransform)
    #' }
    TypeTransformFeaturesCreate = function(projectId, featureTransform = NULL, ...) {
      apiResponse <- private$TypeTransformFeaturesCreateWithHttpInfo(projectId, featureTransform, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `AccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    AccessControlListWithHttpInfo = function(offset, limit, projectId, username = NULL, userId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["username"] <- username

      queryParams["userId"] <- userId

      body <- NULL
      urlPath <- "/projects/{projectId}/accessControl/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SharingListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `AccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    AccessControlPatchManyWithHttpInfo = function(projectId, sharingUpdateOrRemove = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`sharingUpdateOrRemove`) && isa(sharingUpdateOrRemove, c("SharingUpdateOrRemove", "R6"))) {
        body <- `sharingUpdateOrRemove`$toJSON()
      } else {
        stop("AccessControlPatchManyWithHttpInfo requires parameter sharingUpdateOrRemove to be of type SharingUpdateOrRemove.")
      }

      urlPath <- "/projects/{projectId}/accessControl/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `AimPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    AimPatchManyWithHttpInfo = function(projectId, aim = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`aim`) && isa(aim, c("Aim", "R6"))) {
        body <- `aim`$toJSON()
      } else {
        stop("AimPatchManyWithHttpInfo requires parameter aim to be of type Aim.")
      }

      urlPath <- "/projects/{projectId}/aim/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `AutopilotCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    AutopilotCreateWithHttpInfo = function(projectId, autopilot = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`autopilot`) && isa(autopilot, c("Autopilot", "R6"))) {
        body <- `autopilot`$toJSON()
      } else {
        stop("AutopilotCreateWithHttpInfo requires parameter autopilot to be of type Autopilot.")
      }

      urlPath <- "/projects/{projectId}/autopilot/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `AutopilotsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    AutopilotsCreateWithHttpInfo = function(projectId, autopilotStart = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`autopilotStart`) && isa(autopilotStart, c("AutopilotStart", "R6"))) {
        body <- `autopilotStart`$toJSON()
      } else {
        stop("AutopilotsCreateWithHttpInfo requires parameter autopilotStart to be of type AutopilotStart.")
      }

      urlPath <- "/projects/{projectId}/autopilots/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchTypeTransformFeaturesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchTypeTransformFeaturesCreateWithHttpInfo = function(projectId, batchFeatureTransform = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`batchFeatureTransform`) && isa(batchFeatureTransform, c("BatchFeatureTransform", "R6"))) {
        body <- `batchFeatureTransform`$toJSON()
      } else {
        stop("BatchTypeTransformFeaturesCreateWithHttpInfo requires parameter batchFeatureTransform to be of type BatchFeatureTransform.")
      }

      urlPath <- "/projects/{projectId}/batchTypeTransformFeatures/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `BatchTypeTransformFeaturesResultRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    BatchTypeTransformFeaturesResultRetrieveWithHttpInfo = function(projectId, jobId, batchFeatureTransform = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      if (!missing(`batchFeatureTransform`) && isa(batchFeatureTransform, c("BatchFeatureTransform", "R6"))) {
        body <- `batchFeatureTransform`$toJSON()
      } else {
        stop("BatchTypeTransformFeaturesResultRetrieveWithHttpInfo requires parameter batchFeatureTransform to be of type BatchFeatureTransform.")
      }

      urlPath <- "/projects/{projectId}/batchTypeTransformFeaturesResult/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "BatchFeatureTransformRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarCountryCodesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarCountryCodesListWithHttpInfo = function(offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/calendarCountryCodes/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "PreloadedCalendarListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarEventsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarEventsListWithHttpInfo = function(projectId, seriesId = NULL, startDate = NULL, endDate = NULL, offset = 0, limit = 1000, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["seriesId"] <- seriesId

      queryParams["startDate"] <- startDate

      queryParams["endDate"] <- endDate

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/calendarEvents/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CalendarEventsResponseQuery", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsAccessControlList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsAccessControlListWithHttpInfo = function(calendarId, username = NULL, userId = NULL, offset = 0, limit = 0, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`calendarId`)) {
        stop("Missing required parameter `calendarId`.")
      }

      queryParams["username"] <- username

      queryParams["userId"] <- userId

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/calendars/{calendarId}/accessControl/"
      if (!missing(`calendarId`)) {
        urlPath <- gsub(paste0("\\{", "calendarId", "\\}"), URLencode(as.character(`calendarId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CalendarAccessControlListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsAccessControlPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsAccessControlPatchManyWithHttpInfo = function(calendarId, calendarAccessControlUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`calendarId`)) {
        stop("Missing required parameter `calendarId`.")
      }

      if (!missing(`calendarAccessControlUpdate`) && isa(calendarAccessControlUpdate, c("CalendarAccessControlUpdate", "R6"))) {
        body <- `calendarAccessControlUpdate`$toJSON()
      } else {
        stop("CalendarsAccessControlPatchManyWithHttpInfo requires parameter calendarAccessControlUpdate to be of type CalendarAccessControlUpdate.")
      }

      urlPath <- "/calendars/{calendarId}/accessControl/"
      if (!missing(`calendarId`)) {
        urlPath <- gsub(paste0("\\{", "calendarId", "\\}"), URLencode(as.character(`calendarId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsDeleteWithHttpInfo = function(calendarId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`calendarId`)) {
        stop("Missing required parameter `calendarId`.")
      }

      body <- NULL
      urlPath <- "/calendars/{calendarId}/"
      if (!missing(`calendarId`)) {
        urlPath <- gsub(paste0("\\{", "calendarId", "\\}"), URLencode(as.character(`calendarId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsFileUploadCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsFileUploadCreateWithHttpInfo = function(calendarFileUpload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`calendarFileUpload`) && isa(calendarFileUpload, c("CalendarFileUpload", "R6"))) {
        body <- `calendarFileUpload`$toJSON()
      } else {
        stop("CalendarsFileUploadCreateWithHttpInfo requires parameter calendarFileUpload to be of type CalendarFileUpload.")
      }

      urlPath <- "/calendars/fileUpload/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsFromCountryCodeCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsFromCountryCodeCreateWithHttpInfo = function(preloadedCalendar = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`preloadedCalendar`) && isa(preloadedCalendar, c("PreloadedCalendar", "R6"))) {
        body <- `preloadedCalendar`$toJSON()
      } else {
        stop("CalendarsFromCountryCodeCreateWithHttpInfo requires parameter preloadedCalendar to be of type PreloadedCalendar.")
      }

      urlPath <- "/calendars/fromCountryCode/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsFromDatasetCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsFromDatasetCreateWithHttpInfo = function(calendarFromDataset = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`calendarFromDataset`) && isa(calendarFromDataset, c("CalendarFromDataset", "R6"))) {
        body <- `calendarFromDataset`$toJSON()
      } else {
        stop("CalendarsFromDatasetCreateWithHttpInfo requires parameter calendarFromDataset to be of type CalendarFromDataset.")
      }

      urlPath <- "/calendars/fromDataset/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CreatedCalendarDatasetResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsListWithHttpInfo = function(offset, limit, projectId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["projectId"] <- projectId

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/calendars/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CalendarListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsPatchWithHttpInfo = function(calendarId, calendarNameUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`calendarId`)) {
        stop("Missing required parameter `calendarId`.")
      }

      if (!missing(`calendarNameUpdate`) && isa(calendarNameUpdate, c("CalendarNameUpdate", "R6"))) {
        body <- `calendarNameUpdate`$toJSON()
      } else {
        stop("CalendarsPatchWithHttpInfo requires parameter calendarNameUpdate to be of type CalendarNameUpdate.")
      }

      urlPath <- "/calendars/{calendarId}/"
      if (!missing(`calendarId`)) {
        urlPath <- gsub(paste0("\\{", "calendarId", "\\}"), URLencode(as.character(`calendarId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CalendarsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CalendarsRetrieveWithHttpInfo = function(calendarId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`calendarId`)) {
        stop("Missing required parameter `calendarId`.")
      }

      body <- NULL
      urlPath <- "/calendars/{calendarId}/"
      if (!missing(`calendarId`)) {
        urlPath <- gsub(paste0("\\{", "calendarId", "\\}"), URLencode(as.character(`calendarId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CalendarRecord", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsCreateWithHttpInfo = function(projectNuke = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`projectNuke`) && isa(projectNuke, c("ProjectNuke", "R6"))) {
        body <- `projectNuke`$toJSON()
      } else {
        stop("CleanupJobsCreateWithHttpInfo requires parameter projectNuke to be of type ProjectNuke.")
      }

      urlPath <- "/projectCleanupJobs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsDeleteWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/projectCleanupJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsDownloadListWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/projectCleanupJobs/{statusId}/download/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectNukeJobStatus", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsListWithHttpInfo = function(...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/projectCleanupJobs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectNukeJobListStatus", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsRetrieveWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/projectCleanupJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectNukeJobStatus", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CleanupJobsSummaryList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CleanupJobsSummaryListWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/projectCleanupJobs/{statusId}/summary/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectNukeJobStatusSummary", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ClonesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ClonesCreateWithHttpInfo = function(projectClone = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`projectClone`) && isa(projectClone, c("ProjectClone", "R6"))) {
        body <- `projectClone`$toJSON()
      } else {
        stop("ClonesCreateWithHttpInfo requires parameter projectClone to be of type ProjectClone.")
      }

      urlPath <- "/projectClones/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `Create`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CreateWithHttpInfo = function(projectCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`projectCreate`) && isa(projectCreate, c("ProjectCreate", "R6"))) {
        body <- `projectCreate`$toJSON()
      } else {
        stop("CreateWithHttpInfo requires parameter projectCreate to be of type ProjectCreate.")
      }

      urlPath <- "/projects/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `CrossSeriesPropertiesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    CrossSeriesPropertiesCreateWithHttpInfo = function(projectId, crossSeriesGroupByColumnValidatePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`crossSeriesGroupByColumnValidatePayload`) && isa(crossSeriesGroupByColumnValidatePayload, c("CrossSeriesGroupByColumnValidatePayload", "R6"))) {
        body <- `crossSeriesGroupByColumnValidatePayload`$toJSON()
      } else {
        stop("CrossSeriesPropertiesCreateWithHttpInfo requires parameter crossSeriesGroupByColumnValidatePayload to be of type CrossSeriesGroupByColumnValidatePayload.")
      }

      urlPath <- "/projects/{projectId}/crossSeriesProperties/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CrossSeriesGroupByColumnValidateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `Delete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeleteWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeletedProjectsCountList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeletedProjectsCountListWithHttpInfo = function(searchFor = NULL, creator = NULL, organization = NULL, deletedBefore = NULL, deletedAfter = NULL, projectId = NULL, limit = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["searchFor"] <- searchFor

      queryParams["creator"] <- creator

      queryParams["organization"] <- organization

      queryParams["deletedBefore"] <- deletedBefore

      queryParams["deletedAfter"] <- deletedAfter

      queryParams["projectId"] <- projectId

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/deletedProjectsCount/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeletedProjectCountResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeletedProjectsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeletedProjectsListWithHttpInfo = function(searchFor = NULL, creator = NULL, organization = NULL, deletedBefore = NULL, deletedAfter = NULL, projectId = NULL, limit = 20, offset = 0, orderBy = "deletedOn", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["searchFor"] <- searchFor

      queryParams["creator"] <- creator

      queryParams["organization"] <- organization

      queryParams["deletedBefore"] <- deletedBefore

      queryParams["deletedAfter"] <- deletedAfter

      queryParams["projectId"] <- projectId

      queryParams["limit"] <- limit

      queryParams["offset"] <- offset

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/deletedProjects/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DeletedProjectListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DeletedProjectsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DeletedProjectsPatchWithHttpInfo = function(projectId, projectRecover = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`projectRecover`) && isa(projectRecover, c("ProjectRecover", "R6"))) {
        body <- `projectRecover`$toJSON()
      } else {
        stop("DeletedProjectsPatchWithHttpInfo requires parameter projectRecover to be of type ProjectRecover.")
      }

      urlPath <- "/deletedProjects/{projectId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectRecoverResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `DiscardedFeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    DiscardedFeaturesListWithHttpInfo = function(projectId, search = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["search"] <- search

      body <- NULL
      urlPath <- "/projects/{projectId}/discardedFeatures/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "DiscardedFeaturesResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalTimeSeriesBaselineDataValidationJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalTimeSeriesBaselineDataValidationJobsCreateWithHttpInfo = function(projectId, externalTsBaselinePayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`externalTsBaselinePayload`) && isa(externalTsBaselinePayload, c("ExternalTSBaselinePayload", "R6"))) {
        body <- `externalTsBaselinePayload`$toJSON()
      } else {
        stop("ExternalTimeSeriesBaselineDataValidationJobsCreateWithHttpInfo requires parameter externalTsBaselinePayload to be of type ExternalTSBaselinePayload.")
      }

      urlPath <- "/projects/{projectId}/externalTimeSeriesBaselineDataValidationJobs/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ExternalTimeSeriesBaselineDataValidationJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ExternalTimeSeriesBaselineDataValidationJobsRetrieveWithHttpInfo = function(projectId, baselineValidationJobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`baselineValidationJobId`)) {
        stop("Missing required parameter `baselineValidationJobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/externalTimeSeriesBaselineDataValidationJobs/{baselineValidationJobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`baselineValidationJobId`)) {
        urlPath <- gsub(paste0("\\{", "baselineValidationJobId", "\\}"), URLencode(as.character(`baselineValidationJobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ExternalTSBaselineResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureDiscoveryDatasetDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureDiscoveryDatasetDownloadListWithHttpInfo = function(projectId, datasetId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["datasetId"] <- datasetId

      body <- NULL
      urlPath <- "/projects/{projectId}/featureDiscoveryDatasetDownload/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureDiscoveryLogsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureDiscoveryLogsDownloadListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/featureDiscoveryLogs/download/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureDiscoveryLogsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureDiscoveryLogsListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/featureDiscoveryLogs/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureDiscoveryLogListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureDiscoveryRecipeSQLsDownloadList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureDiscoveryRecipeSQLsDownloadListWithHttpInfo = function(projectId, modelId = NULL, statusOnly = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["modelId"] <- modelId

      queryParams["statusOnly"] <- statusOnly

      body <- NULL
      urlPath <- "/projects/{projectId}/featureDiscoveryRecipeSQLs/download/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureDiscoveryRecipeSqlExportsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureDiscoveryRecipeSqlExportsCreateWithHttpInfo = function(projectId, featureDiscoveryRecipeSqlsExport = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`featureDiscoveryRecipeSqlsExport`) && isa(featureDiscoveryRecipeSqlsExport, c("FeatureDiscoveryRecipeSQLsExport", "R6"))) {
        body <- `featureDiscoveryRecipeSqlsExport`$toJSON()
      } else {
        stop("FeatureDiscoveryRecipeSqlExportsCreateWithHttpInfo requires parameter featureDiscoveryRecipeSqlsExport to be of type FeatureDiscoveryRecipeSQLsExport.")
      }

      urlPath <- "/projects/{projectId}/featureDiscoveryRecipeSqlExports/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureHistogramsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureHistogramsRetrieveWithHttpInfo = function(binLimit, projectId, featureName, key = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`binLimit`)) {
        stop("Missing required parameter `binLimit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      queryParams["binLimit"] <- binLimit

      queryParams["key"] <- key

      body <- NULL
      urlPath <- "/projects/{projectId}/featureHistograms/{featureName}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureHistogramResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeatureLineagesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeatureLineagesRetrieveWithHttpInfo = function(projectId, featureLineageId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureLineageId`)) {
        stop("Missing required parameter `featureLineageId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/featureLineages/{featureLineageId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureLineageId`)) {
        urlPath <- gsub(paste0("\\{", "featureLineageId", "\\}"), URLencode(as.character(`featureLineageId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureLineageResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturelistsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturelistsCreateWithHttpInfo = function(projectId, createFeaturelist = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`createFeaturelist`) && isa(createFeaturelist, c("CreateFeaturelist", "R6"))) {
        body <- `createFeaturelist`$toJSON()
      } else {
        stop("FeaturelistsCreateWithHttpInfo requires parameter createFeaturelist to be of type CreateFeaturelist.")
      }

      urlPath <- "/projects/{projectId}/featurelists/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturelistsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturelistsDeleteWithHttpInfo = function(projectId, featurelistId, dryRun = "false", deleteDependencies = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      queryParams["dryRun"] <- dryRun

      queryParams["deleteDependencies"] <- deleteDependencies

      body <- NULL
      urlPath <- "/projects/{projectId}/featurelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistDestroyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturelistsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturelistsListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/featurelists/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturelistsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturelistsPatchWithHttpInfo = function(projectId, featurelistId, updateFeaturelist = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      if (!missing(`updateFeaturelist`) && isa(updateFeaturelist, c("UpdateFeaturelist", "R6"))) {
        body <- `updateFeaturelist`$toJSON()
      } else {
        stop("FeaturelistsPatchWithHttpInfo requires parameter updateFeaturelist to be of type UpdateFeaturelist.")
      }

      urlPath <- "/projects/{projectId}/featurelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturelistsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturelistsRetrieveWithHttpInfo = function(projectId, featurelistId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/featurelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturesListWithHttpInfo = function(projectId, forSegmentedAnalysis = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["forSegmentedAnalysis"] <- forSegmentedAnalysis

      body <- NULL
      urlPath <- "/projects/{projectId}/features/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[ProjectFeatureResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturesMetricsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturesMetricsListWithHttpInfo = function(featureName, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["featureName"] <- featureName

      body <- NULL
      urlPath <- "/projects/{projectId}/features/metrics/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeatureMetricsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturesMultiseriesPropertiesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturesMultiseriesPropertiesListWithHttpInfo = function(projectId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/features/{featureName}/multiseriesProperties/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MultiseriesRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `FeaturesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    FeaturesRetrieveWithHttpInfo = function(projectId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/features/{featureName}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `HdfsProjectsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    HdfsProjectsCreateWithHttpInfo = function(hdfsProjectCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`hdfsProjectCreate`) && isa(hdfsProjectCreate, c("HdfsProjectCreate", "R6"))) {
        body <- `hdfsProjectCreate`$toJSON()
      } else {
        stop("HdfsProjectsCreateWithHttpInfo requires parameter hdfsProjectCreate to be of type HdfsProjectCreate.")
      }

      urlPath <- "/hdfsProjects/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `JobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    JobsDeleteWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/jobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `JobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    JobsListWithHttpInfo = function(projectId, status = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["status"] <- status

      body <- NULL
      urlPath <- "/projects/{projectId}/jobs/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "JobListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `JobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    JobsRetrieveWithHttpInfo = function(projectId, jobId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`jobId`)) {
        stop("Missing required parameter `jobId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/jobs/{jobId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`jobId`)) {
        urlPath <- gsub(paste0("\\{", "jobId", "\\}"), URLencode(as.character(`jobId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "JobDetailsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `List`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ListWithHttpInfo = function(projectName = NULL, projectId = NULL, orderBy = NULL, featureDiscovery = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams["projectName"] <- projectName

      queryParams["projectId"] <- projectId

      queryParams["orderBy"] <- orderBy

      queryParams["featureDiscovery"] <- featureDiscovery

      body <- NULL
      urlPath <- "/projects/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "array[ProjectDetailsResponse]", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturelistsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturelistsCreateWithHttpInfo = function(projectId, createFeaturelist = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`createFeaturelist`) && isa(createFeaturelist, c("CreateFeaturelist", "R6"))) {
        body <- `createFeaturelist`$toJSON()
      } else {
        stop("ModelingFeaturelistsCreateWithHttpInfo requires parameter createFeaturelist to be of type CreateFeaturelist.")
      }

      urlPath <- "/projects/{projectId}/modelingFeaturelists/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturelistsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturelistsDeleteWithHttpInfo = function(projectId, featurelistId, dryRun = "false", deleteDependencies = "false", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      queryParams["dryRun"] <- dryRun

      queryParams["deleteDependencies"] <- deleteDependencies

      body <- NULL
      urlPath <- "/projects/{projectId}/modelingFeaturelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistDestroyResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturelistsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturelistsListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/modelingFeaturelists/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturelistsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturelistsPatchWithHttpInfo = function(projectId, featurelistId, updateFeaturelist = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      if (!missing(`updateFeaturelist`) && isa(updateFeaturelist, c("UpdateFeaturelist", "R6"))) {
        body <- `updateFeaturelist`$toJSON()
      } else {
        stop("ModelingFeaturelistsPatchWithHttpInfo requires parameter updateFeaturelist to be of type UpdateFeaturelist.")
      }

      urlPath <- "/projects/{projectId}/modelingFeaturelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturelistsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturelistsRetrieveWithHttpInfo = function(projectId, featurelistId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featurelistId`)) {
        stop("Missing required parameter `featurelistId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/modelingFeaturelists/{featurelistId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featurelistId`)) {
        urlPath <- gsub(paste0("\\{", "featurelistId", "\\}"), URLencode(as.character(`featurelistId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "FeaturelistResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturesFromDiscardedFeaturesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturesFromDiscardedFeaturesCreateWithHttpInfo = function(projectId, modelingFeaturesCreateFromDiscarded = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`modelingFeaturesCreateFromDiscarded`) && isa(modelingFeaturesCreateFromDiscarded, c("ModelingFeaturesCreateFromDiscarded", "R6"))) {
        body <- `modelingFeaturesCreateFromDiscarded`$toJSON()
      } else {
        stop("ModelingFeaturesFromDiscardedFeaturesCreateWithHttpInfo requires parameter modelingFeaturesCreateFromDiscarded to be of type ModelingFeaturesCreateFromDiscarded.")
      }

      urlPath <- "/projects/{projectId}/modelingFeatures/fromDiscardedFeatures/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelingFeaturesCreateFromDiscardedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturesListWithHttpInfo = function(offset, limit, projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/modelingFeatures/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelingFeatureListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `ModelingFeaturesRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    ModelingFeaturesRetrieveWithHttpInfo = function(projectId, featureName, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`featureName`)) {
        stop("Missing required parameter `featureName`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/modelingFeatures/{featureName}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`featureName`)) {
        urlPath <- gsub(paste0("\\{", "featureName", "\\}"), URLencode(as.character(`featureName`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ModelingFeatureResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultiseriesIdsCrossSeriesPropertiesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultiseriesIdsCrossSeriesPropertiesListWithHttpInfo = function(projectId, multiseriesId, crossSeriesGroupByColumns = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`multiseriesId`)) {
        stop("Missing required parameter `multiseriesId`.")
      }

      queryParams["crossSeriesGroupByColumns"] <- crossSeriesGroupByColumns

      body <- NULL
      urlPath <- "/projects/{projectId}/multiseriesIds/{multiseriesId}/crossSeriesProperties/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`multiseriesId`)) {
        urlPath <- gsub(paste0("\\{", "multiseriesId", "\\}"), URLencode(as.character(`multiseriesId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "CrossSeriesGroupByColumnRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultiseriesNamesList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultiseriesNamesListWithHttpInfo = function(projectId, offset = 0, limit = 100, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/multiseriesNames/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "MultiseriesNamesControllerResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `MultiseriesPropertiesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    MultiseriesPropertiesCreateWithHttpInfo = function(projectId, multiseriesPayload = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`multiseriesPayload`) && isa(multiseriesPayload, c("MultiseriesPayload", "R6"))) {
        body <- `multiseriesPayload`$toJSON()
      } else {
        stop("MultiseriesPropertiesCreateWithHttpInfo requires parameter multiseriesPayload to be of type MultiseriesPayload.")
      }

      urlPath <- "/projects/{projectId}/multiseriesProperties/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `Patch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    PatchWithHttpInfo = function(projectId, projectUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`projectUpdate`) && isa(projectUpdate, c("ProjectUpdate", "R6"))) {
        body <- `projectUpdate`$toJSON()
      } else {
        stop("PatchWithHttpInfo requires parameter projectUpdate to be of type ProjectUpdate.")
      }

      urlPath <- "/projects/{projectId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RelationshipsConfigurationList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RelationshipsConfigurationListWithHttpInfo = function(projectId, configId = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["configId"] <- configId

      body <- NULL
      urlPath <- "/projects/{projectId}/relationshipsConfiguration/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RelationshipsConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RelationshipsConfigurationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RelationshipsConfigurationsCreateWithHttpInfo = function(relationshipsConfigCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`relationshipsConfigCreate`) && isa(relationshipsConfigCreate, c("RelationshipsConfigCreate", "R6"))) {
        body <- `relationshipsConfigCreate`$toJSON()
      } else {
        stop("RelationshipsConfigurationsCreateWithHttpInfo requires parameter relationshipsConfigCreate to be of type RelationshipsConfigCreate.")
      }

      urlPath <- "/relationshipsConfigurations/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RelationshipsConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RelationshipsConfigurationsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RelationshipsConfigurationsDeleteWithHttpInfo = function(relationshipsConfigurationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`relationshipsConfigurationId`)) {
        stop("Missing required parameter `relationshipsConfigurationId`.")
      }

      body <- NULL
      urlPath <- "/relationshipsConfigurations/{relationshipsConfigurationId}/"
      if (!missing(`relationshipsConfigurationId`)) {
        urlPath <- gsub(paste0("\\{", "relationshipsConfigurationId", "\\}"), URLencode(as.character(`relationshipsConfigurationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RelationshipsConfigurationsPut`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RelationshipsConfigurationsPutWithHttpInfo = function(relationshipsConfigurationId, relationshipsConfigCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`relationshipsConfigurationId`)) {
        stop("Missing required parameter `relationshipsConfigurationId`.")
      }

      if (!missing(`relationshipsConfigCreate`) && isa(relationshipsConfigCreate, c("RelationshipsConfigCreate", "R6"))) {
        body <- `relationshipsConfigCreate`$toJSON()
      } else {
        stop("RelationshipsConfigurationsPutWithHttpInfo requires parameter relationshipsConfigCreate to be of type RelationshipsConfigCreate.")
      }

      urlPath <- "/relationshipsConfigurations/{relationshipsConfigurationId}/"
      if (!missing(`relationshipsConfigurationId`)) {
        urlPath <- gsub(paste0("\\{", "relationshipsConfigurationId", "\\}"), URLencode(as.character(`relationshipsConfigurationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PUT",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RelationshipsConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `RelationshipsConfigurationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RelationshipsConfigurationsRetrieveWithHttpInfo = function(relationshipsConfigurationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`relationshipsConfigurationId`)) {
        stop("Missing required parameter `relationshipsConfigurationId`.")
      }

      body <- NULL
      urlPath <- "/relationshipsConfigurations/{relationshipsConfigurationId}/"
      if (!missing(`relationshipsConfigurationId`)) {
        urlPath <- gsub(paste0("\\{", "relationshipsConfigurationId", "\\}"), URLencode(as.character(`relationshipsConfigurationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "RelationshipsConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `Retrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    RetrieveWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectRetrieveResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SecondaryDatasetsConfigurationsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SecondaryDatasetsConfigurationsCreateWithHttpInfo = function(projectId, secondaryDatasetCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`secondaryDatasetCreate`) && isa(secondaryDatasetCreate, c("SecondaryDatasetCreate", "R6"))) {
        body <- `secondaryDatasetCreate`$toJSON()
      } else {
        stop("SecondaryDatasetsConfigurationsCreateWithHttpInfo requires parameter secondaryDatasetCreate to be of type SecondaryDatasetCreate.")
      }

      urlPath <- "/projects/{projectId}/secondaryDatasetsConfigurations/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SecondaryDatasetsConfigurationsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SecondaryDatasetsConfigurationsDeleteWithHttpInfo = function(projectId, secondaryDatasetConfigId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`secondaryDatasetConfigId`)) {
        stop("Missing required parameter `secondaryDatasetConfigId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/secondaryDatasetsConfigurations/{secondaryDatasetConfigId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`secondaryDatasetConfigId`)) {
        urlPath <- gsub(paste0("\\{", "secondaryDatasetConfigId", "\\}"), URLencode(as.character(`secondaryDatasetConfigId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SecondaryDatasetsConfigurationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SecondaryDatasetsConfigurationsListWithHttpInfo = function(projectId, featurelistId = NULL, modelId = NULL, offset = 0, limit = 100, includeDeleted = "true", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["featurelistId"] <- featurelistId

      queryParams["modelId"] <- modelId

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["includeDeleted"] <- includeDeleted

      body <- NULL
      urlPath <- "/projects/{projectId}/secondaryDatasetsConfigurations/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SecondaryDatasetConfigListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SecondaryDatasetsConfigurationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SecondaryDatasetsConfigurationsRetrieveWithHttpInfo = function(projectId, secondaryDatasetConfigId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`secondaryDatasetConfigId`)) {
        stop("Missing required parameter `secondaryDatasetConfigId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/secondaryDatasetsConfigurations/{secondaryDatasetConfigId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`secondaryDatasetConfigId`)) {
        urlPath <- gsub(paste0("\\{", "secondaryDatasetConfigId", "\\}"), URLencode(as.character(`secondaryDatasetConfigId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectSecondaryDatasetConfigResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentationTaskJobResultsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentationTaskJobResultsRetrieveWithHttpInfo = function(projectId, segmentationTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`segmentationTaskId`)) {
        stop("Missing required parameter `segmentationTaskId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/segmentationTaskJobResults/{segmentationTaskId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`segmentationTaskId`)) {
        urlPath <- gsub(paste0("\\{", "segmentationTaskId", "\\}"), URLencode(as.character(`segmentationTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SegmentationResultsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentationTasksCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentationTasksCreateWithHttpInfo = function(projectId, segmentationTaskCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`segmentationTaskCreate`) && isa(segmentationTaskCreate, c("SegmentationTaskCreate", "R6"))) {
        body <- `segmentationTaskCreate`$toJSON()
      } else {
        stop("SegmentationTasksCreateWithHttpInfo requires parameter segmentationTaskCreate to be of type SegmentationTaskCreate.")
      }

      urlPath <- "/projects/{projectId}/segmentationTasks/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentationTasksList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentationTasksListWithHttpInfo = function(projectId, offset = 0, limit = 10, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/segmentationTasks/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SegmentationTaskListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentationTasksMappingsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentationTasksMappingsListWithHttpInfo = function(projectId, segmentationTaskId, offset = 0, limit = 10, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`segmentationTaskId`)) {
        stop("Missing required parameter `segmentationTaskId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/projects/{projectId}/segmentationTasks/{segmentationTaskId}/mappings/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`segmentationTaskId`)) {
        urlPath <- gsub(paste0("\\{", "segmentationTaskId", "\\}"), URLencode(as.character(`segmentationTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SegmentationTaskSegmentMappingsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentationTasksRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentationTasksRetrieveWithHttpInfo = function(projectId, segmentationTaskId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`segmentationTaskId`)) {
        stop("Missing required parameter `segmentationTaskId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/segmentationTasks/{segmentationTaskId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`segmentationTaskId`)) {
        urlPath <- gsub(paste0("\\{", "segmentationTaskId", "\\}"), URLencode(as.character(`segmentationTaskId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "SegmentationTaskResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `SegmentsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    SegmentsPatchWithHttpInfo = function(projectId, segmentId, projectSegmentUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (missing(`segmentId`)) {
        stop("Missing required parameter `segmentId`.")
      }

      if (!missing(`projectSegmentUpdate`) && isa(projectSegmentUpdate, c("ProjectSegmentUpdate", "R6"))) {
        body <- `projectSegmentUpdate`$toJSON()
      } else {
        stop("SegmentsPatchWithHttpInfo requires parameter projectSegmentUpdate to be of type ProjectSegmentUpdate.")
      }

      urlPath <- "/projects/{projectId}/segments/{segmentId}/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }

      if (!missing(`segmentId`)) {
        urlPath <- gsub(paste0("\\{", "segmentId", "\\}"), URLencode(as.character(`segmentId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectSegmentUpdateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `StatusList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    StatusListWithHttpInfo = function(projectId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      body <- NULL
      urlPath <- "/projects/{projectId}/status/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ProjectStatusResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `TypeTransformFeaturesCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    TypeTransformFeaturesCreateWithHttpInfo = function(projectId, featureTransform = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`projectId`)) {
        stop("Missing required parameter `projectId`.")
      }

      if (!missing(`featureTransform`) && isa(featureTransform, c("FeatureTransform", "R6"))) {
        body <- `featureTransform`$toJSON()
      } else {
        stop("TypeTransformFeaturesCreateWithHttpInfo requires parameter featureTransform to be of type FeatureTransform.")
      }

      urlPath <- "/projects/{projectId}/typeTransformFeatures/"
      if (!missing(`projectId`)) {
        urlPath <- gsub(paste0("\\{", "projectId", "\\}"), URLencode(as.character(`projectId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
