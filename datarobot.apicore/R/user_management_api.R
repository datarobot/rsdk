# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title UserManagement operations
#' @description datarobot.apicore.UserManagement
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @importFrom R6 R6Class
#' @export
UserManagementApi <- R6::R6Class(
  "UserManagementApi",
  public = list(
    apiClient = NULL,

    #' @param apiClient A configurable `ApiClient` instance. If none provided, a new client with default configuration will be created.
    initialize = function(apiClient) {
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      } else {
        self$apiClient <- ApiClient$new()
      }
    },
    #' @description Create user group
    #' Produces: "application/json"
    #'
    #' @details Create a new user group.
    #' @param userGroupCreate \link{UserGroupCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserGroupResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`**
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userGroupCreate <- UserGroupCreate$new() # UserGroupCreate |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsCreate(userGroupCreate=userGroupCreate)
    #' }
    GroupsCreate = function(userGroupCreate = NULL, ...) {
      apiResponse <- private$GroupsCreateWithHttpInfo(userGroupCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete user group
    #' Produces: NA
    #'
    #' @details Delete the user group.
    #' @param groupId character. The identifier of the user group.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** Multiple user groups found by the identifier.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsDelete(groupId)
    #' }
    GroupsDelete = function(groupId, ...) {
      apiResponse <- private$GroupsDeleteWithHttpInfo(groupId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete multiple user groups
    #' Produces: NA
    #'
    #' @details Delete the user groups.
    #' @param userGroupBulkDelete \link{UserGroupBulkDelete}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** Multiple user groups found by the identifier.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userGroupBulkDelete <- UserGroupBulkDelete$new() # UserGroupBulkDelete |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsDeleteMany(userGroupBulkDelete=userGroupBulkDelete)
    #' }
    GroupsDeleteMany = function(userGroupBulkDelete = NULL, ...) {
      apiResponse <- private$GroupsDeleteManyWithHttpInfo(userGroupBulkDelete, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update user group
    #' Produces: "application/json"
    #'
    #' @details Update the user group.
    #' @param groupId character. The identifier of the user group.
    #' @param userGroupUpdate \link{UserGroupUpdate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserGroupResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #' userGroupUpdate <- UserGroupUpdate$new() # UserGroupUpdate |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsPatch(groupId, userGroupUpdate=userGroupUpdate)
    #' }
    GroupsPatch = function(groupId, userGroupUpdate = NULL, ...) {
      apiResponse <- private$GroupsPatchWithHttpInfo(groupId, userGroupUpdate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve user group
    #' Produces: "application/json"
    #'
    #' @details Retrieve the user group.
    #' @param groupId character. The identifier of the user group.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserGroupResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** Multiple user groups found by the identifier.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsRetrieve(groupId)
    #' }
    GroupsRetrieve = function(groupId, ...) {
      apiResponse <- private$GroupsRetrieveWithHttpInfo(groupId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add users to group
    #' Produces: "application/json"
    #'
    #' @details Add users to the group.
    #' @param groupId character. The identifier of the user group.
    #' @param modifyUsersInGroup \link{ModifyUsersInGroup}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{AddUsersToGroupResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' \item **`422`** Unable to process the request, or if the user does not belong to the group&#39;s organization, or if one is already in the maximum number of groups, or if the user is not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #' modifyUsersInGroup <- ModifyUsersInGroup$new() # ModifyUsersInGroup |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsUsersCreate(groupId, modifyUsersInGroup=modifyUsersInGroup)
    #' }
    GroupsUsersCreate = function(groupId, modifyUsersInGroup = NULL, ...) {
      apiResponse <- private$GroupsUsersCreateWithHttpInfo(groupId, modifyUsersInGroup, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Remove users from group
    #' Produces: NA
    #'
    #' @details Remove users from the group.
    #' @param groupId character. The identifier of the user group.
    #' @param modifyUsersInGroup \link{ModifyUsersInGroup}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** The user was not found.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #' modifyUsersInGroup <- ModifyUsersInGroup$new() # ModifyUsersInGroup |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsUsersDeleteMany(groupId, modifyUsersInGroup=modifyUsersInGroup)
    #' }
    GroupsUsersDeleteMany = function(groupId, modifyUsersInGroup = NULL, ...) {
      apiResponse <- private$GroupsUsersDeleteManyWithHttpInfo(groupId, modifyUsersInGroup, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List users in group
    #' Produces: "application/json"
    #'
    #' @details List users in the group.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned.
    #' @param groupId character. The identifier of the user group.
    #' @param namePart character. User groups must contain the substring.
    #' @param orderBy character. The order that the results should be retrieved in. Prefix the attribute name with a dash to sort in descending order, e.g. &#x60;orderBy&#x3D;-name&#x60;.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{ListUsersInGroupResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 50 # integer | At most this many results are returned.
    #' groupId <- 'groupId_example' # character | The identifier of the user group.
    #' namePart <- "" # character | User groups must contain the substring.
    #' orderBy <- "" # character | The order that the results should be retrieved in. Prefix the attribute name with a dash to sort in descending order, e.g. `orderBy=-name`.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$GroupsUsersList(offset, limit, groupId, namePart=namePart, orderBy=orderBy)
    #' }
    GroupsUsersList = function(offset, limit, groupId, namePart = "", orderBy = "", ...) {
      apiResponse <- private$GroupsUsersListWithHttpInfo(offset, limit, groupId, namePart, orderBy, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List organization jobs
    #' Produces: "application/json"
    #'
    #' @details List currently running jobs belonging to this organization.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param organizationId character. Organization ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationJobListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' organizationId <- 'organizationId_example' # character | Organization ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsJobsList(offset, limit, organizationId)
    #' }
    OrganizationsJobsList = function(offset, limit, organizationId, ...) {
      apiResponse <- private$OrganizationsJobsListWithHttpInfo(offset, limit, organizationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List organizations
    #' Produces: "application/json"
    #'
    #' @details List organizations available in the system.
    #' @param limit integer. At most this many results are returned.
    #' @param offset integer. The number of records to skip over. Default 0.
    #' @param namePart character. Only return the organizations whose names contain the given substring.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' limit <- 100 # integer | At most this many results are returned.
    #' offset <- 0 # integer | The number of records to skip over. Default 0.
    #' namePart <- "" # character | Only return the organizations whose names contain the given substring.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsList(limit, offset=offset, namePart=namePart)
    #' }
    OrganizationsList = function(limit, offset = 0, namePart = "", ...) {
      apiResponse <- private$OrganizationsListWithHttpInfo(limit, offset, namePart, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve organization
    #' Produces: "application/json"
    #'
    #' @details Retrieve the organization details.
    #' @param organizationId character. Organization ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationRetrieve}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' organizationId <- 'organizationId_example' # character | Organization ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsRetrieve(organizationId)
    #' }
    OrganizationsRetrieve = function(organizationId, ...) {
      apiResponse <- private$OrganizationsRetrieveWithHttpInfo(organizationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Add user to an existing organization.
    #' Produces: "application/json"
    #'
    #' @details Add user to an existing organization. A user can only be part of one organization at a time
    #' @param organizationId character. Organization ID
    #' @param organizationUser \link{OrganizationUser}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationUserCreatedResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`201`**
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' organizationId <- 'organizationId_example' # character | Organization ID
    #' organizationUser <- OrganizationUser$new() # OrganizationUser |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsUsersCreate(organizationId, organizationUser=organizationUser)
    #' }
    OrganizationsUsersCreate = function(organizationId, organizationUser = NULL, ...) {
      apiResponse <- private$OrganizationsUsersCreateWithHttpInfo(organizationId, organizationUser, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Remove user from organization
    #' Produces: NA
    #'
    #' @details Remove the user from the organization.
    #' @param organizationId character. The organization the user is in
    #' @param userId character. The user ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' organizationId <- 'organizationId_example' # character | The organization the user is in
    #' userId <- 'userId_example' # character | The user ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsUsersDelete(organizationId, userId)
    #' }
    OrganizationsUsersDelete = function(organizationId, userId, ...) {
      apiResponse <- private$OrganizationsUsersDeleteWithHttpInfo(organizationId, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description List organization users
    #' Produces: "application/json"
    #'
    #' @details List memberships in this organization.
    #' @param offset integer. This many results will be skipped.
    #' @param limit integer. At most this many results are returned. If 0, all results.
    #' @param organizationId character. Organization ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationUserListResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' offset <- 0 # integer | This many results will be skipped.
    #' limit <- 0 # integer | At most this many results are returned. If 0, all results.
    #' organizationId <- 'organizationId_example' # character | Organization ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsUsersList(offset, limit, organizationId)
    #' }
    OrganizationsUsersList = function(offset, limit, organizationId, ...) {
      apiResponse <- private$OrganizationsUsersListWithHttpInfo(offset, limit, organizationId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Patch organization&#39;s user
    #' Produces: "application/json"
    #'
    #' @details Patch organization&#39;s user. Only system or the organization admin can perform this operation.
    #' @param organizationId character. The organization the user is in
    #' @param userId character. The user ID
    #' @param organizationUserPatch \link{OrganizationUserPatch}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`403`** Invalid Permissions
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' organizationId <- 'organizationId_example' # character | The organization the user is in
    #' userId <- 'userId_example' # character | The user ID
    #' organizationUserPatch <- OrganizationUserPatch$new() # OrganizationUserPatch |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsUsersPatch(organizationId, userId, organizationUserPatch=organizationUserPatch)
    #' }
    OrganizationsUsersPatch = function(organizationId, userId, organizationUserPatch = NULL, ...) {
      apiResponse <- private$OrganizationsUsersPatchWithHttpInfo(organizationId, userId, organizationUserPatch, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve user from organization
    #' Produces: "application/json"
    #'
    #' @details Retrieve the user from this organization.
    #' @param organizationId character. The organization the user is in
    #' @param userId character. The user ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{OrganizationUserResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`**
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' organizationId <- 'organizationId_example' # character | The organization the user is in
    #' userId <- 'userId_example' # character | The user ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$OrganizationsUsersRetrieve(organizationId, userId)
    #' }
    OrganizationsUsersRetrieve = function(organizationId, userId, ...) {
      apiResponse <- private$OrganizationsUsersRetrieveWithHttpInfo(organizationId, userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete.
    #' Produces: "application/json"
    #'
    #' @details Schedules a job which permanently delete the users represented by the provided users ids or organization id. Number of users to be deleted in one go is restricted by DELETED_USERS_BATCH_LIMIT system setting.
    #' @param usersPermadelete \link{UsersPermadelete}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeleteJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The users delete job status link.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`409`** Self deletion or some users are already under deletion.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' \item **`500`** Failed to schedule users perma-delete job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' usersPermadelete <- UsersPermadelete$new() # UsersPermadelete |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupJobsCreate(usersPermadelete=usersPermadelete)
    #' }
    UserCleanupJobsCreate = function(usersPermadelete = NULL, ...) {
      apiResponse <- private$UserCleanupJobsCreateWithHttpInfo(usersPermadelete, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel users perma-deletion.
    #' Produces: NA
    #'
    #' @details Cancel permanent deletion of the selected users.
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupJobsDelete(statusId)
    #' }
    UserCleanupJobsDelete = function(statusId, ...) {
      apiResponse <- private$UserCleanupJobsDeleteWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve users perma-delete job status.
    #' Produces: "application/json"
    #'
    #' @details Get async status of the users perma-delete job.
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeleteJobStatusResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Users perma-delete job status.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupJobsRetrieve(statusId)
    #' }
    UserCleanupJobsRetrieve = function(statusId, ...) {
      apiResponse <- private$UserCleanupJobsRetrieveWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete preview.
    #' Produces: "application/json"
    #'
    #' @details Schedules a job for building preview for users selected for permanent deletion. Number of users to be deleted in one go is restricted by DELETED_USERS_BATCH_LIMIT system setting.
    #' @param usersPermadelete \link{UsersPermadelete}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeletePreviewJobResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** The users delete preview job status link.
    #' \itemize{
    #' \item **`Location`** A url that can be polled to check the status.
    #' }
    #' \item **`409`** Self deletion or some users are already under deletion.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' \item **`500`** Failed to schedule perma-delete preview building job.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' usersPermadelete <- UsersPermadelete$new() # UsersPermadelete |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewJobsCreate(usersPermadelete=usersPermadelete)
    #' }
    UserCleanupPreviewJobsCreate = function(usersPermadelete = NULL, ...) {
      apiResponse <- private$UserCleanupPreviewJobsCreateWithHttpInfo(usersPermadelete, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Cancel users perma-delete preview building.
    #' Produces: NA
    #'
    #' @details Cancel scheduled users permanent delete preview building.
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`204`**
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewJobsDelete(statusId)
    #' }
    UserCleanupPreviewJobsDelete = function(statusId, ...) {
      apiResponse <- private$UserCleanupPreviewJobsDeleteWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Retrieve users perma-delete preview job status.
    #' Produces: "application/json"
    #'
    #' @details Get async status of the users perma-delete preview building job.
    #' @param statusId character. The ID of the status object.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeletePreviewJobStatusResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Perma-delete preview job status.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' statusId <- 'statusId_example' # character | The ID of the status object.
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewJobsRetrieve(statusId)
    #' }
    UserCleanupPreviewJobsRetrieve = function(statusId, ...) {
      apiResponse <- private$UserCleanupPreviewJobsRetrieveWithHttpInfo(statusId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete extended preview.
    #' Produces: NA
    #'
    #' @details Retrieve users permanent delete extended preview.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete extended preview file.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** attachment; filename&#x3D;\&quot;&lt;\&quot;filename\&quot;&gt;\&quot;.json JSON file with users delete extended preview.
    #' \item **`ContentMinusType`** application/json
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewsContentList(reportId)
    #' }
    UserCleanupPreviewsContentList = function(reportId, ...) {
      apiResponse <- private$UserCleanupPreviewsContentListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete users permanent delete report.
    #' Produces: NA
    #'
    #' @details Delete users permanent delete report.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Report is deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewsDelete(reportId)
    #' }
    UserCleanupPreviewsDelete = function(reportId, ...) {
      apiResponse <- private$UserCleanupPreviewsDeleteWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete report parameters.
    #' Produces: "application/json"
    #'
    #' @details Retrieve users permanent delete report parameters.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeleteDeleteReportParamsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete report parameters.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewsDeleteParamsList(reportId)
    #' }
    UserCleanupPreviewsDeleteParamsList = function(reportId, ...) {
      apiResponse <- private$UserCleanupPreviewsDeleteParamsListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete preview statistics.
    #' Produces: "application/json"
    #'
    #' @details Retrieve users permanent delete preview statistics.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeletePreviewStatisticsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete preview statistics.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupPreviewsStatisticsList(reportId)
    #' }
    UserCleanupPreviewsStatisticsList = function(reportId, ...) {
      apiResponse <- private$UserCleanupPreviewsStatisticsListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete extended summary.
    #' Produces: NA
    #'
    #' @details Retrieve users permanent delete extended summary.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete extended summary file.
    #' \itemize{
    #' \item **`ContentMinusDisposition`** attachment; filename&#x3D;\&quot;&lt;\&quot;filename\&quot;&gt;\&quot;.json JSON file with with users delete extended summary.
    #' \item **`ContentMinusType`** application/json
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupSummariesContentList(reportId)
    #' }
    UserCleanupSummariesContentList = function(reportId, ...) {
      apiResponse <- private$UserCleanupSummariesContentListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Delete users permanent delete report.
    #' Produces: NA
    #'
    #' @details Delete users permanent delete report.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`202`** Report is deleted.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupSummariesDelete(reportId)
    #' }
    UserCleanupSummariesDelete = function(reportId, ...) {
      apiResponse <- private$UserCleanupSummariesDeleteWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete report parameters.
    #' Produces: "application/json"
    #'
    #' @details Retrieve users permanent delete report parameters.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeleteDeleteReportParamsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete report parameters.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupSummariesDeleteParamsList(reportId)
    #' }
    UserCleanupSummariesDeleteParamsList = function(reportId, ...) {
      apiResponse <- private$UserCleanupSummariesDeleteParamsListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Users permanent delete summary statistics.
    #' Produces: "application/json"
    #'
    #' @details Retrieve users permanent delete summary statistics.
    #' @param reportId character. Report ID
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UsersPermadeleteSummaryReportStatisticsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The users delete summary statistics.
    #' \itemize{
    #' }
    #' \item **`422`** Invalid data
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' reportId <- 'reportId_example' # character | Report ID
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UserCleanupSummariesStatisticsList(reportId)
    #' }
    UserCleanupSummariesStatisticsList = function(reportId, ...) {
      apiResponse <- private$UserCleanupSummariesStatisticsListWithHttpInfo(reportId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Create a User and add them to an organisation.
    #' Produces: "application/json"
    #'
    #' @details Create a User and add them to an organisation.
    #' @param userCreate \link{UserCreate}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserCreateResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** The username and userId of the newly created user.
    #' \itemize{
    #' }
    #' \item **`409`** User already exists.
    #' \itemize{
    #' }
    #' \item **`422`** Password invalid/required.
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userCreate <- UserCreate$new() # UserCreate |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UsersCreate(userCreate=userCreate)
    #' }
    UsersCreate = function(userCreate = NULL, ...) {
      apiResponse <- private$UsersCreateWithHttpInfo(userCreate, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Get the rate limits and account limits for a user
    #' Produces: "application/json"
    #'
    #' @details User limits are those limits on an account that can be updated per-user. Rate limits that can&#39;t be modified per-user are not returned here.
    #' @param userId character. The id of the user to retrieve usage limits for
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @return \link{UserLimitsResponse}
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data retrieved successfully
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userId <- 'userId_example' # character | The id of the user to retrieve usage limits for
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UsersLimitsList(userId)
    #' }
    UsersLimitsList = function(userId, ...) {
      apiResponse <- private$UsersLimitsListWithHttpInfo(userId, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },
    #' @description Update the rate limits and account limits for a user
    #' Produces: NA
    #'
    #' @details User limits are those limits on an account that can be updated per-user.Rate limits that can&#39;t be modified per-user are not returned here.
    #' @param userId character. The id of the user to update usage limits for
    #' @param userLimitsPatchBody \link{UserLimitsPatchBody}.
    #' @param ... Optional. Additional named parameters to be passed downward.
    #' @details Response status codes, messages, and headers:
    #' \itemize{
    #' \item **`200`** Data updated successfully
    #' \itemize{
    #' }
    #' \item **`409`** The limit being updated is not available to be updated
    #' \itemize{
    #' }
    #' }
    #' @examples
    #' \dontrun{
    #' library(datarobot.apicore)
    #' userId <- 'userId_example' # character | The id of the user to update usage limits for
    #' userLimitsPatchBody <- UserLimitsPatchBody$new() # UserLimitsPatchBody |
    #'
    #' api.instance <- UserManagementApi$new()
    #' result <- api.instance$UsersLimitsPatchMany(userId, userLimitsPatchBody=userLimitsPatchBody)
    #' }
    UsersLimitsPatchMany = function(userId, userLimitsPatchBody = NULL, ...) {
      apiResponse <- private$UsersLimitsPatchManyWithHttpInfo(userId, userLimitsPatchBody, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) == 202) {
        # When the DataRobot Public API returns a 202, this means that
        # an asynchronous job or task has been started. The response will
        # not have a body, but will have a Location header pointing to an
        # endpoint for checking that job's status.
        apiResponse
      } else if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        .ReturnResponse(apiResponse$content)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    }
  ),
  private = list(
    # A helper function to invoke the API operation `GroupsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsCreateWithHttpInfo = function(userGroupCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userGroupCreate`) && isa(userGroupCreate, c("UserGroupCreate", "R6"))) {
        body <- `userGroupCreate`$toJSON()
      } else {
        stop("GroupsCreateWithHttpInfo requires parameter userGroupCreate to be of type UserGroupCreate.")
      }

      urlPath <- "/groups/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserGroupResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsDeleteWithHttpInfo = function(groupId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      body <- NULL
      urlPath <- "/groups/{groupId}/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsDeleteManyWithHttpInfo = function(userGroupBulkDelete = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userGroupBulkDelete`) && isa(userGroupBulkDelete, c("UserGroupBulkDelete", "R6"))) {
        body <- `userGroupBulkDelete`$toJSON()
      } else {
        stop("GroupsDeleteManyWithHttpInfo requires parameter userGroupBulkDelete to be of type UserGroupBulkDelete.")
      }

      urlPath <- "/groups/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsPatchWithHttpInfo = function(groupId, userGroupUpdate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      if (!missing(`userGroupUpdate`) && isa(userGroupUpdate, c("UserGroupUpdate", "R6"))) {
        body <- `userGroupUpdate`$toJSON()
      } else {
        stop("GroupsPatchWithHttpInfo requires parameter userGroupUpdate to be of type UserGroupUpdate.")
      }

      urlPath <- "/groups/{groupId}/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserGroupResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsRetrieveWithHttpInfo = function(groupId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      body <- NULL
      urlPath <- "/groups/{groupId}/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserGroupResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsUsersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsUsersCreateWithHttpInfo = function(groupId, modifyUsersInGroup = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      if (!missing(`modifyUsersInGroup`) && isa(modifyUsersInGroup, c("ModifyUsersInGroup", "R6"))) {
        body <- `modifyUsersInGroup`$toJSON()
      } else {
        stop("GroupsUsersCreateWithHttpInfo requires parameter modifyUsersInGroup to be of type ModifyUsersInGroup.")
      }

      urlPath <- "/groups/{groupId}/users/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "AddUsersToGroupResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsUsersDeleteMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsUsersDeleteManyWithHttpInfo = function(groupId, modifyUsersInGroup = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      if (!missing(`modifyUsersInGroup`) && isa(modifyUsersInGroup, c("ModifyUsersInGroup", "R6"))) {
        body <- `modifyUsersInGroup`$toJSON()
      } else {
        stop("GroupsUsersDeleteManyWithHttpInfo requires parameter modifyUsersInGroup to be of type ModifyUsersInGroup.")
      }

      urlPath <- "/groups/{groupId}/users/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `GroupsUsersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    GroupsUsersListWithHttpInfo = function(offset, limit, groupId, namePart = "", orderBy = "", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`groupId`)) {
        stop("Missing required parameter `groupId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["namePart"] <- namePart

      queryParams["orderBy"] <- orderBy

      body <- NULL
      urlPath <- "/groups/{groupId}/users/"
      if (!missing(`groupId`)) {
        urlPath <- gsub(paste0("\\{", "groupId", "\\}"), URLencode(as.character(`groupId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "ListUsersInGroupResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsJobsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsJobsListWithHttpInfo = function(offset, limit, organizationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/organizations/{organizationId}/jobs/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationJobListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsListWithHttpInfo = function(limit, offset = 0, namePart = "", ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      queryParams["namePart"] <- namePart

      body <- NULL
      urlPath <- "/organizations/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsRetrieveWithHttpInfo = function(organizationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      body <- NULL
      urlPath <- "/organizations/{organizationId}/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationRetrieve", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsUsersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsUsersCreateWithHttpInfo = function(organizationId, organizationUser = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      if (!missing(`organizationUser`) && isa(organizationUser, c("OrganizationUser", "R6"))) {
        body <- `organizationUser`$toJSON()
      } else {
        stop("OrganizationsUsersCreateWithHttpInfo requires parameter organizationUser to be of type OrganizationUser.")
      }

      urlPath <- "/organizations/{organizationId}/users/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationUserCreatedResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsUsersDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsUsersDeleteWithHttpInfo = function(organizationId, userId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      if (missing(`userId`)) {
        stop("Missing required parameter `userId`.")
      }

      body <- NULL
      urlPath <- "/organizations/{organizationId}/users/{userId}/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }

      if (!missing(`userId`)) {
        urlPath <- gsub(paste0("\\{", "userId", "\\}"), URLencode(as.character(`userId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsUsersList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsUsersListWithHttpInfo = function(offset, limit, organizationId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      queryParams["offset"] <- offset

      queryParams["limit"] <- limit

      body <- NULL
      urlPath <- "/organizations/{organizationId}/users/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationUserListResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsUsersPatch`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsUsersPatchWithHttpInfo = function(organizationId, userId, organizationUserPatch = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      if (missing(`userId`)) {
        stop("Missing required parameter `userId`.")
      }

      if (!missing(`organizationUserPatch`) && isa(organizationUserPatch, c("OrganizationUserPatch", "R6"))) {
        body <- `organizationUserPatch`$toJSON()
      } else {
        stop("OrganizationsUsersPatchWithHttpInfo requires parameter organizationUserPatch to be of type OrganizationUserPatch.")
      }

      urlPath <- "/organizations/{organizationId}/users/{userId}/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }

      if (!missing(`userId`)) {
        urlPath <- gsub(paste0("\\{", "userId", "\\}"), URLencode(as.character(`userId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "object", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `OrganizationsUsersRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    OrganizationsUsersRetrieveWithHttpInfo = function(organizationId, userId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`organizationId`)) {
        stop("Missing required parameter `organizationId`.")
      }

      if (missing(`userId`)) {
        stop("Missing required parameter `userId`.")
      }

      body <- NULL
      urlPath <- "/organizations/{organizationId}/users/{userId}/"
      if (!missing(`organizationId`)) {
        urlPath <- gsub(paste0("\\{", "organizationId", "\\}"), URLencode(as.character(`organizationId`), reserved = TRUE), urlPath)
      }

      if (!missing(`userId`)) {
        urlPath <- gsub(paste0("\\{", "userId", "\\}"), URLencode(as.character(`userId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "OrganizationUserResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupJobsCreateWithHttpInfo = function(usersPermadelete = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`usersPermadelete`) && isa(usersPermadelete, c("UsersPermadelete", "R6"))) {
        body <- `usersPermadelete`$toJSON()
      } else {
        stop("UserCleanupJobsCreateWithHttpInfo requires parameter usersPermadelete to be of type UsersPermadelete.")
      }

      urlPath <- "/userCleanupJobs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeleteJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupJobsDeleteWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupJobsRetrieveWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeleteJobStatusResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewJobsCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewJobsCreateWithHttpInfo = function(usersPermadelete = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`usersPermadelete`) && isa(usersPermadelete, c("UsersPermadelete", "R6"))) {
        body <- `usersPermadelete`$toJSON()
      } else {
        stop("UserCleanupPreviewJobsCreateWithHttpInfo requires parameter usersPermadelete to be of type UsersPermadelete.")
      }

      urlPath <- "/userCleanupPreviewJobs/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeletePreviewJobResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewJobsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewJobsDeleteWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviewJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewJobsRetrieve`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewJobsRetrieveWithHttpInfo = function(statusId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`statusId`)) {
        stop("Missing required parameter `statusId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviewJobs/{statusId}/"
      if (!missing(`statusId`)) {
        urlPath <- gsub(paste0("\\{", "statusId", "\\}"), URLencode(as.character(`statusId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeletePreviewJobStatusResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewsContentList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewsContentListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviews/{reportId}/content/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewsDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewsDeleteWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviews/{reportId}/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewsDeleteParamsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewsDeleteParamsListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviews/{reportId}/deleteParams/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeleteDeleteReportParamsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupPreviewsStatisticsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupPreviewsStatisticsListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupPreviews/{reportId}/statistics/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeletePreviewStatisticsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupSummariesContentList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupSummariesContentListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupSummaries/{reportId}/content/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupSummariesDelete`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupSummariesDeleteWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupSummaries/{reportId}/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "DELETE",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupSummariesDeleteParamsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupSummariesDeleteParamsListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupSummaries/{reportId}/deleteParams/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeleteDeleteReportParamsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UserCleanupSummariesStatisticsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UserCleanupSummariesStatisticsListWithHttpInfo = function(reportId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`reportId`)) {
        stop("Missing required parameter `reportId`.")
      }

      body <- NULL
      urlPath <- "/userCleanupSummaries/{reportId}/statistics/"
      if (!missing(`reportId`)) {
        urlPath <- gsub(paste0("\\{", "reportId", "\\}"), URLencode(as.character(`reportId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UsersPermadeleteSummaryReportStatisticsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UsersCreate`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UsersCreateWithHttpInfo = function(userCreate = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`userCreate`) && isa(userCreate, c("UserCreate", "R6"))) {
        body <- `userCreate`$toJSON()
      } else {
        stop("UsersCreateWithHttpInfo requires parameter userCreate to be of type UserCreate.")
      }

      urlPath <- "/users/"

      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "POST",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserCreateResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UsersLimitsList`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UsersLimitsListWithHttpInfo = function(userId, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userId`)) {
        stop("Missing required parameter `userId`.")
      }

      body <- NULL
      urlPath <- "/users/{userId}/limits/"
      if (!missing(`userId`)) {
        urlPath <- gsub(paste0("\\{", "userId", "\\}"), URLencode(as.character(`userId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "GET",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- self$apiClient$deserialize(resp, "UserLimitsResponse", loadNamespace("datarobot.apicore"))
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    },
    # A helper function to invoke the API operation `UsersLimitsPatchMany`. This function is responsible for
    # validating request parameters, building the request, deserializing the response, and handling errors.
    UsersLimitsPatchManyWithHttpInfo = function(userId, userLimitsPatchBody = NULL, ...) {
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`userId`)) {
        stop("Missing required parameter `userId`.")
      }

      if (!missing(`userLimitsPatchBody`) && isa(userLimitsPatchBody, c("UserLimitsPatchBody", "R6"))) {
        body <- `userLimitsPatchBody`$toJSON()
      } else {
        stop("UsersLimitsPatchManyWithHttpInfo requires parameter userLimitsPatchBody to be of type UserLimitsPatchBody.")
      }

      urlPath <- "/users/{userId}/limits/"
      if (!missing(`userId`)) {
        urlPath <- gsub(paste0("\\{", "userId", "\\}"), URLencode(as.character(`userId`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(
        url = paste0(self$apiClient$basePath, urlPath),
        method = "PATCH",
        queryParams = queryParams,
        headerParams = headerParams,
        body = body,
        ...
      )

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new(paste("API client error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new(paste("API server error with ", httr::status_code(resp), " response status code. See $response for more detail."), resp)
      }
    }
  )
)
