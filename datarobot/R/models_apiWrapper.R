# Copyright 2021 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.28.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech


# NOTE: This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the file manually.

# API Wrapper methods for Models
# To use these methods without modification, DR endpoint and token
# should be set as environment variables. This will automatically
# happen when you call `datarobot::ConnectToDataRobot()`.



#' CreateCustomInferenceImagesFeatureImpact
#'
#' Create custom model feature impact.
#'
#' Add a request to calculate feature impact for a custom inference model image to             the queue.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:post:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/`  This route is a counterpart of a corresponding endpoint for native models: :http:post:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`
#'
#' @seealso The method CustomInferenceImagesFeatureImpactCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomInferenceImagesFeatureImpact <- function(backtest, imageId, rowCount, ...) {
  featureImpactCreatePayload <- datarobot.apicore::FeatureImpactCreatePayload$new(backtest = backtest, rowCount = rowCount, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomInferenceImagesFeatureImpactCreate(featureImpactCreatePayload = featureImpactCreatePayload, imageId = imageId))
}

#' ListCustomInferenceImagesFeatureImpact
#'
#' Get custom model feature impact.
#'
#' Retrieve feature impact scores for features in a custom inference model image.  .. minversion:: v2.23     DEPRECATED: please use version route instead:     :http:get:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/featureImpact/`  This route is a counterpart of a corresponding endpoint for native models: :http:get:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`
#'
#' @seealso The method CustomInferenceImagesFeatureImpactList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomInferenceImagesFeatureImpact <- function(imageId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomInferenceImagesFeatureImpactList(imageId = imageId))
}

#' ListCustomModelDeployments
#'
#' List custom model deployments.
#'
#' List of model deployments for user sorted by creation time descending.
#'
#' @seealso The method CustomModelDeploymentsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelDeployments <- function(customModelIds, environmentIds, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelDeploymentsList(customModelIds = customModelIds, offset = offset, environmentIds = environmentIds, limit = limit))
}

#' ListCustomModelLimits
#'
#' Get custom model resource limits.
#'
#' Retrieve custom model resource limits the user has access to.
#'
#' @seealso The method CustomModelLimitsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelLimits <- function(...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelLimitsList())
}

#' CreateCustomModelTests
#'
#' Create custom model test.
#'
#' Test a custom inference model. This will start a job to check that the custom model can make predictions against the supplied dataset without breaking.
#'
#' @seealso The method CustomModelTestsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelTests <- function(networkEgressPolicy, requiresHa, environmentId, customModelId, configuration, replicas, maximumMemory, datasetId, desiredMemory, environmentVersionId, datasetVersionId, customModelVersionId, ...) {
  customModelTests <- datarobot.apicore::CustomModelTests$new(networkEgressPolicy = networkEgressPolicy, requiresHa = requiresHa, environmentId = environmentId, customModelId = customModelId, configuration = configuration, replicas = replicas, maximumMemory = maximumMemory, datasetId = datasetId, desiredMemory = desiredMemory, environmentVersionId = environmentVersionId, datasetVersionId = datasetVersionId, customModelVersionId = customModelVersionId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsCreate(customModelTests = customModelTests))
}

#' DeleteCustomModelTests
#'
#' Cancel custom model test.
#'
#' Cancel custom inference model testing.
#'
#' @seealso The method CustomModelTestsDelete in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DeleteCustomModelTests <- function(customModelTestId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsDelete(customModelTestId = customModelTestId))
}

#' ListCustomModelTests
#'
#' List custom model tests.
#'
#' Retrieve the testing history for a model.
#'
#' @seealso The method CustomModelTestsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelTests <- function(networkEgressPolicy, requiresHa, customModelId, replicas, maximumMemory, desiredMemory, offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsList(networkEgressPolicy = networkEgressPolicy, requiresHa = requiresHa, offset = offset, customModelId = customModelId, replicas = replicas, limit = limit, maximumMemory = maximumMemory, desiredMemory = desiredMemory))
}

#' ListCustomModelTestsLog
#'
#' Get custom model test log.
#'
#' Retrieve the logs from a model testing attempt.
#'
#' @seealso The method CustomModelTestsLogList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelTestsLog <- function(customModelTestId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsLogList(customModelTestId = customModelTestId))
}

#' RetrieveCustomModelTests
#'
#' Get custom model test.
#'
#' Retrieve a specific testing history entry for a custom model.
#'
#' @seealso The method CustomModelTestsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveCustomModelTests <- function(customModelTestId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsRetrieve(customModelTestId = customModelTestId))
}

#' ListCustomModelTestsTail
#'
#' Get custom model test log tail.
#'
#' Retrieve the last N lines of logs from a model testing attempt.
#'
#' @seealso The method CustomModelTestsTailList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelTestsTail <- function(customModelTestId, lines = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelTestsTailList(customModelTestId = customModelTestId, lines = lines))
}

#' ListCustomModelsAccessControl
#'
#' Get a list of users who have access to this custom model and their roles on it.
#'
#' Get a list of users who have access to this custom model and their roles on it.
#'
#' @seealso The method CustomModelsAccessControlList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsAccessControl <- function(customModelId, offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsAccessControlList(offset = offset, customModelId = customModelId, limit = limit))
}

#' PatchManyCustomModelsAccessControl
#'
#' Grant access or update roles for users on this custom model and appropriate learning data.
#'
#' Grant access or update roles for users on this custom model and appropriate learning data. Up to 100 user roles may be set in a single request.
#'
#' @seealso The method CustomModelsAccessControlPatchMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchManyCustomModelsAccessControl <- function(data, customModelId, ...) {
  sharingUpdateOrRemoveWithGrant <- datarobot.apicore::SharingUpdateOrRemoveWithGrant$new(data = data, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsAccessControlPatchMany(sharingUpdateOrRemoveWithGrant = sharingUpdateOrRemoveWithGrant, customModelId = customModelId))
}

#' CreateCustomModels
#'
#' Create custom model.
#'
#'  Creates a new custom model and returns the newly created metadata record for it.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  A regression model is expected to produce predictions that are arbitrary floating-point or integer numbers. A classification model is expected to return predictions with probability scores for each class.  For example, a binary classification model might return:  .. code:: Python      {         positiveClassLabel: probability,         negativeClassLabel: 1.0 - probability     }  For Custom Inference Models, the ``file`` parameter must be either a tarball or zip archive containing, at minimum, a script named ``start_server.sh``.  It may contain additional files, including scripts and precompiled binaries as well as data files.  ``start_server.sh`` may execute these scripts and/or binaries.  When this script is executed, it is run as part of an Environment (specified via subsequent API calls), and all included scripts and binaries can take advantage of any programming language interpreters, compilers, libraries, or other tools included in the Environment. ``start_server.sh`` must be marked as executable (``chmod +x``).  When ``start_server.sh`` is launched, it must launch and maintain (in the foreground) a Web server that listens on two URLs:  * ``GET $URL_PREFIX/``     This route must return a 200 response code with an empty body immediately     if the server is ready to respond to prediction requests.  Otherwise it should     either not accept the request, not respond to the request, or return a     503 response code. * ``POST $URL_PREFIX/predict_no_state/``     This route must accept as input a JSON object of the form:      .. code-block:: Python          {             'X': {                 'col1': [...col1_data...],                 'col2': [...col2_data...],                 'col3': [...col3_data...],                 ...             }         }      The data lists will all be the same length.      It must return a JSON object of the form:      .. code-block:: Python          {             'predictions': [...predictions data...]         }      The predictions data must correspond 1:1 to the rows in the input data lists.      ``$URL_PREFIX`` is provided as an environment variable.  The Web server process must     re-read its value every time the process starts, as it may change.     It is an opaque string that is guaranteed to be a valid URL component,     but may contain path separators (``/``).
#'
#' @seealso The method CustomModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModels <- function(networkEgressPolicy, negativeClassLabel, targetName, replicas, supportsRegression, maximumMemory, description, customModelType, targetType, language, requiresHa, classLabels, supportsBinaryClassification, name, positiveClassLabel, desiredMemory, calibratePredictions = TRUE, predictionThreshold = 0.5, ...) {
  customModelCreate <- datarobot.apicore::CustomModelCreate$new(networkEgressPolicy = networkEgressPolicy, negativeClassLabel = negativeClassLabel, targetName = targetName, replicas = replicas, supportsRegression = supportsRegression, calibratePredictions = calibratePredictions, maximumMemory = maximumMemory, description = description, customModelType = customModelType, targetType = targetType, language = language, predictionThreshold = predictionThreshold, requiresHa = requiresHa, classLabels = classLabels, supportsBinaryClassification = supportsBinaryClassification, name = name, positiveClassLabel = positiveClassLabel, desiredMemory = desiredMemory, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsCreate(customModelCreate = customModelCreate))
}

#' DeleteCustomModels
#'
#' Delete custom model.
#'
#' Delete a custom model. Only users who have permission to edit custom model can delete it. Only custom models which are not currently deployed or undergoing custom model testing can be deleted. Relevant CustomModelImage will be deleted also.
#'
#' @seealso The method CustomModelsDelete in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DeleteCustomModels <- function(customModelId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsDelete(customModelId = customModelId))
}

#' ListCustomModelsDownload
#'
#' Download the latest custom model version content.
#'
#' Download the latest item bundle from a custom model as a zip compressed archive.
#'
#' @seealso The method CustomModelsDownloadList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsDownload <- function(customModelId, pps = "False", ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsDownloadList(pps = pps, customModelId = customModelId))
}

#' CreateCustomModelsFromCustomModel
#'
#' Clone custom model.
#'
#' Creates a copy of the provided custom model, including metadata, versions of that model, and uploaded files. Associates the new versions with files owned by the custom model.
#'
#' @seealso The method CustomModelsFromCustomModelCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsFromCustomModel <- function(customModelId, ...) {
  customModelCopy <- datarobot.apicore::CustomModelCopy$new(customModelId = customModelId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsFromCustomModelCreate(customModelCopy = customModelCopy))
}

#' ListCustomModels
#'
#' List custom models.
#'
#' Retrieve metadata for all custom models the user has access to.
#'
#' @seealso The method CustomModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModels <- function(isDeployed, orderBy, customModelType, searchFor, offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsList(offset = offset, isDeployed = isDeployed, limit = limit, orderBy = orderBy, customModelType = customModelType, searchFor = searchFor))
}

#' PatchCustomModels
#'
#' Update custom model.
#'
#'  Updates metadata for an existing custom model.  All custom models must support at least one target type (binaryClassification, regression). Custom inference models can only support a single target type.  Setting `positiveClassLabel` and `negativeClassLabel` to null will set the labels to their default values (1 and 0 for positiveClassLabel and negativeClassLabel, respectively).  Setting `positiveClassLabel`, `negativeClassLabel`, 'targetName` is disabled if model has active deployments or assigned training data.
#'
#' @seealso The method CustomModelsPatch in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchCustomModels <- function(networkEgressPolicy, negativeClassLabel, targetName, replicas, maximumMemory, description, language, requiresHa, classLabels, customModelId, name, positiveClassLabel, desiredMemory, predictionThreshold = 0.5, ...) {
  customModelUpdate <- datarobot.apicore::CustomModelUpdate$new(networkEgressPolicy = networkEgressPolicy, negativeClassLabel = negativeClassLabel, targetName = targetName, replicas = replicas, maximumMemory = maximumMemory, description = description, language = language, predictionThreshold = predictionThreshold, requiresHa = requiresHa, classLabels = classLabels, name = name, positiveClassLabel = positiveClassLabel, desiredMemory = desiredMemory, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsPatch(customModelUpdate = customModelUpdate, customModelId = customModelId))
}

#' CreateCustomModelsPredictionExplanationsInitialization
#'
#' Create a new prediction explanations initialization for custom model.
#'
#' Create a new prediction explanations initialization for custom model. This is a necessary prerequisite for generating prediction explanations.  .. minversion:: v2.23     DEPRECATED please use custom model version route instead:     :http:post:`/api/v2/customModels/(customModelId)/versions/(customModelVersionId)/predictionExplanationsInitialization/`
#'
#' @seealso The method CustomModelsPredictionExplanationsInitializationCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsPredictionExplanationsInitialization <- function(environmentId, customModelId, environmentVersionId, customModelVersionId, ...) {
  customModelPredictionExplanations <- datarobot.apicore::CustomModelPredictionExplanations$new(environmentId = environmentId, customModelId = customModelId, environmentVersionId = environmentVersionId, customModelVersionId = customModelVersionId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsPredictionExplanationsInitializationCreate(customModelPredictionExplanations = customModelPredictionExplanations))
}

#' RetrieveCustomModels
#'
#' Get custom model.
#'
#' Retrieve metadata for a custom model.
#'
#' @seealso The method CustomModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveCustomModels <- function(customModelId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsRetrieve(customModelId = customModelId))
}

#' PatchManyCustomModelsTrainingData
#'
#' Assign training data to custom model.
#'
#' Assigns training data from provided dataset to provided Custom Inference Model. For each of custom model's deployments the training data from the specified project is used as baseline, this will enable turning drift tracking on for those deployments.
#'
#' @seealso The method CustomModelsTrainingDataPatchMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchManyCustomModelsTrainingData <- function(customModelId, partitionColumn, datasetId, datasetVersionId, ...) {
  trainingDataAssignment <- datarobot.apicore::TrainingDataAssignment$new(partitionColumn = partitionColumn, datasetId = datasetId, datasetVersionId = datasetVersionId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsTrainingDataPatchMany(customModelId = customModelId, trainingDataAssignment = trainingDataAssignment))
}

#' CreateFromLatestCustomModelsVersion
#'
#' Update custom model version files.
#'
#' Create a new custom model version with files added, replaced or deleted. Files from the previous version of a custom models will be used as a basis.
#'
#' @seealso The method CustomModelsVersionCreateFromLatest in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateFromLatestCustomModelsVersion <- function(requiredMetadata, networkEgressPolicy, requiresHa, file, baseEnvironmentId, customModelId, replicas, filePath, maximumMemory, filesToDelete, requiredMetadataValues, desiredMemory, isMajorUpdate = "true", ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionCreateFromLatest(requiredMetadata = requiredMetadata, networkEgressPolicy = networkEgressPolicy, requiresHa = requiresHa, file = file, isMajorUpdate = isMajorUpdate, baseEnvironmentId = baseEnvironmentId, customModelId = customModelId, replicas = replicas, filePath = filePath, maximumMemory = maximumMemory, filesToDelete = filesToDelete, requiredMetadataValues = requiredMetadataValues, desiredMemory = desiredMemory))
}

#' CreateCustomModelsVersionsConversions
#'
#' Generates JAR file from particular files.
#'
#' Converts files in the given custom model version to a JAR file.
#'
#' @seealso The method CustomModelsVersionsConversionsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersionsConversions <- function(customModelId, mainProgramItemId, customModelVersionId, ...) {
  conversionCreateQuery <- datarobot.apicore::ConversionCreateQuery$new(mainProgramItemId = mainProgramItemId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsConversionsCreate(customModelId = customModelId, conversionCreateQuery = conversionCreateQuery, customModelVersionId = customModelVersionId))
}

#' DeleteCustomModelsVersionsConversions
#'
#' Stop a given custom model conversion.
#'
#' Stop a running conversion for given model and model version.
#'
#' @seealso The method CustomModelsVersionsConversionsDelete in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DeleteCustomModelsVersionsConversions <- function(customModelId, conversionId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsConversionsDelete(customModelId = customModelId, conversionId = conversionId, customModelVersionId = customModelVersionId))
}

#' ListCustomModelsVersionsConversions
#'
#' Get a list or latest custom model conversion(s).
#'
#' Get the list of custom model conversions that are associated with the given custom model. Alternatively, it can return a single item list of the latest custom model conversion that is associated with the given custom model version.
#'
#' @seealso The method CustomModelsVersionsConversionsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersionsConversions <- function(customModelId, customModelVersionId, isLatest = "false", offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsConversionsList(isLatest = isLatest, offset = offset, customModelId = customModelId, limit = limit, customModelVersionId = customModelVersionId))
}

#' RetrieveCustomModelsVersionsConversions
#'
#' Get a given custom model conversion.
#'
#' Get a given custom model conversion.
#'
#' @seealso The method CustomModelsVersionsConversionsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveCustomModelsVersionsConversions <- function(customModelId, conversionId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsConversionsRetrieve(customModelId = customModelId, conversionId = conversionId, customModelVersionId = customModelVersionId))
}

#' CreateCustomModelsVersions
#'
#' Create custom model version.
#'
#' Create a new custom model version with attached files if supplied.
#'
#' @seealso The method CustomModelsVersionsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersions <- function(requiredMetadata, networkEgressPolicy, requiresHa, file, baseEnvironmentId, customModelId, replicas, filePath, maximumMemory, requiredMetadataValues, desiredMemory, isMajorUpdate = "true", ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsCreate(requiredMetadata = requiredMetadata, networkEgressPolicy = networkEgressPolicy, requiresHa = requiresHa, file = file, baseEnvironmentId = baseEnvironmentId, isMajorUpdate = isMajorUpdate, customModelId = customModelId, replicas = replicas, filePath = filePath, maximumMemory = maximumMemory, requiredMetadataValues = requiredMetadataValues, desiredMemory = desiredMemory))
}

#' CreateCustomModelsVersionsDependencyBuild
#'
#' Start a custom model version's dependency build.
#'
#' Start a custom model version's dependency build. This is required to test, deploy, or train custom models.
#'
#' @seealso The method CustomModelsVersionsDependencyBuildCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersionsDependencyBuild <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsDependencyBuildCreate(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' DeleteManyCustomModelsVersionsDependencyBuild
#'
#' Cancel dependency build.
#'
#' Cancel the custom model version's dependency build.
#'
#' @seealso The method CustomModelsVersionsDependencyBuildDeleteMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DeleteManyCustomModelsVersionsDependencyBuild <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsDependencyBuildDeleteMany(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' ListCustomModelsVersionsDependencyBuild
#'
#' Retrieve the custom model version's dependency build status.
#'
#' Retrieve the custom model version's dependency build status.
#'
#' @seealso The method CustomModelsVersionsDependencyBuildList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersionsDependencyBuild <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsDependencyBuildList(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' ListCustomModelsVersionsDependencyBuildLog
#'
#' Retrieve the custom model version's dependency build log.
#'
#' Retrieve the custom model version's dependency build log.
#'
#' @seealso The method CustomModelsVersionsDependencyBuildLogList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersionsDependencyBuildLog <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsDependencyBuildLogList(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' ListCustomModelsVersionsDownload
#'
#' Download custom model version content.
#'
#' Download a specific item bundle from a custom model as a zip compressed archive.
#'
#' @seealso The method CustomModelsVersionsDownloadList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersionsDownload <- function(customModelId, customModelVersionId, pps = "False", ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsDownloadList(pps = pps, customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' CreateCustomModelsVersionsFeatureImpact
#'
#' Create custom model feature impact.
#'
#' Add a request to calculate feature impact for a custom inference model image to             the queue.  This route is a counterpart of a corresponding endpoint for native models: :http:post:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`
#'
#' @seealso The method CustomModelsVersionsFeatureImpactCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersionsFeatureImpact <- function(backtest, customModelId, rowCount, customModelVersionId, ...) {
  featureImpactCreatePayload <- datarobot.apicore::FeatureImpactCreatePayload$new(backtest = backtest, rowCount = rowCount, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsFeatureImpactCreate(featureImpactCreatePayload = featureImpactCreatePayload, customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' ListCustomModelsVersionsFeatureImpact
#'
#' Get custom model feature impact.
#'
#' Retrieve feature impact scores for features in a custom inference model image.   This route is a counterpart of a corresponding endpoint for native models: :http:get:`/api/v2/projects/(projectId)/models/(modelId)/featureImpact/`
#'
#' @seealso The method CustomModelsVersionsFeatureImpactList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersionsFeatureImpact <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsFeatureImpactList(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' CreateCustomModelsVersionsFromRepository
#'
#' Create custom model version from remote repository.
#'
#' Create a new custom model version with only files added from the specified remote repository.
#'
#' @seealso The method CustomModelsVersionsFromRepositoryCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersionsFromRepository <- function(requiredMetadata, ref, baseEnvironmentId, customModelId, repositoryId, requiredMetadataValues, sourcePath, isMajorUpdate = TRUE, ...) {
  customModelVersionCreateFromRepository <- datarobot.apicore::CustomModelVersionCreateFromRepository$new(requiredMetadata = requiredMetadata, ref = ref, isMajorUpdate = isMajorUpdate, baseEnvironmentId = baseEnvironmentId, repositoryId = repositoryId, requiredMetadataValues = requiredMetadataValues, sourcePath = sourcePath, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsFromRepositoryCreate(customModelVersionCreateFromRepository = customModelVersionCreateFromRepository, customModelId = customModelId))
}

#' PatchManyCustomModelsVersionsFromRepository
#'
#' Create custom model version from remote repository with files from previous version.
#'
#' Create a new custom model version with files added from a remote repository. Files from the previous version of a custom models will be used as a basis.
#'
#' @seealso The method CustomModelsVersionsFromRepositoryPatchMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchManyCustomModelsVersionsFromRepository <- function(requiredMetadata, ref, baseEnvironmentId, customModelId, repositoryId, requiredMetadataValues, sourcePath, isMajorUpdate = TRUE, ...) {
  customModelVersionCreateFromRepository <- datarobot.apicore::CustomModelVersionCreateFromRepository$new(requiredMetadata = requiredMetadata, ref = ref, isMajorUpdate = isMajorUpdate, baseEnvironmentId = baseEnvironmentId, repositoryId = repositoryId, requiredMetadataValues = requiredMetadataValues, sourcePath = sourcePath, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsFromRepositoryPatchMany(customModelVersionCreateFromRepository = customModelVersionCreateFromRepository, customModelId = customModelId))
}

#' ListCustomModelsVersions
#'
#' List custom model versions.
#'
#' List custom model versions.
#'
#' @seealso The method CustomModelsVersionsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomModelsVersions <- function(customModelId, offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsList(offset = offset, customModelId = customModelId, limit = limit))
}

#' PatchCustomModelsVersions
#'
#' Update custom model version.
#'
#' Edit metadata of a specific model version.
#'
#' @seealso The method CustomModelsVersionsPatch in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchCustomModelsVersions <- function(requiredMetadata, customModelId, description, requiredMetadataValues, customModelVersionId, ...) {
  customModelVersionMetadataUpdate <- datarobot.apicore::CustomModelVersionMetadataUpdate$new(requiredMetadata = requiredMetadata, description = description, requiredMetadataValues = requiredMetadataValues, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsPatch(customModelVersionMetadataUpdate = customModelVersionMetadataUpdate, customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' CreateCustomModelsVersionsPredictionExplanationsInitialization
#'
#' Create a new prediction explanations initialization for custom model version.
#'
#' Create a new prediction explanations initialization for custom model version. This is a necessary prerequisite for generating prediction explanations.
#'
#' @seealso The method CustomModelsVersionsPredictionExplanationsInitializationCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomModelsVersionsPredictionExplanationsInitialization <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsPredictionExplanationsInitializationCreate(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' RetrieveCustomModelsVersions
#'
#' Get custom model version.
#'
#' Display a requested version of a custom model along with the files attached to it.
#'
#' @seealso The method CustomModelsVersionsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveCustomModelsVersions <- function(customModelId, customModelVersionId, ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomModelsVersionsRetrieve(customModelId = customModelId, customModelVersionId = customModelVersionId))
}

#' CreateCustomTrainingBlueprints
#'
#' Create a blueprint from a single custom training estimator.
#'
#' This route creates a blueprint from a custom training estimator with an environment so that it can be trained via blueprint ID.
#'
#' @seealso The method CustomTrainingBlueprintsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateCustomTrainingBlueprints <- function(customModelVersionId, ...) {
  customTrainingBlueprintCreate <- datarobot.apicore::CustomTrainingBlueprintCreate$new(customModelVersionId = customModelVersionId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$CustomTrainingBlueprintsCreate(customTrainingBlueprintCreate = customTrainingBlueprintCreate))
}

#' ListCustomTrainingBlueprints
#'
#' List training blueprints.
#'
#' List custom training blueprints.  This route retrieves the metadata for all custom training blueprints             a user has access to.
#'
#' @seealso The method CustomTrainingBlueprintsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListCustomTrainingBlueprints <- function(customModelId, targetTypes, offset = 0, limit = 1000, reverse = "False", ...) {
  return(datarobot.apicore::ModelsApi$new()$CustomTrainingBlueprintsList(offset = offset, customModelId = customModelId, limit = limit, reverse = reverse, targetTypes = targetTypes))
}

#' CreateModelExports
#'
#' Create model export job
#'
#' Create model export job. Note: Export of User and Open-Source models (and blenders including these models) is not supported at the moment.
#'
#' @seealso The method ModelExportsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateModelExports <- function(percentile, modelId, projectId, ...) {
  modelExport <- datarobot.apicore::ModelExport$new(percentile = percentile, modelId = modelId, projectId = projectId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ModelExportsCreate(modelExport = modelExport))
}

#' CreateModelPackagesArchive
#'
#' Archive a model package.
#'
#' Permanently archive a model package. It will no longer be able to be used in new deployments or replacement. It will not be accessible in the model package list api. It will only be accessible at the model package retrieve route for this model package.
#'
#' @seealso The method ModelPackagesArchiveCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateModelPackagesArchive <- function(modelPackageId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesArchiveCreate(modelPackageId = modelPackageId))
}

#' ListModelPackagesFeatures
#'
#' Retrieve feature list.
#'
#' Retrieve the feature list for given model package.
#'
#' @seealso The method ModelPackagesFeaturesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModelPackagesFeatures <- function(search, orderBy, modelPackageId, offset = 0, includeNonPredictionFeatures = "false", limit = 50, forSegmentedAnalysis = "false", ...) {
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesFeaturesList(search = search, offset = offset, includeNonPredictionFeatures = includeNonPredictionFeatures, limit = limit, orderBy = orderBy, forSegmentedAnalysis = forSegmentedAnalysis, modelPackageId = modelPackageId))
}

#' CreateModelPackagesFromLearningModel
#'
#' Create model package from DataRobot model.
#'
#' Create model package from DataRobot model.
#'
#' @seealso The method ModelPackagesFromLearningModelCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateModelPackagesFromLearningModel <- function(predictionThreshold, modelId, name = "null", ...) {
  modelPackageCreateFromLearningModel <- datarobot.apicore::ModelPackageCreateFromLearningModel$new(predictionThreshold = predictionThreshold, modelId = modelId, name = name, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesFromLearningModelCreate(modelPackageCreateFromLearningModel = modelPackageCreateFromLearningModel))
}

#' ListModelPackages
#'
#' List model packages
#'
#' Retrieve the list of model packages a user has access to.
#'
#' @seealso The method ModelPackagesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModelPackages <- function(predictionThreshold, forChallenger, search, modelId, imported, predictionEnvironmentId, similarTo, modelKind, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesList(predictionThreshold = predictionThreshold, forChallenger = forChallenger, search = search, offset = offset, modelId = modelId, imported = imported, limit = limit, predictionEnvironmentId = predictionEnvironmentId, similarTo = similarTo, modelKind = modelKind))
}

#' RetrieveModelPackages
#'
#' Retrieve info about a model package.
#'
#' Retrieve info about a model package.
#'
#' @seealso The method ModelPackagesRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveModelPackages <- function(modelPackageId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesRetrieve(modelPackageId = modelPackageId))
}

#' ListModelPackagesSharedRoles
#'
#' Get model package's access control list
#'
#' Get a list of users, groups and organizations who have access to this template and their roles on the template.
#'
#' @seealso The method ModelPackagesSharedRolesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModelPackagesSharedRoles <- function(shareRecipientType, name, id, modelPackageId, offset = 0, limit = 10, ...) {
  return(datarobot.apicore::ModelsApi$new()$ModelPackagesSharedRolesList(shareRecipientType = shareRecipientType, offset = offset, name = name, limit = limit, id = id, modelPackageId = modelPackageId))
}

#' CreateProjectsBlenderBuilders
#'
#' Create blenders using the blender builder system.
#'
#' Create a blender builder job, which will create one or more blenders.  The CORRELATION     method uses a combination of model accuracy score along with correlation between models to     select models for blending.  The VALIDATION method uses the raw model accuracy scores, but     can be useful for creating different types of blenders with those models.
#'
#' @seealso The method ProjectsBlenderBuildersCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateProjectsBlenderBuilders <- function(models, blendMethods, heuristic, correlationWeight, projectId, topN, maxModels, ...) {
  baseBlenderBuilderCreate <- datarobot.apicore::BaseBlenderBuilderCreate$new(models = models, blendMethods = blendMethods, heuristic = heuristic, correlationWeight = correlationWeight, topN = topN, maxModels = maxModels, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsBlenderBuildersCreate(baseBlenderBuilderCreate = baseBlenderBuilderCreate, projectId = projectId))
}

#' ListProjectsBlenderBuilders
#'
#' Get information about all blender builder jobs associated with the project.
#'
#' Get information about all blender builder jobs associated with the project.
#'
#' @seealso The method ProjectsBlenderBuildersList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsBlenderBuilders <- function(projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsBlenderBuildersList(offset = offset, limit = limit, projectId = projectId))
}

#' RetrieveProjectsBlenderBuilders
#'
#' Get information about a completed blender builder job.
#'
#' Get information about a completed blender builder job.
#'
#' @seealso The method ProjectsBlenderBuildersRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveProjectsBlenderBuilders <- function(buildId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsBlenderBuildersRetrieve(buildId = buildId, projectId = projectId))
}

#' IsBlenderEligible
#'
#' Check if models can be blended.
#'
#' Check if models can be blended.
#'
#' @seealso The method ProjectsBlenderModelsBlendCheckCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
IsBlenderEligible <- function(project, modelIds, blendMethod, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "blenderModels", "blendCheck")
  body <- list(modelIds = modelIds, blenderMethod = blendMethod)
  # start of generated addition
  # end of generated addition
  response <- DataRobotPOST(routeString, body = body, encode = "json")
  ApplySchema(response, c("reason", "blendable"))
}

#' RequestBlender
#'
#' Create a blender from other models using a specified blender method.
#'
#' Create a blender from other models using a specified blender method. Note: Time Series projects only allow the following blender methods: \"AVG\", \"MED\", \"FORECAST_DISTANCE_ENET\", and \"FORECAST_DISTANCE_AVG\".
#'
#' @seealso The method ProjectsBlenderModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestBlender <- function(project, modelsToBlend, blendMethod, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "blenderModels")
  body <- list(modelIds = I(modelsToBlend), blenderMethod = blendMethod)
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  message("New blender request received")
  JobIdFromResponse(postResponse)
}

#' ListProjectsBlenderModels
#'
#' List all blenders in a project.
#'
#' List all blenders in a project.
#'
#' @seealso The method ProjectsBlenderModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsBlenderModels <- function(projectId, offset = 0, limit = 0, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsBlenderModelsList(offset = offset, limit = limit, projectId = projectId))
}

#' GetBlenderModel
#'
#' Retrieve a blender.
#'
#' Retrieve a blender. Blenders are a special type of models, so the response includes all attributes that would be in a response to :http:get:`/api/v2/projects/(projectId)/models/(modelId)/` as well as some additional ones.
#'
#' @seealso The method ProjectsBlenderModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetBlenderModel <- function(project, modelId, ...) {

  # Fail if modelId is an empty string
  if (modelId == "") {
    stop("Invalid modelId specified")
  } else {
    projectId <- ValidateProject(project)
    fullProject <- GetProject(projectId)
    projectName <- fullProject$projectName
    projectTarget <- fullProject$target
    projectMetric <- fullProject$metric
    routeString <- UrlJoin("projects", projectId, "blenderModels", modelId)
    # start of generated addition
    # end of generated addition
    modelDetails <- DataRobotGET(routeString)
    listNames <- names(modelDetails)
    modelDetails$metrics <- ReformatMetrics(modelDetails$metrics)
    modelDetails$projectName <- projectName
    modelDetails$projectTarget <- projectTarget
    modelDetails$projectMetric <- projectMetric
    if (length(modelDetails$processes) == 0) {
      modelDetails$processes <- character(0)
    }
    as.dataRobotBlenderModel(modelDetails)
  }
}

#' ListProjectsCombinedModels
#'
#' Retrieve all existing combined models for this project.
#'
#' Retrieve all existing combined models for this project. .. note::      To retrieve information on the segments for a combined model, retrieve the combined model using :http:get:`/api/v2/projects/(projectId)/combinedModels/(combinedModelId)/`
#'
#' @seealso The method ProjectsCombinedModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsCombinedModels <- function(projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsCombinedModelsList(offset = offset, limit = limit, projectId = projectId))
}

#' RetrieveProjectsCombinedModels
#'
#' Retrieve an existing combined model.
#'
#' Retrieve an existing combined model. If available, contains information on which champion model is used for each segment.
#'
#' @seealso The method ProjectsCombinedModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveProjectsCombinedModels <- function(combinedModelId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsCombinedModelsRetrieve(combinedModelId = combinedModelId, projectId = projectId))
}

#' ListProjectsCombinedModelsSegmentsDownload
#'
#' Download Combined Model segments info.
#'
#' Download Combined Model segments info (name, related project & model details) as a CSV.
#'
#' @seealso The method ProjectsCombinedModelsSegmentsDownloadList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsCombinedModelsSegmentsDownload <- function(combinedModelId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsCombinedModelsSegmentsDownloadList(combinedModelId = combinedModelId, projectId = projectId))
}

#' ListProjectsCombinedModelsSegments
#'
#' Retrieve Combined Model segments info.
#'
#' Retrieve Combined Model segments info (name, related project & model details).
#'
#' @seealso The method ProjectsCombinedModelsSegmentsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsCombinedModelsSegments <- function(combinedModelId, searchSegmentName, projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsCombinedModelsSegmentsList(offset = offset, combinedModelId = combinedModelId, searchSegmentName = searchSegmentName, limit = limit, projectId = projectId))
}


#' RequestNewDatetimeModel
#'
#' Train a new datetime model.
#'
#' Train a new datetime model.  All durations and datetimes should be specified in accordance with the :ref:`timestamp and duration formatting rules<time_format>`.
#'
#' @seealso The method ProjectsDatetimeModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestNewDatetimeModel <- function(project, blueprint, featurelist = NULL, trainingRowCount = NULL, trainingDuration = NULL, timeWindowSamplePct = NULL, monotonicIncreasingFeaturelistId = NULL, monotonicDecreasingFeaturelistId = NULL, ...) {

  #
  #########################################################################
  #
  #  Sets up the creation of a new model in project, based on blueprint,
  #  both required parameters; additional optional parameters are
  #  featurelist, samplePct, and scoringType.  Note that blueprint is a
  #  list, which must contain the elements blueprintId and projectId.
  #  This function returns the integer-valued modelJobId, which can be
  #  used with the function GetModelFromJobId to retrieve the model once
  #  it has been built.
  #
  #########################################################################
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "datetimeModels")
  #
  #  Construct the body for the POST command
  #
  #  NOTE: if more than one parameter is to be passed in the body of the POST
  #        command, they are passed as an unboxed dataframe with
  #        encode = "json"; if only the required parameter blueprintID is
  #        to be passed, it is passed as a list without encode = "json"
  #
  #  Check whether blueprint$projectId differs from projectId.
  #  If so, need to specify sourceProjectId as value
  #  from blueprint list; since this is not usually the case,
  #  pre-specify secondProject = FALSE # nolint
  #
  blueprintId <- blueprint$blueprintId
  bodyFrame <- list(blueprintId = blueprintId)
  if (!identical(blueprint$projectId, projectId)) {
    bodyFrame$sourceProjectId <- blueprint$projectId
  }
  if (!is.null(featurelist)) {
    bodyFrame$featurelistId <- featurelist$featurelistId
  }
  if (!is.null(trainingRowCount)) {
    bodyFrame$trainingRowCount <- trainingRowCount
  }
  if (!is.null(trainingDuration)) {
    bodyFrame$trainingDuration <- trainingDuration
  }
  if (!is.null(timeWindowSamplePct)) {
    bodyFrame$timeWindowSamplePct <- timeWindowSamplePct
  }
  bodyFrame <- addMonotonicFeaturelist(
    bodyFrame,
    monotonicDecreasingFeaturelistId,
    "monotonicDecreasingFeaturelistId"
  )
  bodyFrame <- addMonotonicFeaturelist(
    bodyFrame,
    monotonicIncreasingFeaturelistId,
    "monotonicIncreasingFeaturelistId"
  )

  body <- if (length(bodyFrame) > 1) {
    lapply(bodyFrame, jsonlite::unbox)
  } else {
    list(blueprintId = bodyFrame$blueprintId)
  }

  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  message("New datetime model request received")
  JobIdFromResponse(postResponse)
}

#' CreateProjectsDatetimeModelsFromModel
#'
#' Retrain an existing datetime model with specified parameters.
#'
#' Retrain an existing datetime model using a new training period for the model training set (with optional time window sampling) or different feature list.  All durations and datetimes should be specified in accordance with the :ref:`timestamp and duration formatting rules<time_format>`.  Note that only one of `trainingDuration` or `trainingRowCount` or `trainingStartDate` and `trainingEndDate` should be specified. If `trainingStartDate` and `trainingEndDate` are specified, the source model must be frozen.
#'
#' @seealso The method ProjectsDatetimeModelsFromModelCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateProjectsDatetimeModelsFromModel <- function(timeWindowSamplePct, monotonicIncreasingFeaturelistId, monotonicDecreasingFeaturelistId, trainingDuration, trainingEndDate, trainingStartDate, modelId, trainingRowCount, samplingMethod, featurelistId, projectId, useProjectSettings, nClusters, ...) {
  retrainDatetimeModel <- datarobot.apicore::RetrainDatetimeModel$new(timeWindowSamplePct = timeWindowSamplePct, monotonicIncreasingFeaturelistId = monotonicIncreasingFeaturelistId, monotonicDecreasingFeaturelistId = monotonicDecreasingFeaturelistId, trainingDuration = trainingDuration, trainingEndDate = trainingEndDate, trainingStartDate = trainingStartDate, modelId = modelId, trainingRowCount = trainingRowCount, samplingMethod = samplingMethod, featurelistId = featurelistId, useProjectSettings = useProjectSettings, nClusters = nClusters, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsDatetimeModelsFromModelCreate(retrainDatetimeModel = retrainDatetimeModel, projectId = projectId))
}

#' ListProjectsDatetimeModels
#'
#' List datetime partitioned project models
#'
#' List all the models from a datetime partitioned project.
#'
#' @seealso The method ProjectsDatetimeModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsDatetimeModels <- function(bulkOperationId, projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsDatetimeModelsList(offset = offset, bulkOperationId = bulkOperationId, limit = limit, projectId = projectId))
}

#' GetDatetimeModel
#'
#' Get datetime model
#'
#' Look up a particular datetime model All durations and datetimes are specified in accordance with :ref:`timestamp and duration formatting rules <time_format>`.
#'
#' @seealso The method ProjectsDatetimeModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetDatetimeModel <- function(project, modelId, ...) {

  #  Fail if modelId is an empty string
  if (modelId == "") {
    stop("modelId must not be blank")
  } else {
    projectId <- ValidateProject(project)
    fullProject <- GetProject(projectId)
    routeString <- UrlJoin("projects", projectId, "datetimeModels", modelId)
    # start of generated addition
    # end of generated addition
    modelDetails <- DataRobotGET(routeString)
    #
    #  Request successful - extract data from $content element of
    #  Reformat results: (1) change name "id" to "modelId";
    #  (2) reformat $metrics list component to replace NULL
    #  representation of missing values with NA
    #
    #  Also, add projectName, projectTarget, and projectMetric
    #
    #  NOTE: if the $processes list is empty, it is represented
    #        as an empty list rather than an empty character vector,
    #        while ListModels returns an empty character vector
    #        for this case; for compatibility, check
    #        for this case and reformat if detected
    #
    names(modelDetails)[names(modelDetails) == "id"] <- "modelId"
    modelDetails$metrics <- ReformatMetrics(modelDetails$metrics)
    modelDetails$projectName <- fullProject$projectName
    modelDetails$projectTarget <- fullProject$target
    modelDetails$projectMetric <- fullProject$metric
    if (length(modelDetails$processes) == 0) {
      modelDetails$processes <- character(0)
    }
    modelDetails <- as.dataRobotDatetimeModel(modelDetails)
    class(modelDetails) <- "dataRobotDatetimeModel"
    modelDetails
  }
}

#' CreateProjectsDeploymentReadyModels
#'
#' Prepare a model for deployment
#'
#' Prepare a specific model for deployment. This model will go through the recommendation stages.
#'
#' @seealso The method ProjectsDeploymentReadyModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateProjectsDeploymentReadyModels <- function(modelId, projectId, ...) {
  prepareForDeployment <- datarobot.apicore::PrepareForDeployment$new(modelId = modelId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsDeploymentReadyModelsCreate(prepareForDeployment = prepareForDeployment, projectId = projectId))
}

#' RetrieveProjectsEureqaDistributionPlot
#'
#' Retrieve Eureqa model details plot.
#'
#' Retrieve Eureqa model details plot.  Available for classification projects only
#'
#' @seealso The method ProjectsEureqaDistributionPlotRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveProjectsEureqaDistributionPlot <- function(solutionId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsEureqaDistributionPlotRetrieve(solutionId = solutionId, projectId = projectId))
}

#' RetrieveProjectsEureqaModelDetail
#'
#' Retrieve Eureqa model details plot.
#'
#' Retrieve Eureqa model details plot.  Available for regression projects only
#'
#' @seealso The method ProjectsEureqaModelDetailRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RetrieveProjectsEureqaModelDetail <- function(solutionId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsEureqaModelDetailRetrieve(solutionId = solutionId, projectId = projectId))
}

#' AddEureqaSolution
#'
#' Create a new model from an existing eureqa solution.
#'
#' Create a new model from an existing eureqa solution.
#'
#' @seealso The method ProjectsEureqaModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
AddEureqaSolution <- function(project, eureqaSolutionId, ...) {
  project <- ValidateProject(project)
  routeString <- UrlJoin("projects", project, "eureqaModels")
  body <- list(solutionId = eureqaSolutionId)
  # start of generated addition
  # end of generated addition
  DataRobotPOST(routeString, body = body)
  message("Solution added")
  invisible(NULL)
}




#' ListProjectsFrozenModels
#'
#' List all frozen models from a project.
#'
#' List all frozen models from a project.
#'
#' @seealso The method ProjectsFrozenModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsFrozenModels <- function(withMetric, projectId, offset = 0, limit = 0, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsFrozenModelsList(offset = offset, withMetric = withMetric, limit = limit, projectId = projectId))
}

#' GetFrozenModel
#'
#' Look up a particular frozen model.
#'
#' Look up a particular frozen model. If model with given ID exists but it's not frozen, returns 404 Not Found.
#'
#' @seealso The method ProjectsFrozenModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetFrozenModel <- function(project, modelId, ...) {

  #  Fail if modelId is an empty string
  if (modelId == "") {
    stop("modelId must not be blank")
  } else {
    projectId <- ValidateProject(project)
    fullProject <- GetProject(projectId)
    projectName <- fullProject$projectName
    projectTarget <- fullProject$target
    projectMetric <- fullProject$metric
    routeString <- UrlJoin("projects", projectId, "frozenModels", modelId)
    # start of generated addition
    # end of generated addition
    modelDetails <- DataRobotGET(routeString)
    #
    #  Request successful - extract data from $content element of
    #  Reformat results: (1) change name "id" to "modelId";
    #  (2) reformat $metrics list component to replace NULL
    #  representation of missing values with NA
    #
    #  Also, add projectName, projectTarget, and projectMetric
    #
    #  NOTE: if the $processes list is empty, it is represented
    #        as an empty list rather than an empty character vector,
    #        while ListModels returns an empty character vector
    #        for this case; for compatibility, check
    #        for this case and reformat if detected
    #
    modelDetails$metrics <- ReformatMetrics(modelDetails$metrics)
    modelDetails$projectName <- projectName
    modelDetails$projectTarget <- projectTarget
    modelDetails$projectMetric <- projectMetric
    if (length(modelDetails$processes) == 0) {
      modelDetails$processes <- character(0)
    }
    as.dataRobotFrozenModel(modelDetails)
  }
}

#' DeleteModelJob
#'
#' Cancel a modeling job.
#'
#' Cancel a modeling job
#'
#' @seealso The method ProjectsModelJobsDelete in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DeleteModelJob <- function(project, modelJobId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "modelJobs", modelJobId)
  # start of generated addition
  # end of generated addition
  response <- DataRobotDELETE(routeString)
  message(paste("Job", modelJobId, "deleted from project", projectId))
}

#' ListModelJobs
#'
#' List modeling jobs
#'
#' List modeling jobs.
#'
#' @seealso The method ProjectsModelJobsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModelJobs <- function(project, status = NULL, ...) {
  projectId <- ValidateProject(project)
  query <- if (is.null(status)) NULL else list(status = status)
  routeString <- UrlJoin("projects", projectId, "modelJobs")
  # start of generated addition
  # end of generated addition
  pendingList <- DataRobotGET(routeString, query = query)
  if (length(pendingList) == 0) {
    data.frame(
      status = character(0), processes = I(list()), projectId = character(0),
      modelId = character(0), samplePct = numeric(0), modelType = character(0),
      featurelistId = character(0), modelCategory = character(0),
      blueprintId = character(0), modelJobId = character(0),
      trainingRowCount = numeric(0), isBlocked = logical(0)
    )
  } else {
    as.dataRobotModelJob(pendingList)
  }
}

#' GetModelJob
#'
#' Look up a specific modeling job
#'
#' Look up a particular modeling job
#'
#' @seealso The method ProjectsModelJobsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetModelJob <- function(project, modelJobId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "modelJobs", modelJobId)
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, followLocation = FALSE)
  as.dataRobotModelJob(response)
}



#' ListProjectsModelsClusterNames
#'
#' Retrieve cluster names assigned to an unsupervised cluster model
#'
#' Retrieve all cluster names assigned to an unsupervised cluster model
#'
#' @seealso The method ProjectsModelsClusterNamesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsModelsClusterNames <- function(modelId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsClusterNamesList(modelId = modelId, projectId = projectId))
}

#' PatchManyProjectsModelsClusterNames
#'
#' Update cluster names assigned to an unsupervised cluster model
#'
#' Update and then retrieve all cluster names assigned to an unsupervised cluster model
#'
#' @seealso The method ProjectsModelsClusterNamesPatchMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PatchManyProjectsModelsClusterNames <- function(modelId, clusterNameMappings, projectId, ...) {
  clusterNamesUpdateParam <- datarobot.apicore::ClusterNamesUpdateParam$new(clusterNameMappings = clusterNameMappings, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsClusterNamesPatchMany(modelId = modelId, clusterNamesUpdateParam = clusterNamesUpdateParam, projectId = projectId))
}

#' RequestNewModel
#'
#' Train a new model
#'
#' Train a new model. To specify the amount of data to use to train the model, use either `samplePct` to express a percentage of the rows of the dataset to use or `trainingRowCount` to express the number of rows to use. If neither `samplePct` or `trainingRowCount` is specified, the model will be trained on the maximum available training data that can be used to train an in-memory model. For projects using smart sampling, samplePct and trainingRowCount will be interpreted as a percent or number of rows of the minority class.   When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64% of the data. Using actual integer row counts (or `project.max_training_rows`) avoids ambiguity around how many rows of data you want the model to use.
#'
#' @seealso The method ProjectsModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestNewModel <- function(project, blueprint, featurelist = NULL, samplePct = NULL, trainingRowCount = NULL, scoringType = NULL, monotonicIncreasingFeaturelistId = NULL, monotonicDecreasingFeaturelistId = NULL, ...) {

  #
  #########################################################################
  #
  #  Sets up the creation of a new model in project, based on blueprint,
  #  both required parameters; additional optional parameters are
  #  featurelist, samplePct, and scoringType.  Note that blueprint is a
  #  list, which must contain the elements blueprintId and projectId.
  #  This function returns the integer-valued modelJobId, which can be
  #  used with the function GetModelFromJobId to retrieve the model once
  #  it has been built.
  #
  #########################################################################
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models")
  #
  #  Construct the body for the POST command
  #
  #  NOTE: if more than one parameter is to be passed in the body of the POST
  #        command, they are passed as an unboxed dataframe with
  #        encode = "json"; if only the required parameter blueprintID is
  #        to be passed, it is passed as a list without encode = "json"
  #
  #  Check whether blueprint$projectId differs from projectId.
  #  If so, need to specify sourceProjectId as value
  #  from blueprint list; since this is not usually the case,
  #  pre-specify secondProject = FALSE # nolint
  #

  blueprintId <- blueprint$blueprintId
  bodyFrame <- list(blueprintId = blueprintId)
  if (!identical(blueprint$projectId, projectId)) {
    bodyFrame$sourceProjectId <- blueprint$projectId
  }
  if (!is.null(featurelist)) {
    bodyFrame$featurelistId <- featurelist$featurelistId
  }
  if (!is.null(samplePct)) {
    bodyFrame$samplePct <- samplePct
  }
  if (!is.null(trainingRowCount)) {
    bodyFrame$trainingRowCount <- trainingRowCount
  }
  if (!is.null(scoringType)) {
    bodyFrame$scoringType <- scoringType
  }
  bodyFrame <- addMonotonicFeaturelist(
    bodyFrame,
    monotonicDecreasingFeaturelistId,
    "monotonicDecreasingFeaturelistId"
  )
  bodyFrame <- addMonotonicFeaturelist(
    bodyFrame,
    monotonicIncreasingFeaturelistId,
    "monotonicIncreasingFeaturelistId"
  )
  body <- if (length(bodyFrame) > 1) {
    lapply(bodyFrame, jsonlite::unbox)
  } else {
    list(blueprintId = bodyFrame$blueprintId)
  }
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  message("New model request received")
  JobIdFromResponse(postResponse)
}




#' DownloadTransferableModel
#'
#' Download exported model
#'
#' Download exported model
#'
#' @seealso The method ProjectsModelsExportList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DownloadTransferableModel <- function(project, modelId, modelFile, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "export")
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, as = "file", filename = modelFile)
  invisible(NULL)
}


#' CreateProjectsModelsFromModel
#'
#' Retrain a model
#'
#' Retrain an existing model using a new sample size and/or feature list.When configuring retraining sample sizes for models in projects with large row counts, DataRobot recommends requesting sample sizes using integer row counts instead of percentages. This is because percentages map to many actual possible row counts and only one of which is the actual sample size for up to validation. For example, if a project has 199,408 rows and you request a 64% sample size, any number of rows between 126,625 rows and 128,618 rows maps to 64% of the data. Using actual integer row counts (or `project.max_training_rows`) avoids ambiguity around how many rows of data you want the model to use. Note that only one of `samplePct` or `trainingRowCount` should be specified.
#'
#' @seealso The method ProjectsModelsFromModelCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateProjectsModelsFromModel <- function(monotonicIncreasingFeaturelistId, monotonicDecreasingFeaturelistId, samplePct, scoringType, modelId, trainingRowCount, featurelistId, projectId, nClusters, ...) {
  retrainModel <- datarobot.apicore::RetrainModel$new(monotonicIncreasingFeaturelistId = monotonicIncreasingFeaturelistId, monotonicDecreasingFeaturelistId = monotonicDecreasingFeaturelistId, samplePct = samplePct, scoringType = scoringType, modelId = modelId, trainingRowCount = trainingRowCount, featurelistId = featurelistId, nClusters = nClusters, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsFromModelCreate(retrainModel = retrainModel, projectId = projectId))
}

#' ListModels
#'
#' List project models
#'
#' Lists all the models from a project.
#'
#' @seealso The method ProjectsModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModels <- function(project, orderBy = NULL, filter = NULL, bulkOperationId = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
  projectId <- ValidateProject(project)
  fullProject <- GetProject(projectId)
  routeString <- UrlJoin("projects", projectId, "models")
  if (length(orderBy) > 1) {
    orderBy <- paste0(orderBy, collapse = ",")
  }
  if (is.null(orderBy)) {
    orderBy <- "-metric"
  } else if (!is.character(orderBy)) {
    stop("`orderBy` must be a character vector.")
  }
  isStarred <- NULL
  if (!is.null(filter)) {
    if (!is.list(filter)) {
      stop("`filter` must be a list.")
    }
    if ("isStarred" %in% names(filter)) {
      if (isTRUE(filter$isStarred)) {
        isStarred <- "True"
      } else if (identical(filter$isStarred, FALSE)) {
        isStarred <- "False"
      } else {
        stop("`isStarred` must be logical (`TRUE` or `FALSE`).")
      }
    }
  }
  params <- list(
    "orderBy" = orderBy,
    "isStarred" = isStarred
  )
  for (i in seq_along(filter)) {
    if (names(filter)[[i]] != "isStarred") {
      params[[names(filter)[[i]]]] <- filter[[i]]
    }
  }
  # start of generated addition
  params <- get0("params", mode = "list", ifnotfound = list())
  params$bulkOperationId <- bulkOperationId
  params$name <- name
  params$samplePct <- samplePct
  params$withMetric <- withMetric
  params$isStarred <- isStarred
  # end of generated addition
  modelInfo <- DataRobotGET(routeString, simplify = FALSE, query = params)
  if (length(modelInfo) == 0) {
    if (is.null(filter)) {
      message("No models have been built yet in this project.")
    }
    returnList <- list()
  } else {
    modelInfo <- lapply(modelInfo, function(model) {
      model$projectName <- fullProject$projectName
      model$projectTarget <- fullProject$target
      model$projectMetric <- fullProject$metric
      model$metrics <- ReformatMetrics(model$metrics)
      model
    })
    returnList <- lapply(modelInfo, as.dataRobotModel)
  }
  currentModelJobs <- ListModelJobs(projectId)
  if (NROW(currentModelJobs) > 0) {
    message("Some models are still in progress")
  }
  class(returnList) <- c("listOfModels", "listSubclass")
  returnList
}

#' GetMissingValuesReport
#'
#' Retrieve a summary of how the model's subtasks handle missing values.
#'
#' Retrieve a summary of how the model's subtasks handle missing values         Only models built after the missing value report feature was added will have reports,         and only models with at least one imputation or encoding task, e.g. ordinal encoding,         missing value imputation. Blenders and scaleout models do not support Missing Value reports.          The report will describe how each feature's missing values were treated, and report how many         missing values were present in the training data. Features which were not processed by a         given blueprint task will not mention it: for instance, a categorical feature with many         unique values may not be considered eligible for processing by a One-Hot Encoding          Report is collected for those features which are considered eligible by given         blueprint task. For instance, categorical feature with a lot of unique values may not be         considered as eligible in One-Hot Encoding task.
#'
#' @seealso The method ProjectsModelsMissingReportList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetMissingValuesReport <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  if (!is.character(modelId)) {
    stop("Invalid modelId")
  }
  routeString <- UrlJoin("projects", projectId, "models", modelId, "missingReport")
  # start of generated addition
  # end of generated addition
  result <- DataRobotGET(routeString, simplify = FALSE)
  as.dataRobotMissingValuesReport(result$missingValuesReport)
}

#' ListProjectsModelsNumIterationsTrained
#'
#' Get number of iterations trained
#'
#' Retrieve the actual number of iterations or estimators trained by a tree-based early stopping model.
#'
#' @seealso The method ProjectsModelsNumIterationsTrainedList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsModelsNumIterationsTrained <- function(modelId, projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsNumIterationsTrainedList(modelId = modelId, projectId = projectId))
}

#' GetModelParameters
#'
#' Retrieve model parameters.
#'
#' Retrieve model parameters. These are the parameters that appear in the webapp on the `Coefficients` tab. Note that they are only available for some models.
#'
#' @seealso The method ProjectsModelsParametersList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetModelParameters <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "parameters")
  # start of generated addition
  # end of generated addition
  params <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  as.dataRobotModelParameters(params)
}


#' CreateProjectsModelsPredictionIntervals
#'
#' Calculate prediction intervals for the specified percentiles for this model.
#'
#' Submit a job to calculate prediction intervals for the specified percentiles for this model.  Note that the project this model belongs to must be a time series project.
#'
#' @seealso The method ProjectsModelsPredictionIntervalsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateProjectsModelsPredictionIntervals <- function(percentiles, modelId, projectId, ...) {
  predictionIntervalsCreate <- datarobot.apicore::PredictionIntervalsCreate$new(percentiles = percentiles, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsPredictionIntervalsCreate(predictionIntervalsCreate = predictionIntervalsCreate, modelId = modelId, projectId = projectId))
}

#' ListProjectsModelsPredictionIntervals
#'
#' Retrieve prediction intervals that are already calculated for this model.
#'
#' Retrieve prediction intervals (in descending order) that are already calculated for this model. Note that the project this model belongs to must be a time series project.
#'
#' @seealso The method ProjectsModelsPredictionIntervalsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsModelsPredictionIntervals <- function(modelId, projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsModelsPredictionIntervalsList(offset = offset, modelId = modelId, limit = limit, projectId = projectId))
}

#' GetPrimeEligibility
#'
#' Check a Model for Prime Eligibility
#'
#' Check if a model can be approximated by DataRobot Prime
#'
#' @seealso The method ProjectsModelsPrimeInfoList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetPrimeEligibility <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "primeInfo")
  # start of generated addition
  # end of generated addition
  modelPrimeInfo <- DataRobotGET(routeString)
  as.dataRobotPrimeEligibility(modelPrimeInfo)
}

#' RequestApproximation
#'
#' Create Rulesets
#'
#' Approximate an existing model on the leaderboard with DataRobot Prime. A request body should be an empty JSON {}
#'
#' @seealso The method ProjectsModelsPrimeRulesetsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestApproximation <- function(project, modelId, body = NULL, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "primeRulesets")
  # start of generated addition
  body <- get0("body", mode = "list", ifnotfound = list())
  body$body <- body
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, returnRawResponse = TRUE, body = body)
  routeString <- UrlJoin("projects", projectId, "jobs", JobIdFromResponse(postResponse))
  jobsResponse <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  jobsResponse$id
}

#' GetRulesets
#'
#' List Rulesets
#'
#' List all the rulesets approximating a model  When rulesets are created for the parent model, all of the rulesets are created at once, but not all rulesets have corresponding Prime models (until they are directly requested).
#'
#' @seealso The method ProjectsModelsPrimeRulesetsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetRulesets <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "primeRulesets")
  # start of generated addition
  # end of generated addition
  getResponse <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  return(as.list(getResponse))
}

#' GetModel
#'
#' Get model
#'
#' Look up a particular model.
#'
#' @seealso The method ProjectsModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetModel <- function(project, modelId, ...) {

  #  Fail if modelId is an empty string
  if (modelId == "") {
    stop("modelId must not be blank")
  } else {
    projectId <- ValidateProject(project)
    fullProject <- GetProject(projectId)
    routeString <- UrlJoin("projects", projectId, "models", modelId)
    # start of generated addition
    # end of generated addition
    modelDetails <- DataRobotGET(routeString)
    #
    #  Request successful - extract data from $content element of
    #  Reformat results: (1) change name "id" to "modelId";
    #  (2) reformat $metrics list component to replace NULL
    #  representation of missing values with NA
    #
    #  Also, add projectName, projectTarget, and projectMetric
    #
    #  NOTE: if the $processes list is empty, it is represented
    #        as an empty list rather than an empty character vector,
    #        while ListModels returns an empty character vector
    #        for this case; for compatibility, check
    #        for this case and reformat if detected
    #

    names(modelDetails)[names(modelDetails) == "id"] <- "modelId"
    modelDetails$metrics <- ReformatMetrics(modelDetails$metrics)
    modelDetails$projectName <- fullProject$projectName
    modelDetails$projectTarget <- fullProject$target
    modelDetails$projectMetric <- fullProject$metric
    if (length(modelDetails$processes) == 0) {
      modelDetails$processes <- character(0)
    }
    as.dataRobotModel(modelDetails)
  }
}

#' DownloadScoringCode
#'
#' Retrieve Scoring Code
#'
#' Retrieve Scoring Code for making new predictions from an existing model offline. You need the \"Scoring Code\" feature enabled to use this route.  By default, returns a compiled executable JAR that can be executed locally to calculate model predictions, or it can be used as a library for a Java application. Execute it with the '--help` parameters to learn how to use it as a command-line utility. See model API documentation (https://javadoc.io/doc/com.datarobot/datarobot-prediction/latest/index.html) to be able to use it inside an existing Java application.  With the sourceCode query parameter set to 'true', returns a source code archive that can be used to review internal calculations of the model. This JAR is NOT executable.  See \"https://app.datarobot.com/docs/predictions/scoring-code/scorecode.html\" in DataRobot application for more information.
#'
#' @seealso The method ProjectsModelsScoringCodeList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DownloadScoringCode <- function(project, modelId, fileName, sourceCode = FALSE, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "models", modelId, "scoringCode")
  query <- list("sourceCode" = tolower(as.character(sourceCode)))
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, as = "file", filename = fileName, query = query)
  invisible(NULL)
}


#' CreatePrimeCode
#'
#' Create a Prime File
#'
#' Request creation and validation of source code from a Prime model
#'
#' @seealso The method ProjectsPrimeFilesCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreatePrimeCode <- function(project, primeModelId, language, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeFiles")
  body <- list(modelId = primeModelId, language = language)
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE)
  routeString <- UrlJoin("projects", projectId, "jobs", JobIdFromResponse(postResponse))
  jobsResponse <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  jobsResponse$id
}

#' DownloadPrimeCode
#'
#' Download Code
#'
#' Download code from an existing Prime file
#'
#' @seealso The method ProjectsPrimeFilesDownloadList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DownloadPrimeCode <- function(project, primeFileId, filepath, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeFiles", primeFileId, "download")
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, as = "file", filename = filepath)
  invisible(NULL)
}

#' ListPrimeFiles
#'
#' Get Prime Files
#'
#' List all DataRobot Prime files available for download
#'
#' @seealso The method ProjectsPrimeFilesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListPrimeFiles <- function(project, parentModelId = NULL, modelId = NULL, offset = 0, limit = 0, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeFiles")
  query <- list()
  if (!is.null(parentModelId)) {
    query$parentModelId <- parentModelId
  }
  if (!is.null(modelId)) {
    query$modelId <- modelId
  }
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$offset <- offset
  query$limit <- limit
  # end of generated addition
  response <- DataRobotGET(routeString, query = query, simplifyDataFrame = FALSE, encode = "json")
  response <- GetServerDataInRows(response)
  return(response)
}

#' GetPrimeFile
#'
#' Retrieve metadata about a DataRobot Prime file
#'
#' Retrieve metadata about a DataRobot Prime file available for download
#'
#' @seealso The method ProjectsPrimeFilesRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetPrimeFile <- function(project, primeFileId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeFiles", primeFileId)
  # start of generated addition
  # end of generated addition
  return(DataRobotGET(routeString))
}

#' RequestPrimeModel
#'
#' Create a Prime Model from a Ruleset
#'
#' Create a Prime model using a particular ruleset.  DataRobot Prime is not available for multiclass projects.  Once rulesets approximating a parent model have been created, using POST /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/, this route will allow creation of a Prime model using one of those rulesets.  Available rulesets can be retrieved via GET /api/v2/projects/(projectId)/models/(modelId)/primeRulesets/.
#'
#' @seealso The method ProjectsPrimeModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestPrimeModel <- function(project, ruleset, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeModels")
  parentModelId <- ruleset$parentModelId
  rulesetId <- ruleset$rulesetId
  bodyFrame <- data.frame(parentModelId = parentModelId, rulesetId = rulesetId)
  body <- jsonlite::unbox(bodyFrame)
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  routeString <- UrlJoin("projects", projectId, "jobs", JobIdFromResponse(postResponse))
  jobsResponse <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  jobsResponse$id
}

#' ListPrimeModels
#'
#' List all Prime models in a project
#'
#' List all Prime models in a project
#'
#' @seealso The method ProjectsPrimeModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListPrimeModels <- function(project, offset = 0, limit = 100, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeModels")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$offset <- offset
  query$limit <- limit
  # end of generated addition
  primeInfo <- DataRobotGET(routeString, query = query)
  primeInfo <- GetServerDataInRows(primeInfo)
  as.dataRobotPrimeModels(primeInfo)
}

#' GetPrimeModel
#'
#' Retrieve a Prime model details
#'
#' Retrieve a Prime model details
#'
#' @seealso The method ProjectsPrimeModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetPrimeModel <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "primeModels", modelId)
  # start of generated addition
  # end of generated addition
  primeInfo <- DataRobotGET(routeString)
  as.dataRobotPrimeModel(primeInfo)
}

#' RequestNewRatingTableModel
#'
#' Create New Models From A Rating Table
#'
#' Create a new rating table model from a validated rating table record
#'
#' @seealso The method ProjectsRatingTableModelsCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RequestNewRatingTableModel <- function(project, ratingTableId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTableModels")
  if (is(ratingTableId, "dataRobotRatingTable")) {
    ratingTableId <- ratingTableId$id
  }
  body <- list("ratingTableId" = ratingTableId)
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE)
  message("New model request from rating table received")
  JobIdFromResponse(postResponse)
}

#' ListRatingTableModels
#'
#' List Rating Table Models
#'
#' Lists all the models from a project that have rating tables
#'
#' @seealso The method ProjectsRatingTableModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListRatingTableModels <- function(project, bulkOperationId = NULL, orderBy = NULL, name = NULL, samplePct = NULL, withMetric = NULL, isStarred = NULL, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTableModels")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$bulkOperationId <- bulkOperationId
  query$orderBy <- orderBy
  query$name <- name
  query$samplePct <- samplePct
  query$withMetric <- withMetric
  query$isStarred <- isStarred
  # end of generated addition
  ratingTableModels <- DataRobotGET(routeString, simplifyDataFrame = FALSE, query = query)
  ratingTableModels <- lapply(ratingTableModels, as.dataRobotRatingTableModel)
  class(ratingTableModels) <- c("listOfRatingTableModels", "listOfModels", "listSubclass")
  ratingTableModels
}

#' GetRatingTableModel
#'
#' Retrieve Rating Table Model
#'
#' Look up a particular rating table model
#'
#' @seealso The method ProjectsRatingTableModelsRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetRatingTableModel <- function(project, modelId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTableModels", modelId)
  # start of generated addition
  # end of generated addition
  as.dataRobotRatingTableModel(DataRobotGET(routeString))
}

#' CreateRatingTable
#'
#' Upload Modified Rating Table File
#'
#' Create a new rating table from a rating table file This will create a new rating table, regardless of whether the validation succeeds. The rating table object will have a validationError which will be left blank in the case of successful validation.
#'
#' @seealso The method ProjectsRatingTablesCreate in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
CreateRatingTable <- function(project, parentModelId, dataSource, ratingTableName = "UploadedRatingTable", ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTables")
  body <- list(
    parentModelId = parentModelId,
    ratingTableName = ratingTableName,
    ratingTableFile = UploadData(dataSource)
  )
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE)
  JobIdFromResponse(postResponse)
}

#' DownloadRatingTable
#'
#' Retrieve Rating Table File
#'
#' Retrieve the CSV file for the rating table
#'
#' @seealso The method ProjectsRatingTablesFileList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
DownloadRatingTable <- function(project, ratingTableId, filename, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTables", ratingTableId, "file")
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, as = "file", filename = filename)
  invisible(NULL)
}

#' ListRatingTables
#'
#' List Rating Tables For The Project
#'
#' List RatingTable objects for a project.     These contain metadata about the rating table and the location at which the corresponding rating      table file can be retrieved.
#'
#' @seealso The method ProjectsRatingTablesList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListRatingTables <- function(project, parentModelId = NULL, modelId = NULL, offset = 0, limit = 0, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTables")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$parentModelId <- parentModelId
  query$modelId <- modelId
  query$offset <- offset
  query$limit <- limit
  # end of generated addition
  ratingTables <- DataRobotGET(routeString, simplifyDataFrame = FALSE, query = query)
  ratingTables <- GetServerDataInRows(ratingTables)
  ratingTables <- lapply(ratingTables, as.dataRobotRatingTable)
  class(ratingTables) <- c("listOfRatingTables", "listSubclass")
  ratingTables
}

#' RenameRatingTable
#'
#' Update an uploaded rating table
#'
#' Rating tables may only be updated if they have not yet been used to create a model.
#'
#' @seealso The method ProjectsRatingTablesPatch in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
RenameRatingTable <- function(project, ratingTableId, ratingTableName, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTables", ratingTableId)
  body <- list(ratingTableName = ratingTableName)
  # start of generated addition
  # end of generated addition
  ratingTable <- as.dataRobotRatingTable(DataRobotPATCH(routeString, body = body))
  WarnOnInvalidRatingTable(ratingTable)
  ratingTable
}

#' GetRatingTable
#'
#' Retrieve Rating Table Information
#'
#' Retrieves a rating table
#'
#' @seealso The method ProjectsRatingTablesRetrieve in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
GetRatingTable <- function(project, ratingTableId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "ratingTables", ratingTableId)
  # start of generated addition
  # end of generated addition
  ratingTable <- as.dataRobotRatingTable(DataRobotGET(routeString))
  WarnOnInvalidRatingTable(ratingTable)
  ratingTable
}

#' ListModelRecommendations
#'
#' List recommended models for the project
#'
#' Retrieves all of the current recommended models for the project
#'
#' @seealso The method ProjectsRecommendedModelsList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListModelRecommendations <- function(project, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "recommendedModels")
  # start of generated addition
  # end of generated addition
  modelRecommendations <- DataRobotGET(routeString, simplifyDataFrame = FALSE)
  modelRecommendations <- lapply(modelRecommendations, as.dataRobotModelRecommendation)
  class(modelRecommendations) <- c("listOfModelRecommendations", "listSubclass")
  modelRecommendations
}

#' ListProjectsRecommendedModelsRecommendedModel
#'
#' Get recommended model
#'
#' This route returns the simplest recommended model available. To see all the available recommended models, use :http:get:`/api/v2/projects/(projectId)/recommendedModels/`
#'
#' @seealso The method ProjectsRecommendedModelsRecommendedModelList in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
ListProjectsRecommendedModelsRecommendedModel <- function(projectId, ...) {
  return(datarobot.apicore::ModelsApi$new()$ProjectsRecommendedModelsRecommendedModelList(projectId = projectId))
}

#' PutManyProjectsSegmentChampion
#'
#' Update champion model for a segment project.
#'
#' Update champion model for a segment project.
#'
#' @seealso The method ProjectsSegmentChampionPutMany in [datarobot.apicore::ModelsApi], which this function wraps.
#' @family Models
#' @export
PutManyProjectsSegmentChampion <- function(modelId, projectId, ...) {
  segmentChampionModelUpdate <- datarobot.apicore::SegmentChampionModelUpdate$new(modelId = modelId, validateParams = TRUE)
  return(datarobot.apicore::ModelsApi$new()$ProjectsSegmentChampionPutMany(segmentChampionModelUpdate = segmentChampionModelUpdate, projectId = projectId))
}
