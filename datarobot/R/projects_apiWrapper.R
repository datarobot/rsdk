# Copyright 2021-2022 DataRobot, Inc. and its affiliates.
#
# All rights reserved.
#
# DataRobot, Inc.
#
# This is proprietary source code of DataRobot, Inc. and its
# affiliates.

# Public API
#
# DataRobot's Public facing API
#
# The version of the OpenAPI document: 2.29.0
# Contact: api-maintainer@datarobot.com
# Generated by: https://openapi-generator.tech


# NOTE: This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the file manually.

# API Wrapper methods for Projects
# To use these methods without modification, DR endpoint and token
# should be set as environment variables. This will automatically
# happen when you call `datarobot::ConnectToDataRobot()`.



#' ListProjectsAccessControl
#'
#' Get project's access control list
#'
#' Get a list of users who have access to this project and their roles on the project.
#' @details This method invokes `GET /projects/{projectId}/accessControl/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method AccessControlList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsAccessControl <- function(userId, projectId, username, offset = 0, limit = 0, ...) {
  return(datarobot.apicore::ProjectsApi$new()$AccessControlList(offset = offset, limit = limit, userId = userId, projectId = projectId, username = username, ...))
}

#' PatchManyProjectsAccessControl
#'
#' Update project's access controls
#'
#' Set roles for users on this project.
#' @details This method invokes `PATCH /projects/{projectId}/accessControl/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method AccessControlPatchMany in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PatchManyProjectsAccessControl <- function(data, projectId, sendNotification = TRUE, includeFeatureDiscoveryEntities = FALSE, ...) {
  sharingUpdateOrRemove <- datarobot.apicore::SharingUpdateOrRemove$new(data = data, sendNotification = sendNotification, includeFeatureDiscoveryEntities = includeFeatureDiscoveryEntities, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$AccessControlPatchMany(sharingUpdateOrRemove = sharingUpdateOrRemove, projectId = projectId, ...))
}

#' PauseQueue
#'
#' Pause or unpause Autopilot
#'
#' Pause or unpause the autopilot for a project.
#' @details This method invokes `POST /projects/{projectId}/autopilot/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method AutopilotCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PauseQueue <- function(project, command = NULL, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "autopilot")
  bodyList <- list(command = "stop")
  # start of generated addition
  bodyList <- get0("bodyList", mode = "list", ifnotfound = list())
  bodyList$autopilot <- get0("bodyList$autopilot", mode = "list", ifnotfound = list())

  bodyList$autopilot$command <- command
  # end of generated addition
  response <- DataRobotPOST(routeString, body = bodyList)
  message(paste("Queue for project", projectId, "paused"))
}

#' StartNewAutoPilot
#'
#' Start autopilot
#'
#' Start autopilot on provided featurelist.
#' @details This method invokes `POST /projects/{projectId}/autopilots/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method AutopilotsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
StartNewAutoPilot <- function(project, featurelistId, mode = AutopilotMode$FullAuto, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "autopilots")
  payload <- list(featurelistId = featurelistId, mode = mode)
  # start of generated addition
  # end of generated addition
  invisible(DataRobotPOST(routeString, body = payload))
}

#' BatchFeaturesTypeTransform
#'
#' Create multiple new features by changing the type of existing features.
#'
#' Create multiple new features by changing the type of existing features.
#' @details This method invokes `POST /projects/{projectId}/batchTypeTransformFeatures/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method BatchTypeTransformFeaturesCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
BatchFeaturesTypeTransform <- function(project, parentNames, variableType, prefix = NULL, suffix = NULL, maxWait = 600, ...) {
  project <- ValidateProject(project)
  if (!is.character(parentNames)) {
    stop(sQuote("parentNames"), " must be a character vector.")
  }
  ValidateParameterIn(variableType, VariableTransformTypes, allowNULL = FALSE)
  payload <- list(
    parentNames = as.list(parentNames),
    variableType = variableType
  )
  if (!is.null(prefix)) {
    payload$prefix <- prefix
  }
  if (!is.null(suffix)) {
    payload$suffix <- suffix
  }
  routeString <- UrlJoin("projects", project, "batchTypeTransformFeatures")
  body <- lapply(payload, Unbox)
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  WaitForAsyncReturn(GetRedirectFromResponse(postResponse),
    addUrl = FALSE,
    maxWait = maxWait,
    failureStatuses = "ERROR"
  )
  ListFeatureInfo(project)
}

#' RetrieveProjectsBatchTypeTransformFeaturesResult
#'
#' Retrieve the result of a batch variable type transformation.
#'
#' Retrieve the result of a batch variable type transformation.
#' @details This method invokes `GET /projects/{projectId}/batchTypeTransformFeaturesResult/{jobId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method BatchTypeTransformFeaturesResultRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsBatchTypeTransformFeaturesResult <- function(variableType, jobId, parentNames, prefix, suffix, projectId, ...) {
  batchFeatureTransform <- datarobot.apicore::BatchFeatureTransform$new(variableType = variableType, parentNames = parentNames, prefix = prefix, suffix = suffix, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$BatchTypeTransformFeaturesResultRetrieve(batchFeatureTransform = batchFeatureTransform, jobId = jobId, projectId = projectId, ...))
}

#' ListCalendarCountryCodes
#'
#' Retrieve the list of allowed country codes to request preloaded calendars generation for.
#'
#' Retrieve the list of allowed country codes to request preloaded calendars generation for.
#' @details This method invokes `GET /calendarCountryCodes/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarCountryCodesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListCalendarCountryCodes <- function(offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CalendarCountryCodesList(offset = offset, limit = limit, ...))
}

#' ListProjectsCalendarEvents
#'
#' List available calendar events for the project.
#'
#' List available calendar events for the project.
#' @details This method invokes `GET /projects/{projectId}/calendarEvents/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarEventsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsCalendarEvents <- function(endDate, projectId, startDate, seriesId, offset = 0, limit = 1000, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CalendarEventsList(offset = offset, endDate = endDate, limit = limit, projectId = projectId, startDate = startDate, seriesId = seriesId, ...))
}

#' ListCalendarsAccessControl
#'
#' Get a list of users who have access to this calendar and their roles on the calendar.
#'
#' Get a list of users who have access to this calendar and their roles on the calendar.
#' @details This method invokes `GET /calendars/{calendarId}/accessControl/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsAccessControlList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListCalendarsAccessControl <- function(calendarId, userId, username, offset = 0, limit = 0, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CalendarsAccessControlList(offset = offset, calendarId = calendarId, limit = limit, userId = userId, username = username, ...))
}

#' PatchManyCalendarsAccessControl
#'
#' Update the access control for this calendar.
#'
#' Update the access control for this calendar. See the entity sharing documentation \\<sharing\\> for more information.
#' @details This method invokes `PATCH /calendars/{calendarId}/accessControl/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsAccessControlPatchMany in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PatchManyCalendarsAccessControl <- function(calendarId, users, ...) {
  calendarAccessControlUpdate <- datarobot.apicore::CalendarAccessControlUpdate$new(users = users, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$CalendarsAccessControlPatchMany(calendarId = calendarId, calendarAccessControlUpdate = calendarAccessControlUpdate, ...))
}

#' DeleteCalendar
#'
#' Delete a calendar.
#'
#' Delete a calendar. This can only be done if all projects and deployments using the calendar have been deleted.
#' @details This method invokes `DELETE /calendars/{calendarId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsDelete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteCalendar <- function(calendarId, ...) {
  calendarId <- ValidateCalendar(calendarId)
  routeString <- UrlJoin("calendars", calendarId)
  # start of generated addition
  # end of generated addition
  DataRobotDELETE(routeString)
  invisible(NULL)
}

#' CreateCalendar
#'
#' Create a calendar from a file.
#'
#' Create a calendar from a file in a csv or xlsx format. The calendar file specifies the dates or events in a dataset such that DataRobot automatically derives and creates special features based on the calendar events (e.g., time until the next event, labeling the most recent event).
#' @details This method invokes `POST /calendars/fileUpload/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsFileUploadCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateCalendar <- function(dataSource, name = NULL, multiSeriesIdColumn = NULL, maxWait = 600, ...) {
  if (length(multiSeriesIdColumn) > 1) {
    stop("Only a single column can be used to define events.")
  }
  if (is.list(multiSeriesIdColumn)) {
    # take the first
    multiSeriesIdColumn <- multiSeriesIdColumn[[1]]
  }

  if (is.null(name)) {
    name <- dataSource
  }
  routeString <- UrlJoin("calendars", "fileUpload")
  body <- list(name = name, file = UploadData(dataSource))
  if (!is.null(multiSeriesIdColumn)) {
    # API expects a JSON array string like '["series_id"]' or nothing at all
    body$multiseriesIdColumns <- jsonlite::toJSON(multiSeriesIdColumn)
  }
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE)
  calendar <- WaitForAsyncReturn(GetRedirectFromResponse(postResponse),
    maxWait = maxWait,
    addUrl = FALSE,
    failureStatuses = TaskFailureStatuses
  )
  as.dataRobotCalendar(calendar)
}

#' CreateCalendarsFromCountryCode
#'
#' Initialize generation of preloaded calendars.
#'
#' Initialize generation of preloaded calendars. Preloaded calendars are available only for time series projects. Preloaded calendars do not support multiseries calendars.
#' @details This method invokes `POST /calendars/fromCountryCode/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsFromCountryCodeCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateCalendarsFromCountryCode <- function(endDate, countryCode, startDate, ...) {
  preloadedCalendar <- datarobot.apicore::PreloadedCalendar$new(endDate = endDate, countryCode = countryCode, startDate = startDate, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$CalendarsFromCountryCodeCreate(preloadedCalendar = preloadedCalendar, ...))
}

#' CreateCalendarsFromDataset
#'
#' Create a calendar from the dataset
#'
#' Create a calendar from the dataset.
#' @details This method invokes `POST /calendars/fromDataset/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsFromDatasetCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateCalendarsFromDataset <- function(name, deleteOnError, multiseriesIdColumns, datasetId, datasetVersionId, ...) {
  calendarFromDataset <- datarobot.apicore::CalendarFromDataset$new(name = name, deleteOnError = deleteOnError, multiseriesIdColumns = multiseriesIdColumns, datasetId = datasetId, datasetVersionId = datasetVersionId, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$CalendarsFromDatasetCreate(calendarFromDataset = calendarFromDataset, ...))
}

#' ListCalendars
#'
#' List all available calendars for a user.
#'
#' List all the calendars which the user has access to.
#' @details This method invokes `GET /calendars/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListCalendars <- function(offset = 0, limit = 0, projectId = NULL, ...) {

  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$offset <- offset
  query$limit <- limit
  query$projectId <- projectId
  # end of generated addition
  calendars <- DataRobotGET("calendars", simplifyDataFrame = FALSE, query = query)
  calendars <- GetServerDataInRows(calendars)
  calendars <- lapply(calendars, as.dataRobotCalendar)
  class(calendars) <- c("listOfCalendars", "listSubclass")
  calendars
}

#' UpdateCalendar
#'
#' Update a calendar's name
#'
#' Update a calendar's name
#' @details This method invokes `PATCH /calendars/{calendarId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsPatch in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
UpdateCalendar <- function(calendarId, name = NULL, ...) {
  calendarId <- ValidateCalendar(calendarId)
  routeString <- UrlJoin("calendars", calendarId)
  body <- list(name = name)
  # start of generated addition
  # end of generated addition
  DataRobotPATCH(routeString, body = body)
  GetCalendar(calendarId)
}

#' GetCalendar
#'
#' Retrieve information about a calendar.
#'
#' List all the information about a calendar such as the total number of event dates, the earliest calendar event date, the IDs of projects currently using this calendar and the others.
#' @details This method invokes `GET /calendars/{calendarId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CalendarsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetCalendar <- function(calendarId, ...) {
  routeString <- UrlJoin("calendars", calendarId)
  # start of generated addition
  # end of generated addition
  as.dataRobotCalendar(DataRobotGET(routeString))
}

#' CreateProjectCleanupJobs
#'
#' Schedule Project Permadelete Job
#'
#' Add list of projects to permadelete and returns async status
#' @details This method invokes `POST /projectCleanupJobs/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateProjectCleanupJobs <- function(deletedAfter, creator, organization, deletedBefore, projectIds, searchFor, offset = 0, limit = 1000, ...) {
  projectNuke <- datarobot.apicore::ProjectNuke$new(deletedAfter = deletedAfter, creator = creator, offset = offset, organization = organization, limit = limit, deletedBefore = deletedBefore, projectIds = projectIds, searchFor = searchFor, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsCreate(projectNuke = projectNuke, ...))
}

#' DeleteProjectCleanupJobs
#'
#' Cancel Scheduled Project Permadelete Job
#'
#' Stop permadelete job, if possible
#' @details This method invokes `DELETE /projectCleanupJobs/{statusId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsDelete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteProjectCleanupJobs <- function(statusId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsDelete(statusId = statusId, ...))
}

#' ListProjectCleanupJobsDownload
#'
#' Download a projects permadeletion report.
#'
#' Get a file containing a per-project report of permanent deletion.
#' @details This method invokes `GET /projectCleanupJobs/{statusId}/download/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsDownloadList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectCleanupJobsDownload <- function(statusId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsDownloadList(statusId = statusId, ...))
}

#' ListProjectCleanupJobs
#'
#' Retrieve Project Permadelete job status
#'
#' Get async status of the project permadelete job
#' @details This method invokes `GET /projectCleanupJobs/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectCleanupJobs <- function(...) {
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsList(...))
}

#' RetrieveProjectCleanupJobs
#'
#' Retrieve Project Permadelete job status
#'
#' Get async status of the project permadelete job
#' @details This method invokes `GET /projectCleanupJobs/{statusId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectCleanupJobs <- function(statusId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsRetrieve(statusId = statusId, ...))
}

#' ListProjectCleanupJobsSummary
#'
#' Get a projects cleanup jobs summary.
#'
#' Get number of projects whose deletion finished in particular state
#' @details This method invokes `GET /projectCleanupJobs/{statusId}/summary/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CleanupJobsSummaryList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectCleanupJobsSummary <- function(statusId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$CleanupJobsSummaryList(statusId = statusId, ...))
}

#' CloneProject
#'
#' Clone a project
#'
#' > Create a clone of an existing project. > > The resultant project will begin the initial exploratory data analysis > and will be ready to set the target of the new project shortly.
#' @details This method invokes `POST /projectClones/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ClonesCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CloneProject <- function(project, newProjectName = NULL, maxWait = 600, ...) {
  projectId <- ValidateProject(project)

  body <- list()
  body$projectId <- projectId
  body$projectName <- newProjectName
  routeString <- "projectClones/"
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, timeout = maxWait)
  message(paste(
    "Project clone of",
    project$id,
    "requested"
  ))
  clonedProject <- ProjectFromJobResponse(postResponse,
    maxWait = maxWait
  )
  message(sprintf(
    "Project %s '%s' created from original project %s",
    clonedProject$projectId,
    clonedProject$projectName,
    projectId
  ))
  as.dataRobotProjectShort(clonedProject)
}

#' SetTarget
#'
#' Start modeling
#'
#' Start the data modeling process.
#' @details This method invokes `PATCH /projects/{projectId}/aim/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ConfigureAndStartAutopilot in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
SetTarget <- function(project, target, metric = NULL, weights = NULL, partition = NULL, mode = AutopilotMode$Quick, seed = NULL, targetType = NULL, positiveClass = NULL, blueprintThreshold = NULL, responseCap = NULL, featurelistId = NULL, smartDownsampled = NULL, majorityDownsamplingRate = NULL, scaleoutModelingMode = NULL, accuracyOptimizedBlueprints = NULL, offset = NULL, exposure = NULL, eventsCount = NULL, monotonicIncreasingFeaturelistId = NULL, monotonicDecreasingFeaturelistId = NULL, onlyIncludeMonotonicBlueprints = FALSE, maxWait = 600, ...) {
  if (is.null(target)) {
    stop("No target variable specified - cannot start Autopilot")
  }

  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "aim")
  pStat <- GetProjectStatus(projectId)
  stage <- as.character(pStat[which(names(pStat) == "stage")])
  if (!identical(stage, ProjectStage$AIM)) {
    errorMsg <- paste(
      "Autopilot stage is", stage,
      "but it must be 'aim' to set the target and start a new project"
    )
    stop(strwrap(errorMsg))
  }

  bodyList <- list(target = target)
  bodyList$metric <- metric
  bodyList$weights <- weights
  bodyList$mode <- mode
  bodyList$seed <- seed
  bodyList$positiveClass <- positiveClass
  bodyList$blueprintThreshold <- blueprintThreshold
  bodyList$responseCap <- responseCap
  bodyList$featurelistId <- featurelistId
  bodyList$smartDownsampled <- smartDownsampled
  bodyList$majorityDownsamplingRate <- majorityDownsamplingRate
  bodyList$scaleoutModelingMode <- scaleoutModelingMode
  bodyList$accuracyOptimizedMb <- accuracyOptimizedBlueprints
  bodyList$offset <- offset
  bodyList$exposure <- exposure
  bodyList$eventsCount <- eventsCount
  if (is.list(monotonicIncreasingFeaturelistId) &&
    "featurelistId" %in% names(monotonicIncreasingFeaturelistId)) {
    monotonicIncreasingFeaturelistId <- monotonicIncreasingFeaturelistId$featurelistId
  }
  bodyList$monotonicIncreasingFeaturelistId <- monotonicIncreasingFeaturelistId
  if (is.list(monotonicDecreasingFeaturelistId) &&
    "featurelistId" %in% names(monotonicDecreasingFeaturelistId)) {
    monotonicDecreasingFeaturelistId <- monotonicDecreasingFeaturelistId$featurelistId
  }
  bodyList$monotonicDecreasingFeaturelistId <- monotonicDecreasingFeaturelistId
  bodyList$onlyIncludeMonotonicBlueprints <- onlyIncludeMonotonicBlueprints
  ValidateParameterIn(targetType, TargetType)
  bodyList$targetType <- targetType

  if (!is.null(partition) && !is(partition, "partition")) {
    partitioningMethods <- c(
      "CreateRandomPartition", "CreateStratifiedPartition",
      "CreateGroupPartition", "CreateUserPartition",
      "CreateDatetimePartitionSpecification"
    )
    stop(
      "You must use a valid partition object to specify your partitioning.",
      " See docs for ", paste0(lapply(partitioningMethods, sQuote), collapse = ", "),
      " for examples."
    )
  }
  if (!is.null(partition)) {
    if (IsDateTimePartition(partition)) {
      partition <- as.dataRobotDatetimePartitionSpecification(partition)
      if (IsMultiSeriesPartition(partition)) {
        properties <- RequestMultiSeriesDetection(project,
          partition$datetimePartitionColumn,
          partition$multiseriesIdColumns,
          maxWait = maxWait
        )
        if (!is.list(partition$multiseriesIdColumns)) {
          partition$multiseriesIdColumns <- list(partition$multiseriesIdColumns)
        }
        if (IsCrossSeriesGroupByPartition(partition)) {
          properties <- RequestCrossSeriesDetection(project,
            partition$datetimePartitionColumn,
            partition$multiseriesIdColumns,
            partition$crossSeriesGroupByColumns,
            maxWait = maxWait
          )
          if (!is.list(partition$crossSeriesGroupByColumns)) {
            partition$crossSeriesGroupByColumns <- list(partition$crossSeriesGroupByColumns)
          }
        }
        properties <- as.dataRobotFeatureInfo(properties)
        ValidateMultiSeriesProperties(properties)
      }
    }
    bodyList <- append(bodyList, partition)
  }
  body <- lapply(bodyList, Unbox)
  # start of generated addition
  # end of generated addition
  # start of generated addition
  # end of generated addition
  response <- DataRobotPATCH(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  WaitForAsyncReturn(GetRedirectFromResponse(response),
    addUrl = FALSE,
    maxWait = maxWait,
    failureStatuses = "ERROR"
  )
  message("Autopilot started")
}

#' SetupProject
#'
#' Create project.
#'
#' Create a new project.
#' @details This method invokes `POST /projects/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method Create in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
SetupProject <- function(dataSource, projectName = NULL, maxWait = 60 * 60, ...) {
  if (is.null(projectName)) {
    projectName <- deparse(substitute(dataSource))
  }
  dataList <- list(projectName = projectName)
  if (isURL(dataSource)) {
    dataList$url <- dataSource
  } else {
    dataList$file <- UploadData(dataSource)
  }
  routeString <- "projects/"
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = dataList, returnRawResponse = TRUE, timeout = maxWait)
  message(paste(
    "Project", projectName,
    "creation requested, awaiting creation"
  ))
  project <- ProjectFromJobResponse(postResponse, maxWait = maxWait)
  message(sprintf("Project %s (%s) created", project$projectId, project$projectName))
  as.dataRobotProjectShort(project)
}

#' RequestCrossSeriesDetection
#'
#' Validate columns for potential use as the group-by column for cross-series functionality.
#'
#' Validate columns for potential use as the group-by column for cross-series functionality.  The group-by column is an optional setting that indicates how to further splitseries into related groups. For example, if each series represents sales of an individual product, the group-by column could be the product category, e.g., \"clothing\" or \"sports equipment\".
#' @details This method invokes `POST /projects/{projectId}/crossSeriesProperties/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method CrossSeriesPropertiesCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RequestCrossSeriesDetection <- function(project, dateColumn, multiseriesIdColumns = NULL, crossSeriesGroupByColumns = NULL, maxWait = 600, ...) {
  payload <- list("datetimePartitionColumn" = dateColumn)
  projectId <- ValidateProject(project)

  if (!is.null(multiseriesIdColumns)) {
    if (length(multiseriesIdColumns) > 1) {
      stop("Currently only one multiseries id column is supported.")
    }
    if (is.list(multiseriesIdColumns)) {
      multiseriesIdColumns <- multiseriesIdColumns[[1]]
    }
    payload$multiseriesIdColumn <- multiseriesIdColumns
  }

  if (!is.null(crossSeriesGroupByColumns)) {
    if (length(crossSeriesGroupByColumns) > 1) {
      stop("Currently only one cross series group by column is supported.")
    }
    if (!is.list(crossSeriesGroupByColumns)) {
      crossSeriesGroupByColumns <- list(crossSeriesGroupByColumns)
    }
    payload$crossSeriesGroupByColumns <- crossSeriesGroupByColumns
  }

  routeString <- UrlJoin("projects", projectId, "crossSeriesProperties")
  # start of generated addition
  # end of generated addition
  response <- DataRobotPOST(routeString, returnRawResponse = TRUE, body = payload, encode = "json")
  message(paste("Cross series group by for feature", dateColumn, "submitted"))
  response <- WaitForAsyncReturn(GetRedirectFromResponse(response),
    addUrl = FALSE,
    maxWait = maxWait,
    failureStatuses = "ERROR"
  )
  response <- response$crossSeriesGroupByColumns
  response <- response[response$name == crossSeriesGroupByColumns[[1]], ]
  timeSeriesEligible <- TRUE
  if (length(response) == 0) {
    crossSeriesEligible <- FALSE
    crossSeriesEligibilityReason <- "not_found"
  } else {
    crossSeriesEligibilityReason <- response$eligibility
    crossSeriesEligible <- identical(crossSeriesEligibilityReason, "suitable")
  }
  as.dataRobotMultiSeriesProperties(list(
    "timeSeriesEligible" = timeSeriesEligible,
    "crossSeriesEligible" = crossSeriesEligible,
    "crossSeriesEligibilityReason" = crossSeriesEligibilityReason,
    "timeUnit" = NULL,
    "timeStep" = NULL
  ))
}

#' DeleteProject
#'
#' Delete a project
#'
#' Delete a project
#' @details This method invokes `DELETE /projects/{projectId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method Delete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteProject <- function(project, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId)
  # start of generated addition
  # end of generated addition
  response <- DataRobotDELETE(routeString)
  if (is.list(project)) {
    projectName <- project$projectName
  } else {
    projectName <- ""
  }
  message(paste(
    "Project", projectName, "with projectId = ",
    projectId, "deleted"
  ))
}

#' ListDeletedProjectsCount
#'
#' Count soft-deleted projects.
#'
#' Get current number of deleted projects matching search criteria. Value is limited by DELETED_PROJECTS_BATCH_LIMIT system setting. That means that the actual amount of deleted projects can be greater than the limit, but counting will stop when reaching it.
#' @details This method invokes `GET /deletedProjectsCount/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method DeletedProjectsCountList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListDeletedProjectsCount <- function(deletedAfter, creator, organization, limit, deletedBefore, projectId, searchFor, ...) {
  return(datarobot.apicore::ProjectsApi$new()$DeletedProjectsCountList(deletedAfter = deletedAfter, creator = creator, organization = organization, limit = limit, deletedBefore = deletedBefore, projectId = projectId, searchFor = searchFor, ...))
}

#' ListDeletedProjects
#'
#' Retrieve a list of soft-deleted projects
#'
#' Retrieve a list of soft-deleted projects matching search criteria
#' @details This method invokes `GET /deletedProjects/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method DeletedProjectsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListDeletedProjects <- function(deletedAfter, creator, organization, deletedBefore, projectId, searchFor, offset = 0, limit = 20, orderBy = "deletedOn", ...) {
  return(datarobot.apicore::ProjectsApi$new()$DeletedProjectsList(deletedAfter = deletedAfter, creator = creator, offset = offset, organization = organization, limit = limit, orderBy = orderBy, deletedBefore = deletedBefore, projectId = projectId, searchFor = searchFor, ...))
}

#' PatchDeletedProjects
#'
#' Recover soft-deleted project
#'
#' Recover (undelete) soft-deleted project
#' @details This method invokes `PATCH /deletedProjects/{projectId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method DeletedProjectsPatch in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PatchDeletedProjects <- function(action, projectId, ...) {
  projectRecover <- datarobot.apicore::ProjectRecover$new(action = action, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$DeletedProjectsPatch(projectRecover = projectRecover, projectId = projectId, ...))
}

#' RetrieveDiscardedFeaturesInformation
#'
#' Get discarded features.
#'
#' Get features which were discarded during feature reduction process.
#' @details This method invokes `GET /projects/{projectId}/discardedFeatures/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method DiscardedFeaturesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveDiscardedFeaturesInformation <- function(projectId, search = NULL, ...) {
  routeString <- UrlJoin("projects", projectId, "discardedFeatures")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$search <- search
  # end of generated addition
  response <- DataRobotGET(routeString, query = query)
  return(as.dataRobotDiscardedFeaturesInformation(response))
}

#' CreateProjectsExternalTimeSeriesBaselineDataValidationJobs
#'
#' Validate baseline data
#'
#' This route validates if a provided catalog version id can be used as baseline for calculating metrics. This functionality is available only for time series projects.For a baseline dataset to be valid, the number of unique date amd multiseries_id columnrows must match the unique number of date and multiseries_id column rows in the uploadedtraining dataset. This functionality is limited to one forecast distance. Additionally, the catalog must be a snapshot.
#' @details This method invokes `POST /projects/{projectId}/externalTimeSeriesBaselineDataValidationJobs/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ExternalTimeSeriesBaselineDataValidationJobsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateProjectsExternalTimeSeriesBaselineDataValidationJobs <- function(forecastWindowStart, forecastWindowEnd, catalogVersionId, holdoutEndDate, multiseriesIdColumns, holdoutStartDate, backtests, projectId, target, datetimePartitionColumn, ...) {
  externalTsBaselinePayload <- datarobot.apicore::ExternalTSBaselinePayload$new(forecastWindowStart = forecastWindowStart, forecastWindowEnd = forecastWindowEnd, catalogVersionId = catalogVersionId, holdoutEndDate = holdoutEndDate, multiseriesIdColumns = multiseriesIdColumns, holdoutStartDate = holdoutStartDate, backtests = backtests, target = target, datetimePartitionColumn = datetimePartitionColumn, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$ExternalTimeSeriesBaselineDataValidationJobsCreate(externalTsBaselinePayload = externalTsBaselinePayload, projectId = projectId, ...))
}

#' RetrieveProjectsExternalTimeSeriesBaselineDataValidationJobs
#'
#' Retrieve Baseline Validation Job
#'
#' Retrieve information to confirm if the validation job triggered via /api/v2/projects/(projectId)/externalTimeSeriesBaselineDataValidationJobs/ is valid.
#' @details This method invokes `GET /projects/{projectId}/externalTimeSeriesBaselineDataValidationJobs/{baselineValidationJobId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ExternalTimeSeriesBaselineDataValidationJobsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsExternalTimeSeriesBaselineDataValidationJobs <- function(baselineValidationJobId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$ExternalTimeSeriesBaselineDataValidationJobsRetrieve(baselineValidationJobId = baselineValidationJobId, projectId = projectId, ...))
}

#' ListProjectsFeatureDiscoveryDatasetDownload
#'
#' Download the project dataset with features added by feature discovery
#'
#' Download the project dataset with features added by feature discovery
#' @details This method invokes `GET /projects/{projectId}/featureDiscoveryDatasetDownload/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureDiscoveryDatasetDownloadList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsFeatureDiscoveryDatasetDownload <- function(datasetId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$FeatureDiscoveryDatasetDownloadList(datasetId = datasetId, projectId = projectId, ...))
}

#' ListProjectsFeatureDiscoveryLogsDownload
#'
#' Retrieve a text file containing the feature discovery log
#'
#' Retrieve a text file containing the feature discovery log. This route is only supported for feature discovery projects that have finished partitioning.
#' @details This method invokes `GET /projects/{projectId}/featureDiscoveryLogs/download/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureDiscoveryLogsDownloadList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsFeatureDiscoveryLogsDownload <- function(projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$FeatureDiscoveryLogsDownloadList(projectId = projectId, ...))
}

#' ListProjectsFeatureDiscoveryLogs
#'
#' Retrieve the feature discovery log content and log length
#'
#' Retrieve the feature discovery log content and log length for a feature discovery project. This route is only supported for feature discovery projects that have finished partitioning
#' @details This method invokes `GET /projects/{projectId}/featureDiscoveryLogs/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureDiscoveryLogsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsFeatureDiscoveryLogs <- function(projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ProjectsApi$new()$FeatureDiscoveryLogsList(offset = offset, limit = limit, projectId = projectId, ...))
}

#' ListProjectsFeatureDiscoveryRecipeSQLsDownload
#'
#' Download feature discovery SQL recipe
#'
#' Download feature discovery SQL recipe for a project
#' @details This method invokes `GET /projects/{projectId}/featureDiscoveryRecipeSQLs/download/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureDiscoveryRecipeSQLsDownloadList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsFeatureDiscoveryRecipeSQLsDownload <- function(modelId, projectId, statusOnly = "false", ...) {
  return(datarobot.apicore::ProjectsApi$new()$FeatureDiscoveryRecipeSQLsDownloadList(modelId = modelId, statusOnly = statusOnly, projectId = projectId, ...))
}

#' CreateProjectsFeatureDiscoveryRecipeSqlExports
#'
#' Generate feature discovery SQL recipe
#'
#' Generate feature discovery SQL recipe for a project
#' @details This method invokes `POST /projects/{projectId}/featureDiscoveryRecipeSqlExports/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureDiscoveryRecipeSqlExportsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateProjectsFeatureDiscoveryRecipeSqlExports <- function(modelId, projectId, ...) {
  featureDiscoveryRecipeSqlsExport <- datarobot.apicore::FeatureDiscoveryRecipeSQLsExport$new(modelId = modelId, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$FeatureDiscoveryRecipeSqlExportsCreate(featureDiscoveryRecipeSqlsExport = featureDiscoveryRecipeSqlsExport, projectId = projectId, ...))
}

#' GetFeatureHistogram
#'
#' Get feature histogram
#'
#' Get histogram chart data for a specific feature. Information that can be used to build histogram charts. Plot data returned is based on raw data that is calculated during initial project creation and updated after the project's target variable has been selected. The number of bins in the histogram is no greater than the requested limit.
#' @details This method invokes `GET /projects/{projectId}/featureHistograms/{featureName}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureHistogramsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetFeatureHistogram <- function(project, featureName, binLimit = NULL, key = NULL, ...) {
  projectId <- ValidateProject(project)
  featureForUrl <- if (is.character(featureName)) URLencode(enc2utf8(featureName)) else featureName
  routeString <- UrlJoin("projects", projectId, "featureHistograms", featureForUrl)
  query <- list()
  query$binLimit <- binLimit
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$key <- key
  # end of generated addition
  as.dataRobotFeatureHistogram(DataRobotGET(routeString, simplifyDataFrame = FALSE, query = query)$plot)
}

#' RetrieveProjectsFeatureLineages
#'
#' Retrieve Feature Discovery Lineage
#'
#' Retrieve single Feature Discovery feature lineage.
#' @details This method invokes `GET /projects/{projectId}/featureLineages/{featureLineageId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeatureLineagesRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsFeatureLineages <- function(featureLineageId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$FeatureLineagesRetrieve(featureLineageId = featureLineageId, projectId = projectId, ...))
}

#' CreateFeaturelist
#'
#' Create a new featurelist.
#'
#' Create a new featurelist from list of feature names.
#' @details This method invokes `POST /projects/{projectId}/featurelists/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturelistsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateFeaturelist <- function(project, listName, featureNames, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "featurelists")
  # I(featureNames) tells httr/jsonlite not to unbox length-1 vectors to scalars
  body <- list(name = listName, features = I(featureNames))
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = body, returnRawResponse = TRUE, encode = "json")
  featurelistInfo <- DataRobotGET(GetRedirectFromResponse(postResponse), addUrl = FALSE)
  message(paste("Featurelist", listName, "created"))
  as.dataRobotFeaturelist(featurelistInfo)
}


#' ListFeaturelists
#'
#' List featurelists
#'
#' List all featurelists for a project.
#' @details This method invokes `GET /projects/{projectId}/featurelists/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturelistsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListFeaturelists <- function(project, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "featurelists")
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString)
  featurelists <- list()
  for (i in seq(nrow(response))) {
    flist <- as.list(response[i, ])
    flist$features <- flist$features[[1]]
    flist <- as.dataRobotFeaturelist(flist)
    featurelists <- append(featurelists, list(flist))
  }
  class(featurelists) <- c("listOfFeaturelists", "listSubclass")
  featurelists
}


#' GetFeaturelist
#'
#' Retrieve a feature list
#'
#' Retrieve a single known feature list.
#' @details This method invokes `GET /projects/{projectId}/featurelists/{featurelistId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturelistsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetFeaturelist <- function(project, featurelistId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "featurelists", featurelistId)
  # start of generated addition
  # end of generated addition
  featurelist <- DataRobotGET(routeString)
  as.dataRobotFeaturelist(featurelist)
}

#' ListFeatureInfo
#'
#' List project features
#'
#' List the features from a project with descriptive information.
#' @details This method invokes `GET /projects/{projectId}/features/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListFeatureInfo <- function(project, forSegmentedAnalysis = "false", ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "features")
  query <- list()
  query$forSegmentedAnalysis <- forSegmentedAnalysis
  lapply(
    # start of generated addition
    # end of generated addition
    DataRobotGET(routeString, simplifyDataFrame = FALSE, query = query),
    as.dataRobotFeatureInfo
  )
}

#' GetValidMetrics
#'
#' List feature metrics
#'
#' List the appropriate metrics if a feature were chosen as the target. The metrics listed will include both weighted and unweighted metrics - which are appropriate will depend on whether a weights column is used.
#' @details This method invokes `GET /projects/{projectId}/features/metrics/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturesMetricsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetValidMetrics <- function(project, target, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "features", "metrics")
  query <- list(featureName = target)
  # start of generated addition
  # end of generated addition
  response <- DataRobotGET(routeString, query = query)
  response$availableMetrics
}


#' GetFeatureInfo
#'
#' Get project feature
#'
#' Retrieve the specified feature with descriptive information. Descriptive information for features also includes summary statistics as of v2.8. These are returned via the fields max, min, mean, median, and stdDev. These fields are formatted according to the original feature type of the feature. For example, the format will be numeric if your feature is numeric, in feet and inches if your feature is length type, in currency if your feature is currency type, in time format if your feature is time type, or in ISO date format if your feature is a date type. Numbers will be rounded so that they have at most two non-zero decimal digits. For projects created prior to v2.8, these descriptive statistics will not be available. Also, some features, like categorical and text features, may not have summary statistics.
#' @details This method invokes `GET /projects/{projectId}/features/{featureName}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method FeaturesRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetFeatureInfo <- function(project, featureName, ...) {
  projectId <- ValidateProject(project)
  featureForUrl <- if (is.character(featureName)) URLencode(enc2utf8(featureName)) else featureName
  routeString <- UrlJoin("projects", projectId, "features", featureForUrl)
  # simplifyDataFrame because feature$keySummary should be a DF
  # start of generated addition
  # end of generated addition
  as.dataRobotFeatureInfo(DataRobotGET(routeString, simplifyDataFrame = TRUE))
}

#' CreateHdfsProjects
#'
#' Create a project from an HDFS file source.
#'
#' Create a project from an HDFS file via WebHDFS API. Represent the file using URL, optionally, port, and optionally, user/password credentials. For example, {\"url\": \"hdfs://\\<ip\\>/path/to/file.csv\", \"port\": \"50070\"}.
#' @details This method invokes `POST /hdfsProjects/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method HdfsProjectsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateHdfsProjects <- function(password, port, projectName, user, url, ...) {
  hdfsProjectCreate <- datarobot.apicore::HdfsProjectCreate$new(password = password, port = port, projectName = projectName, user = user, url = url, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$HdfsProjectsCreate(hdfsProjectCreate = hdfsProjectCreate, ...))
}

#' DeleteProjectsJobs
#'
#' Cancel Job
#'
#' Cancel a pending job.
#' @details This method invokes `DELETE /projects/{projectId}/jobs/{jobId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method JobsDelete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteProjectsJobs <- function(jobId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$JobsDelete(jobId = jobId, projectId = projectId, ...))
}

#' ListJobs
#'
#' List project jobs
#'
#' List the project's jobs.
#' @details This method invokes `GET /projects/{projectId}/jobs/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method JobsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListJobs <- function(project, status = NULL, ...) {
  projectId <- ValidateProject(project)
  query <- if (is.null(status)) {
    NULL
  } else {
    list(status = status)
  }
  routeString <- UrlJoin("projects", projectId, "jobs")
  # start of generated addition
  # end of generated addition
  jobsResponse <- DataRobotGET(routeString, query = query, simplifyDataFrame = FALSE)
  return(as.list(jobsResponse$jobs))
}

#' GetJob
#'
#' Get job
#'
#' Retrieve details for a job that has been started but has not yet completed.
#' @details This method invokes `GET /projects/{projectId}/jobs/{jobId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method JobsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetJob <- function(project, jobId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "jobs", jobId)
  # start of generated addition
  # end of generated addition
  return(DataRobotGET(routeString, followLocation = FALSE))
}

#' ListProjects
#'
#' List projects
#'
#' List all available projects.
#' @details This method invokes `GET /projects/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method List in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjects <- function(filter = NULL, projectName = NULL, projectId = NULL, orderBy = NULL, featureDiscovery = NULL, ...) {
  routeString <- "projects/"
  params <- NULL
  if (!is.null(filter)) {
    if (!is.list(filter)) {
      stop("`filter` must be a list.")
    }
    if ("projectName" %in% names(filter)) {
      if (length(filter$projectName) != 1) {
        stop("`projectName` must be a character vector of length 1.")
      }
      params <- list("projectName" = filter$projectName)
    }
  }
  # start of generated addition
  params <- get0("params", mode = "list", ifnotfound = list())
  params$projectName <- projectName
  params$projectId <- projectId
  params$orderBy <- orderBy
  params$featureDiscovery <- featureDiscovery
  # end of generated addition
  returnValue <- DataRobotGET(routeString, query = params)
  projectSummaryList(returnValue)
}

#' CreateModelingFeaturelist
#'
#' Create a new modeling featurelist.
#'
#' Create new modeling featurelist from list of feature names. Only time series projects differentiate between modeling and input featurelists. On other projects, this route will behave the same as :<http:post>:/api/v2/projects/(projectId)/featurelists/. On time series projects, this can be used after the target has been set in order to create a new featurelist on the modeling features, although the previously mentioned route for creating featurelists will be disabled. On time series projects, only modeling features may be passed to this route to create a featurelist.
#' @details This method invokes `POST /projects/{projectId}/modelingFeaturelists/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturelistsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateModelingFeaturelist <- function(project, listName, featureNames, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "modelingFeaturelists")
  # I(featureNames) tells httr/jsonlite not to unbox length-1 vectors to scalars
  body <- list(name = listName, features = I(featureNames))
  # start of generated addition
  # end of generated addition
  featurelistInfo <- DataRobotPOST(routeString, body = body, encode = "json")
  message(paste("Featurelist", listName, "created"))
  as.dataRobotFeaturelist(featurelistInfo)
}


#' ListModelingFeaturelists
#'
#' List all modeling featurelists from a project
#'
#' List all modeling featurelists from the project requested by ID. This route will only become available after the target and partitioning options have been set for a project. Modeling featurelists are featurelists of modeling features, and are the correct featurelists to use when creating models or restarting the autopilot. In a time series project, these will differ from those returned from :<http:get>:/api/v2/projects/(projectId)/featurelists/ while in other projects these will be identical. See the `documentation <input_vs_modeling>` for more information on the distinction between input and modeling data in time series projects.
#' @details This method invokes `GET /projects/{projectId}/modelingFeaturelists/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturelistsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListModelingFeaturelists <- function(project, offset = 0, limit = 0, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "modelingFeaturelists")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$offset <- offset
  query$limit <- limit
  # end of generated addition
  response <- DataRobotGET(routeString, query = query)
  response <- GetServerDataInRows(response)
  featurelists <- list()
  for (i in seq(nrow(response))) {
    flist <- as.list(response[i, ])
    flist$features <- flist$features[[1]]
    flist <- as.dataRobotFeaturelist(flist)
    featurelists <- append(featurelists, list(flist))
  }
  class(featurelists) <- c("listOfModelingFeaturelists", "listSubclass")
  featurelists
}


#' GetModelingFeaturelist
#'
#' Retrieve a single modeling featurelist by ID
#'
#' Retrieve a single modeling featurelist by ID. When reporting the number of models that \"use\" a featurelist, a model is considered to use a featurelist if it is used as to train the model or as a monotonic constraint featurelist, or if the model is a blender with component models that use the featurelist. This route will only become available after the target and partitioning options have been set for a project. Modeling featurelists are featurelists of modeling features, and are the appropriate featurelists to use when creating models or restarting the autopilot. In a time series project, these will be distinct from those returned from :<http:get>:/api/v2/projects/(projectId)/featurelists/ while in other projects these will be identical.
#' @details This method invokes `GET /projects/{projectId}/modelingFeaturelists/{featurelistId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturelistsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetModelingFeaturelist <- function(project, featurelistId, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "modelingFeaturelists", featurelistId)
  # start of generated addition
  # end of generated addition
  featurelist <- DataRobotGET(routeString)
  as.dataRobotFeaturelist(featurelist)
}

#' RestoreDiscardedFeatures
#'
#' Restore discarded time series features.
#'
#' Restore discarded time series features.
#' @details This method invokes `POST /projects/{projectId}/modelingFeatures/fromDiscardedFeatures/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturesFromDiscardedFeaturesCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RestoreDiscardedFeatures <- function(projectId, featuresToRestore, maxWait = 60 * 10, ...) {
  bodyData <- list(featuresToRestore = featuresToRestore)
  routeString <- UrlJoin("projects", projectId, "modelingFeatures", "fromDiscardedFeatures")
  # start of generated addition
  # end of generated addition
  postResponse <- DataRobotPOST(routeString, body = bodyData, addUrl = TRUE, encode = "json", returnRawResponse = TRUE, stopOnError = FALSE)
  formattedResponse <- HandleRouteResponse(postResponse)
  if (httr::status_code(postResponse) == 202L) {
    WaitForAsyncReturn(GetRedirectFromResponse(postResponse), addUrl = FALSE, maxWait = maxWait)
  }
  return(formattedResponse)
}

#' ListProjectsModelingFeatures
#'
#' List project modeling features.
#'
#' List the features from a project that are used for modeling with descriptive information.
#' @details This method invokes `GET /projects/{projectId}/modelingFeatures/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsModelingFeatures <- function(projectId, offset = 0, limit = 0, ...) {
  return(datarobot.apicore::ProjectsApi$new()$ModelingFeaturesList(offset = offset, limit = limit, projectId = projectId, ...))
}

#' RetrieveProjectsModelingFeatures
#'
#' Retrieve project modeling feature.
#'
#' Retrieve the specified modeling feature with descriptive information.
#' @details This method invokes `GET /projects/{projectId}/modelingFeatures/{featureName}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method ModelingFeaturesRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsModelingFeatures <- function(featureName, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$ModelingFeaturesRetrieve(featureName = featureName, projectId = projectId, ...))
}

#' ListProjectsMultiseriesIdsCrossSeriesProperties
#'
#' Retrieve eligible cross-series group-by columns.
#'
#' Retrieve eligible cross-series group-by columns.  Note that validation will have to have been triggered via :<http:post>:/api/v2/projects/(projectId)/crossSeriesProperties/ in order for results to appear here.
#' @details This method invokes `GET /projects/{projectId}/multiseriesIds/{multiseriesId}/crossSeriesProperties/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method MultiseriesIdsCrossSeriesPropertiesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsMultiseriesIdsCrossSeriesProperties <- function(multiseriesId, crossSeriesGroupByColumns, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$MultiseriesIdsCrossSeriesPropertiesList(multiseriesId = multiseriesId, crossSeriesGroupByColumns = crossSeriesGroupByColumns, projectId = projectId, ...))
}

#' ListProjectsMultiseriesNames
#'
#' List the names of a multiseries project.
#'
#' List the individual series names of a multiseries project
#' @details This method invokes `GET /projects/{projectId}/multiseriesNames/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method MultiseriesNamesList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsMultiseriesNames <- function(projectId, offset = 0, limit = 100, ...) {
  return(datarobot.apicore::ProjectsApi$new()$MultiseriesNamesList(offset = offset, limit = limit, projectId = projectId, ...))
}

#' RequestMultiSeriesDetection
#'
#' Detect multiseries properties
#'
#' Analyze relationships between potential partition and multiseries ID columns. Time series projects require that each timestamp have at most one row corresponding to it. However, multiple series of data can be handled within a single project by designating a multiseries ID column that assigns each row to a particular series. See the `multiseries <multiseries>` docs on time series projects for more information. A detection job analyzing the relationship between the multiseries ID column and the datetime partition column must be ran before it can be used. If the desired multiseries ID column(s) are known, it can be specified to limit the analysis to only those columns.
#' @details This method invokes `POST /projects/{projectId}/multiseriesProperties/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method MultiseriesPropertiesCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RequestMultiSeriesDetection <- function(project, dateColumn, multiseriesIdColumns = NULL, maxWait = 600, ...) {
  payload <- list("datetimePartitionColumn" = dateColumn)
  if (!is.null(multiseriesIdColumns)) {
    if (!is.list(multiseriesIdColumns)) {
      multiseriesIdColumns <- list(multiseriesIdColumns)
    }
    if (length(multiseriesIdColumns) > 1) {
      stop("Currently only one multiseries id column is supported.")
    }
    payload$multiseriesIdColumns <- multiseriesIdColumns
  }
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "multiseriesProperties")
  # start of generated addition
  # end of generated addition
  response <- DataRobotPOST(routeString, returnRawResponse = TRUE, body = payload, encode = "json")
  message(paste("Multiseries for feature", dateColumn, "submitted"))
  response <- WaitForAsyncReturn(GetRedirectFromResponse(response),
    addUrl = FALSE,
    maxWait = maxWait,
    failureStatuses = "ERROR"
  )
  response <- response$detectedMultiseriesIdColumns
  if (!is.null(multiseriesIdColumns)) {
    response <- response[response$multiseriesIdColumns == multiseriesIdColumns[[1]], ]
    if (length(response) == 0) {
      timeSeriesEligible <- FALSE
      timeUnit <- NULL
      timeStep <- NULL
    } else {
      timeSeriesEligible <- TRUE
      timeUnit <- unlist(response$timeUnit)
      timeStep <- unlist(response$timeStep)
    }
  } else {
    if (length(response) == 0) {
      timeSeriesEligible <- FALSE
      timeUnit <- NULL
      timeStep <- NULL
    } else {
      warning("Multiple potential multiseries id columns were detected.")
      timeSeriesEligible <- TRUE
      timeUnit <- NULL
      timeStep <- NULL
    }
  }
  as.dataRobotMultiSeriesProperties(list(
    "timeSeriesEligible" = timeSeriesEligible,
    "crossSeriesEligible" = NULL,
    "crossSeriesEligibilityReason" = NULL,
    "timeUnit" = timeUnit,
    "timeStep" = timeStep
  ))
}

#' UpdateProject
#'
#' Update project
#'
#' Change project name, worker count, or unlock the holdout.   If any of the optional json arguments are not provided, that aspect of the project will not be altered.
#' @details This method invokes `PATCH /projects/{projectId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method Patch in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
UpdateProject <- function(project, newProjectName = NULL, workerCount = NULL, holdoutUnlocked = NULL, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId)
  bodyList <- list()
  if (identical(workerCount, "max")) {
    workerCount <- -1
  }
  bodyList$workerCount <- workerCount
  bodyList$holdoutUnlocked <- holdoutUnlocked
  bodyList$projectName <- newProjectName
  if (all(unlist(Map(is.null, bodyList)))) {
    stop("No update data is provided")
  }
  body <- jsonlite::unbox(as.data.frame(bodyList))
  # start of generated addition
  # end of generated addition
  response <- DataRobotPATCH(routeString, body = body, encode = "json")
  message(paste("Project", projectId, "updated"))
}

#' GetFeatureDiscoveryRelationships
#'
#' Retrieve relationships configuration for a project
#'
#' Retrieve relationships configuration for a project
#' @details This method invokes `GET /projects/{projectId}/relationshipsConfiguration/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method RelationshipsConfigurationList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetFeatureDiscoveryRelationships <- function(project, configId = NULL, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "relationshipsConfiguration")
  # start of generated addition
  query <- get0("query", mode = "list", ifnotfound = list())
  query$configId <- configId
  # end of generated addition
  response <- DataRobotGET(routeString, query = query)
  return(response)
}

#' CreateRelationshipsConfigurations
#'
#' Create a relationships configuration
#'
#' Create a relationships configuration
#' @details This method invokes `POST /relationshipsConfigurations/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method RelationshipsConfigurationsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateRelationshipsConfigurations <- function(relationships, featureDiscoverySettings, datasetDefinitions, featureDiscoveryMode, ...) {
  relationshipsConfigCreate <- datarobot.apicore::RelationshipsConfigCreate$new(relationships = relationships, featureDiscoverySettings = featureDiscoverySettings, datasetDefinitions = datasetDefinitions, featureDiscoveryMode = featureDiscoveryMode, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$RelationshipsConfigurationsCreate(relationshipsConfigCreate = relationshipsConfigCreate, ...))
}

#' DeleteRelationshipsConfigurations
#'
#' Delete a relationships configuration
#'
#' Delete a relationships configuration
#' @details This method invokes `DELETE /relationshipsConfigurations/{relationshipsConfigurationId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method RelationshipsConfigurationsDelete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteRelationshipsConfigurations <- function(relationshipsConfigurationId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$RelationshipsConfigurationsDelete(relationshipsConfigurationId = relationshipsConfigurationId, ...))
}

#' PutRelationshipsConfigurations
#'
#' Replace a relationships configuration
#'
#' Replace a relationships configuration
#' @details This method invokes `PUT /relationshipsConfigurations/{relationshipsConfigurationId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method RelationshipsConfigurationsPut in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PutRelationshipsConfigurations <- function(relationships, featureDiscoverySettings, relationshipsConfigurationId, datasetDefinitions, featureDiscoveryMode, ...) {
  relationshipsConfigCreate <- datarobot.apicore::RelationshipsConfigCreate$new(relationships = relationships, featureDiscoverySettings = featureDiscoverySettings, datasetDefinitions = datasetDefinitions, featureDiscoveryMode = featureDiscoveryMode, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$RelationshipsConfigurationsPut(relationshipsConfigCreate = relationshipsConfigCreate, relationshipsConfigurationId = relationshipsConfigurationId, ...))
}

#' RetrieveRelationshipsConfigurations
#'
#' Retrieve a relationships configuration
#'
#' Retrieve a relationships configuration
#' @details This method invokes `GET /relationshipsConfigurations/{relationshipsConfigurationId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method RelationshipsConfigurationsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveRelationshipsConfigurations <- function(relationshipsConfigurationId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$RelationshipsConfigurationsRetrieve(relationshipsConfigurationId = relationshipsConfigurationId, ...))
}

#' GetProject
#'
#' Get project.
#'
#' Look up a particular project
#' @details This method invokes `GET /projects/{projectId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method Retrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetProject <- function(project, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId)
  # start of generated addition
  # end of generated addition
  projectDetails <- DataRobotGET(routeString)
  idIndex <- which(names(projectDetails) == "id")
  names(projectDetails)[idIndex] <- "projectId"
  return(as.dataRobotProject(projectDetails))
}

#' CreateProjectsSecondaryDatasetsConfigurations
#'
#' Create secondary dataset configurations for a project.
#'
#' Create secondary dataset configurations for a project.
#' @details This method invokes `POST /projects/{projectId}/secondaryDatasetsConfigurations/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SecondaryDatasetsConfigurationsCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateProjectsSecondaryDatasetsConfigurations <- function(modelId, name, featurelistId, config, projectId, secondaryDatasets, save = TRUE, ...) {
  secondaryDatasetCreate <- datarobot.apicore::SecondaryDatasetCreate$new(modelId = modelId, save = save, name = name, featurelistId = featurelistId, config = config, secondaryDatasets = secondaryDatasets, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$SecondaryDatasetsConfigurationsCreate(secondaryDatasetCreate = secondaryDatasetCreate, projectId = projectId, ...))
}

#' DeleteProjectsSecondaryDatasetsConfigurations
#'
#' Soft deletes a secondary dataset configuration.
#'
#' Soft deletes a secondary dataset configuration.
#' @details This method invokes `DELETE /projects/{projectId}/secondaryDatasetsConfigurations/{secondaryDatasetConfigId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SecondaryDatasetsConfigurationsDelete in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
DeleteProjectsSecondaryDatasetsConfigurations <- function(secondaryDatasetConfigId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SecondaryDatasetsConfigurationsDelete(secondaryDatasetConfigId = secondaryDatasetConfigId, projectId = projectId, ...))
}

#' ListProjectsSecondaryDatasetsConfigurations
#'
#' List all secondary dataset configurations for a project
#'
#' List all secondary dataset configurations for a project, optionally filtered by feature list id.
#' @details This method invokes `GET /projects/{projectId}/secondaryDatasetsConfigurations/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SecondaryDatasetsConfigurationsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsSecondaryDatasetsConfigurations <- function(modelId, featurelistId, projectId, offset = 0, limit = 100, includeDeleted = "false", ...) {
  return(datarobot.apicore::ProjectsApi$new()$SecondaryDatasetsConfigurationsList(offset = offset, modelId = modelId, limit = limit, includeDeleted = includeDeleted, featurelistId = featurelistId, projectId = projectId, ...))
}

#' RetrieveProjectsSecondaryDatasetsConfigurations
#'
#' Retrieve secondary dataset configuration by ID.
#'
#' Retrieve secondary dataset configuration by ID.
#' @details This method invokes `GET /projects/{projectId}/secondaryDatasetsConfigurations/{secondaryDatasetConfigId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SecondaryDatasetsConfigurationsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsSecondaryDatasetsConfigurations <- function(secondaryDatasetConfigId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SecondaryDatasetsConfigurationsRetrieve(secondaryDatasetConfigId = secondaryDatasetConfigId, projectId = projectId, ...))
}

#' RetrieveProjectsSegmentationTaskJobResults
#'
#' Retrieve segmentation task statuses.
#'
#' Retrieve the statuses of segmentation task jobs associated with the ID.
#' @details This method invokes `GET /projects/{projectId}/segmentationTaskJobResults/{segmentationTaskId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentationTaskJobResultsRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsSegmentationTaskJobResults <- function(segmentationTaskId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SegmentationTaskJobResultsRetrieve(segmentationTaskId = segmentationTaskId, projectId = projectId, ...))
}

#' CreateProjectsSegmentationTasks
#'
#' Create segmentation tasks.
#'
#' Create segmentation tasks for the dataset used in the project.
#' @details This method invokes `POST /projects/{projectId}/segmentationTasks/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentationTasksCreate in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
CreateProjectsSegmentationTasks <- function(userDefinedSegmentIdColumns, multiseriesIdColumns, modelPackageId, projectId, target, datetimePartitionColumn, useAutomatedSegmentation = FALSE, useTimeSeries = FALSE, ...) {
  segmentationTaskCreate <- datarobot.apicore::SegmentationTaskCreate$new(userDefinedSegmentIdColumns = userDefinedSegmentIdColumns, useAutomatedSegmentation = useAutomatedSegmentation, multiseriesIdColumns = multiseriesIdColumns, useTimeSeries = useTimeSeries, modelPackageId = modelPackageId, target = target, datetimePartitionColumn = datetimePartitionColumn, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$SegmentationTasksCreate(segmentationTaskCreate = segmentationTaskCreate, projectId = projectId, ...))
}

#' ListProjectsSegmentationTasks
#'
#' List segmentation tasks.
#'
#' List all segmentation tasks created for the project.
#' @details This method invokes `GET /projects/{projectId}/segmentationTasks/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentationTasksList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsSegmentationTasks <- function(projectId, offset = 0, limit = 10, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SegmentationTasksList(offset = offset, limit = limit, projectId = projectId, ...))
}

#' ListProjectsSegmentationTasksMappings
#'
#' Retrieve seriesId to segmentId mappings.
#'
#' Retrieve the seriesId to segmentId mappings for a Segmentation Task.
#' @details This method invokes `GET /projects/{projectId}/segmentationTasks/{segmentationTaskId}/mappings/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentationTasksMappingsList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
ListProjectsSegmentationTasksMappings <- function(segmentationTaskId, projectId, offset = 0, limit = 10, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SegmentationTasksMappingsList(offset = offset, limit = limit, segmentationTaskId = segmentationTaskId, projectId = projectId, ...))
}

#' RetrieveProjectsSegmentationTasks
#'
#' Retrieve segmentation task.
#'
#' Retrieve information about a segmentation task.
#' @details This method invokes `GET /projects/{projectId}/segmentationTasks/{segmentationTaskId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentationTasksRetrieve in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
RetrieveProjectsSegmentationTasks <- function(segmentationTaskId, projectId, ...) {
  return(datarobot.apicore::ProjectsApi$new()$SegmentationTasksRetrieve(segmentationTaskId = segmentationTaskId, projectId = projectId, ...))
}

#' PatchProjectsSegments
#'
#' Update child segment project.
#'
#' The only supported operation right now is segment restart, which removes existing child segment project and starts another child project instead for the given segment. Should be only used for child segments which are stuck during project startup or upload.
#' @details This method invokes `PATCH /projects/{projectId}/segments/{segmentId}/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method SegmentsPatch in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
PatchProjectsSegments <- function(segmentId, projectId, operation = "restart", ...) {
  projectSegmentUpdate <- datarobot.apicore::ProjectSegmentUpdate$new(operation = operation, validateParams = TRUE)
  return(datarobot.apicore::ProjectsApi$new()$SegmentsPatch(segmentId = segmentId, projectSegmentUpdate = projectSegmentUpdate, projectId = projectId, ...))
}

#' GetProjectStatus
#'
#' Check project status
#'
#' Check the status of a project
#' @details This method invokes `GET /projects/{projectId}/status/` in the DataRobot Public API.
#'
#' @param ... Additional keyword arguments to be passed on to the `datarobot.apicore` and `httr` libraries.
#'
#' @seealso The method StatusList in [datarobot.apicore::ProjectsApi], which invokes the same underlying API endpoint.
#' @export
#' @md
GetProjectStatus <- function(project, ...) {
  projectId <- ValidateProject(project)
  routeString <- UrlJoin("projects", projectId, "status")
  # start of generated addition
  # end of generated addition
  autopilotStatus <- DataRobotGET(routeString)
  return(autopilotStatus)
}
